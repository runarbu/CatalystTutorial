
=== part 2 - adding a model ===

Most interesting and useful web applications are about delivering content to
the user in an intelligent way.

The thing that distinguishes dynamic content from static content is that the
data is filtered and transformed to tailor the changing needs of each user on
the fly.

In order to deliver content you must have the data to generate it from, and
this is where models come in.

While usually in web applications models serve as interfaces to a database
backend, in this movie we're going to do things somewhat more manually.

There are various plugins on the CPAN to make the database more accessible
directly via a Catalyst application - Catalyst::Helper::Controller::Scaffold
being the prime example.

While this is useful for quickstarting an application, we feel that it has
little educational value.

So, if you remember from the first movie, we're writing a stupid administration
panel. In this tutorial we'll create a model that wraps around the /etc/passwd
user database, and we'll use this to write a user browser and editor.

So what the hell is a model anyway? In Catalyst it's just a class. You can
create a file for it using the create script.

    ./script/megasuperadmin_create.pl model Users

This creates the file lib/MegaSuperAdmin/Model/Users.pm

Catalyst will load the new Model class as startup, as well as any other module
in the Model, View and Controller directories.

For now we're going to leave this file alone - we don't know yet what kind of
API we're going to need. To find out what it is we actually want to write,
we'll start with the controller action that's going to use it.

Let's begin by creating a template for the user listing page. This lets us
focus on the information we're going to be displaying.

	<html>
		<head>
			<title>User List</title>
		</head>
	
		<body>
			<table>
				<thead>
					<tr>
						<th>ID</th>
						<th>Name</th>
					</tr>
				</thead>
				<tbody>
				[% FOR user = users %]
					<tr>
						<th>[% user.uid %]</td>
						<td>[% user.name %]</td>
					</tr>
				[% END %]
				</tbody>
			</table>
		</body>
	</html>

Now let's make a controller that will make use of this template.

	./script/megasuperadmin_create.pl controller Users

Let's just test out the template and see if it's working correctly:
	
	sub list : Local {
		my ( $self, $c ) = @_;
	
		$c->stash->{users} = [
			{
				name => "moose",
				id => 1,
				home => "/home/moose",
			},
		];
		
		$c->stash->{template} = "user_list.tt";
	
		$c->forward( $c->view("TT") );
	}

http://localhost:3000/users/list

That's pretty much what we expected.

By the way, did you notice that we are repeating the forward to the TT view?
One way to get around this is to add an C<end> action to the top level
application, which looks like this:

sub end : Private {
    my ( $self, $c ) = @_;

    $c->forward( $c->view("TT") )
        if $c->stash->{template};
}

Then we can just remove all the forwards from the actions. The DefaultEnd
plugin provides a more complete implementation of an C<end> action. It's useful
for when you don't need to do anything else in your C<end> than what it
provides.

Anyway, now that we have fake data on the screen and it looks OK, let's start
using real data. It's time to fill in MegaSuperAdmin::Model::Users.

We are going to model the /etc/passwd file. To make it more than just read
only, we'll be using a temporary copy of the file.

This code defines a component with two methods, 'user', which returns a user
object when given a name, and 'users' which returns all the users.

It also defines a user class, which just delegates all method names to the
Unix::PasswdFile module using AUTOLOAD. This way you can call methods like uid
and home, as we did in the template above, and get the right data.

The only method which is not simply delegated is 'rename'. That's because the
name stored in the user object must be updated after the rename is actually
performed, so that we can delegate subsequent method calls to the new user.

Models are about creating convenience for other parts of the program. A nice
thing about TT is that it doesn't care whether the thing you give it is a hash
or an object.

	package TheApp::Model::Users;
	
	use strict;
	use warnings;
	use base 'Catalyst::Model';
	
	use Unix::PasswdFile;
	use File::Temp qw/tempfile/;
	use File::Copy;
	
	# make a temporary copy
	my ( $fh, $filename ) = tempfile;
	copy( "/etc/passwd" => $fh );
	my $passwd = Unix::PasswdFile->new( $filename, locking => "none" );
	
	# return a list of users
	sub users {
		my $self = shift;
		map { $self->user($_) } $passwd->users;
	}
	
	# return a single user
	sub user {
		my ( $self, $name ) = @_;
	
		return unless defined $passwd->uid( $name );
	
		TheApp::Model::Users::User->new( $name, $passwd );
	}
	
	package TheApp::Model::Users::User;
	
	use base qw/Class::Accessor::Fast/;
	__PACKAGE__->mk_accessors(qw/name/);
	
	sub new {
		my ( $class, $name, $passwd ) = @_;
	
		bless {
			name => $name,
			storage => $passwd,
		}, $class;
	}
	
	sub AUTOLOAD {
		my $self = shift;
	
		my ( $method ) = ( our $AUTOLOAD =~ /([^:]+)$/ );
		return if $method eq "DESTROY";
	
		$self->{storage}->$method( $self->name, @_ );
	}
	
	sub rename {
		my ( $self, $new_name ) = @_;
		
		$self->{storage}->rename( $self->name, $new_name );
		$self->name( $new_name );
	}
	
	1;

Now all that's left to do in our controller is this:


	$c->stash->{users} = [ $c->model("Users")->users ];

	http://localhost:3000/users/list

Isn't that nifty?

This might seem lame, but let's look at what we actually did.

We created a small web application script thingy that lists the users on your
machine in a clean way. The reason it is clean, is that the code which handles
the data modeling is separated from the code which handles the logic, which is
yet again separate from the code that does the display.

The three main parts of our application - choosing what content to provide,
generating content from a backend, and displaying the content to the user, are
called controllers, models, and views.

As our controllers become more complicated this separation will become
increasingly important.

We are now going to add features to inspect individual users, and
even change data around.

Let's begin by creating a new template to show a single user:

<html>
    <head>
        <title>Users : [% user.name %]</title>
    </head>

    <body>
        [% IF user %]
            <table>
                <thead>
                    <tr>
                        [% FOR heading = [ "name", "uid", "gid", "comment", "shell", "home" ] %]
                            <th>[% heading %]</th>
                        [% END %]
                    </tr>
                </thead>
            
                <tbody>
                    <tr>
                        [% FOR field = [ "name", "uid", "gid", "gecos", "shell", "home" ] %]
                            <td>[% user.$field | html_entity %]</td>
                        [% END %]
                    </tr>
                </tbody>
            </table>
        
            <a href="[% c.uri_for('/users/list') %]">return to listing</a>  
        [% ELSE %]
            No such user
        [% END %]
    <body>
</html>

For those who don't know, the 'GECOS' field is used to store extra info about
the user. This is typically referred to as the Comment field, and is used to
store the real name on most operating systems.

This template assumes the 'user' variable is set in the template.

Now let's add an action to the Users controller that will let us inspect a
single user:

sub view : Local {  
    my ( $self, $c, $name ) = @_;
    
    if ( $name =~ /^(\w+)$/ ) {
        $c->stash->{user} = $c->model("Users")->user( $name );
    }
    
    $c->stash->{template} = "user.tt";
}

The only remarkable thing about this otherwise simple action is the way it
receives the value of $name - it's an argument.

    http://syeeda.local:3000/users/view

    http://syeeda.local:3000/users/view/root

As you can see the argument to the action is the path element below it. This
lets us use very pretty URIs.

To make this interface accessible, let's link to it from the listing page

    <td><a href="[% c.uri_for("/users/view/$user.name") %]">[% user.name %]</a></td>

    http://syeeda.local:3000/users/list

    click around

Now let's add editing capabilities... This involves three things - adding new
users, modifying existing users, and deleting users.

Deleting is simple: Unix::PasswdFile has a delete method. Due to the way
Unix::PasswdFile is implemented this will just work using our AUTOLOAD
subroutine, as a method on the user object.

Let's use this in an action:

    sub delete : Local {
        my ( $self, $c, $name ) = @_;
        
        my $stash = $c->stash;

        $stash->{user_name} = $name;
        
        if ( my $user = $c->model("Users")->user($name) ) {
            $user->delete;
        } else {
            $stash->{error} = "No such user";
        }
    }

Let's also add a template to display the results of user deletion.

But first - aren't you sick of setting the template in the stash all the time?
It turns out that we can actually let Catalyst::View::TT do the hard work for
us - all we have to do is be a little more organized.

    root
        passwords
            generate.tt
        users
            list.tt
            view.tt
            delete.tt


    __PACKAGE__->config( TEMPLATE_EXTENSION => '.tt' );
    

    remove all $c->stash->{template}


Now that we've organized the templates, let's create a new one for the delete
action.

    <html>
        <head>
            <title>Delete</title>
        </head>
        <body>
            [% IF error %]
                User [% user_name %] was not deleted: [% error %]
            [% ELSE %]
                Deleted [% user_name %]
            [% END %]
            <br> <a href="[% c.uri_for("/users/list") %]">return to listing</a>
        </body>
    </html>

The reason we're using the 'user_name' variable instead of just 'name', is that
that variable is filled in with our Catalyst application name.

	http://localhost:3000/users/delete/username

So, this seems to work.

Now let's add a delete button to the view page.

Make sure to never create normal links that make any changes to your data -
they can be very dangerous, because spiders and web acceleration utilities can
inadvertently delete or change data in your application by following these
links.

In general, it is also a good practice to redirect after a dangerous form
submission succeeds, and to use the POST form submission method as opposed to
the GET one, so that the action cannot be repeated if the user reloads.

We're going to add an extra measure of safety to our delete action - a form
parameter that is required for the deletion to actually happen.

    sub delete : Local {
        my ( $self, $c, $name ) = @_;
        
        my $stash = $c->stash;

        $stash->{user_name} = $name;
        
        if ( my $user = $c->model("Users")->user($name) ) {
            no warnings 'uninitialized';
            if ( $c->req->param("really") eq "yes" ) {
                $user->delete;
            } else {
                $stash->{error} = "You didn't really mean it";
            }
        } else {
            $stash->{error} = "No such user";
        }
    }
    
    http://localhost:3000/delete/foo
    http://localhost:3000/delete/foo?really=yes

Now let's link to this action from the user inspector:

    <form method="post" action="[% c.uri_for("/users/delete/$user.name") %]">
        <input type="hidden" name="really" value="yes" />
        <input type="submit" value="delete" />
    </form>


	click around, zap root, etc

Now that we can delete users, we also want to edit and add them.

We'll begin by creating a template for the edit page.

We'll start by just creating a copy of the view template. To make it into a
form, we'll replace the data printing with input fields.

Of course, we also need to remove the delete button and add a <form> element.

    <html>
        <head>
            <title>Users : [% user.name %]</title>
        </head>
    
        <body>
            [% IF user %]
                <form action="[% c.uri_for("/users/do_edit/$user.name") %]" method="post">
                    <table>
                        <thead>
                            <tr>
                                [% FOR heading = [ "name", "uid", "gid", "comment", "shell", "home" ] %]
                                    <th>[% heading %]</th>
                                [% END %]
                            </tr>
                        </thead>
                    
                        <tbody>
                            <tr>
                                [% FOR field = [ "name", "uid", "gid", "gecos", "shell", "home" ] %]
                                    <td><input type="text" value="[% user.$field | html_entity %]" name="[% field %]" /></td>
                                [% END %]
                            </tr>
                        </tbody>
                    </table>
                    <input type="submit" value="save" />
                </form>
            
                <a href="[% c.uri_for('/users/list') %]">return to listing</a>  
            [% ELSE %]
                No such user
            [% END %]
        <body>
    </html>

Because this template is so similar to view.tt, we can cheat and actually use
the view action to populate it.


    sub edit : Local {
        my ( $self, $c ) = @_;
        
        $c->forward("view");
    }

The list of arguments is kept from action to action, within the same request.
What happens here is that the view action will set the 'user' parameter in the
stash, but the automatically selected template will be 'edit.tt'.

    http://localhost:3000/users/edit/foo

    click save
    
    see error

Now it's time to create the do_edit action, which actually accepts the
parameters and saves them.

First, we'll have to validate the parameters:

    sub do_edit : Local {
        my ( $self, $c, $name ) = @_;
        
        if ( my $user = $c->model("Users")->user( $name ) ) {
        
            $c->form(
                name  => [ 'NOT_BLANK', [ REGEX => qr/^\w+$/ ] ],
                uid   => [ 'INT' ],
                gid   => [ 'INT' ],
                gecos => [ [ REGEX => qr/^[^:]*$/ ] ],
                shell => [ [ REGEX => qr/^[^:]*$/ ] ],
                home  => [ [ REGEX => qr/^[^:]*$/ ] ],
            );

This form validator declaration assures that the uid and gid fields are
integers, that the name contains nothing but alphanumerics, and that the other
fields contain no colons.

So, if the form is valid, we can save things. If not, we throw a fit.
    
            if ( $c->form->success ) {
                my $params = $c->form->valid;
    
    			# if a different name was provided, use the rename method
    			if ( my $new_name = delete $params->{name} and $new_name ne $user->name ) {
					$user->rename( $name );
				}
    
                # set all the fields
                foreach my $field ( keys %$params ) {
                    $user->$field( $params->{$field} );
                }
                
                $c->stash->{user} = $user;
                $c->stash->{template} = 'users/view.tt';
            } else {
                $c->stash->{user} = $c->req->params;
                $c->stash->{template} = 'users/edit.tt';
            }
        } else {
            # just for the error
            $c->stash->{template} = 'users/view.tt';
        }
    }
    
If the form is invalid, we will abuse the edit.tt template, by just sending
back the invalid parameters as if they were the user - remember that Template
Toolkit doesn't care whether the values of variables are objects or hashes. You
can add error reporting like we did in the first movie - consider it an
excercise for the viewer.

If the user doesn't exist at all, we use the view template which already has
the error reporting written in it.

If the form was valid, then we can save the changes. In this case we can once
more reuse the view template, which will just display the user we edited.

	http://localhost:3000/users/edit/foo
	
	save with bad data
	
	save with unicode for fun
	
	use nonexistent user
	
	rename a user
	
	rename a user with a bad value

Whoops! We found a bug.

If the user is renamed with our form, and the name value is invalid, the
generated form will point to a bad URI. Let's fix this:

    [% actual_username = user.name UNLESS actual_username %]
	<form action="[% c.uri_for("/users/do_edit/$actual_username") %]" method="post">
	
	sub do_edit : Local {
		...
		$c->stash->{actual_username} = $name;
	}

Now let's link to the edit page. For interface consistency we'll do it like we
did the delete button:

    <form method="post" action="[% c.uri_for("/users/edit/$user.name") %]">
        <input type="submit" value="edit" />
    </form>

So, all we have left is adding new users - we've got deleting and editing already.

Since we already have a form for editing users, we can abuse it once more -
adding a user is like editing an empty user.

The only difference is where the form will post to - adding a user and editing
one are different behavior in terms of the way our model abstracts things.

    [% action = "edit" UNLESS action %]
    <form action="[% c.uri_for("/users/do_$action/$actual_username") %]" method="post">
                                          ^^^^^^^

This new variable will default to 'edit' when not set. In our 'add' action we
will use it to divert the form to another action:

    sub add : Local { 
        my ( $self, $c ) = @_;
        
        $c->stash->{user} = {};
        $c->stash->{action} = "add";
        $c->stash->{template} = "users/edit.tt";
    }

Again, this is just reusing the existing templates. The real work is done in
'do_add', much like 'do_edit'

    sub do_add : Local {
        my ( $self, $c ) = @_;
        
        $c->forward("validate_user_form");
    }

Now we have to validate the form again, in the same way.

Let's refactor

    sub validate_user_form : Private {
        my ( $self, $c ) = @_;
        
        $c->form(
            name  => [ 'NOT_BLANK', [ REGEX => qr/^\w+$/ ] ],
            uid   => [ 'INT' ],
            gid   => [ 'INT' ],
            gecos => [ [ REGEX => qr/^[^:]*$/ ] ],
            shell => [ [ REGEX => qr/^[^:]*$/ ] ],
            home  => [ [ REGEX => qr/^[^:]*$/ ] ],
        );
    }
    
    sub do_edit : Local {
        my ( $self, $c, $name ) = @_;
        
        if
        
            $c->forward("validate_user_form");
    
        ... 
    }

Now, let's reuse the view template one more time, and show the user that was
created.

    sub do_add : Local {
        my ( $self, $c ) = @_;
        
        $c->forward("validate_user_form");
        
        $c->stash->{template} = "users/view.tt";
        
        if ( $c->form->success ) {
            
            $c->stash->{user} = $c->model("Users")->add_user( $c->form->valid );
        }
    }

Just one problem: there's no 'add_user' method in the model yet. Let's add it

    sub add_user {
        my ( $self, $params ) = @_;
        
        $passwd->user(
            $params->{name},
            "*",
            @{ $params }{qw/uid gid gecos home shell/},
        );
        
        return $self->user( $params->{name} );
    }

We're hard coding 'star' for the password field because handling shadow files
and crypted passwords is just too much unnecessary headache for an introduction
to Catalyst.

The very last thing to do is to add a button to the user listing, where we can
add new users.

	<form method="post" action="[% c.uri_for("/users/edit/$user.name") %]">
        <input type="submit" value="edit" />
    </form>

So, the point of this movie was that models are there to help us manage the
responsibilities in an application.

The views handle templating and display.

The controllers take care of throwing data around.

The model keeps the controllers clean of the implementation details of storage.

Our model was really simple, because it leveraged an existing tool -
Unix::PasswdFile. To contrast this, imagine how horrible it was if we were to
parse and edit the password files right there in the controllers.

This is what MVC is all about.


