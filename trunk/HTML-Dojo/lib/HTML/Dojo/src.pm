package HTML::Dojo::src;
1;
__DATA__
__CPAN_DIR__ src
__CPAN_FILE__ src/AdapterRegistry.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.AdapterRegistry");
dojo.require("dojo.lang.func");

dojo.AdapterRegistry = function(){
    /***
        A registry to facilitate adaptation.

        Pairs is an array of [name, check, wrap] triples
        
        All check/wrap functions in this registry should be of the same arity.
    ***/
    this.pairs = [];
}

dojo.lang.extend(dojo.AdapterRegistry, {
    register: function (name, check, wrap, /* optional */ override){
        /***
			The check function should return true if the given arguments are
			appropriate for the wrap function.

			If override is given and true, the check function will be given
			highest priority.  Otherwise, it will be the lowest priority
			adapter.
        ***/

        if (override) {
            this.pairs.unshift([name, check, wrap]);
        } else {
            this.pairs.push([name, check, wrap]);
        }
    },

    match: function (/* ... */) {
        /***
			Find an adapter for the given arguments.

			If no suitable adapter is found, throws NotFound.
        ***/
        for(var i = 0; i < this.pairs.length; i++){
            var pair = this.pairs[i];
            if(pair[1].apply(this, arguments)){
                return pair[2].apply(this, arguments);
            }
        }
		throw new Error("No match found");
        // dojo.raise("No match found");
    },

    unregister: function (name) {
        /***
			Remove a named adapter from the registry
        ***/
        for(var i = 0; i < this.pairs.length; i++){
            var pair = this.pairs[i];
            if(pair[0] == name){
                this.pairs.splice(i, 1);
                return true;
            }
        }
        return false;
    }
});

__CPAN_FILE__ src/animation.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.animation");
dojo.require("dojo.animation.Animation");

__CPAN_FILE__ src/behavior.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.behavior");
dojo.require("dojo.event.*");

dojo.require("dojo.experimental");
dojo.experimental("dojo.behavior");

dojo.behavior = new function(){
	function arrIn(obj, name){
		if(!obj[name]){ obj[name] = []; }
		return obj[name];
	}

	function forIn(obj, scope, func){
		var tmpObj = {};
		for(var x in obj){
			if(typeof tmpObj[x] == "undefined"){
				if(!func){
					scope(obj[x], x);
				}else{
					func.call(scope, obj[x], x);
				}
			}
		}
	}

	// FIXME: need a better test so we don't exclude nightly Safari's!
	this.behaviors = {};
	this.add = function(behaviorObj){
		/*	behavior objects are specified in the following format:
		 *
		 *	{ 
		 *	 	"#id": {
		 *			"found": function(element){
		 *				// ...
		 *			},
		 *
		 *			"onblah": {targetObj: foo, targetFunc: "bar"},
		 *
		 *			"onblarg": "/foo/bar/baz/blarg",
		 *
		 *			"onevent": function(evt){
		 *			},
		 *
		 *			"onotherevent: function(evt){
		 *				// ...
		 *			}
		 *		},
		 *
		 *		"#id2": {
		 *			// ...
		 *		},
		 *
		 *		"#id3": function(element){
		 *			// ...
		 *		},
		 *
		 *		// publish the match on a topic
		 *		"#id4": "/found/topic/name",
		 *
		 *		// match all direct descendants
		 *		"#id4 > *": function(element){
		 *			// ...
		 *		},
		 *
		 *		// match the first child node that's an element
		 *		"#id4 > @firstElement": { ... },
		 *
		 *		// match the last child node that's an element
		 *		"#id4 > @lastElement":  { ... },
		 *
		 *		// all elements of type tagname
		 *		"tagname": {
		 *			// ...
		 *		},
		 *
		 *		// maps to roughly:
		 *		//	dojo.lang.forEach(body.getElementsByTagName("tagname1"), function(node){
		 *		//		dojo.lang.forEach(node.getElementsByTagName("tagname2"), function(node2){
		 *		//			dojo.lang.forEach(node2.getElementsByTagName("tagname3", function(node3){
		 *		//				// apply rules
		 *		//			});
		 *		//		});
		 *		//	});
		 *		"tagname1 tagname2 tagname3": {
		 *			// ...
		 *		},
		 *
		 *		".classname": {
		 *			// ...
		 *		},
		 *
		 *		"tagname.classname": {
		 *			// ...
		 *		},
		 *	}
		 *
		 *	The "found" method is a generalized handler that's called as soon
		 *	as the node matches the selector. Rules for values that follow also
		 *	apply to the "found" key.
		 *	
		 *	The "on*" handlers are attached with dojo.event.connect(). If the
		 *	value is not a function but is rather an object, it's assumed to be
		 *	the "other half" of a dojo.event.kwConnect() argument object. It
		 *	may contain any/all properties of such a connection modifier save
		 *	for the sourceObj and sourceFunc properties which are filled in by
		 *	the system automatically. If a string is instead encountered, the
		 *	node publishes the specified event on the topic contained in the
		 *	string value.
		 *
		 *	If the value corresponding to the ID key is a function and not a
		 *	list, it's treated as though it was the value of "found".
		 *
		 */

		var tmpObj = {};
		forIn(behaviorObj, this, function(behavior, name){
			var tBehavior = arrIn(this.behaviors, name);
			if((dojo.lang.isString(behavior))||(dojo.lang.isFunction(behavior))){
				behavior = { found: behavior };
			}
			forIn(behavior, function(rule, ruleName){
				arrIn(tBehavior, ruleName).push(rule);
			});
		});
	}

	this.apply = function(){
		dojo.profile.start("dojo.behavior.apply");
		var r = dojo.render.html;
		// note, we apply one way for fast queries and one way for slow
		// iteration. So be it.
		var safariGoodEnough = (!r.safari);
		if(r.safari){
			// Anything over release #420 should work the fast way
			var uas = r.UA.split("AppleWebKit/")[1];
			if(parseInt(uas.match(/[0-9.]{3,}/)) >= 420){
				safariGoodEnough = true;
			}
		}
		if((dj_undef("behaviorFastParse", djConfig) ? (safariGoodEnough) : djConfig["behaviorFastParse"])){
			this.applyFast();
		}else{
			this.applySlow();
		}
		dojo.profile.end("dojo.behavior.apply");
	}

	this.matchCache = {};

	this.elementsById = function(id, handleRemoved){
		var removed = [];
		var added = [];
		arrIn(this.matchCache, id);
		if(handleRemoved){
			var nodes = this.matchCache[id];
			for(var x=0; x<nodes.length; x++){
				if(nodes[x].id != ""){
					removed.push(nodes[x]);
					nodes.splice(x, 1);
					x--;
				}
			}
		}
		var tElem = dojo.byId(id);
		while(tElem){
			if(!tElem["idcached"]){
				added.push(tElem);
			}
			tElem.id = "";
			tElem = dojo.byId(id);
		}
		this.matchCache[id] = this.matchCache[id].concat(added);
		dojo.lang.forEach(this.matchCache[id], function(node){
			node.id = id;
			node.idcached = true;
		});
		return { "removed": removed, "added": added, "match": this.matchCache[id] };
	}

	this.applyToNode = function(node, action, ruleSetName){
		if(typeof action == "string"){
			dojo.event.topic.registerPublisher(action, node, ruleSetName);
		}else if(typeof action == "function"){
			if(ruleSetName == "found"){
				action(node);
			}else{
				dojo.event.connect(node, ruleSetName, action);
			}
		}else{
			action.srcObj = node;
			action.srcFunc = ruleSetName;
			dojo.event.kwConnect(action);
		}
	}

	this.applyFast = function(){
		dojo.profile.start("dojo.behavior.applyFast");
		// fast DOM queries...wheeee!
		forIn(this.behaviors, function(tBehavior, id){
			var elems = dojo.behavior.elementsById(id);
			dojo.lang.forEach(elems.added, 
				function(elem){
					forIn(tBehavior, function(ruleSet, ruleSetName){
						if(dojo.lang.isArray(ruleSet)){
							dojo.lang.forEach(ruleSet, function(action){
								dojo.behavior.applyToNode(elem, action, ruleSetName);
							});
						}
					});
				}
			);
		});
		dojo.profile.end("dojo.behavior.applyFast");
	}
	
	this.applySlow = function(){
		// iterate. Ugg.
		dojo.profile.start("dojo.behavior.applySlow");
		var all = document.getElementsByTagName("*");
		var allLen = all.length;
		for(var x=0; x<allLen; x++){
			var elem = all[x];
			if((elem.id)&&(!elem["behaviorAdded"])&&(this.behaviors[elem.id])){
				elem["behaviorAdded"] = true;
				forIn(this.behaviors[elem.id], function(ruleSet, ruleSetName){
					if(dojo.lang.isArray(ruleSet)){
						dojo.lang.forEach(ruleSet, function(action){
							dojo.behavior.applyToNode(elem, action, ruleSetName);
						});
					}
				});
			}
		}
		dojo.profile.end("dojo.behavior.applySlow");
	}
}

dojo.addOnLoad(dojo.behavior, "apply");

__CPAN_FILE__ src/bootstrap1.js
/**
* @file bootstrap1.js
*
* bootstrap file that runs before hostenv_*.js file.
*
* @author Copyright 2004 Mark D. Anderson (mda@discerning.com)
* @author Licensed under the Academic Free License 2.1 http://www.opensource.org/licenses/afl-2.1.php
*
* $Id: bootstrap1.js 3802 2006-05-07 22:33:47Z sjmiles $
*/

/**
 * The global djConfig can be set prior to loading the library, to override
 * certain settings.  It does not exist under dojo.* so that it can be set
 * before the dojo variable exists. Setting any of these variables *after* the
 * library has loaded does nothing at all. The variables that can be set are
 * as follows:
 */

/**
 * dj_global is an alias for the top-level global object in the host
 * environment (the "window" object in a browser).
 */
var dj_global = this; //typeof window == 'undefined' ? this : window;

/**
 *  True if name is defined, either on obj or globally if obj is false
 *  Note that 'defined' and 'exists' are not the same concept. 
 */
function dj_undef(name, obj){
	if(!obj){ obj = dj_global; }
	// exception if obj is not an Object
	return (typeof obj[name] == "undefined");
}

/**
 * djConfig is the global configuration object 
 */
if(dj_undef("djConfig")){ 
	var djConfig = {}; 
}

/**
 * dojo is the root variable of (almost all) our public symbols.
 */
if(dj_undef("dojo")){ 
	var dojo = {}; 
}

dojo.version = {
	major: 0, minor: 2, patch: 2, flag: "+",
	revision: Number("$Rev: 3802 $".match(/[0-9]+/)[0]),
	toString: function(){
		with(dojo.version){
			return major + "." + minor + "." + patch + flag + " (" + revision + ")";
		}
	}
}

/**
 * get 'obj[name]' if it is defined, otherwise create as Object if 'create' is true, otherwise return null
 * caveat: 'defined' and 'exists' are not the same concept
 */
dojo.evalProp = function(name, obj, create){
	return (obj && !dj_undef(name, obj) ? obj[name] : (create ? (obj[name]={}) : undefined));
}

/**
 * Parse a reference specified as a string descriptor into an object reference and a property name.
 */
dojo.parseObjPath = function(objpath, context, create){
	var obj = (context ? context : dj_global);
	var names = objpath.split('.');
	var prop = names.pop();
	for (var i=0,l=names.length;i<l && obj;i++){
		obj = dojo.evalProp(names[i], obj, create);
	}
	return {obj: obj, prop: prop};
}

/*
 * evaluate a string like "A.B" without using eval.
 */
dojo.evalObjPath = function(objpath, create){
	if(typeof objpath != "string"){ 
		return dj_global; 
	}
	// fast path for no periods
	if(objpath.indexOf('.') == -1){
		return dojo.evalProp(objpath, dj_global, create);
	}
	with (dojo.parseObjPath(objpath, dj_global, create)){
		return dojo.evalProp(prop, obj, create);
	}	
}

// ****************************************************************
// global public utils
// ****************************************************************

/*
 * utility to print an Error. 
 * TODO: overriding Error.prototype.toString won't accomplish this?
 * ... since natively generated Error objects do not always reflect such things?
 */
dojo.errorToString = function(excep){
	return ((!dj_undef("message", excep)) ? excep.message : (dj_undef("description", excep) ? excep : excep.description ));
}

/**
* Throws an Error object given the string err. For now, will also do a println
* to the user first.
*/
dojo.raise = function(message, excep){
	if(excep){
		message = message + ": "+dojo.errorToString(excep);
	}
	var he = dojo.hostenv;
	if((!dj_undef("hostenv", dojo))&&(!dj_undef("println", dojo.hostenv))){ 
		dojo.hostenv.println("FATAL: " + message);
	}
	throw Error(message);
}

//Stub functions so things don't break.
dojo.debug = function(){}
dojo.debugShallow = function(obj){}
dojo.profile = { start: function(){}, end: function(){}, stop: function(){}, dump: function(){} };

/**
 * We put eval() in this separate function to keep down the size of the trapped
 * evaluation context.
 *
 * Note that:
 * - JSC eval() takes an optional second argument which can be 'unsafe'.
 * - Mozilla/SpiderMonkey eval() takes an optional second argument which is the
 *   scope object for new symbols.
*/
function dj_eval(s){ return dj_global.eval ? dj_global.eval(s) : eval(s); }


/**
 * Convenience for throwing an exception because some function is not
 * implemented.
 */
dojo.unimplemented = function(funcname, extra){
	// FIXME: need to move this away from dj_*
	var mess = "'" + funcname + "' not implemented";
	if((!dj_undef(extra))&&(extra)){ mess += " " + extra; }
	dojo.raise(mess);
}

/**
 * Convenience for informing of deprecated behaviour.
 */
dojo.deprecated = function(behaviour, extra, removal){
	var mess = "DEPRECATED: " + behaviour;
	if(extra){ mess += " " + extra; }
	if(removal){ mess += " -- will be removed in version: " + removal; }
	dojo.debug(mess);
}

/**
 * Does inheritance
 */
dojo.inherits = function(subclass, superclass){
	if(typeof superclass != 'function'){ 
		dojo.raise("dojo.inherits: superclass argument ["+superclass+"] must be a function (subclass: [" + subclass + "']");
	}
	subclass.prototype = new superclass();
	subclass.prototype.constructor = subclass;
	subclass.superclass = superclass.prototype;
	// DEPRICATED: super is a reserved word, use 'superclass'
	subclass['super'] = superclass.prototype;
}

// an object that authors use determine what host we are running under
dojo.render = (function(){

	function vscaffold(prefs, names){
		var tmp = {
			capable: false,
			support: {
				builtin: false,
				plugin: false
			},
			prefixes: prefs
		};
		for(var x in names){
			tmp[x] = false;
		}
		return tmp;
	}

	return {
		name: "",
		ver: dojo.version,
		os: { win: false, linux: false, osx: false },
		html: vscaffold(["html"], ["ie", "opera", "khtml", "safari", "moz"]),
		svg: vscaffold(["svg"], ["corel", "adobe", "batik"]),
		vml: vscaffold(["vml"], ["ie"]),
		swf: vscaffold(["Swf", "Flash", "Mm"], ["mm"]),
		swt: vscaffold(["Swt"], ["ibm"])
	};
})();

// ****************************************************************
// dojo.hostenv methods that must be defined in hostenv_*.js
// ****************************************************************

/**
 * The interface definining the interaction with the EcmaScript host environment.
*/

/*
 * None of these methods should ever be called directly by library users.
 * Instead public methods such as loadModule should be called instead.
 */
dojo.hostenv = (function(){

	// default configuration options
	var config = {
		isDebug: false,
		allowQueryConfig: false,
		baseScriptUri: "",
		baseRelativePath: "",
		libraryScriptUri: "",
		iePreventClobber: false,
		ieClobberMinimal: true,
		preventBackButtonFix: true,
		searchIds: [],
		parseWidgets: true
	};

	if (typeof djConfig == "undefined") { djConfig = config; }
	else {
		for (var option in config) {
			if (typeof djConfig[option] == "undefined") {
				djConfig[option] = config[option];
			}
		}
	}

	return {
		name_: '(unset)',
		version_: '(unset)',

		/**
		 * Return the name of the hostenv.
		 */
		getName: function(){ return this.name_; },

		/**
		* Return the version of the hostenv.
		*/
		getVersion: function(){ return this.version_; },

		/**
		 * Read the plain/text contents at the specified uri.  If getText() is
		 * not implemented, then it is necessary to override loadUri() with an
		 * implementation that doesn't rely on it.
		 */
		getText: function(uri){
			dojo.unimplemented('getText', "uri=" + uri);
		}
	};
})();

/**
 * Return the base script uri that other scripts are found relative to.
 * It is either the empty string, or a non-empty string ending in '/'.
 */
dojo.hostenv.getBaseScriptUri = function(){
	if(djConfig.baseScriptUri.length){ 
		return djConfig.baseScriptUri;
	}
	var uri = new String(djConfig.libraryScriptUri||djConfig.baseRelativePath);
	if (!uri) { dojo.raise("Nothing returned by getLibraryScriptUri(): " + uri); }

	var lastslash = uri.lastIndexOf('/');
	djConfig.baseScriptUri = djConfig.baseRelativePath;
	return djConfig.baseScriptUri;
}

__CPAN_FILE__ src/bootstrap2.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

//Semicolon is for when this file is integrated with a custom build on one line
//with some other file's contents. Sometimes that makes things not get defined
//properly, particularly with the using the closure below to do all the work.
;(function(){
	//Don't do this work if dojo.js has already done it.
	if(typeof dj_usingBootstrap != "undefined"){
		return;
	}

	var isRhino = false;
	var isSpidermonkey = false;
	var isDashboard = false;
	if((typeof this["load"] == "function")&&(typeof this["Packages"] == "function")){
		isRhino = true;
	}else if(typeof this["load"] == "function"){
		isSpidermonkey  = true;
	}else if(window.widget){
		isDashboard = true;
	}

	var tmps = [];
	if((this["djConfig"])&&((djConfig["isDebug"])||(djConfig["debugAtAllCosts"]))){
		tmps.push("debug.js");
	}

	if((this["djConfig"])&&(djConfig["debugAtAllCosts"])&&(!isRhino)&&(!isDashboard)){
		tmps.push("browser_debug.js");
	}

	//Support compatibility packages. Right now this only allows setting one
	//compatibility package. Might need to revisit later down the line to support
	//more than one.
	if((this["djConfig"])&&(djConfig["compat"])){
		tmps.push("compat/" + djConfig["compat"] + ".js");
	}

	var loaderRoot = djConfig["baseScriptUri"];
	if((this["djConfig"])&&(djConfig["baseLoaderUri"])){
		loaderRoot = djConfig["baseLoaderUri"];
	}

	for(var x=0; x < tmps.length; x++){
		var spath = loaderRoot+"src/"+tmps[x];
		if(isRhino||isSpidermonkey){
			load(spath);
		} else {
			try {
				document.write("<scr"+"ipt type='text/javascript' src='"+spath+"'></scr"+"ipt>");
			} catch (e) {
				var script = document.createElement("script");
				script.src = spath;
				document.getElementsByTagName("head")[0].appendChild(script);
			}
		}
	}
})();

__CPAN_FILE__ src/browser_debug.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.hostenv.loadedUris.push("../src/bootstrap1.js");
dojo.hostenv.loadedUris.push("../src/loader.js");
dojo.hostenv.loadedUris.push("../src/hostenv_browser.js");
dojo.hostenv.loadedUris.push("../src/bootstrap2.js");

function removeComments(contents){
	contents = new String((!contents) ? "" : contents);
	// clobber all comments
	contents = contents.replace( /^(.*?)\/\/(.*)$/mg , "$1");
	contents = contents.replace( /(\n)/mg , "__DOJONEWLINE");
	contents = contents.replace( /\/\*(.*?)\*\//g , "");
	return contents.replace( /__DOJONEWLINE/mg , "\n");
}

dojo.hostenv.getRequiresAndProvides = function(contents){
	// FIXME: should probably memoize this!
	if(!contents){ return []; }
	

	// check to see if we need to load anything else first. Ugg.
	var deps = [];
	var tmp;
	RegExp.lastIndex = 0;
	var testExp = /dojo.(hostenv.loadModule|hosetnv.require|require|requireIf|kwCompoundRequire|hostenv.conditionalLoadModule|hostenv.startPackage|provide)\([\w\W]*?\)/mg;
	while((tmp = testExp.exec(contents)) != null){
		deps.push(tmp[0]);
	}
	return deps;
}

dojo.hostenv.getDelayRequiresAndProvides = function(contents){
	// FIXME: should probably memoize this!
	if(!contents){ return []; }

	// check to see if we need to load anything else first. Ugg.
	var deps = [];
	var tmp;
	RegExp.lastIndex = 0;
	var testExp = /dojo.(requireAfterIf)\([\w\W]*?\)/mg;
	while((tmp = testExp.exec(contents)) != null){
		deps.push(tmp[0]);
	}
	return deps;
}

/*
dojo.getNonExistantDescendants = function(objpath){
	var ret = [];
	// fast path for no periods
	if(typeof objpath != "string"){ return dj_global; }
	if(objpath.indexOf('.') == -1){
		if(dj_undef(objpath, dj_global)){
			ret.push[objpath];
		}
		return ret;
	}

	var syms = objpath.split(/\./);
	var obj = dj_global;
	for(var i=0;i<syms.length;++i){
		if(dj_undef(syms[i], obj)){
			for(var j=i; j<syms.length; j++){
				ret.push(syms.slice(0, j+1).join("."));
			}
			break;
		}
	}
	return ret;
}
*/

dojo.clobberLastObject = function(objpath){
	if(objpath.indexOf('.') == -1){
		if(!dj_undef(objpath, dj_global)){
			delete dj_global[objpath];
		}
		return true;
	}

	var syms = objpath.split(/\./);
	var base = dojo.evalObjPath(syms.slice(0, -1).join("."), false);
	var child = syms[syms.length-1];
	if(!dj_undef(child, base)){
		// alert(objpath);
		delete base[child];
		return true;
	}
	return false;
}

var removals = [];

function zip(arr){
	var ret = [];
	var seen = {};
	for(var x=0; x<arr.length; x++){
		if(!seen[arr[x]]){
			ret.push(arr[x]);
			seen[arr[x]] = true;
		}
	}
	return ret;
}

// over-write dj_eval to prevent actual loading of subsequent files
var old_dj_eval = dj_eval;
dj_eval = function(){ return true; }
dojo.hostenv.oldLoadUri = dojo.hostenv.loadUri;
dojo.hostenv.loadUri = function(uri){
	if(dojo.hostenv.loadedUris[uri]){
		return true; // fixes endless recursion opera trac 471
	}
	try{
		var text = this.getText(uri, null, true);
		var requires = dojo.hostenv.getRequiresAndProvides(text);
		eval(requires.join(";"));
		dojo.hostenv.loadedUris.push(uri);
		dojo.hostenv.loadedUris[uri] = true;
		var delayRequires = dojo.hostenv.getDelayRequiresAndProvides(text);
		eval(delayRequires.join(";"));
	}catch(e){ 
		alert(e);
	}
	return true;
}

dojo.hostenv.writeIncludes = function(){
	for(var x=removals.length-1; x>=0; x--){
		dojo.clobberLastObject(removals[x]);
	}
	var depList = [];
	var seen = {};
	for(var x=0; x<dojo.hostenv.loadedUris.length; x++){
		var curi = dojo.hostenv.loadedUris[x];
		// dojo.debug(curi);
		if(!seen[curi]){
			seen[curi] = true;
			depList.push(curi);
		}
	}

	dojo.hostenv._global_omit_module_check = true;
	for(var x=4; x<depList.length; x++){
		document.write("<script type='text/javascript' src='"+depList[x]+"'></script>");
	}
	document.write("<script type='text/javascript'>dojo.hostenv._global_omit_module_check = false;</script>");

	// turn off debugAtAllCosts, so that dojo.require() calls inside of ContentPane hrefs
	// work correctly
	dj_eval = old_dj_eval;
	dojo.hostenv.loadUri = dojo.hostenv.oldLoadUri;
}

__CPAN_FILE__ src/crypto.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.crypto");

//	enumerations for use in crypto code. Note that 0 == default, for the most part.
dojo.crypto.cipherModes={ ECB:0, CBC:1, PCBC:2, CFB:3, OFB:4, CTR:5 };
dojo.crypto.outputTypes={ Base64:0,Hex:1,String:2,Raw:3 };

__CPAN_FILE__ src/data.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data");

// currently a stub for dojo.data

dojo.data = {};

__CPAN_FILE__ src/date.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.date");


/* Supplementary Date Functions
 *******************************/

dojo.date.setDayOfYear = function (dateObject, dayofyear) {
	dateObject.setMonth(0);
	dateObject.setDate(dayofyear);
	return dateObject;
}

dojo.date.getDayOfYear = function (dateObject) {
	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1);
	return Math.floor((dateObject.getTime() -
		firstDayOfYear.getTime()) / 86400000);
}




dojo.date.setWeekOfYear = function (dateObject, week, firstDay) {
	if (arguments.length == 1) { firstDay = 0; } // Sunday
	dojo.unimplemented("dojo.date.setWeekOfYear");
}

dojo.date.getWeekOfYear = function (dateObject, firstDay) {
	if (arguments.length == 1) { firstDay = 0; } // Sunday

	// work out the first day of the year corresponding to the week
	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1);
	var day = firstDayOfYear.getDay();
	firstDayOfYear.setDate(firstDayOfYear.getDate() -
			day + firstDay - (day > firstDay ? 7 : 0));

	return Math.floor((dateObject.getTime() -
		firstDayOfYear.getTime()) / 604800000);
}




dojo.date.setIsoWeekOfYear = function (dateObject, week, firstDay) {
	if (arguments.length == 1) { firstDay = 1; } // Monday
	dojo.unimplemented("dojo.date.setIsoWeekOfYear");
}

dojo.date.getIsoWeekOfYear = function (dateObject, firstDay) {
	if (arguments.length == 1) { firstDay = 1; } // Monday
	dojo.unimplemented("dojo.date.getIsoWeekOfYear");
}




/* ISO 8601 Functions
 *********************/

dojo.date.setIso8601 = function (dateObject, string){
	var comps = (string.indexOf("T") == -1) ? string.split(" ") : string.split("T");
	dojo.date.setIso8601Date(dateObject, comps[0]);
	if (comps.length == 2) { dojo.date.setIso8601Time(dateObject, comps[1]); }
	return dateObject;
}

dojo.date.fromIso8601 = function (string) {
	return dojo.date.setIso8601(new Date(0, 0), string);
}




dojo.date.setIso8601Date = function (dateObject, string) {
	var regexp = "^([0-9]{4})((-?([0-9]{2})(-?([0-9]{2}))?)|" +
			"(-?([0-9]{3}))|(-?W([0-9]{2})(-?([1-7]))?))?$";
	var d = string.match(new RegExp(regexp));
	if(!d) {
		dojo.debug("invalid date string: " + string);
		return false;
	}
	var year = d[1];
	var month = d[4];
	var date = d[6];
	var dayofyear = d[8];
	var week = d[10];
	var dayofweek = (d[12]) ? d[12] : 1;

	dateObject.setYear(year);
	
	if (dayofyear) { dojo.date.setDayOfYear(dateObject, Number(dayofyear)); }
	else if (week) {
		dateObject.setMonth(0);
		dateObject.setDate(1);
		var gd = dateObject.getDay();
		var day =  (gd) ? gd : 7;
		var offset = Number(dayofweek) + (7 * Number(week));
		
		if (day <= 4) { dateObject.setDate(offset + 1 - day); }
		else { dateObject.setDate(offset + 8 - day); }
	} else {
		if (month) { 
			dateObject.setDate(1);
			dateObject.setMonth(month - 1); 
		}
		if (date) { dateObject.setDate(date); }
	}
	
	return dateObject;
}

dojo.date.fromIso8601Date = function (string) {
	return dojo.date.setIso8601Date(new Date(0, 0), string);
}




dojo.date.setIso8601Time = function (dateObject, string) {
	// first strip timezone info from the end
	var timezone = "Z|(([-+])([0-9]{2})(:?([0-9]{2}))?)$";
	var d = string.match(new RegExp(timezone));

	var offset = 0; // local time if no tz info
	if (d) {
		if (d[0] != 'Z') {
			offset = (Number(d[3]) * 60) + Number(d[5]);
			offset *= ((d[2] == '-') ? 1 : -1);
		}
		offset -= dateObject.getTimezoneOffset();
		string = string.substr(0, string.length - d[0].length);
	}

	// then work out the time
	var regexp = "^([0-9]{2})(:?([0-9]{2})(:?([0-9]{2})(\.([0-9]+))?)?)?$";
	var d = string.match(new RegExp(regexp));
	if(!d) {
		dojo.debug("invalid time string: " + string);
		return false;
	}
	var hours = d[1];
	var mins = Number((d[3]) ? d[3] : 0);
	var secs = (d[5]) ? d[5] : 0;
	var ms = d[7] ? (Number("0." + d[7]) * 1000) : 0;

	dateObject.setHours(hours);
	dateObject.setMinutes(mins);
	dateObject.setSeconds(secs);
	dateObject.setMilliseconds(ms);
	
	return dateObject;
}

dojo.date.fromIso8601Time = function (string) {
	return dojo.date.setIso8601Time(new Date(0, 0), string);
}



/* Informational Functions
 **************************/

dojo.date.shortTimezones = ["IDLW", "BET", "HST", "MART", "AKST", "PST", "MST",
	"CST", "EST", "AST", "NFT", "BST", "FST", "AT", "GMT", "CET", "EET", "MSK",
	"IRT", "GST", "AFT", "AGTT", "IST", "NPT", "ALMT", "MMT", "JT", "AWST",
	"JST", "ACST", "AEST", "LHST", "VUT", "NFT", "NZT", "CHAST", "PHOT",
	"LINT"];
dojo.date.timezoneOffsets = [-720, -660, -600, -570, -540, -480, -420, -360,
	-300, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300,
	330, 345, 360, 390, 420, 480, 540, 570, 600, 630, 660, 690, 720, 765, 780,
	840];
/*
dojo.date.timezones = ["International Date Line West", "Bering Standard Time",
	"Hawaiian Standard Time", "Marquesas Time", "Alaska Standard Time",
	"Pacific Standard Time (USA)", "Mountain Standard Time",
	"Central Standard Time (USA)", "Eastern Standard Time (USA)",
	"Atlantic Standard Time", "Newfoundland Time", "Brazil Standard Time",
	"Fernando de Noronha Standard Time (Brazil)", "Azores Time",
	"Greenwich Mean Time", "Central Europe Time", "Eastern Europe Time",
	"Moscow Time", "Iran Standard Time", "Gulf Standard Time",
	"Afghanistan Time", "Aqtobe Time", "Indian Standard Time", "Nepal Time",
	"Almaty Time", "Myanmar Time", "Java Time",
	"Australian Western Standard Time", "Japan Standard Time",
	"Australian Central Standard Time", "Lord Hove Standard Time (Australia)",
	"Vanuata Time", "Norfolk Time (Australia)", "New Zealand Standard Time",
	"Chatham Standard Time (New Zealand)", "Phoenix Islands Time (Kribati)",
	"Line Islands Time (Kribati)"];
*/
dojo.date.months = ["January", "February", "March", "April", "May", "June",
	"July", "August", "September", "October", "November", "December"];
dojo.date.shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "June",
	"July", "Aug", "Sep", "Oct", "Nov", "Dec"];
dojo.date.days = ["Sunday", "Monday", "Tuesday", "Wednesday",
	"Thursday", "Friday", "Saturday"];
dojo.date.shortDays = ["Sun", "Mon", "Tues", "Wed", "Thur", "Fri", "Sat"];


dojo.date.getDaysInMonth = function (dateObject) {
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if (month == 1 && dojo.date.isLeapYear(dateObject)) { return 29; }
	else { return days[month]; }
}

dojo.date.isLeapYear = function (dateObject) {
	/*
	 * Leap years are years with an additional day YYYY-02-29, where the year
	 * number is a multiple of four with the following exception: If a year
	 * is a multiple of 100, then it is only a leap year if it is also a
	 * multiple of 400. For example, 1900 was not a leap year, but 2000 is one.
	 */
	var year = dateObject.getFullYear();
	return (year%400 == 0) ? true : (year%100 == 0) ? false : (year%4 == 0) ? true : false;
}



dojo.date.getDayName = function (dateObject) {
	return dojo.date.days[dateObject.getDay()];
}

dojo.date.getDayShortName = function (dateObject) {
	return dojo.date.shortDays[dateObject.getDay()];
}




dojo.date.getMonthName = function (dateObject) {
	return dojo.date.months[dateObject.getMonth()];
}

dojo.date.getMonthShortName = function (dateObject) {
	return dojo.date.shortMonths[dateObject.getMonth()];
}




dojo.date.getTimezoneName = function (dateObject) {
	// need to negate timezones to get it right 
	// i.e UTC+1 is CET winter, but getTimezoneOffset returns -60
	var timezoneOffset = -(dateObject.getTimezoneOffset());
	
	for (var i = 0; i < dojo.date.timezoneOffsets.length; i++) {
		if (dojo.date.timezoneOffsets[i] == timezoneOffset) {
			return dojo.date.shortTimezones[i];
		}
	}
	
	// we don't know so return it formatted as "+HH:MM"
	function $ (s) { s = String(s); while (s.length < 2) { s = "0" + s; } return s; }
	return (timezoneOffset < 0 ? "-" : "+") + $(Math.floor(Math.abs(
		timezoneOffset)/60)) + ":" + $(Math.abs(timezoneOffset)%60);
}




dojo.date.getOrdinal = function (dateObject) {
	var date = dateObject.getDate();

	if (date%100 != 11 && date%10 == 1) { return "st"; }
	else if (date%100 != 12 && date%10 == 2) { return "nd"; }
	else if (date%100 != 13 && date%10 == 3) { return "rd"; }
	else { return "th"; }
}



/* Date Formatter Functions
 ***************************/

// POSIX strftime
// see <http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html>
dojo.date.format = dojo.date.strftime = function (dateObject, format) {

	// zero pad
	var padChar = null;
	function _ (s, n) {
		s = String(s);
		n = (n || 2) - s.length;
		while (n-- > 0) { s = (padChar == null ? "0" : padChar) + s; }
		return s;
	}
	
	function $ (property) {
		switch (property) {
			case "a": // abbreviated weekday name according to the current locale
				return dojo.date.getDayShortName(dateObject); break;

			case "A": // full weekday name according to the current locale
				return dojo.date.getDayName(dateObject); break;

			case "b":
			case "h": // abbreviated month name according to the current locale
				return dojo.date.getMonthShortName(dateObject); break;
				
			case "B": // full month name according to the current locale
				return dojo.date.getMonthName(dateObject); break;
				
			case "c": // preferred date and time representation for the current
				      // locale
				return dateObject.toLocaleString(); break;

			case "C": // century number (the year divided by 100 and truncated
				      // to an integer, range 00 to 99)
				return _(Math.floor(dateObject.getFullYear()/100)); break;
				
			case "d": // day of the month as a decimal number (range 01 to 31)
				return _(dateObject.getDate()); break;
				
			case "D": // same as %m/%d/%y
				return $("m") + "/" + $("d") + "/" + $("y"); break;
					
			case "e": // day of the month as a decimal number, a single digit is
				      // preceded by a space (range ' 1' to '31')
				if (padChar == null) { padChar = " "; }
				return _(dateObject.getDate(), 2); break;
			
			case "g": // like %G, but without the century.
				break;
			
			case "G": // The 4-digit year corresponding to the ISO week number
				      // (see %V).  This has the same format and value as %Y,
				      // except that if the ISO week number belongs to the
				      // previous or next year, that year is used instead.
				break;
			
			case "F": // same as %Y-%m-%d
				return $("Y") + "-" + $("m") + "-" + $("d"); break;
				
			case "H": // hour as a decimal number using a 24-hour clock (range
				      // 00 to 23)
				return _(dateObject.getHours()); break;
				
			case "I": // hour as a decimal number using a 12-hour clock (range
				      // 01 to 12)
				return _(dateObject.getHours() % 12 || 12); break;
				
			case "j": // day of the year as a decimal number (range 001 to 366)
				return _(dojo.date.getDayOfYear(dateObject), 3); break;
				
			case "m": // month as a decimal number (range 01 to 12)
				return _(dateObject.getMonth() + 1); break;
				
			case "M": // minute as a decimal numbe
				return _(dateObject.getMinutes()); break;
			
			case "n":
				return "\n"; break;

			case "p": // either `am' or `pm' according to the given time value,
				      // or the corresponding strings for the current locale
				return dateObject.getHours() < 12 ? "am" : "pm"; break;
				
			case "r": // time in a.m. and p.m. notation
				return $("I") + ":" + $("M") + ":" + $("S") + " " + $("p"); break;
				
			case "R": // time in 24 hour notation
				return $("H") + ":" + $("M"); break;
				
			case "S": // second as a decimal number
				return _(dateObject.getSeconds()); break;

			case "t":
				return "\t"; break;

			case "T": // current time, equal to %H:%M:%S
				return $("H") + ":" + $("M") + ":" + $("S"); break;
				
			case "u": // weekday as a decimal number [1,7], with 1 representing
				      // Monday
				return String(dateObject.getDay() || 7); break;
				
			case "U": // week number of the current year as a decimal number,
				      // starting with the first Sunday as the first day of the
				      // first week
				return _(dojo.date.getWeekOfYear(dateObject)); break;

			case "V": // week number of the year (Monday as the first day of the
				      // week) as a decimal number [01,53]. If the week containing
				      // 1 January has four or more days in the new year, then it 
				      // is considered week 1. Otherwise, it is the last week of 
				      // the previous year, and the next week is week 1.
				return _(dojo.date.getIsoWeekOfYear(dateObject)); break;
				
			case "W": // week number of the current year as a decimal number,
				      // starting with the first Monday as the first day of the
				      // first week
				return _(dojo.date.getWeekOfYear(dateObject, 1)); break;
				
			case "w": // day of the week as a decimal, Sunday being 0
				return String(dateObject.getDay()); break;

			case "x": // preferred date representation for the current locale
				      // without the time
				break;

			case "X": // preferred date representation for the current locale
				      // without the time
				break;

			case "y": // year as a decimal number without a century (range 00 to
				      // 99)
				return _(dateObject.getFullYear()%100); break;
				
			case "Y": // year as a decimal number including the century
				return String(dateObject.getFullYear()); break;
			
			case "z": // time zone or name or abbreviation
				var timezoneOffset = dateObject.getTimezoneOffset();
				return (timezoneOffset < 0 ? "-" : "+") + 
					_(Math.floor(Math.abs(timezoneOffset)/60)) + ":" +
					_(Math.abs(timezoneOffset)%60); break;
				
			case "Z": // time zone or name or abbreviation
				return dojo.date.getTimezoneName(dateObject); break;
			
			case "%":
				return "%"; break;
		}
	}

	// parse the formatting string and construct the resulting string
	var string = "";
	var i = 0, index = 0, switchCase;
	while ((index = format.indexOf("%", i)) != -1) {
		string += format.substring(i, index++);
		
		// inspect modifier flag
		switch (format.charAt(index++)) {
			case "_": // Pad a numeric result string with spaces.
				padChar = " "; break;
			case "-": // Do not pad a numeric result string.
				padChar = ""; break;
			case "0": // Pad a numeric result string with zeros.
				padChar = "0"; break;
			case "^": // Convert characters in result string to upper case.
				switchCase = "upper"; break;
			case "#": // Swap the case of the result string.
				switchCase = "swap"; break;
			default: // no modifer flag so decremenet the index
				padChar = null; index--; break;
		}

		// toggle case if a flag is set
		property = $(format.charAt(index++));
		if (switchCase == "upper" ||
			(switchCase == "swap" && /[a-z]/.test(property))) {
			property = property.toUpperCase();
		} else if (switchCase == "swap" && !/[a-z]/.test(property)) {
			property = property.toLowerCase();
		}
		swicthCase = null;
		
		string += property;
		i = index;
	}
	string += format.substring(i);
	
	return string;
}

/* compare and add
 ******************/
dojo.date.compareTypes={
	// 	summary
	//	bitmask for comparison operations.
	DATE:1, TIME:2 
};
dojo.date.compare=function(/* Date */ dateA, /* Date */ dateB, /* int */ options){
	//	summary
	//	Compare two date objects by date, time, or both.
	var dA=dateA;
	var dB=dateB||new Date();
	var now=new Date();
	var opt=options||(dojo.date.compareTypes.DATE|dojo.date.compareTypes.TIME);
	var d1=new Date(
		((opt&dojo.date.compareTypes.DATE)?(dA.getFullYear()):now.getFullYear()), 
		((opt&dojo.date.compareTypes.DATE)?(dA.getMonth()):now.getMonth()), 
		((opt&dojo.date.compareTypes.DATE)?(dA.getDate()):now.getDate()), 
		((opt&dojo.date.compareTypes.TIME)?(dA.getHours()):0), 
		((opt&dojo.date.compareTypes.TIME)?(dA.getMinutes()):0), 
		((opt&dojo.date.compareTypes.TIME)?(dA.getSeconds()):0)
	);
	var d2=new Date(
		((opt&dojo.date.compareTypes.DATE)?(dB.getFullYear()):now.getFullYear()), 
		((opt&dojo.date.compareTypes.DATE)?(dB.getMonth()):now.getMonth()), 
		((opt&dojo.date.compareTypes.DATE)?(dB.getDate()):now.getDate()), 
		((opt&dojo.date.compareTypes.TIME)?(dB.getHours()):0), 
		((opt&dojo.date.compareTypes.TIME)?(dB.getMinutes()):0), 
		((opt&dojo.date.compareTypes.TIME)?(dB.getSeconds()):0)
	);
	if(d1.valueOf()>d2.valueOf()){
		return 1;	//	int
	}
	if(d1.valueOf()<d2.valueOf()){
		return -1;	//	int
	}
	return 0;	//	int
}

dojo.date.dateParts={ 
	//	summary
	//	constants for use in dojo.date.add
	YEAR:0, MONTH:1, DAY:2, HOUR:3, MINUTE:4, SECOND:5, MILLISECOND:6 
};
dojo.date.add=function(/* Date */ d, /* dojo.date.dateParts */ unit, /* int */ amount){
	var n=(amount)?amount:1;
	var v;
	switch(unit){
		case dojo.date.dateParts.YEAR:{
			v=new Date(d.getFullYear()+n, d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
			break;
		}
		case dojo.date.dateParts.MONTH:{
			v=new Date(d.getFullYear(), d.getMonth()+n, d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
			break;
		}
		case dojo.date.dateParts.HOUR:{
			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours()+n, d.getMinutes(), d.getSeconds(), d.getMilliseconds());
			break;
		}
		case dojo.date.dateParts.MINUTE:{
			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes()+n, d.getSeconds(), d.getMilliseconds());
			break;
		}
		case dojo.date.dateParts.SECOND:{
			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds()+n, d.getMilliseconds());
			break;
		}
		case dojo.date.dateParts.MILLISECOND:{
			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()+n);
			break;
		}
		default:{
			v=new Date(d.getFullYear(), d.getMonth(), d.getDate()+n, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
		}
	};
	return v;	//	Date
};

/* Deprecated
 *************/


dojo.date.toString = function(date, format){
	dojo.deprecated("dojo.date.toString",
		"use dojo.date.format instead", "0.4");

	if (format.indexOf("#d") > -1) {
		format = format.replace(/#dddd/g, dojo.date.getDayOfWeekName(date));
		format = format.replace(/#ddd/g, dojo.date.getShortDayOfWeekName(date));
		format = format.replace(/#dd/g, (date.getDate().toString().length==1?"0":"")+date.getDate());
		format = format.replace(/#d/g, date.getDate());
	}

	if (format.indexOf("#M") > -1) {
		format = format.replace(/#MMMM/g, dojo.date.getMonthName(date));
		format = format.replace(/#MMM/g, dojo.date.getShortMonthName(date));
		format = format.replace(/#MM/g, ((date.getMonth()+1).toString().length==1?"0":"")+(date.getMonth()+1));
		format = format.replace(/#M/g, date.getMonth() + 1);
	}

	if (format.indexOf("#y") > -1) {
		var fullYear = date.getFullYear().toString();
		format = format.replace(/#yyyy/g, fullYear);
		format = format.replace(/#yy/g, fullYear.substring(2));
		format = format.replace(/#y/g, fullYear.substring(3));
	}

	// Return if only date needed;
	if (format.indexOf("#") == -1) {
		return format;
	}
	
	if (format.indexOf("#h") > -1) {
		var hours = date.getHours();
		hours = (hours > 12 ? hours - 12 : (hours == 0) ? 12 : hours);
		format = format.replace(/#hh/g, (hours.toString().length==1?"0":"")+hours);
		format = format.replace(/#h/g, hours);
	}
	
	if (format.indexOf("#H") > -1) {
		format = format.replace(/#HH/g, (date.getHours().toString().length==1?"0":"")+date.getHours());
		format = format.replace(/#H/g, date.getHours());
	}
	
	if (format.indexOf("#m") > -1) {
		format = format.replace(/#mm/g, (date.getMinutes().toString().length==1?"0":"")+date.getMinutes());
		format = format.replace(/#m/g, date.getMinutes());
	}

	if (format.indexOf("#s") > -1) {
		format = format.replace(/#ss/g, (date.getSeconds().toString().length==1?"0":"")+date.getSeconds());
		format = format.replace(/#s/g, date.getSeconds());
	}
	
	if (format.indexOf("#T") > -1) {
		format = format.replace(/#TT/g, date.getHours() >= 12 ? "PM" : "AM");
		format = format.replace(/#T/g, date.getHours() >= 12 ? "P" : "A");
	}

	if (format.indexOf("#t") > -1) {
		format = format.replace(/#tt/g, date.getHours() >= 12 ? "pm" : "am");
		format = format.replace(/#t/g, date.getHours() >= 12 ? "p" : "a");
	}
					
	return format;
	
}


dojo.date.daysInMonth = function (month, year) {
	dojo.deprecated("daysInMonth(month, year)",
		"replaced by getDaysInMonth(dateObject)", "0.4");
	return dojo.date.getDaysInMonth(new Date(year, month, 1));
}

/**
 *
 * Returns a string of the date in the version "January 1, 2004"
 *
 * @param date The date object
 */
dojo.date.toLongDateString = function(date) {
	dojo.deprecated("dojo.date.toLongDateString",
		'use dojo.date.format(date, "%B %e, %Y") instead', "0.4");
	return dojo.date.format(date, "%B %e, %Y")
}

/**
 *
 * Returns a string of the date in the version "Jan 1, 2004"
 *
 * @param date The date object
 */
dojo.date.toShortDateString = function(date) {
	dojo.deprecated("dojo.date.toShortDateString",
		'use dojo.date.format(date, "%b %e, %Y") instead', "0.4");
	return dojo.date.format(date, "%b %e, %Y");
}

/**
 *
 * Returns military formatted time
 *
 * @param date the date object
 */
dojo.date.toMilitaryTimeString = function(date){
	dojo.deprecated("dojo.date.toMilitaryTimeString",
		'use dojo.date.format(date, "%T")', "0.4");
	return dojo.date.format(date, "%T");
}

/**
 *
 * Returns a string of the date relative to the current date.
 *
 * @param date The date object
 *
 * Example returns:
 * - "1 minute ago"
 * - "4 minutes ago"
 * - "Yesterday"
 * - "2 days ago"
 */
dojo.date.toRelativeString = function(date) {
	var now = new Date();
	var diff = (now - date) / 1000;
	var end = " ago";
	var future = false;
	if(diff < 0) {
		future = true;
		end = " from now";
		diff = -diff;
	}

	if(diff < 60) {
		diff = Math.round(diff);
		return diff + " second" + (diff == 1 ? "" : "s") + end;
	} else if(diff < 3600) {
		diff = Math.round(diff/60);
		return diff + " minute" + (diff == 1 ? "" : "s") + end;
	} else if(diff < 3600*24 && date.getDay() == now.getDay()) {
		diff = Math.round(diff/3600);
		return diff + " hour" + (diff == 1 ? "" : "s") + end;
	} else if(diff < 3600*24*7) {
		diff = Math.round(diff/(3600*24));
		if(diff == 1) {
			return future ? "Tomorrow" : "Yesterday";
		} else {
			return diff + " days" + end;
		}
	} else {
		return dojo.date.toShortDateString(date);
	}
}

/**
 * Retrieves the day of the week the Date is set to.
 *
 * @return The day of the week
 */
dojo.date.getDayOfWeekName = function (date) {
	dojo.deprecated("dojo.date.getDayOfWeekName",
		"use dojo.date.getDayName instead", "0.4");
	return dojo.date.days[date.getDay()];
}

/**
 * Retrieves the short day of the week name the Date is set to.
 *
 * @return The short day of the week name
 */
dojo.date.getShortDayOfWeekName = function (date) {
	dojo.deprecated("dojo.date.getShortDayOfWeekName",
		"use dojo.date.getDayShortName instead", "0.4");
	return dojo.date.shortDays[date.getDay()];
}

/**
 * Retrieves the short month name the Date is set to.
 *
 * @return The short month name
 */
dojo.date.getShortMonthName = function (date) {
	dojo.deprecated("dojo.date.getShortMonthName",
		"use dojo.date.getMonthShortName instead", "0.4");
	return dojo.date.shortMonths[date.getMonth()];
}


/**
 * Convert a Date to a SQL string, optionally ignoring the HH:MM:SS portion of the Date
 */
dojo.date.toSql = function(date, noTime) {
	return dojo.date.format(date, "%F" + !noTime ? " %T" : "");
}

/**
 * Convert a SQL date string to a JavaScript Date object
 */
dojo.date.fromSql = function(sqlDate) {
	var parts = sqlDate.split(/[\- :]/g);
	while(parts.length < 6) {
		parts.push(0);
	}
	return new Date(parts[0], (parseInt(parts[1],10)-1), parts[2], parts[3], parts[4], parts[5]);
}


__CPAN_FILE__ src/debug.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/**
 * Produce a line of debug output. 
 * Does nothing unless djConfig.isDebug is true.
 * varargs, joined with ''.
 * Caller should not supply a trailing "\n".
 */
dojo.debug = function(){
	if (!djConfig.isDebug) { return; }
	var args = arguments;
	if(dj_undef("println", dojo.hostenv)){
		dojo.raise("dojo.debug not available (yet?)");
	}
	var isJUM = dj_global["jum"] && !dj_global["jum"].isBrowser;
	var s = [(isJUM ? "": "DEBUG: ")];
	for(var i=0;i<args.length;++i){
		if(!false && args[i] instanceof Error){
			var msg = "[" + args[i].name + ": " + dojo.errorToString(args[i]) +
				(args[i].fileName ? ", file: " + args[i].fileName : "") +
				(args[i].lineNumber ? ", line: " + args[i].lineNumber : "") + "]";
		} else {
			try {
				var msg = String(args[i]);
			} catch(e) {
				if(dojo.render.html.ie) {
					var msg = "[ActiveXObject]";
				} else {
					var msg = "[unknown]";
				}
			}
		}
		s.push(msg);
	}
	if(isJUM){ // this seems to be the only way to get JUM to "play nice"
		jum.debug(s.join(" "));
	}else{
		dojo.hostenv.println(s.join(" "));
	}
}

/**
 * this is really hacky for now - just 
 * display the properties of the object
**/

dojo.debugShallow = function(obj){
	if (!djConfig.isDebug) { return; }
	dojo.debug('------------------------------------------------------------');
	dojo.debug('Object: '+obj);
	var props = [];
	for(var prop in obj){
		try {
			props.push(prop + ': ' + obj[prop]);
		} catch(E) {
			props.push(prop + ': ERROR - ' + E.message);
		}
	}
	props.sort();
	for(var i = 0; i < props.length; i++) {
		dojo.debug(props[i]);
	}
	dojo.debug('------------------------------------------------------------');
}

dojo.debugDeep = function(obj){
	if (!djConfig.isDebug) { return; }
	if (!window.open){ return dojo.debug('Deep debugging is only supported in host environments with window.open'); }
	var win = window.open(dojo.uri.dojoUri("src/debug/deep.html"), '_blank', 'width=600, height=400, resizable=yes, scrollbars=yes, status=yes');
	win.debugVar = obj;
}

__CPAN_FILE__ src/Deferred.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.Deferred");
dojo.require("dojo.lang.func");

dojo.Deferred = function(/* optional */ canceller){
	/*
	NOTE: this namespace and documentation are imported wholesale 
		from MochiKit

	Encapsulates a sequence of callbacks in response to a value that
	may not yet be available.  This is modeled after the Deferred class
	from Twisted <http://twistedmatrix.com>.

	Why do we want this?  JavaScript has no threads, and even if it did,
	threads are hard.  Deferreds are a way of abstracting non-blocking
	events, such as the final response to an XMLHttpRequest.

	The sequence of callbacks is internally represented as a list
	of 2-tuples containing the callback/errback pair.  For example,
	the following call sequence::

		var d = new Deferred();
		d.addCallback(myCallback);
		d.addErrback(myErrback);
		d.addBoth(myBoth);
		d.addCallbacks(myCallback, myErrback);

	is translated into a Deferred with the following internal
	representation::

		[
			[myCallback, null],
			[null, myErrback],
			[myBoth, myBoth],
			[myCallback, myErrback]
		]

	The Deferred also keeps track of its current status (fired).
	Its status may be one of three things:

		-1: no value yet (initial condition)
		0: success
		1: error

	A Deferred will be in the error state if one of the following
	three conditions are met:

		1. The result given to callback or errback is "instanceof" Error
		2. The previous callback or errback raised an exception while
		   executing
		3. The previous callback or errback returned a value "instanceof"
			Error

	Otherwise, the Deferred will be in the success state.  The state of
	the Deferred determines the next element in the callback sequence to
	run.

	When a callback or errback occurs with the example deferred chain,
	something equivalent to the following will happen (imagine that
	exceptions are caught and returned)::

		// d.callback(result) or d.errback(result)
		if(!(result instanceof Error)){
			result = myCallback(result);
		}
		if(result instanceof Error){
			result = myErrback(result);
		}
		result = myBoth(result);
		if(result instanceof Error){
			result = myErrback(result);
		}else{
			result = myCallback(result);
		}

	The result is then stored away in case another step is added to the
	callback sequence.	Since the Deferred already has a value available,
	any new callbacks added will be called immediately.

	There are two other "advanced" details about this implementation that
	are useful:

	Callbacks are allowed to return Deferred instances themselves, so you
	can build complicated sequences of events with ease.

	The creator of the Deferred may specify a canceller.  The canceller
	is a function that will be called if Deferred.cancel is called before
	the Deferred fires.	 You can use this to implement clean aborting of
	an XMLHttpRequest, etc.	 Note that cancel will fire the deferred with
	a CancelledError (unless your canceller returns another kind of
	error), so the errbacks should be prepared to handle that error for
	cancellable Deferreds.

	*/
	
	this.chain = [];
	this.id = this._nextId();
	this.fired = -1;
	this.paused = 0;
	this.results = [null, null];
	this.canceller = canceller;
	this.silentlyCancelled = false;
};

dojo.lang.extend(dojo.Deferred, {
	getFunctionFromArgs: function(){
		var a = arguments;
		if((a[0])&&(!a[1])){
			if(dojo.lang.isFunction(a[0])){
				return a[0];
			}else if(dojo.lang.isString(a[0])){
				return dj_global[a[0]];
			}
		}else if((a[0])&&(a[1])){
			return dojo.lang.hitch(a[0], a[1]);
		}
		return null;
	},

	repr: function(){
		var state;
		if(this.fired == -1){
			state = 'unfired';
		}else if(this.fired == 0){
			state = 'success';
		} else {
			state = 'error';
		}
		return 'Deferred(' + this.id + ', ' + state + ')';
	},

	toString: dojo.lang.forward("repr"),

	_nextId: (function(){
		var n = 1;
		return function(){ return n++; };
	})(),

	cancel: function(){
		/***
		Cancels a Deferred that has not yet received a value, or is
		waiting on another Deferred as its value.

		If a canceller is defined, the canceller is called. If the
		canceller did not return an error, or there was no canceller,
		then the errback chain is started with CancelledError.
		***/
		if(this.fired == -1){
			if (this.canceller){
				this.canceller(this);
			}else{
				this.silentlyCancelled = true;
			}
			if(this.fired == -1){
				this.errback(new Error(this.repr()));
			}
		}else if(	(this.fired == 0)&&
					(this.results[0] instanceof dojo.Deferred)){
			this.results[0].cancel();
		}
	},
			

	_pause: function(){
		// Used internally to signal that it's waiting on another Deferred
		this.paused++;
	},

	_unpause: function(){
		// Used internally to signal that it's no longer waiting on
		// another Deferred.
		this.paused--;
		if ((this.paused == 0) && (this.fired >= 0)) {
			this._fire();
		}
	},

	_continue: function(res){
		// Used internally when a dependent deferred fires.
		this._resback(res);
		this._unpause();
	},

	_resback: function(res){
		// The primitive that means either callback or errback
		this.fired = ((res instanceof Error) ? 1 : 0);
		this.results[this.fired] = res;
		this._fire();
	},

	_check: function(){
		if(this.fired != -1){
			if(!this.silentlyCancelled){
				dojo.raise("already called!");
			}
			this.silentlyCancelled = false;
			return;
		}
	},

	callback: function(res){
		/*
		Begin the callback sequence with a non-error value.
		
		callback or errback should only be called once on a given
		Deferred.
		*/
		this._check();
		this._resback(res);
	},

	errback: function(res){
		// Begin the callback sequence with an error result.
		this._check();
		if(!(res instanceof Error)){
			res = new Error(res);
		}
		this._resback(res);
	},

	addBoth: function(cb, cbfn){
		/*
		Add the same function as both a callback and an errback as the
		next element on the callback sequence.	This is useful for code
		that you want to guarantee to run, e.g. a finalizer.
		*/
		var enclosed = this.getFunctionFromArgs(cb, cbfn);
		if(arguments.length > 2){
			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
		}
		return this.addCallbacks(enclosed, enclosed);
	},

	addCallback: function(cb, cbfn){
		// Add a single callback to the end of the callback sequence.
		var enclosed = this.getFunctionFromArgs(cb, cbfn);
		if(arguments.length > 2){
			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
		}
		return this.addCallbacks(enclosed, null);
	},

	addErrback: function(cb, cbfn){
		// Add a single callback to the end of the callback sequence.
		var enclosed = this.getFunctionFromArgs(cb, cbfn);
		if(arguments.length > 2){
			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
		}
		return this.addCallbacks(null, enclosed);
		return this.addCallbacks(null, fn);
	},

	addCallbacks: function (cb, eb) {
		// Add separate callback and errback to the end of the callback
		// sequence.
		this.chain.push([cb, eb])
		if (this.fired >= 0) {
			this._fire();
		}
		return this;
	},

	_fire: function(){
		// Used internally to exhaust the callback sequence when a result
		// is available.
		var chain = this.chain;
		var fired = this.fired;
		var res = this.results[fired];
		var self = this;
		var cb = null;
		while (chain.length > 0 && this.paused == 0) {
			// Array
			var pair = chain.shift();
			var f = pair[fired];
			if (f == null) {
				continue;
			}
			try {
				res = f(res);
				fired = ((res instanceof Error) ? 1 : 0);
				if(res instanceof dojo.Deferred) {
					cb = function(res){
						self._continue(res);
					}
					this._pause();
				}
			}catch(err){
				fired = 1;
				res = err;
			}
		}
		this.fired = fired;
		this.results[fired] = res;
		if((cb)&&(this.paused)){
			// this is for "tail recursion" in case the dependent
			// deferred is already fired
			res.addBoth(cb);
		}
	}
});

__CPAN_FILE__ src/doc.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.doc");
dojo.require("dojo.io.*");
dojo.require("dojo.event.topic");
dojo.require("dojo.rpc.JotService");
dojo.require("dojo.dom");

/*
 * TODO:
 *
 * Package summary needs to compensate for "is"
 * Handle host environments
 * Deal with dojo.widget weirdness
 * Parse parameters
 * Limit function parameters to only the valid ones (Involves packing parameters onto meta during rewriting)
 * Package display page
 *
 */

dojo.doc._count = 0;
dojo.doc._keys = {};
dojo.doc._myKeys = [];
dojo.doc._callbacks = {function_names: []};
dojo.doc._cache = {}; // Saves the JSON objects in cache
dojo.doc._rpc = new dojo.rpc.JotService;
dojo.doc._rpc.serviceUrl = "http://dojotoolkit.org/~pottedmeat/jsonrpc.php";

dojo.doc.functionNames = function(/*mixed*/ selectKey, /*Function*/ callback){
	// summary: Returns an ordered list of package and function names.
	dojo.debug("functionNames()");
	if(!selectKey){
		selectKey = ++dojo.doc._count;
	}
	dojo.doc._buildCache({
		type: "function_names",
		callbacks: [dojo.doc._functionNames, callback],
		selectKey: selectKey
	});
}

dojo.doc._functionNames = function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
	var searchData = [];
	for(var key in data){
		// Add the package if it doesn't exist in its children
		if(!dojo.lang.inArray(data[key], key)){
			searchData.push([key, key]);
		}
		// Add the functions
		for(var pkg_key in data[key]){
			searchData.push([data[key][pkg_key], data[key][pkg_key]]);
		}
	}

	searchData = searchData.sort(dojo.doc._sort);

	if(evt.callbacks && evt.callbacks.length){
		var callback = evt.callbacks.shift();
		callback.call(null, type, searchData, evt);
	}
}

dojo.doc.getMeta = function(/*mixed*/ selectKey, /*Function*/ callback, /*Function*/ name, /*String?*/ id){
	// summary: Gets information about a function in regards to its meta data
	dojo.debug("getMeta(" + name + ")");
	if(!selectKey){
		selectKey = ++dojo.doc._count;
	}
	dojo.doc._buildCache({
		type: "meta",
		callbacks: [callback],
		name: name,
		id: id,
		selectKey: selectKey
	});
}

dojo.doc._getMeta = function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
	dojo.debug("_getMeta(" + evt.name + ") has package: " + evt.pkg + " with: " + type);
	if("load" == type && evt.pkg){
		evt.type = "meta";
		dojo.doc._buildCache(evt);
	}else{
		if(evt.callbacks && evt.callbacks.length){
			var callback = evt.callbacks.shift();
			callback.call(null, "error", {}, evt);
		}
	}
}

dojo.doc.getSrc = function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name, /*String?*/ id){
	// summary: Gets src file (created by the doc parser)
	dojo.debug("getSrc()");
	if(!selectKey){
		selectKey = ++dojo.doc._count;
	}	
	dojo.doc._buildCache({
		type: "src",
		callbacks: [callback],
		name: name,
		id: id,
		selectKey: selectKey
	});
}

dojo.doc._getSrc = function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
	dojo.debug("_getSrc()");
	if(evt.pkg){	
		evt.type = "src";
		dojo.doc._buildCache(evt);
	}else{
		if(evt.callbacks && evt.callbacks.length){
			var callback =  evt.callbacks.shift();
			callback.call(null, "error", {}, evt);
		}
	}
}

dojo.doc.getDoc = function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name, /*String?*/ id){
	// summary: Gets external documentation stored on jot
	dojo.debug("getDoc()");
	if(!selectKey){
		selectKey = ++dojo.doc._count;
	}
	var input = {
		type: "doc",
		callbacks: [callback],
		name: name,
		id: id,
		selectKey: selectKey
	}
	dojo.doc.functionPackage(dojo.doc._getDoc, input);
}

dojo.doc._getDoc = function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
	dojo.debug("_getDoc(" + evt.pkg + "/" + evt.name + ")");
	
	dojo.doc._keys[evt.selectKey] = {count: 0};

	var search = {};
	search.forFormName = "DocFnForm";
	search.limit = 1;

	if(!evt.id){
		search.filter = "it/DocFnForm/require = '" + evt.pkg + "' and it/DocFnForm/name = '" + evt.name + "' and not(it/DocFnForm/id)";
	}else{
		search.filter = "it/DocFnForm/require = '" + evt.pkg + "' and it/DocFnForm/name = '" + evt.name + "' and it/DocFnForm/id = '" + evt.id + "'";
	}
	
	dojo.doc._rpc.callRemote("search", search).addCallbacks(function(data){ evt.type = "fn"; dojo.doc._gotDoc("load", data.list[0], evt); }, function(data){ evt.type = "fn"; dojo.doc._gotDoc("error", {}, evt); });
	
	search.forFormName = "DocParamForm";

	if(!evt.id){
		search.filter = "it/DocParamForm/fns = '" + evt.pkg + "=>" + evt.name + "'";
	}else{
		search.filter = "it/DocParamForm/fns = '" + evt.pkg + "=>" + evt.name + "=>" + evt.id + "'";
	}
	delete search.limit;

	dojo.doc._rpc.callRemote("search", search).addCallbacks(function(data){ evt.type = "param"; dojo.doc._gotDoc("load", data.list, evt); }, function(data){ evt.type = "param"; dojo.doc._gotDoc("error", {}, evt); });
}

dojo.doc._gotDoc = function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
	dojo.debug("_gotDoc(" + evt.type + ") for " + evt.selectKey);
	dojo.doc._keys[evt.selectKey][evt.type] = data;
	if(++dojo.doc._keys[evt.selectKey].count == 2){
		dojo.debug("_gotDoc() finished");
		var keys = dojo.doc._keys[evt.selectKey];
		var description = '';
		if(!keys.fn){
			keys.fn = {}
		}
		if(keys.fn["main/text"]){
			description = dojo.dom.createDocumentFromText(keys.fn["main/text"]).childNodes[0].innerHTML;
			if(!description){
				description = keys.fn["main/text"];
			}			
		}
		data = {
			description: description,
			returns: keys.fn["DocFnForm/returns"],
			id: keys.fn["DocFnForm/id"],
			parameters: {},
			variables: []
		}
		for(var i = 0, param; param = keys["param"][i]; i++){
			data.parameters[param["DocParamForm/name"]] = {
				description: param["DocParamForm/desc"]
			};
		}

		delete dojo.doc._keys[evt.selectKey];
		
		if(evt.callbacks && evt.callbacks.length){
			var callback = evt.callbacks.shift();
			callback.call(null, "load", data, evt);
		}
	}
}

dojo.doc.getPkgMeta = function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name){
	dojo.debug("getPkgMeta(" + name + ")");
	if(!selectKey){
		selectKey = ++dojo.doc._count;
	}
	dojo.doc._buildCache({
		type: "pkgmeta",
		callbacks: [callback],
		name: name,
		selectKey: selectKey
	});
}

dojo.doc._getPkgMeta = function(/*Object*/ input){
	dojo.debug("_getPkgMeta(" + input.name + ")");
	input.type = "pkgmeta";
	dojo.doc._buildCache(input);
}

dojo.doc._onDocSearch = function(/*Object*/ input){
	dojo.debug("_onDocSearch(" + input.name + ")");
	if(!input.name){
		return;
	}
	if(!input.selectKey){
		input.selectKey = ++dojo.doc._count;
	}
	input.callbacks = [dojo.doc._onDocSearchFn];
	input.name = input.name.toLowerCase();
	input.type = "function_names";

	dojo.doc._buildCache(input);
}

dojo.doc._onDocSearchFn = function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
	dojo.debug("_onDocSearchFn(" + evt.name + ")");
	var packages = [];
	var size = 0;
	pkgLoop:
	for(var pkg in data){
		for(var i = 0, fn; fn = data[pkg][i]; i++){
			if(fn.toLowerCase().indexOf(evt.name) > -1){
				// Build a list of all packages that need to be loaded and their loaded state.
				++size;
				packages.push(pkg);
				continue pkgLoop;
			}
		}
	}
	dojo.doc._keys[evt.selectKey] = {};
	dojo.doc._keys[evt.selectKey].pkgs = packages;
	dojo.doc._keys[evt.selectKey].pkg = evt.name; // Remember what we were searching for
	dojo.doc._keys[evt.selectKey].loaded = 0;
	for(var i = 0, pkg; pkg = packages[i]; i++){
		setTimeout("dojo.doc.getPkgMeta(\"" + evt.selectKey + "\", dojo.doc._onDocResults, \"" + pkg + "\");", i*10);
	}
}

dojo.doc._onDocResults = function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
	dojo.debug("_onDocResults(" + evt.name + "/" + dojo.doc._keys[evt.selectKey].pkg + ") " + type);
	++dojo.doc._keys[evt.selectKey].loaded;

	if(dojo.doc._keys[evt.selectKey].loaded == dojo.doc._keys[evt.selectKey].pkgs.length){
		var info = dojo.doc._keys[evt.selectKey];
		var pkgs = info.pkgs;
		var name = info.pkg;
		delete dojo.doc._keys[evt.selectKey];
		var results = {selectKey: evt.selectKey, docResults: []};
		data = dojo.doc._cache;

		for(var i = 0, pkg; pkg = pkgs[i]; i++){
			if(!data[pkg]){
				continue;
			}
			for(var fn in data[pkg]["meta"]){
				if(fn.toLowerCase().indexOf(name) == -1){
					continue;
				}
				if(fn != "requires"){
					for(var sig in data[pkg]["meta"][fn]){
						var result = {
							pkg: pkg,
							name: fn,
							summary: ""
						}
						if(data[pkg]["meta"][fn][sig]["summary"]){
							result.summary = data[pkg]["meta"][fn][sig]["summary"];
						}
						results.docResults.push(result);
					}
				}
			}
		}

		dojo.debug("Publishing docResults");
		dojo.event.topic.publish("docResults", results);
	}
}

// Get doc
// Get meta
// Get src
// Get function signature
dojo.doc._onDocSelectFunction = function(/*Object*/ input){
	dojo.debug("_onDocSelectFunction(" + input.name + ")");
	if(!input.name){
		return false;
	}
	if(!input.selectKey){
		input.selectKey = ++dojo.doc._count;
	}

	dojo.doc._keys[input.selectKey] = {size: 0};
	dojo.doc._myKeys[++dojo.doc._count] = {selectKey: input.selectKey, type: "meta"}
	dojo.doc.getMeta(dojo.doc._count, dojo.doc._onDocSelectResults, input.name);
	dojo.doc._myKeys[++dojo.doc._count] = {selectKey: input.selectKey, type: "src"}
	dojo.doc.getSrc(dojo.doc._count, dojo.doc._onDocSelectResults, input.name);
	dojo.doc._myKeys[++dojo.doc._count] = {selectKey: input.selectKey, type: "doc"}
	dojo.doc.getDoc(dojo.doc._count, dojo.doc._onDocSelectResults, input.name);
}

dojo.doc._onDocSelectResults = function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
	dojo.debug("dojo.doc._onDocSelectResults(" + evt.type + ", " + evt.name + ")");
	var myKey = dojo.doc._myKeys[evt.selectKey];
	dojo.doc._keys[myKey.selectKey][myKey.type] = data;
	dojo.doc._keys[myKey.selectKey].size;
	if(++dojo.doc._keys[myKey.selectKey].size == 3){
		var key = dojo.lang.mixin(evt, dojo.doc._keys[myKey.selectKey]);
		delete key.size;
		dojo.debug(dojo.json.serialize(key));
		dojo.debug("Publishing docFunctionDetail");
		dojo.event.topic.publish("docFunctionDetail", key);
		delete dojo.doc._keys[myKey.selectKey];
		delete dojo.doc._myKeys[evt.selectKey];
	}
}

dojo.doc._buildCache = function(/*Object*/ input){
	dojo.debug("_buildCache() type: " + input.type);
	if(input.type == "function_names"){
		if(!dojo.doc._cache["function_names"]){
			dojo.debug("_buildCache() new cache");
			if(input.callbacks && input.callbacks.length){
				dojo.doc._callbacks.function_names.push([input, input.callbacks.shift()]);
			}
			dojo.doc._cache["function_names"] = {loading: true};
			dojo.io.bind({
				url: "json/function_names",
				mimetype: "text/json",
				error: function(type, data, evt){
					for(var i = 0, callback; callback = dojo.doc._callbacks.function_names[i]; i++){
						callback[1].call(null, "error", {}, callback[0]);
					}
				},
				load: function(type, data, evt){
					for(var key in data){
						// Packages starting with _ have a parent of "dojo"
						if(key.charAt(0) == "_"){
							var new_key = "dojo" + key.substring(1, key.length);
							data[new_key] = data[key];
							delete data[key];
							key = new_key;
						}
						// Function names starting with _ have a parent of their package name
						for(var pkg_key in data[key]){
							if(data[key][pkg_key].charAt(0) == "_"){
								var new_value = key + data[key][pkg_key].substring(1, data[key][pkg_key].length);
								data[key][pkg_key] = new_value;
							}
						}
						// Save data to the cache
					}
					dojo.doc._cache['function_names'] = data;
					for(var i = 0, callback; callback = dojo.doc._callbacks.function_names[i]; i++){
						callback[1].call(null, "load", data, callback[0]);
					}
				}
			});
		}else if(dojo.doc._cache["function_names"].loading){
			dojo.debug("_buildCache() loading cache");
			if(input.callbacks && input.callbacks.length){
				dojo.doc._callbacks.function_names.push([input, input.callbacks.shift()]);
			}
		}else{
			dojo.debug("_buildCache() from cache");
			if(input.callbacks && input.callbacks.length){
				var callback = input.callbacks.shift();
				callback.call(null, "load", dojo.doc._cache["function_names"], input);
			}
		}
	}else if(input.type == "meta" || input.type == "src"){
		if(!input.pkg){
			if(input.type == "meta"){
				dojo.doc.functionPackage(dojo.doc._getMeta, input);
			}else{
				dojo.doc.functionPackage(dojo.doc._getSrc, input);
			}
		}else{
			try{
				if(input.id){
					var cached = dojo.doc._cache[input.pkg][input.name][input.id][input.type];
				}else{
					var cached = dojo.doc._cache[input.pkg][input.name][input.type];
				}
			}catch(e){}

			if(cached){
				if(input.callbacks && input.callbacks.length){
					var callback = input.callbacks.shift();
					callback.call(null, "load", cached, input);
					return;
				}
			}

			dojo.debug("Finding " + input.type + " for: " + input.pkg + ", function: " + input.name + ", id: " + input.id);

			var name = input.name.replace(new RegExp('^' + input.pkg.replace(/\./g, "\\.")), "_");
			var pkg = input.pkg.replace(/^(dojo|\*)/g, "_");

			var mimetype = "text/json";
			if(input.type == "src"){
				mimetype = "text/plain"
			}

			var url;
			if(input.id){
				url = "json/" + pkg + "/" + name + "/" + input.id + "/" + input.type;
			}else{
				url = "json/" + pkg + "/" + name + "/" + input.type;		
			}

			dojo.io.bind({
				url: url,
				input: input,
				mimetype: mimetype,
				error: function(type, data, evt, args){
					if(args.input.callbacks && args.input.callbacks.length){
						if(!data){
							data = {};
						}
						if(!dojo.doc._cache[args.input.pkg]){
							dojo.doc._cache[args.input.pkg] = {};
						}
						if(!dojo.doc._cache[args.input.pkg][args.input.name]){
							dojo.doc._cache[args.input.pkg][args.input.name] = {};
						}
						if(args.input.type == "meta"){
							if(args.input.id){
								data.sig = dojo.doc._cache[args.input.pkg][args.input.name][args.input.id].sig;
								data.params = dojo.doc._cache[args.input.pkg][args.input.name][args.input.id].params;
							}else{
								data.sig = dojo.doc._cache[args.input.pkg][args.input.name].sig;								
								data.params = dojo.doc._cache[args.input.pkg][args.input.name].params;
							}
						}
						var callback = args.input.callbacks.shift();
						callback.call(null, "error", data, args.input);
					}
				},
				load: function(type, data, evt, args){
					if(!data){
						data = {};
					}
					if(!dojo.doc._cache[args.input.pkg]){
						dojo.doc._cache[args.input.pkg] = {};
					}
					if(!dojo.doc._cache[args.input.pkg][args.input.name]){
						dojo.doc._cache[args.input.pkg][args.input.name] = {};
					}
					if(args.input.id){
						dojo.doc._cache[args.input.pkg][args.input.name][args.input.id][args.input.type] = data;
						if(args.input.type == "meta"){
							data.sig = dojo.doc._cache[args.input.pkg][args.input.name][args.input.id].sig;
							data.params = dojo.doc._cache[args.input.pkg][args.input.name][args.input.id].params;
						}
					}else{
						dojo.doc._cache[args.input.pkg][args.input.name][args.input.type] = data;
						if(args.input.type == "meta"){
							data.sig = dojo.doc._cache[args.input.pkg][args.input.name].sig;
							data.params = dojo.doc._cache[args.input.pkg][args.input.name].params;
						}
					}
					if(args.input.callbacks && args.input.callbacks.length){
						var callback = input.callbacks.shift();
						callback.call(null, "load", data, args.input);
					}
				}
			});
		}
	}else if(input.type == "pkgmeta"){
		try{
			var cached = dojo.doc._cache[input.name]["meta"];
		}catch(e){}

		if(cached){
			if(input.callbacks && input.callbacks.length){
				var callback = input.callbacks.shift();
				callback.call(null, "load", cached, input);
				return;
			}
		}

		dojo.debug("Finding package meta for: " + input.name);

		var pkg = input.name.replace(/^(dojo|\*)/g, "_");

		dojo.io.bind({
			url: "json/" + pkg + "/meta",
			input: input,
			mimetype: "text/json",
			error: function(type, data, evt, args){
				if(args.input.callbacks && args.input.callbacks.length){
					var callback = args.input.callbacks.shift();
					callback.call(null, "error", {}, args.input);
				}
			},
			load: function(type, data, evt, args){
				if(!dojo.doc._cache[args.input.name]){
					dojo.doc._cache[args.input.name] = {};
				}
				
				for(var key in data){
					if(key != "requires"){
						if(key.charAt(0) == "_"){
							var new_key = args.input.name + key.substring(1, key.length);
							data[new_key] = data[key];
							delete data[key];
							for(var sig in data[new_key]){
								if(sig == "is"){
									continue;
								}
								var real_sig = sig;
								if(sig.charAt(0) == "("){
									real_sig = "undefined " + real_sig;
								}
								real_sig = real_sig.split("(");
								real_sig = real_sig[0] + new_key + "(" + real_sig[1];
								var parameters = {};
								var parRegExp = /(?:\(|,)([^,\)]+)/g;
								var result;
								while(result = parRegExp.exec(real_sig)){
									var parts = result[1].split(" ");
									if(parts.length > 1){
										var pName = parts.pop();
										var pType = parts.join(" ");
										var pOpt = false;
										if(pType.indexOf("?") != -1){
											pType = pType.replace("?", "");
											pOpt = true;
										}
										parameters[pName] = {type: pType, opt: pOpt};
									}else{
										parameters[parts[0]] = {type: "", opt: false};
									}
								}
								real_sig = real_sig.replace(/\?/g, "");
								if(data[new_key][sig].summary || dojo.lang.isArray(data[new_key][sig])){
									if(!dojo.doc._cache[args.input.name][new_key]){
										dojo.doc._cache[args.input.name][new_key] = {};
									}
									dojo.doc._cache[args.input.name][new_key].sig = real_sig;
									dojo.doc._cache[args.input.name][new_key].params = parameters;
								}else{
									// Polymorphic sigs
								}
							}
						}
					}
				}

				dojo.doc._cache[args.input.name]["meta"] = data;
				if(input.callbacks && input.callbacks.length){
					var callback = input.callbacks.shift();
					callback.call(null, "load", data, input);
				}
			}
		});
	}
}

dojo.doc.selectFunction = function(/*String*/ name, /*String?*/ id){
	// summary: The combined information
}



dojo.doc.savePackage = function(/*String*/ name, /*String*/ description){
	dojo.doc._rpc.callRemote(
		"saveForm",
		{
			form: "DocPkgForm",
			path: "/WikiHome/DojoDotDoc/id",
			pname1: "main/text",
			pvalue1: "Test"
		}
	).addCallbacks(dojo.doc._results, dojo.doc._results);
}

dojo.doc.functionPackage = function(/*Function*/ callback, /*Object*/ input){
	dojo.debug("functionPackage() name: " + input.name + " for type: " + input.type);
	input.type = "function_names";
	input.callbacks.unshift(callback);
	input.callbacks.unshift(dojo.doc._functionPackage);
	dojo.doc._buildCache(input);
}

dojo.doc._functionPackage = function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
	dojo.debug("_functionPackage() name: " + evt.name + " for: " + evt.type + " with: " + type);
	evt.pkg = '';

	var data = dojo.doc._cache['function_names'];
	for(var key in data){
		if(dojo.lang.inArray(data[key], evt.name)){
			evt.pkg = key;
			break;
		}
	}

	if(evt.callbacks && evt.callbacks.length){
		var callback = evt.callbacks.shift();
		callback.call(null, type, data[key], evt);
	}
}

dojo.doc._sort = function(a, b){
	if(a[0] < b[0]){
		return -1;
	}
	if(a[0] > b[0]){
		return 1;
	}
  return 0;
}

dojo.event.topic.registerPublisher("docSearch");  	
dojo.event.topic.registerPublisher("docResults");  	
dojo.event.topic.registerPublisher("docSelectFunction");  	
dojo.event.topic.registerPublisher("docFunctionDetail");

dojo.event.topic.subscribe("docSearch", dojo.doc, "_onDocSearch");
dojo.event.topic.subscribe("docSelectFunction", dojo.doc, "_onDocSelectFunction");

__CPAN_FILE__ src/dom.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.dom");
dojo.require("dojo.lang.array");

dojo.dom.ELEMENT_NODE                  = 1;
dojo.dom.ATTRIBUTE_NODE                = 2;
dojo.dom.TEXT_NODE                     = 3;
dojo.dom.CDATA_SECTION_NODE            = 4;
dojo.dom.ENTITY_REFERENCE_NODE         = 5;
dojo.dom.ENTITY_NODE                   = 6;
dojo.dom.PROCESSING_INSTRUCTION_NODE   = 7;
dojo.dom.COMMENT_NODE                  = 8;
dojo.dom.DOCUMENT_NODE                 = 9;
dojo.dom.DOCUMENT_TYPE_NODE            = 10;
dojo.dom.DOCUMENT_FRAGMENT_NODE        = 11;
dojo.dom.NOTATION_NODE                 = 12;
	
dojo.dom.dojoml = "http://www.dojotoolkit.org/2004/dojoml";

/**
 *	comprehensive list of XML namespaces
**/
dojo.dom.xmlns = {
	svg : "http://www.w3.org/2000/svg",
	smil : "http://www.w3.org/2001/SMIL20/",
	mml : "http://www.w3.org/1998/Math/MathML",
	cml : "http://www.xml-cml.org",
	xlink : "http://www.w3.org/1999/xlink",
	xhtml : "http://www.w3.org/1999/xhtml",
	xul : "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
	xbl : "http://www.mozilla.org/xbl",
	fo : "http://www.w3.org/1999/XSL/Format",
	xsl : "http://www.w3.org/1999/XSL/Transform",
	xslt : "http://www.w3.org/1999/XSL/Transform",
	xi : "http://www.w3.org/2001/XInclude",
	xforms : "http://www.w3.org/2002/01/xforms",
	saxon : "http://icl.com/saxon",
	xalan : "http://xml.apache.org/xslt",
	xsd : "http://www.w3.org/2001/XMLSchema",
	dt: "http://www.w3.org/2001/XMLSchema-datatypes",
	xsi : "http://www.w3.org/2001/XMLSchema-instance",
	rdf : "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
	rdfs : "http://www.w3.org/2000/01/rdf-schema#",
	dc : "http://purl.org/dc/elements/1.1/",
	dcq: "http://purl.org/dc/qualifiers/1.0",
	"soap-env" : "http://schemas.xmlsoap.org/soap/envelope/",
	wsdl : "http://schemas.xmlsoap.org/wsdl/",
	AdobeExtensions : "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
};

dojo.dom.isNode = function(wh){
	if(typeof Element == "object") {
		try {
			return wh instanceof Element;
		} catch(E) {}
	} else {
		// best-guess
		return wh && !isNaN(wh.nodeType);
	}
}

dojo.dom.getTagName = function(node){
	dojo.deprecated("dojo.dom.getTagName", "use node.tagName instead", "0.4");

	var tagName = node.tagName;
	if(tagName.substr(0,5).toLowerCase()!="dojo:"){
		
		if(tagName.substr(0,4).toLowerCase()=="dojo"){
			// FIXME: this assuumes tag names are always lower case
			return "dojo:" + tagName.substring(4).toLowerCase();
		}

		// allow lower-casing
		var djt = node.getAttribute("dojoType")||node.getAttribute("dojotype");
		if(djt){
			return "dojo:"+djt.toLowerCase();
		}
		
		if((node.getAttributeNS)&&(node.getAttributeNS(this.dojoml,"type"))){
			return "dojo:" + node.getAttributeNS(this.dojoml,"type").toLowerCase();
		}
		try{
			// FIXME: IE really really doesn't like this, so we squelch
			// errors for it
			djt = node.getAttribute("dojo:type");
		}catch(e){ /* FIXME: log? */ }
		if(djt){
			return "dojo:"+djt.toLowerCase();
		}

		if((!dj_global["djConfig"])||(!djConfig["ignoreClassNames"])){
			// FIXME: should we make this optionally enabled via djConfig?
			var classes = node.className||node.getAttribute("class");
			// FIXME: following line, without check for existence of classes.indexOf
			// breaks firefox 1.5's svg widgets
			if((classes)&&(classes.indexOf)&&(classes.indexOf("dojo-") != -1)){
				var aclasses = classes.split(" ");
				for(var x=0; x<aclasses.length; x++){
					if((aclasses[x].length>5)&&(aclasses[x].indexOf("dojo-")>=0)){
						return "dojo:"+aclasses[x].substr(5).toLowerCase();
					}
				}
			}
		}

	}
	return tagName.toLowerCase();
}

dojo.dom.getUniqueId = function(){
	do {
		var id = "dj_unique_" + (++arguments.callee._idIncrement);
	}while(document.getElementById(id));
	return id;
}
dojo.dom.getUniqueId._idIncrement = 0;

dojo.dom.firstElement = dojo.dom.getFirstChildElement = function(parentNode, tagName){
	var node = parentNode.firstChild;
	while(node && node.nodeType != dojo.dom.ELEMENT_NODE){
		node = node.nextSibling;
	}
	if(tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
		node = dojo.dom.nextElement(node, tagName);
	}
	return node;
}

dojo.dom.lastElement = dojo.dom.getLastChildElement = function(parentNode, tagName){
	var node = parentNode.lastChild;
	while(node && node.nodeType != dojo.dom.ELEMENT_NODE) {
		node = node.previousSibling;
	}
	if(tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
		node = dojo.dom.prevElement(node, tagName);
	}
	return node;
}

dojo.dom.nextElement = dojo.dom.getNextSiblingElement = function(node, tagName){
	if(!node) { return null; }
	do {
		node = node.nextSibling;
	} while(node && node.nodeType != dojo.dom.ELEMENT_NODE);

	if(node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
		return dojo.dom.nextElement(node, tagName);
	}
	return node;
}

dojo.dom.prevElement = dojo.dom.getPreviousSiblingElement = function(node, tagName){
	if(!node) { return null; }
	if(tagName) { tagName = tagName.toLowerCase(); }
	do {
		node = node.previousSibling;
	} while(node && node.nodeType != dojo.dom.ELEMENT_NODE);

	if(node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
		return dojo.dom.prevElement(node, tagName);
	}
	return node;
}

// TODO: hmph
/*this.forEachChildTag = function(node, unaryFunc) {
	var child = this.getFirstChildTag(node);
	while(child) {
		if(unaryFunc(child) == "break") { break; }
		child = this.getNextSiblingTag(child);
	}
}*/

dojo.dom.moveChildren = function(srcNode, destNode, trim){
	var count = 0;
	if(trim) {
		while(srcNode.hasChildNodes() &&
			srcNode.firstChild.nodeType == dojo.dom.TEXT_NODE) {
			srcNode.removeChild(srcNode.firstChild);
		}
		while(srcNode.hasChildNodes() &&
			srcNode.lastChild.nodeType == dojo.dom.TEXT_NODE) {
			srcNode.removeChild(srcNode.lastChild);
		}
	}
	while(srcNode.hasChildNodes()){
		destNode.appendChild(srcNode.firstChild);
		count++;
	}
	return count;
}

dojo.dom.copyChildren = function(srcNode, destNode, trim){
	var clonedNode = srcNode.cloneNode(true);
	return this.moveChildren(clonedNode, destNode, trim);
}

dojo.dom.removeChildren = function(node){
	var count = node.childNodes.length;
	while(node.hasChildNodes()){ node.removeChild(node.firstChild); }
	return count;
}

dojo.dom.replaceChildren = function(node, newChild){
	// FIXME: what if newChild is an array-like object?
	dojo.dom.removeChildren(node);
	node.appendChild(newChild);
}

dojo.dom.removeNode = function(node){
	if(node && node.parentNode){
		// return a ref to the removed child
		return node.parentNode.removeChild(node);
	}
}

dojo.dom.getAncestors = function(node, filterFunction, returnFirstHit) {
	var ancestors = [];
	var isFunction = dojo.lang.isFunction(filterFunction);
	while(node) {
		if (!isFunction || filterFunction(node)) {
			ancestors.push(node);
		}
		if (returnFirstHit && ancestors.length > 0) { return ancestors[0]; }
		
		node = node.parentNode;
	}
	if (returnFirstHit) { return null; }
	return ancestors;
}

dojo.dom.getAncestorsByTag = function(node, tag, returnFirstHit) {
	tag = tag.toLowerCase();
	return dojo.dom.getAncestors(node, function(el){
		return ((el.tagName)&&(el.tagName.toLowerCase() == tag));
	}, returnFirstHit);
}

dojo.dom.getFirstAncestorByTag = function(node, tag) {
	return dojo.dom.getAncestorsByTag(node, tag, true);
}

dojo.dom.isDescendantOf = function(node, ancestor, guaranteeDescendant){
	// guaranteeDescendant allows us to be a "true" isDescendantOf function
	if(guaranteeDescendant && node) { node = node.parentNode; }
	while(node) {
		if(node == ancestor){ return true; }
		node = node.parentNode;
	}
	return false;
}

dojo.dom.innerXML = function(node){
	if(node.innerXML){
		return node.innerXML;
	}else if(typeof XMLSerializer != "undefined"){
		return (new XMLSerializer()).serializeToString(node);
	}
}

dojo.dom.createDocumentFromText = function(str, mimetype){
	if(!mimetype) { mimetype = "text/xml"; }
	if(typeof DOMParser != "undefined") {
		var parser = new DOMParser();
		return parser.parseFromString(str, mimetype);
	}else if(typeof ActiveXObject != "undefined"){
		var domDoc = new ActiveXObject("Microsoft.XMLDOM");
		if(domDoc) {
			domDoc.async = false;
			domDoc.loadXML(str);
			return domDoc;
		}else{
			dojo.debug("toXml didn't work?");
		}
	/*
	}else if((dojo.render.html.capable)&&(dojo.render.html.safari)){
		// FIXME: this doesn't appear to work!
		// from: http://web-graphics.com/mtarchive/001606.php
		// var xml = '<?xml version="1.0"?>'+str;
		var mtype = "text/xml";
		var xml = '<?xml version="1.0"?>'+str;
		var url = "data:"+mtype+";charset=utf-8,"+encodeURIComponent(xml);
		var req = new XMLHttpRequest();
		req.open("GET", url, false);
		req.overrideMimeType(mtype);
		req.send(null);
		return req.responseXML;
	*/
	}else if(document.createElement){
		// FIXME: this may change all tags to uppercase!
		var tmp = document.createElement("xml");
		tmp.innerHTML = str;
		if(document.implementation && document.implementation.createDocument) {
			var xmlDoc = document.implementation.createDocument("foo", "", null);
			for(var i = 0; i < tmp.childNodes.length; i++) {
				xmlDoc.importNode(tmp.childNodes.item(i), true);
			}
			return xmlDoc;
		}
		// FIXME: probably not a good idea to have to return an HTML fragment
		// FIXME: the tmp.doc.firstChild is as tested from IE, so it may not
		// work that way across the board
		return tmp.document && tmp.document.firstChild ?
			tmp.document.firstChild : tmp;
	}
	return null;
}

dojo.dom.prependChild = function(node, parent) {
	if(parent.firstChild) {
		parent.insertBefore(node, parent.firstChild);
	} else {
		parent.appendChild(node);
	}
	return true;
}

dojo.dom.insertBefore = function(node, ref, force){
	if (force != true &&
		(node === ref || node.nextSibling === ref)){ return false; }
	var parent = ref.parentNode;
	parent.insertBefore(node, ref);
	return true;
}

dojo.dom.insertAfter = function(node, ref, force){
	var pn = ref.parentNode;
	if(ref == pn.lastChild){
		if((force != true)&&(node === ref)){
			return false;
		}
		pn.appendChild(node);
	}else{
		return this.insertBefore(node, ref.nextSibling, force);
	}
	return true;
}

dojo.dom.insertAtPosition = function(node, ref, position){
	if((!node)||(!ref)||(!position)){ return false; }
	switch(position.toLowerCase()){
		case "before":
			return dojo.dom.insertBefore(node, ref);
		case "after":
			return dojo.dom.insertAfter(node, ref);
		case "first":
			if(ref.firstChild){
				return dojo.dom.insertBefore(node, ref.firstChild);
			}else{
				ref.appendChild(node);
				return true;
			}
			break;
		default: // aka: last
			ref.appendChild(node);
			return true;
	}
}

dojo.dom.insertAtIndex = function(node, containingNode, insertionIndex){
	var siblingNodes = containingNode.childNodes;

	// if there aren't any kids yet, just add it to the beginning

	if (!siblingNodes.length){
		containingNode.appendChild(node);
		return true;
	}

	// otherwise we need to walk the childNodes
	// and find our spot

	var after = null;

	for(var i=0; i<siblingNodes.length; i++){

		var sibling_index = siblingNodes.item(i)["getAttribute"] ? parseInt(siblingNodes.item(i).getAttribute("dojoinsertionindex")) : -1;

		if (sibling_index < insertionIndex){
			after = siblingNodes.item(i);
		}
	}

	if (after){
		// add it after the node in {after}

		return dojo.dom.insertAfter(node, after);
	}else{
		// add it to the start

		return dojo.dom.insertBefore(node, siblingNodes.item(0));
	}
}
	
/**
 * implementation of the DOM Level 3 attribute.
 * 
 * @param node The node to scan for text
 * @param text Optional, set the text to this value.
 */
dojo.dom.textContent = function(node, text){
	if (text) {
		dojo.dom.replaceChildren(node, document.createTextNode(text));
		return text;
	} else {
		var _result = "";
		if (node == null) { return _result; }
		for (var i = 0; i < node.childNodes.length; i++) {
			switch (node.childNodes[i].nodeType) {
				case 1: // ELEMENT_NODE
				case 5: // ENTITY_REFERENCE_NODE
					_result += dojo.dom.textContent(node.childNodes[i]);
					break;
				case 3: // TEXT_NODE
				case 2: // ATTRIBUTE_NODE
				case 4: // CDATA_SECTION_NODE
					_result += node.childNodes[i].nodeValue;
					break;
				default:
					break;
			}
		}
		return _result;
	}
}

dojo.dom.collectionToArray = function(collection){
	dojo.deprecated("dojo.dom.collectionToArray", "use dojo.lang.toArray instead", "0.4");
	return dojo.lang.toArray(collection);
}

dojo.dom.hasParent = function (node) {
	return node && node.parentNode && dojo.dom.isNode(node.parentNode);
}

/**
 * Determines if node has any of the provided tag names and
 * returns the tag name that matches, empty string otherwise.
 *
 * Examples:
 *
 * myFooNode = <foo />
 * isTag(myFooNode, "foo"); // returns "foo"
 * isTag(myFooNode, "bar"); // returns ""
 * isTag(myFooNode, "FOO"); // returns ""
 * isTag(myFooNode, "hey", "foo", "bar"); // returns "foo"
**/
dojo.dom.isTag = function(node /* ... */) {
	if(node && node.tagName) {
		var arr = dojo.lang.toArray(arguments, 1);
		return arr[ dojo.lang.find(node.tagName, arr) ] || "";
	}
	return "";
}

__CPAN_FILE__ src/event.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.event");

dojo.require("dojo.lang.array");
dojo.require("dojo.lang.extras");
dojo.require("dojo.lang.func");

dojo.event = new function(){
	this.canTimeout = dojo.lang.isFunction(dj_global["setTimeout"])||dojo.lang.isAlien(dj_global["setTimeout"]);

	// FIXME: where should we put this method (not here!)?
	function interpolateArgs(args){
		var dl = dojo.lang;
		var ao = {
			srcObj: dj_global,
			srcFunc: null,
			adviceObj: dj_global,
			adviceFunc: null,
			aroundObj: null,
			aroundFunc: null,
			adviceType: (args.length>2) ? args[0] : "after",
			precedence: "last",
			once: false,
			delay: null,
			rate: 0,
			adviceMsg: false
		};

		switch(args.length){
			case 0: return;
			case 1: return;
			case 2:
				ao.srcFunc = args[0];
				ao.adviceFunc = args[1];
				break;
			case 3:
				if((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isString(args[2]))){
					ao.adviceType = "after";
					ao.srcObj = args[0];
					ao.srcFunc = args[1];
					ao.adviceFunc = args[2];
				}else if((dl.isString(args[1]))&&(dl.isString(args[2]))){
					ao.srcFunc = args[1];
					ao.adviceFunc = args[2];
				}else if((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isFunction(args[2]))){
					ao.adviceType = "after";
					ao.srcObj = args[0];
					ao.srcFunc = args[1];
					var tmpName  = dojo.lang.nameAnonFunc(args[2], ao.adviceObj);
					ao.adviceFunc = tmpName;
				}else if((dl.isFunction(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))){
					ao.adviceType = "after";
					ao.srcObj = dj_global;
					var tmpName  = dojo.lang.nameAnonFunc(args[0], ao.srcObj);
					ao.srcFunc = tmpName;
					ao.adviceObj = args[1];
					ao.adviceFunc = args[2];
				}
				break;
			case 4:
				if((dl.isObject(args[0]))&&(dl.isObject(args[2]))){
					// we can assume that we've got an old-style "connect" from
					// the sigslot school of event attachment. We therefore
					// assume after-advice.
					ao.adviceType = "after";
					ao.srcObj = args[0];
					ao.srcFunc = args[1];
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else if((dl.isString(args[0]))&&(dl.isString(args[1]))&&(dl.isObject(args[2]))){
					ao.adviceType = args[0];
					ao.srcObj = dj_global;
					ao.srcFunc = args[1];
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else if((dl.isString(args[0]))&&(dl.isFunction(args[1]))&&(dl.isObject(args[2]))){
					ao.adviceType = args[0];
					ao.srcObj = dj_global;
					var tmpName  = dojo.lang.nameAnonFunc(args[1], dj_global);
					ao.srcFunc = tmpName;
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else if((dl.isString(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))&&(dl.isFunction(args[3]))){
					ao.srcObj = args[1];
					ao.srcFunc = args[2];
					var tmpName  = dojo.lang.nameAnonFunc(args[3], dj_global);
					ao.adviceObj = dj_global;
					ao.adviceFunc = tmpName;
				}else if(dl.isObject(args[1])){
					ao.srcObj = args[1];
					ao.srcFunc = args[2];
					ao.adviceObj = dj_global;
					ao.adviceFunc = args[3];
				}else if(dl.isObject(args[2])){
					ao.srcObj = dj_global;
					ao.srcFunc = args[1];
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else{
					ao.srcObj = ao.adviceObj = ao.aroundObj = dj_global;
					ao.srcFunc = args[1];
					ao.adviceFunc = args[2];
					ao.aroundFunc = args[3];
				}
				break;
			case 6:
				ao.srcObj = args[1];
				ao.srcFunc = args[2];
				ao.adviceObj = args[3]
				ao.adviceFunc = args[4];
				ao.aroundFunc = args[5];
				ao.aroundObj = dj_global;
				break;
			default:
				ao.srcObj = args[1];
				ao.srcFunc = args[2];
				ao.adviceObj = args[3]
				ao.adviceFunc = args[4];
				ao.aroundObj = args[5];
				ao.aroundFunc = args[6];
				ao.once = args[7];
				ao.delay = args[8];
				ao.rate = args[9];
				ao.adviceMsg = args[10];
				break;
		}

		if(dl.isFunction(ao.aroundFunc)){
			var tmpName  = dojo.lang.nameAnonFunc(ao.aroundFunc, ao.aroundObj);
			ao.aroundFunc = tmpName;
		}

		if(!dl.isString(ao.srcFunc)){
			ao.srcFunc = dojo.lang.getNameInObj(ao.srcObj, ao.srcFunc);
		}

		if(!dl.isString(ao.adviceFunc)){
			ao.adviceFunc = dojo.lang.getNameInObj(ao.adviceObj, ao.adviceFunc);
		}

		if((ao.aroundObj)&&(!dl.isString(ao.aroundFunc))){
			ao.aroundFunc = dojo.lang.getNameInObj(ao.aroundObj, ao.aroundFunc);
		}

		if(!ao.srcObj){
			dojo.raise("bad srcObj for srcFunc: "+ao.srcFunc);
		}
		if(!ao.adviceObj){
			dojo.raise("bad adviceObj for adviceFunc: "+ao.adviceFunc);
		}
		return ao;
	}

	this.connect = function(){
		if(arguments.length == 1){
			var ao = arguments[0];
		}else{
			var ao = interpolateArgs(arguments);
		}

		if(dojo.lang.isArray(ao.srcObj) && ao.srcObj!=""){
			var tmpAO = {};
			for(var x in ao){
				tmpAO[x] = ao[x];
			}
			var mjps = [];
			dojo.lang.forEach(ao.srcObj, function(src){
				if((dojo.render.html.capable)&&(dojo.lang.isString(src))){
					src = dojo.byId(src);
					// dojo.debug(src);
				}
				tmpAO.srcObj = src;
				// dojo.debug(tmpAO.srcObj, tmpAO.srcFunc);
				// dojo.debug(tmpAO.adviceObj, tmpAO.adviceFunc);
				mjps.push(dojo.event.connect.call(dojo.event, tmpAO));
			});
			return mjps;
		}

		// FIXME: just doing a "getForMethod()" seems to be enough to put this into infinite recursion!!
		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
		if(ao.adviceFunc){
			var mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);
		}

		mjp.kwAddAdvice(ao);

		return mjp;	// advanced users might want to fsck w/ the join point
					// manually
	}

	this.log = function(a1, a2){
		var kwArgs;
		if((arguments.length == 1)&&(typeof a1 == "object")){
			kwArgs = a1;
		}else{
			kwArgs = {
				srcObj: a1,
				srcFunc: a2
			};
		}
		kwArgs.adviceFunc = function(){
			var argsStr = [];
			for(var x=0; x<arguments.length; x++){
				argsStr.push(arguments[x]);
			}
			dojo.debug("("+kwArgs.srcObj+")."+kwArgs.srcFunc, ":", argsStr.join(", "));
		}
		this.kwConnect(kwArgs);
	}

	this.connectBefore = function(){
		var args = ["before"];
		for(var i = 0; i < arguments.length; i++) { args.push(arguments[i]); }
		return this.connect.apply(this, args);
	}

	this.connectAround = function(){
		var args = ["around"];
		for(var i = 0; i < arguments.length; i++) { args.push(arguments[i]); }
		return this.connect.apply(this, args);
	}

	this.connectOnce = function(){
		var ao = interpolateArgs(arguments);
		ao.once = true;
		return this.connect(ao);
	}

	this._kwConnectImpl = function(kwArgs, disconnect){
		var fn = (disconnect) ? "disconnect" : "connect";
		if(typeof kwArgs["srcFunc"] == "function"){
			kwArgs.srcObj = kwArgs["srcObj"]||dj_global;
			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj);
			kwArgs.srcFunc = tmpName;
		}
		if(typeof kwArgs["adviceFunc"] == "function"){
			kwArgs.adviceObj = kwArgs["adviceObj"]||dj_global;
			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj);
			kwArgs.adviceFunc = tmpName;
		}
		return dojo.event[fn](	(kwArgs["type"]||kwArgs["adviceType"]||"after"),
									kwArgs["srcObj"]||dj_global,
									kwArgs["srcFunc"],
									kwArgs["adviceObj"]||kwArgs["targetObj"]||dj_global,
									kwArgs["adviceFunc"]||kwArgs["targetFunc"],
									kwArgs["aroundObj"],
									kwArgs["aroundFunc"],
									kwArgs["once"],
									kwArgs["delay"],
									kwArgs["rate"],
									kwArgs["adviceMsg"]||false );
	}

	this.kwConnect = function(kwArgs){
		return this._kwConnectImpl(kwArgs, false);

	}

	this.disconnect = function(){
		var ao = interpolateArgs(arguments);
		if(!ao.adviceFunc){ return; } // nothing to disconnect
		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
		return mjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once);
	}

	this.kwDisconnect = function(kwArgs){
		return this._kwConnectImpl(kwArgs, true);
	}
}

// exactly one of these is created whenever a method with a joint point is run,
// if there is at least one 'around' advice.
dojo.event.MethodInvocation = function(join_point, obj, args) {
	this.jp_ = join_point;
	this.object = obj;
	this.args = [];
	for(var x=0; x<args.length; x++){
		this.args[x] = args[x];
	}
	// the index of the 'around' that is currently being executed.
	this.around_index = -1;
}

dojo.event.MethodInvocation.prototype.proceed = function() {
	this.around_index++;
	if(this.around_index >= this.jp_.around.length){
		return this.jp_.object[this.jp_.methodname].apply(this.jp_.object, this.args);
		// return this.jp_.run_before_after(this.object, this.args);
	}else{
		var ti = this.jp_.around[this.around_index];
		var mobj = ti[0]||dj_global;
		var meth = ti[1];
		return mobj[meth].call(mobj, this);
	}
} 


dojo.event.MethodJoinPoint = function(obj, methname){
	this.object = obj||dj_global;
	this.methodname = methname;
	this.methodfunc = this.object[methname];
	this.before = [];
	this.after = [];
	this.around = [];
}

dojo.event.MethodJoinPoint.getForMethod = function(obj, methname) {
	// if(!(methname in obj)){
	if(!obj){ obj = dj_global; }
	if(!obj[methname]){
		// supply a do-nothing method implementation
		obj[methname] = function(){};
	}else if((!dojo.lang.isFunction(obj[methname]))&&(!dojo.lang.isAlien(obj[methname]))){
		return null; // FIXME: should we throw an exception here instead?
	}
	// we hide our joinpoint instance in obj[methname + '$joinpoint']
	var jpname = methname + "$joinpoint";
	var jpfuncname = methname + "$joinpoint$method";
	var joinpoint = obj[jpname];
	if(!joinpoint){
		var isNode = false;
		if(dojo.event["browser"]){
			if( (obj["attachEvent"])||
				(obj["nodeType"])||
				(obj["addEventListener"]) ){
				isNode = true;
				dojo.event.browser.addClobberNodeAttrs(obj, [jpname, jpfuncname, methname]);
			}
		}
		var origArity = obj[methname].length;
		obj[jpfuncname] = obj[methname];
		// joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, methname);
		joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, jpfuncname);
		obj[methname] = function(){ 
			var args = [];

			if((isNode)&&(!arguments.length)){
				var evt = null;
				try{
					if(obj.ownerDocument){
						evt = obj.ownerDocument.parentWindow.event;
					}else if(obj.documentElement){
						evt = obj.documentElement.ownerDocument.parentWindow.event;
					}else{
						evt = window.event;
					}
				}catch(e){
					evt = window.event;
				}

				if(evt){
					args.push(dojo.event.browser.fixEvent(evt, this));
				}
			}else{
				for(var x=0; x<arguments.length; x++){
					if((x==0)&&(isNode)&&(dojo.event.browser.isEvent(arguments[x]))){
						args.push(dojo.event.browser.fixEvent(arguments[x], this));
					}else{
						args.push(arguments[x]);
					}
				}
			}
			// return joinpoint.run.apply(joinpoint, arguments); 
			return joinpoint.run.apply(joinpoint, args); 
		}
		obj[methname].__preJoinArity = origArity;
	}
	return joinpoint;
}

dojo.lang.extend(dojo.event.MethodJoinPoint, {
	unintercept: function(){
		this.object[this.methodname] = this.methodfunc;
		this.before = [];
		this.after = [];
		this.around = [];
	},

	disconnect: dojo.lang.forward("unintercept"),

	run: function() {
		var obj = this.object||dj_global;
		var args = arguments;

		// optimization. We only compute once the array version of the arguments
		// pseudo-arr in order to prevent building it each time advice is unrolled.
		var aargs = [];
		for(var x=0; x<args.length; x++){
			aargs[x] = args[x];
		}

		var unrollAdvice  = function(marr){ 
			if(!marr){
				dojo.debug("Null argument to unrollAdvice()");
				return;
			}
		  
			var callObj = marr[0]||dj_global;
			var callFunc = marr[1];
			
			if(!callObj[callFunc]){
				dojo.raise("function \"" + callFunc + "\" does not exist on \"" + callObj + "\"");
			}
			
			var aroundObj = marr[2]||dj_global;
			var aroundFunc = marr[3];
			var msg = marr[6];
			var undef;

			var to = {
				args: [],
				jp_: this,
				object: obj,
				proceed: function(){
					return callObj[callFunc].apply(callObj, to.args);
				}
			};
			to.args = aargs;

			var delay = parseInt(marr[4]);
			var hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != "undefined"));
			if(marr[5]){
				var rate = parseInt(marr[5]);
				var cur = new Date();
				var timerSet = false;
				if((marr["last"])&&((cur-marr.last)<=rate)){
					if(dojo.event.canTimeout){
						if(marr["delayTimer"]){
							clearTimeout(marr.delayTimer);
						}
						var tod = parseInt(rate*2); // is rate*2 naive?
						var mcpy = dojo.lang.shallowCopy(marr);
						marr.delayTimer = setTimeout(function(){
							// FIXME: on IE at least, event objects from the
							// browser can go out of scope. How (or should?) we
							// deal with it?
							mcpy[5] = 0;
							unrollAdvice(mcpy);
						}, tod);
					}
					return;
				}else{
					marr.last = cur;
				}
			}

			// FIXME: need to enforce rates for a connection here!

			if(aroundFunc){
				// NOTE: around advice can't delay since we might otherwise depend
				// on execution order!
				aroundObj[aroundFunc].call(aroundObj, to);
			}else{
				// var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);
				if((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  // FIXME: the render checks are grotty!
					dj_global["setTimeout"](function(){
						if(msg){
							callObj[callFunc].call(callObj, to); 
						}else{
							callObj[callFunc].apply(callObj, args); 
						}
					}, delay);
				}else{ // many environments can't support delay!
					if(msg){
						callObj[callFunc].call(callObj, to); 
					}else{
						callObj[callFunc].apply(callObj, args); 
					}
				}
			}
		}

		if(this.before.length>0){
			dojo.lang.forEach(this.before, unrollAdvice);
		}

		var result;
		if(this.around.length>0){
			var mi = new dojo.event.MethodInvocation(this, obj, args);
			result = mi.proceed();
		}else if(this.methodfunc){
			result = this.object[this.methodname].apply(this.object, args);
		}

		if(this.after.length>0){
			dojo.lang.forEach(this.after, unrollAdvice);
		}

		return (this.methodfunc) ? result : null;
	},

	getArr: function(kind){
		var arr = this.after;
		// FIXME: we should be able to do this through props or Array.in()
		if((typeof kind == "string")&&(kind.indexOf("before")!=-1)){
			arr = this.before;
		}else if(kind=="around"){
			arr = this.around;
		}
		return arr;
	},

	kwAddAdvice: function(args){
		this.addAdvice(	args["adviceObj"], args["adviceFunc"], 
						args["aroundObj"], args["aroundFunc"], 
						args["adviceType"], args["precedence"], 
						args["once"], args["delay"], args["rate"], 
						args["adviceMsg"]);
	},

	addAdvice: function(	thisAdviceObj, thisAdvice, 
							thisAroundObj, thisAround, 
							advice_kind, precedence, 
							once, delay, rate, asMessage){
		var arr = this.getArr(advice_kind);
		if(!arr){
			dojo.raise("bad this: " + this);
		}

		var ao = [thisAdviceObj, thisAdvice, thisAroundObj, thisAround, delay, rate, asMessage];
		
		if(once){
			if(this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr) >= 0){
				return;
			}
		}

		if(precedence == "first"){
			arr.unshift(ao);
		}else{
			arr.push(ao);
		}
	},

	hasAdvice: function(thisAdviceObj, thisAdvice, advice_kind, arr){
		if(!arr){ arr = this.getArr(advice_kind); }
		var ind = -1;
		for(var x=0; x<arr.length; x++){
			if((arr[x][0] == thisAdviceObj)&&(arr[x][1] == thisAdvice)){
				ind = x;
			}
		}
		return ind;
	},

	removeAdvice: function(thisAdviceObj, thisAdvice, advice_kind, once){
		var arr = this.getArr(advice_kind);
		var ind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);
		if(ind == -1){
			return false;
		}
		while(ind != -1){
			arr.splice(ind, 1);
			if(once){ break; }
			ind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);
		}
		return true;
	}
});

__CPAN_FILE__ src/experimental.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.experimental");

/**
 * Convenience for informing of experimental code.
 */
dojo.experimental = function(packageName, extra){
	var mess = "EXPERIMENTAL: " + packageName;
	mess += " -- Not yet ready for use.  APIs subject to change without notice.";
	if(extra){ mess += " " + extra; }
	dojo.debug(mess);
}

__CPAN_FILE__ src/flash.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.flash");

dojo.require("dojo.string.*");
dojo.require("dojo.uri.*");


/** 
		The goal of dojo.flash is to make it easy to extend Flash's capabilities
		into an AJAX/DHTML environment. Robust, performant, reliable 
		JavaScript/Flash communication is harder than most realize when they
		delve into the topic, especially if you want it
		to work on Internet Explorer, Firefox, and Safari, and to be able to
		push around hundreds of K of information quickly. Dojo.flash makes it
		possible to support these platforms; you have to jump through a few
		hoops to get its capabilites, but if you are a library writer 
		who wants to bring Flash's storage or streaming sockets ability into
		DHTML, for example, then dojo.flash is perfect for you.
  
		Dojo.flash provides an easy object for interacting with the Flash plugin. 
		This object provides methods to determine the current version of the Flash
		plugin (dojo.flash.info); execute Flash instance methods 
		independent of the Flash version
		being used (dojo.flash.comm); write out the necessary markup to 
		dynamically insert a Flash object into the page (dojo.flash.Embed; and 
		do dynamic installation and upgrading of the current Flash plugin in 
		use (dojo.flash.Install).
		
		To use dojo.flash, you must first wait until Flash is finished loading 
		and initializing before you attempt communication or interaction. 
		To know when Flash is finished use dojo.event.connect:
		
		dojo.event.connect(dojo.flash, "loaded", myInstance, "myCallback");
		
		Then, while the page is still loading provide the file name
		and the major version of Flash that will be used for Flash/JavaScript
		communication (see "Flash Communication" below for information on the 
		different kinds of Flash/JavaScript communication supported and how they 
		depend on the version of Flash installed):
		
		dojo.flash.setSwf({flash6: "src/storage/storage_flash6.swf",
											 flash8: "src/storage/storage_flash8.swf"});
		
		This will cause dojo.flash to pick the best way of communicating
		between Flash and JavaScript based on the platform.
		
		If no SWF files are specified, then Flash is not initialized.
		
		Your Flash must use DojoExternalInterface to expose Flash methods and
		to call JavaScript; see "Flash Communication" below for details.
		
		setSwf can take an optional 'visible' attribute to control whether
		the Flash object is visible or not on the page; the default is visible:
		
		dojo.flash.setSwf({flash6: "src/storage/storage_flash6.swf",
											 flash8: "src/storage/storage_flash8.swf",
											 visible: false});
		
		Once finished, you can query Flash version information:
		
		dojo.flash.info.version
		
		Or can communicate with Flash methods that were exposed:
		
		var results = dojo.flash.comm.sayHello("Some Message");
		
		Only string values are currently supported for both arguments and
		for return results. Everything will be cast to a string on both
		the JavaScript and Flash sides.
		
		-------------------
		Flash Communication
		-------------------
		
		dojo.flash allows Flash/JavaScript communication in 
		a way that can pass large amounts of data back and forth reliably and
		very fast. The dojo.flash
		framework encapsulates the specific way in which this communication occurs,
		presenting a common interface to JavaScript irrespective of the underlying
		Flash version.
		
		There are currently three major ways to do Flash/JavaScript communication
		in the Flash community:
		
		1) Flash 6+ - Uses Flash methods, such as SetVariable and TCallLabel,
		and the fscommand handler to do communication. Strengths: Very fast,
		mature, and can send extremely large amounts of data; can do
		synchronous method calls. Problems: Does not work on Safari; works on 
		Firefox/Mac OS X only if Flash 8 plugin is installed; cryptic to work with.
		
		2) Flash 8+ - Uses ExternalInterface, which provides a way for Flash
		methods to register themselves for callbacks from JavaScript, and a way
		for Flash to call JavaScript. Strengths: Works on Safari; elegant to
		work with; can do synchronous method calls. Problems: Extremely buggy 
		(fails if there are new lines in the data, for example); performance
		degrades drastically in O(n^2) time as data grows; locks up the browser while
		it is communicating; does not work in Internet Explorer if Flash
		object is dynamically added to page with document.writeln, DOM methods,
		or innerHTML.
		
		3) Flash 6+ - Uses two seperate Flash applets, one that we 
		create over and over, passing input data into it using the PARAM tag, 
		which then uses a Flash LocalConnection to pass the data to the main Flash
		applet; communication back to Flash is accomplished using a getURL
		call with a javascript protocol handler, such as "javascript:myMethod()".
		Strengths: the most cross browser, cross platform pre-Flash 8 method
		of Flash communication known; works on Safari. Problems: Timing issues;
		clunky and complicated; slow; can only send very small amounts of
		data (several K); all method calls are asynchronous.
		
		dojo.flash.comm uses only the first two methods. This framework
		was created primarily for dojo.storage, which needs to pass very large
		amounts of data synchronously and reliably across the Flash/JavaScript
		boundary. We use the first method, the Flash 6 method, on all platforms
		that support it, while using the Flash 8 ExternalInterface method
		only on Safari with some special code to help correct ExternalInterface's
		bugs.
		
		Since dojo.flash needs to have two versions of the Flash
		file it wants to generate, a Flash 6 and a Flash 8 version to gain
		true cross-browser compatibility, several tools are provided to ease
		development on the Flash side.
		
		In your Flash file, if you want to expose Flash methods that can be
		called, use the DojoExternalInterface class to register methods. This
		class is an exact API clone of the standard ExternalInterface class, but
		can work in Flash 6+ browsers. Under the covers it uses the best
		mechanism to do communication:
		
		class HelloWorld{
			function HelloWorld(){
				// Initialize the DojoExternalInterface class
				DojoExternalInterface.initialize();
				
				// Expose your methods
				DojoExternalInterface.addCallback("sayHello", this, this.sayHello);
				
				// Tell JavaScript that you are ready to have method calls
				DojoExternalInterface.loaded();
				
				// Call some JavaScript
				var resultsReady = function(results){
					trace("Received the following results from JavaScript: " + results);
				}
				DojoExternalInterface.call("someJavaScriptMethod", resultsReady, 
																	 someParameter);
			}
			
			function sayHello(){ ... }
			
			static main(){ ... }
		}
		
		DojoExternalInterface adds two new functions to the ExternalInterface
		API: initialize() and loaded(). initialize() must be called before
		any addCallback() or call() methods are run, and loaded() must be
		called after you are finished adding your callbacks. Calling loaded()
		will fire the dojo.flash.loaded() event, so that JavaScript can know that
		Flash has finished loading and adding its callbacks, and can begin to
		interact with the Flash file.
		
		To generate your SWF files, use the ant task
		"buildFlash". You must have the open source Motion Twin ActionScript 
		compiler (mtasc) installed and in your path to use the "buildFlash"
		ant task; download and install mtasc from http://www.mtasc.org/.
		
		
		
		buildFlash usage:
		
		ant buildFlash -Ddojo.flash.file=../tests/flash/HelloWorld.as
		
		where "dojo.flash.file" is the relative path to your Flash 
		ActionScript file.
		
		This will generate two SWF files, one ending in _flash6.swf and the other
		ending in _flash8.swf in the same directory as your ActionScript method:
		
		HelloWorld_flash6.swf
		HelloWorld_flash8.swf
		
		Initialize dojo.flash with the filename and Flash communication version to
		use during page load; see the documentation for dojo.flash for details:
		
		dojo.flash.setSwf({flash6: "tests/flash/HelloWorld_flash6.swf",
											 flash8: "tests/flash/HelloWorld_flash8.swf"});
		
		Now, your Flash methods can be called from JavaScript as if they are native
		Flash methods, mirrored exactly on the JavaScript side:
		
		dojo.flash.comm.sayHello();
		
		Only Strings are supported being passed back and forth currently.
		
		JavaScript to Flash communication is synchronous; i.e., results are returned
		directly from the method call:
		
		var results = dojo.flash.comm.sayHello();
		
		Flash to JavaScript communication is asynchronous due to limitations in
		the underlying technologies; you must use a results callback to handle
		results returned by JavaScript in your Flash AS files:
		
		var resultsReady = function(results){
			trace("Received the following results from JavaScript: " + results);
		}
		DojoExternalInterface.call("someJavaScriptMethod", resultsReady);
		
		
		
		-------------------
		Notes
		-------------------
		
		If you have both Flash 6 and Flash 8 versions of your file:
		
		dojo.flash.setSwf({flash6: "tests/flash/HelloWorld_flash6.swf",
											 flash8: "tests/flash/HelloWorld_flash8.swf"});
											 
		but want to force the browser to use a certain version of Flash for
		all platforms (for testing, for example), use the djConfig
		variable 'forceFlashComm' with the version number to force:
		
		var djConfig = { forceFlashComm: 6 };
		
		Two values are currently supported, 6 and 8, for the two styles of
		communication described above. Just because you force dojo.flash
		to use a particular communication style is no guarantee that it will
		work; for example, Flash 8 communication doesn't work in Internet
		Explorer due to bugs in Flash, and Flash 6 communication does not work
		in Safari. It is best to let dojo.flash determine the best communication
		mechanism, and to use the value above only for debugging the dojo.flash
		framework itself.
		
		Also note that dojo.flash can currently only work with one Flash object
		on the page; it and the API do not yet support multiple Flash objects on
		the same page.
		
		We use some special tricks to get decent, linear performance
		out of Flash 8's ExternalInterface on Safari; see the blog
		post 
		http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html
		for details.
		
		Your code can detect whether the Flash player is installing or having
		its version revved in two ways. First, if dojo.flash detects that
		Flash installation needs to occur, it sets dojo.flash.info.installing
		to true. Second, you can detect if installation is necessary with the
		following callback:
		
		dojo.event.connect(dojo.flash, "installing", myInstance, "myCallback");
		
		You can use this callback to delay further actions that might need Flash;
		when installation is finished the full page will be refreshed and the
		user will be placed back on your page with Flash installed.
		
		Two utility methods exist if you want to add loading and installing
		listeners without creating dependencies on dojo.event; these are
		'addLoadingListener' and 'addInstallingListener'.
		
		-------------------
		Todo/Known Issues
		-------------------

		There are several tasks I was not able to do, or did not need to fix
		to get dojo.storage out:		
		
		* When using Flash 8 communication, Flash method calls to JavaScript
		are not working properly; serialization might also be broken for certain
		invalid characters when it is Flash invoking JavaScript methods.
		The Flash side needs to have more sophisticated serialization/
		deserialization mechanisms like JavaScript currently has. The
		test_flash2.html unit tests should also be updated to have much more
		sophisticated Flash to JavaScript unit tests, including large
		amounts of data.
		
		* On Internet Explorer, after doing a basic install, the page is
		not refreshed or does not detect that Flash is now available. The way
		to fix this is to create a custom small Flash file that is pointed to
		during installation; when it is finished loading, it does a callback
		that says that Flash installation is complete on IE, and we can proceed
		to initialize the dojo.flash subsystem.
		
		@author Brad Neuberg, bkn3@columbia.edu
*/

dojo.flash = {
	flash6_version: null,
	flash8_version: null,
	ready: false,
	_visible: true,
	_loadedListeners: new Array(),
	_installingListeners: new Array(),
	
	/** Sets the SWF files and versions we are using. */
	setSwf: function(fileInfo){
		//dojo.debug("setSwf");
		if(fileInfo == null || dojo.lang.isUndefined(fileInfo)){
			return;
		}
		
		if(fileInfo.flash6 != null && !dojo.lang.isUndefined(fileInfo.flash6)){
			this.flash6_version = fileInfo.flash6;
		}
		
		if(fileInfo.flash8 != null && !dojo.lang.isUndefined(fileInfo.flash8)){
			this.flash8_version = fileInfo.flash8;
		}
		
		if(!dojo.lang.isUndefined(fileInfo.visible)){
			this._visible = fileInfo.visible;
		}
		
		// initialize ourselves		
		this._initialize();
	},
	
	/** Returns whether we are using Flash 6 for communication on this platform. */
	useFlash6: function(){
		if(this.flash6_version == null){
			return false;
		}else if (this.flash6_version != null && dojo.flash.info.commVersion == 6){
			// if we have a flash 6 version of this SWF, and this browser supports 
			// communicating using Flash 6 features...
			return true;
		}else{
			return false;
		}
	},
	
	/** Returns whether we are using Flash 8 for communication on this platform. */
	useFlash8: function(){
		if(this.flash8_version == null){
			return false;
		}else if (this.flash8_version != null && dojo.flash.info.commVersion == 8){
			// if we have a flash 8 version of this SWF, and this browser supports
			// communicating using Flash 8 features...
			return true;
		}else{
			return false;
		}
	},
	
	/** Adds a listener to know when Flash is finished loading. 
			Useful if you don't want a dependency on dojo.event. */
	addLoadedListener: function(listener){
		this._loadedListeners.push(listener);
	},

	/** Adds a listener to know if Flash is being installed. 
			Useful if you don't want a dependency on dojo.event. */
	addInstallingListener: function(listener){
		this._installingListeners.push(listener);
	},	
	
	/** 
			A callback when the Flash subsystem is finished loading and can be
			worked with. To be notified when Flash is finished loading, connect
			your callback to this method using the following:
			
			dojo.event.connect(dojo.flash, "loaded", myInstance, "myCallback");
	*/
	loaded: function(){
		//dojo.debug("dojo.flash.loaded");
		dojo.flash.ready = true;
		if(dojo.flash._loadedListeners.length > 0){
			for(var i = 0;i < dojo.flash._loadedListeners.length; i++){
				dojo.flash._loadedListeners[i].call(null);
			}
		}
	},
	
	/** 
			A callback to know if Flash is currently being installed or
			having its version revved. To be notified if Flash is installing, connect
			your callback to this method using the following:
			
			dojo.event.connect(dojo.flash, "installing", myInstance, "myCallback");
	*/
	installing: function(){
	 //dojo.debug("installing");
	 if(dojo.flash._installingListeners.length > 0){
			for(var i = 0;i < dojo.flash._installingListeners.length; i++){
				dojo.flash._installingListeners[i].call(null);
			}
		}
	},
	
	/** Initializes dojo.flash. */
	_initialize: function(){
		//dojo.debug("dojo.flash._initialize");
		// see if we need to rev or install Flash on this platform
		var installer = new dojo.flash.Install();
		dojo.flash.installer = installer;

		if(installer.needed() == true){		
			installer.install();
		}else{
			//dojo.debug("Writing object out");
			// write the flash object into the page
			dojo.flash.obj = new dojo.flash.Embed(this._visible);
			dojo.flash.obj.write(dojo.flash.info.commVersion);
			
			// initialize the way we do Flash/JavaScript communication
			dojo.flash.comm = new dojo.flash.Communicator();
		}
	}
};


/** 
		A class that helps us determine whether Flash is available,
		it's major and minor versions, and what Flash version features should
		be used for Flash/JavaScript communication. Parts of this code
		are adapted from the automatic Flash plugin detection code autogenerated 
		by the Macromedia Flash 8 authoring environment. 
		
		An instance of this class can be accessed on dojo.flash.info after
		the page is finished loading.
		
		This constructor must be called before the page is finished loading. 
*/
dojo.flash.Info = function(){
	// Visual basic helper required to detect Flash Player ActiveX control 
	// version information on Internet Explorer
	if(dojo.render.html.ie){
		document.writeln('<script language="VBScript" type="text/vbscript"\>');
		document.writeln('Function VBGetSwfVer(i)');
		document.writeln('  on error resume next');
		document.writeln('  Dim swControl, swVersion');
		document.writeln('  swVersion = 0');
		document.writeln('  set swControl = CreateObject("ShockwaveFlash.ShockwaveFlash." + CStr(i))');
		document.writeln('  if (IsObject(swControl)) then');
		document.writeln('    swVersion = swControl.GetVariable("$version")');
		document.writeln('  end if');
		document.writeln('  VBGetSwfVer = swVersion');
		document.writeln('End Function');
		document.writeln('</script\>');
	}
	
	this._detectVersion();
	this._detectCommunicationVersion();
}

dojo.flash.Info.prototype = {
	/** The full version string, such as "8r22". */
	version: -1,
	
	/** 
			The major, minor, and revisions of the plugin. For example, if the
			plugin is 8r22, then the major version is 8, the minor version is 0,
			and the revision is 22. 
	*/
	versionMajor: -1,
	versionMinor: -1,
	versionRevision: -1,
	
	/** Whether this platform has Flash already installed. */
	capable: false,
	
	/** 
			The major version number for how our Flash and JavaScript communicate.
			This can currently be the following values:
			6 - We use a combination of the Flash plugin methods, such as SetVariable
			and TCallLabel, along with fscommands, to do communication.
			8 - We use the ExternalInterface API. 
			-1 - For some reason neither method is supported, and no communication
			is possible. 
	*/
	commVersion: 6,
	
	/** Set if we are in the middle of a Flash installation session. */
	installing: false,
	
	/** 
			Asserts that this environment has the given major, minor, and revision
			numbers for the Flash player. Returns true if the player is equal
			or above the given version, false otherwise.
			
			Example: To test for Flash Player 7r14:
			
			dojo.flash.info.isVersionOrAbove(7, 0, 14)
	*/
	isVersionOrAbove: function(reqMajorVer, reqMinorVer, reqVer){
		// make the revision a decimal (i.e. transform revision 14 into
		// 0.14
		reqVer = parseFloat("." + reqVer);
		
		if(this.versionMajor >= reqMajorVer && this.versionMinor >= reqMinorVer
			 && this.versionRevision >= reqVer){
			return true;
		}else{
			return false;
		}
	},
	
	_detectVersion: function(){
		var versionStr;
		
		// loop backwards through the versions until we find the newest version	
		for(var testVersion = 25; testVersion > 0; testVersion--){
			if(dojo.render.html.ie){
				versionStr = VBGetSwfVer(testVersion);
			}else{
				versionStr = this._JSFlashInfo(testVersion);		
			}
				
			if(versionStr == -1 ){
				this.capable = false; 
				return;
			}else if(versionStr != 0){
				var versionArray;
				if(dojo.render.html.ie){
					var tempArray = versionStr.split(" ");
					var tempString = tempArray[1];
					versionArray = tempString.split(",");
				}else{
					versionArray = versionStr.split(".");
				}
					
				this.versionMajor = versionArray[0];
				this.versionMinor = versionArray[1];
				this.versionRevision = versionArray[2];
				
				// 7.0r24 == 7.24
				versionString = this.versionMajor + "." + this.versionRevision;
				this.version = parseFloat(versionString);
				
				this.capable = true;
				
				break;
			}
		}
	},
	
	/** 
			JavaScript helper required to detect Flash Player PlugIn version 
			information. Internet Explorer uses a corresponding Visual Basic
			version to interact with the Flash ActiveX control. 
	*/
	_JSFlashInfo: function(testVersion){
		// NS/Opera version >= 3 check for Flash plugin in plugin array
		if(navigator.plugins != null && navigator.plugins.length > 0){
			if(navigator.plugins["Shockwave Flash 2.0"] || 
				 navigator.plugins["Shockwave Flash"]){
				var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
				var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
				var descArray = flashDescription.split(" ");
				var tempArrayMajor = descArray[2].split(".");
				var versionMajor = tempArrayMajor[0];
				var versionMinor = tempArrayMajor[1];
				if(descArray[3] != ""){
					tempArrayMinor = descArray[3].split("r");
				}else{
					tempArrayMinor = descArray[4].split("r");
				}
				var versionRevision = tempArrayMinor[1] > 0 ? tempArrayMinor[1] : 0;
				var version = versionMajor + "." + versionMinor + "." 
											+ versionRevision;
											
				return version;
			}
		}
		
		return -1;
	},
	
	/** 
			Detects the mechanisms that should be used for Flash/JavaScript 
			communication, setting 'commVersion' to either 6 or 8. If the value is
			6, we use Flash Plugin 6+ features, such as GetVariable, TCallLabel,
			and fscommand, to do Flash/JavaScript communication; if the value is
			8, we use the ExternalInterface API for communication. 
	*/
	_detectCommunicationVersion: function(){
		if(this.capable == false){
			this.commVersion = null;
			return;
		}
		
		// detect if the user has over-ridden the default flash version
		if (typeof djConfig["forceFlashComm"] != "undefined" &&
				typeof djConfig["forceFlashComm"] != null){
			this.commVersion = djConfig["forceFlashComm"];
			return;
		}
		
		// we prefer Flash 6 features over Flash 8, because they are much faster
		// and much less buggy
		
		// at this point, we don't have a flash file to detect features on,
		// so we need to instead look at the browser environment we are in
		if(dojo.render.html.safari == true || dojo.render.html.opera == true){
			this.commVersion = 8;
		}else{
			this.commVersion = 6;
		}
	}
};

/** A class that is used to write out the Flash object into the page. */
dojo.flash.Embed = function(visible){
	this._visible = visible;
}

dojo.flash.Embed.prototype = {
	/** 
			The width of this Flash applet. The default is the minimal width
			necessary to show the Flash settings dialog. 
	*/
	width: 215,
	
	/** 
			The height of this Flash applet. The default is the minimal height
			necessary to show the Flash settings dialog. 
	*/
	height: 138,
	
	/** The id of the Flash object. */
	id: "flashObject",
	
	/** Controls whether this is a visible Flash applet or not. */
	_visible: true,
			
	/** 
			Writes the Flash into the page. This must be called before the page
			is finished loading. 
			@param flashVer The Flash version to write.
			@param doExpressInstall Whether to write out Express Install
			information. Optional value; defaults to false.
	*/
	write: function(flashVer, doExpressInstall){
		//dojo.debug("write");
		if(dojo.lang.isUndefined(doExpressInstall)){
			doExpressInstall = false;
		}
		
		// determine our container div's styling
		var containerStyle = new dojo.string.Builder();
		containerStyle.append("width: " + this.width + "px; ");
		containerStyle.append("height: " + this.height + "px; ");
		if(this._visible == false){
			containerStyle.append("position: absolute; ");
			containerStyle.append("z-index: 10000; ");
			containerStyle.append("top: -1000px; ");
			containerStyle.append("left: -1000px; ");
		}
		containerStyle = containerStyle.toString();

		// figure out the SWF file to get and how to write out the correct HTML
		// for this Flash version
		var objectHTML;
		var swfloc;
		// Flash 6
		if(flashVer == 6){
			swfloc = dojo.flash.flash6_version;
			var dojoPath = djConfig.baseRelativePath;
			swfloc = swfloc + "?baseRelativePath=" + escape(dojoPath);
			
			objectHTML = 
						  '<embed id="' + this.id + '" src="' + swfloc + '" '
						+ '    quality="high" bgcolor="#ffffff" '
						+ '    width="' + this.width + '" height="' + this.height + '" '
						+ '    name="' + this.id + '" '
						+ '    align="middle" allowScriptAccess="sameDomain" '
						+ '    type="application/x-shockwave-flash" swLiveConnect="true" '
						+ '    pluginspage="http://www.macromedia.com/go/getflashplayer">';
		}else{ // Flash 8
			swfloc = dojo.flash.flash8_version;
			var swflocObject = swfloc, swflocEmbed = swfloc;
			if(doExpressInstall){
				// the location to redirect to after installing
				var redirectURL = escape(window.location);
				document.title = document.title.slice(0, 47) + " - Flash Player Installation";
				var docTitle = escape(document.title);
				swflocObject += "?MMredirectURL=" + redirectURL
				                + "&MMplayerType=ActiveX"
				                + "&MMdoctitle="+docTitle;
				swflocEmbed += "?MMredirectURL=" + redirectURL + "&MMplayerType=PlugIn";
			}
			
			objectHTML =
				'<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" '
				  + 'codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0" '
				  + 'width="' + this.width + '" '
				  + 'height="' + this.height + '" '
				  + 'id="' + this.id + '" '
				  + 'align="middle"> '
				  + '<param name="allowScriptAccess" value="sameDomain" /> '
				  + '<param name="movie" value="' + swflocObject + '" /> '
				  + '<param name="quality" value="high" /> '
				  + '<param name="bgcolor" value="#ffffff" /> '
				  + '<embed src="' + swflocEmbed + '" '
				  + 'quality="high" '
				  + 'bgcolor="#ffffff" '
				  + 'width="' + this.width + '" '
				  + 'height="' + this.height + '" '
				  + 'id="' + this.id + '" '
				  + 'name="' + this.id + '" '
				  + 'swLiveConnect="true" '
				  + 'align="middle" '
				  + 'allowScriptAccess="sameDomain" '
				  + 'type="application/x-shockwave-flash" '
				  + 'pluginspage="http://www.macromedia.com/go/getflashplayer" />'
				+ '</object>';
		}

		// now write everything out
		objectHTML = '<div id="' + this.id + 'Container" style="' + containerStyle + '"> '
						+ objectHTML
					 + '</div>';
		document.writeln(objectHTML);
	},  
	
	/** Gets the Flash object DOM node. */
	get: function(){
		//return (dojo.render.html.ie) ? window[this.id] : document[this.id];
		
		// more robust way to get Flash object; version above can break
		// communication on IE sometimes
		return document.getElementById(this.id);
	},
	
	/** Sets the visibility of this Flash object. */
	setVisible: function(visible){
		var container = dojo.byId(this.id + "Container");
		if(visible == true){
			container.style.visibility = "visible";
		}else{
			container.style.position = "absolute";
			container.style.x = "-1000px";
			container.style.y = "-1000px";
			container.style.visibility = "hidden";
		}
	},
	
	/** Centers the flash applet on the page. */
	center: function(){
		// FIXME: replace this with Dojo's centering code rather than our own
		// We want to center the Flash applet vertically and horizontally
		var elementWidth = this.width;
		var elementHeight = this.height;
    
		// get the browser width and height; the code below
		// works in IE and Firefox in compatibility, non-strict
		// mode
		var browserWidth = document.body.clientWidth;
		var browserHeight = document.body.clientHeight;
    
		// in Firefox if we are in standards compliant mode
		// (with a strict doctype), then the browser width
		// and height have to be computed from the root level
		// HTML element not the BODY element
		if(!dojo.render.html.ie && document.compatMode == "CSS1Compat"){
			browserWidth = document.body.parentNode.clientWidth;
			browserHeight = document.body.parentNode.clientHeight;
		}else if(dojo.render.html.ie && document.compatMode == "CSS1Compat"){
			// IE 6 in standards compliant mode has to be calculated
			// differently
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
		}else if(dojo.render.html.safari){ // Safari works different
			browserHeight = self.innerHeight;
		}
    
		// get where we are scrolled to in the document
		// the code below works in FireFox
		var scrolledByWidth = window.scrollX;
		var scrolledByHeight = window.scrollY;
		// compute these values differently for IE;
		// IE has two possibilities; it is either in standards
		// compatibility mode or it is not
		if(typeof scrolledByWidth == "undefined"){
			if(document.compatMode == "CSS1Compat"){ // standards mode
				scrolledByWidth = document.documentElement.scrollLeft;
				scrolledByHeight = document.documentElement.scrollTop;
			}else{ // Pre IE6 non-standards mode
				scrolledByWidth = document.body.scrollLeft;
				scrolledByHeight = document.body.scrollTop;
			}
		}

		// compute the centered position    
		var x = scrolledByWidth + (browserWidth - elementWidth) / 2;
		var y = scrolledByHeight + (browserHeight - elementHeight) / 2; 

		// set the centered position
		var container = dojo.byId(this.id + "Container");
		container.style.top = y + "px";
		container.style.left = x + "px";
	}
};


/** 
		A class that is used to communicate between Flash and JavaScript in 
		a way that can pass large amounts of data back and forth reliably,
		very fast, and with synchronous method calls. This class encapsulates the 
		specific way in which this communication occurs,
		presenting a common interface to JavaScript irrespective of the underlying
		Flash version.
*/
dojo.flash.Communicator = function(){
	if(dojo.flash.useFlash6()){
		this._writeFlash6();
	}else if (dojo.flash.useFlash8()){
		this._writeFlash8();
	}
}

dojo.flash.Communicator.prototype = {
	_writeFlash6: function(){
		var id = dojo.flash.obj.id;
		
		// global function needed for Flash 6 callback;
		// we write it out as a script tag because the VBScript hook for IE
		// callbacks does not work properly if this function is evalled() from
		// within the Dojo system
		document.writeln('<script language="JavaScript">');
		document.writeln('  function ' + id + '_DoFSCommand(command, args){ ');
		document.writeln('    dojo.flash.comm._handleFSCommand(command, args); ');
		document.writeln('}');
		document.writeln('</script>');
		
		// hook for Internet Explorer to receive FSCommands from Flash
		if(dojo.render.html.ie){
			document.writeln('<SCRIPT LANGUAGE=VBScript\> ');
			document.writeln('on error resume next ');
			document.writeln('Sub ' + id + '_FSCommand(ByVal command, ByVal args)');
			document.writeln(' call ' + id + '_DoFSCommand(command, args)');
			document.writeln('end sub');
			document.writeln('</SCRIPT\> ');
		}
	},
	
	_writeFlash8: function(){
		// nothing needs to be written out for Flash 8 communication; 
		// happens automatically
	},
	
	/** Flash 6 communication. */
	
	/** Handles fscommand's from Flash to JavaScript. Flash 6 communication. */
	_handleFSCommand: function(command, args){
		//dojo.debug("fscommand, command="+command+", args="+args);
		// Flash 8 on Mac/Firefox precedes all commands with the string "FSCommand:";
		// strip it off if it is present
		if(command != null && !dojo.lang.isUndefined(command)
			&& /^FSCommand:(.*)/.test(command) == true){
			command = command.match(/^FSCommand:(.*)/)[1];
		}
		 
		if(command == "addCallback"){ // add Flash method for JavaScript callback
			this._fscommandAddCallback(command, args);
		}else if(command == "call"){ // Flash to JavaScript method call
			this._fscommandCall(command, args);
		}else if(command == "fscommandReady"){ // see if fscommands are ready
			this._fscommandReady();
		}
	},
	
	/** Handles registering a callable Flash function. Flash 6 communication. */
	_fscommandAddCallback: function(command, args){
		var functionName = args;
			
		// do a trick, where we link this function name to our wrapper
		// function, _call, that does the actual JavaScript to Flash call
		var callFunc = function(){
			return dojo.flash.comm._call(functionName, arguments);
		};			
		dojo.flash.comm[functionName] = callFunc;
		
		// indicate that the call was successful
		dojo.flash.obj.get().SetVariable("_succeeded", true);
	},
	
	/** Handles Flash calling a JavaScript function. Flash 6 communication. */
	_fscommandCall: function(command, args){
		var plugin = dojo.flash.obj.get();
		var functionName = args;
		
		// get the number of arguments to this method call and build them up
		var numArgs = parseInt(plugin.GetVariable("_numArgs"));
		var flashArgs = new Array();
		for(var i = 0; i < numArgs; i++){
			var currentArg = plugin.GetVariable("_" + i);
			flashArgs.push(currentArg);
		}
		
		// get the function instance; we technically support more capabilities
		// than ExternalInterface, which can only call global functions; if
		// the method name has a dot in it, such as "dojo.flash.loaded", we
		// eval it so that the method gets run against an instance
		var runMe;
		if(functionName.indexOf(".") == -1){ // global function
			runMe = window[functionName];
		}else{
			// instance function
			runMe = eval(functionName);
		}
		
		// make the call and get the results
		var results = null;
		if(!dojo.lang.isUndefined(runMe) && runMe != null){
			results = runMe.apply(null, flashArgs);
		}
		
		// return the results to flash
		plugin.SetVariable("_returnResult", results);
	},
	
	/** Reports that fscommands are ready to run if executed from Flash. */
	_fscommandReady: function(){
		var plugin = dojo.flash.obj.get();
		plugin.SetVariable("fscommandReady", "true");
	},
	
	/** 
			The actual function that will execute a JavaScript to Flash call; used
			by the Flash 6 communication method. 
	*/
	_call: function(functionName, args){
		// we do JavaScript to Flash method calls by setting a Flash variable
		// "_functionName" with the function name; "_numArgs" with the number
		// of arguments; and "_0", "_1", etc for each numbered argument. Flash
		// reads these, executes the function call, and returns the result
		// in "_returnResult"
		var plugin = dojo.flash.obj.get();
		plugin.SetVariable("_functionName", functionName);
		plugin.SetVariable("_numArgs", args.length);
		for(var i = 0; i < args.length; i++){
			// unlike Flash 8's ExternalInterface, Flash 6 has no problem with
			// any special characters _except_ for the null character \0; double
			// encode this so the Flash side never sees it, but we can get it 
			// back if the value comes back to JavaScript
			var value = args[i];
			value = value.replace(/\0/g, "\\0");
			
			plugin.SetVariable("_" + i, value);
		}
		
		// now tell Flash to execute this method using the Flash Runner
		plugin.TCallLabel("/_flashRunner", "execute");
		
		// get the results
		var results = plugin.GetVariable("_returnResult");
		
		// we double encoded all null characters as //0 because Flash breaks
		// if they are present; turn the //0 back into /0
		results = results.replace(/\\0/g, "\0");
		
		return results;
	},
	
	/** Flash 8 communication. */
	
	/** 
			Registers the existence of a Flash method that we can call with
			JavaScript, using Flash 8's ExternalInterface. 
	*/
	_addExternalInterfaceCallback: function(methodName){
		var wrapperCall = function(){
			// some browsers don't like us changing values in the 'arguments' array, so
			// make a fresh copy of it
			var methodArgs = new Array(arguments.length);
			for(var i = 0; i < arguments.length; i++){
				methodArgs[i] = arguments[i];
			}
			return dojo.flash.comm._execFlash(methodName, methodArgs);
		};
		
		dojo.flash.comm[methodName] = wrapperCall;
	},
	
	/** 
			Encodes our data to get around ExternalInterface bugs.
			Flash 8 communication.
	*/
	_encodeData: function(data){
		// double encode all entity values, or they will be mis-decoded
		// by Flash when returned
		var entityRE = /\&([^;]*)\;/g;
		data = data.replace(entityRE, "&amp;$1;");
		
		// entity encode XML-ish characters, or Flash's broken XML serializer
		// breaks
		data = data.replace(/</g, "&lt;");
		data = data.replace(/>/g, "&gt;");
		
		// transforming \ into \\ doesn't work; just use a custom encoding
		data = data.replace("\\", "&custom_backslash;&custom_backslash;");
		
		data = data.replace(/\n/g, "\\n");
		data = data.replace(/\r/g, "\\r");
		data = data.replace(/\f/g, "\\f");
		data = data.replace(/\0/g, "\\0"); // null character
		data = data.replace(/\'/g, "\\\'");
		data = data.replace(/\"/g, '\\\"');
		
		return data;
	},
	
	/** 
			Decodes our data to get around ExternalInterface bugs.
			Flash 8 communication.
	*/
	_decodeData: function(data){
		if(data == null || typeof data == "undefined"){
			return data;
		}
		
		// certain XMLish characters break Flash's wire serialization for
		// ExternalInterface; these are encoded on the 
		// DojoExternalInterface side into a custom encoding, rather than
		// the standard entity encoding, because otherwise we won't be able to
		// differentiate between our own encoding and any entity characters
		// that are being used in the string itself
		data = data.replace(/\&custom_lt\;/g, "<");
		data = data.replace(/\&custom_gt\;/g, ">");
		
		// Unfortunately, Flash returns us our String with special characters
		// like newlines broken into seperate characters. So if \n represents
		// a new line, Flash returns it as "\" and "n". This means the character
		// is _not_ a newline. This forces us to eval() the string to cause
		// escaped characters to turn into their real special character values.
		data = eval('"' + data + '"');
		
		return data;
	},
	
	/** 
			Sends our method arguments over to Flash in chunks in order to
			have ExternalInterface's performance not be O(n^2).
			Flash 8 communication.
	*/
	_chunkArgumentData: function(value, argIndex){
		var plugin = dojo.flash.obj.get();
		
		// cut up the string into pieces, and push over each piece one
		// at a time
		var numSegments = Math.ceil(value.length / 1024);
		for(var i = 0; i < numSegments; i++){
			var startCut = i * 1024;
			var endCut = i * 1024 + 1024;
			if(i == (numSegments - 1)){
				endCut = i * 1024 + value.length;
			}
			
			var piece = value.substring(startCut, endCut);
			
			// encode each piece seperately, rather than the entire
			// argument data, because ocassionally a special 
			// character, such as an entity like &foobar;, will fall between
			// piece boundaries, and we _don't_ want to encode that value if
			// it falls between boundaries, or else we will end up with incorrect
			// data when we patch the pieces back together on the other side
			piece = this._encodeData(piece);
			
			// directly use the underlying CallFunction method used by
			// ExternalInterface, which is vastly faster for large strings
			// and lets us bypass some Flash serialization bugs
			plugin.CallFunction('<invoke name="chunkArgumentData" '
														+ 'returntype="javascript">'
														+ '<arguments>'
														+ '<string>' + piece + '</string>'
														+ '<number>' + argIndex + '</number>'
														+ '</arguments>'
														+ '</invoke>');
		}
	},
	
	/** 
			Gets our method return data in chunks for better performance.
			Flash 8 communication.
	*/
	_chunkReturnData: function(){
		var plugin = dojo.flash.obj.get();
		
		var numSegments = plugin.getReturnLength();
		var resultsArray = new Array();
		for(var i = 0; i < numSegments; i++){
			// directly use the underlying CallFunction method used by
			// ExternalInterface, which is vastly faster for large strings
			var piece = 
					plugin.CallFunction('<invoke name="chunkReturnData" '
															+ 'returntype="javascript">'
															+ '<arguments>'
															+ '<number>' + i + '</number>'
															+ '</arguments>'
															+ '</invoke>');
															
			// remove any leading or trailing JavaScript delimiters, which surround
			// our String when it comes back from Flash since we bypass Flash's
			// deserialization routines by directly calling CallFunction on the
			// plugin
			if(piece == '""' || piece == "''"){
				piece = "";
			}else{
				piece = piece.substring(1, piece.length-1);
			}
		
			resultsArray.push(piece);
		}
		var results = resultsArray.join("");
		
		return results;
	},
	
	/** 
			Executes a Flash method; called from the JavaScript wrapper proxy we
			create on dojo.flash.comm.
			Flash 8 communication.
	*/
	_execFlash: function(methodName, methodArgs){
		var plugin = dojo.flash.obj.get();
				
		// begin Flash method execution
		plugin.startExec();
		
		// set the number of arguments
		plugin.setNumberArguments(methodArgs.length);
		
		// chunk and send over each argument
		for(var i = 0; i < methodArgs.length; i++){
			this._chunkArgumentData(methodArgs[i], i);
		}
		
		// execute the method
		plugin.exec(methodName);
														
		// get the return result
		var results = this._chunkReturnData();
		
		// decode the results
		results = this._decodeData(results);
		
		// reset everything
		plugin.endExec();
		
		return results;

	}
}

/** 
		Figures out the best way to automatically install the Flash plugin
		for this browser and platform. Also determines if installation or
		revving of the current plugin is needed on this platform.
*/
dojo.flash.Install = function(){
}

dojo.flash.Install.prototype = {
	/** 
			Determines if installation or revving of the current plugin is 
			needed. 
	*/
	needed: function(){
		// do we even have flash?
		if(dojo.flash.info.capable == false){
			return true;
		}

		// are we on the Mac? Safari needs Flash version 8 to do Flash 8
		// communication, while Firefox/Mac needs Flash 8 to fix bugs it has
		// with Flash 6 communication
		if(dojo.render.os.mac == true && !dojo.flash.info.isVersionOrAbove(8, 0, 0)){
			return true;
		}

		// other platforms need at least Flash 6 or above
		if(!dojo.flash.info.isVersionOrAbove(6, 0, 0)){
			return true;
		}

		// otherwise we don't need installation
		return false;
	},

	/** Performs installation or revving of the Flash plugin. */
	install: function(){
		//dojo.debug("install");
		// indicate that we are installing
		dojo.flash.info.installing = true;
		dojo.flash.installing();
		
		if(dojo.flash.info.capable == false){ // we have no Flash at all
			//dojo.debug("Completely new install");
			// write out a simple Flash object to force the browser to prompt
			// the user to install things
			var installObj = new dojo.flash.Embed(false);
			installObj.write(8); // write out HTML for Flash 8 version+
		}else if(dojo.flash.info.isVersionOrAbove(6, 0, 65)){ // Express Install
			//dojo.debug("Express install");
			var installObj = new dojo.flash.Embed(false);
			installObj.write(8, true); // write out HTML for Flash 8 version+
			installObj.setVisible(true);
			installObj.center();
		}else{ // older Flash install than version 6r65
			alert("This content requires a more recent version of the Macromedia "
						+" Flash Player.");
			window.location.href = "http://www.macromedia.com/go/getflashplayer";
		}
	},
	
	/** 
			Called when the Express Install is either finished, failed, or was
			rejected by the user.
	*/
	_onInstallStatus: function(msg){
		if (msg == "Download.Complete"){
			// Installation is complete.
			dojo.flash._initialize();
		}else if(msg == "Download.Cancelled"){
			alert("This content requires a more recent version of the Macromedia "
						+" Flash Player.");
			window.location.href = "http://www.macromedia.com/go/getflashplayer";
		}else if (msg == "Download.Failed"){
			// The end user failed to download the installer due to a network failure
			alert("There was an error downloading the Flash Player update. "
						+ "Please try again later, or visit macromedia.com to download "
						+ "the latest version of the Flash plugin.");
		}	
	}
}

// find out if Flash is installed
dojo.flash.info = new dojo.flash.Info();

// vim:ts=4:noet:tw=0:

__CPAN_FILE__ src/hostenv_adobesvg.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*
 * Adobe SVG Viewer host environment
 */
if(typeof window == 'undefined'){
	dojo.raise("attempt to use adobe svg hostenv when no window object");
}

with(dojo.render){
	name = navigator.appName;
	ver = parseFloat(navigator.appVersion, 10);
	switch(navigator.platform){
		case "MacOS":
			os.osx =  true;
			break;
		case "Linux":
			os.linux =  true;
			break;
		case "Windows":
			os.win =  true;
			break;
		default:
			os.linux = true;
			break;
	};
	svg.capable = true;
	svg.support.builtin = true;
	svg.adobe = true;
};

// browserEval("alert(window.location);");

dojo.hostenv.println = function(s){
	try{
    // FIXME: this may not work with adobe's viewer, as we may first need a 
		// reference to the svgDocument
		// FIXME: need a way to determine where to position the text for this
    var ti = document.createElement("text");
    ti.setAttribute("x","50");
		var yPos = 25 + 15*document.getElementsByTagName("text").length;
    ti.setAttribute("y",yPos);
		var tn = document.createTextNode(s);
		ti.appendChild(tn);
		document.documentElement.appendChild(ti);
	}catch(e){

	}
}

dojo.debug = function() {
	if (!djConfig.isDebug) { return; }
	var args = arguments;
	if(typeof dojo.hostenv.println != 'function'){
		dojo.raise("attempt to call dojo.debug when there is no dojo.hostenv println implementation (yet?)");
	}
	var isJUM = dj_global["jum"];
	var s = isJUM ? "": "DEBUG: ";
	for(var i=0;i<args.length;++i){ s += args[i]; }
	if(isJUM){ // this seems to be the only way to get JUM to "play nice"
		jum.debug(s);
	}else{
		dojo.hostenv.println(s);
	}
}

dojo.hostenv.startPackage("dojo.hostenv");

dojo.hostenv.name_ = 'adobesvg';

dojo.hostenv.anonCtr = 0;
dojo.hostenv.anon = {};

dojo.hostenv.nameAnonFunc = function(anonFuncPtr, namespaceObj){
	var ret = "_"+this.anonCtr++;
	var nso = (namespaceObj || this.anon);
	while(typeof nso[ret] != "undefined"){
		ret = "_"+this.anonCtr++;
	}
	nso[ret] = anonFuncPtr;
	return ret;
}

dojo.hostenv.modulesLoadedFired = false;
dojo.hostenv.modulesLoadedListeners = [];
dojo.hostenv.getTextStack = [];
dojo.hostenv.loadUriStack = [];
dojo.hostenv.loadedUris = [];


dojo.hostenv.modulesLoaded = function(){
	if(this.modulesLoadedFired){ return; }
	if((this.loadUriStack.length==0)&&(this.getTextStack.length==0)){
		if(this.inFlightCount > 0){ 
			dojo.debug("couldn't initialize, there are files still in flight");
			return;
		}
		this.modulesLoadedFired = true;
		var mll = this.modulesLoadedListeners;
		for(var x=0; x<mll.length; x++){
			mll[x]();
		}
	}
}

dojo.hostenv.getNewAnonFunc = function(){
	var ret = "_"+this.anonCtr++;
	while(typeof this.anon[ret] != "undefined"){
		ret = "_"+this.anonCtr++;
	}
	// this.anon[ret] = function(){};
	eval("dojo.nostenv.anon."+ret+" = function(){};");
	return [ret, this.anon[ret]];
}

dojo.hostenv.displayStack = function(){
	var oa = [];
	var stack = this.loadUriStack;
	for(var x=0; x<stack.length; x++){
		oa.unshift([stack[x][0], (typeof stack[x][2])]);
	}
	dojo.debug("<pre>"+oa.join("\n")+"</pre>");
}

dojo.hostenv.unwindUriStack = function(){
	var stack = this.loadUriStack;
	for(var x in dojo.hostenv.loadedUris){
		for(var y=stack.length-1; y>=0; y--){
			if(stack[y][0]==x){
				stack.splice(y, 1);
			}
		}
	}
	var next = stack.pop();
	if((!next)&&(stack.length==0)){ 
		return;
	}
	for(var x=0; x<stack.length; x++){
		if((stack[x][0]==next[0])&&(stack[x][2])){
			next[2] == stack[x][2]
		}
	}
	var last = next;
	while(dojo.hostenv.loadedUris[next[0]]){
		last = next;
		next = stack.pop();
	}
	while(typeof next[2] == "string"){ // unwind as far as we can
		try{
			// dojo.debug("<pre><![CDATA["+next[2]+"]]></pre>");
			dj_eval(next[2]);
			next[1](true);
		}catch(e){
			dojo.debug("we got an error when loading "+next[0]);
			dojo.debug("error: "+e);
			// for(var x in e){ alert(x+" "+e[x]); }
		}
		dojo.hostenv.loadedUris[next[0]] = true;
		dojo.hostenv.loadedUris.push(next[0]);
		last = next;
		next = stack.pop();
		if((!next)&&(stack.length==0)){ break; }
		while(dojo.hostenv.loadedUris[next[0]]){
			last = next;
			next = stack.pop();
		}
	}
	if(next){
		stack.push(next);
		dojo.debug("### CHOKED ON: "+next[0]);
	}
}

/**
 * Reads the contents of the URI, and evaluates the contents.
 * Returns true if it succeeded. Returns false if the URI reading failed. Throws if the evaluation throws.
 * The result of the eval is not available to the caller.
 */
dojo.hostenv.loadUri = function(uri, cb){
	if(dojo.hostenv.loadedUris[uri]){
		return;
	}
	var stack = this.loadUriStack;
	stack.push([uri, cb, null]);
	var tcb = function(contents){
		// gratuitous hack for Adobe SVG 3, what a fucking POS
		if(contents.content){
			contents = contents.content;
		}

		// stack management
		var next = stack.pop();
		if((!next)&&(stack.length==0)){ 
			dojo.hostenv.modulesLoaded();
			return;
		}
		if(typeof contents == "string"){
			stack.push(next);
			for(var x=0; x<stack.length; x++){
				if(stack[x][0]==uri){
					stack[x][2] = contents;
				}
			}
			next = stack.pop();
		}
		if(dojo.hostenv.loadedUris[next[0]]){ 
			// dojo.debug("WE ALREADY HAD: "+next[0]);
			dojo.hostenv.unwindUriStack();
			return;
		}
		// push back onto stack
		stack.push(next);
		if(next[0]!=uri){
			//  and then unwind as far as we can
			if(typeof next[2] == "string"){
				dojo.hostenv.unwindUriStack();
			}

		}else{
			if(!contents){ 
				next[1](false);
			}else{
				var deps = dojo.hostenv.getDepsForEval(next[2]);
				if(deps.length>0){
					eval(deps.join(";"));
				}else{
					dojo.hostenv.unwindUriStack();
				}
			}
		}
	}
	this.getText(uri, tcb, true);
}

/**
 * Reads the contents of the URI, and evaluates the contents.
 * Returns true if it succeeded. Returns false if the URI reading failed. Throws if the evaluation throws.
 * The result of the eval is not available to the caller.
 */
dojo.hostenv.loadUri = function(uri, cb){
	if(dojo.hostenv.loadedUris[uri]){
		return;
	}
	var stack = this.loadUriStack;
	stack.push([uri, cb, null]);
	var tcb = function(contents){
		// gratuitous hack for Adobe SVG 3, what a fucking POS
		if(contents.content){
			contents = contents.content;
		}

		// stack management
		var next = stack.pop();
		if((!next)&&(stack.length==0)){ 
			dojo.hostenv.modulesLoaded();
			return;
		}
		if(typeof contents == "string"){
			stack.push(next);
			for(var x=0; x<stack.length; x++){
				if(stack[x][0]==uri){
					stack[x][2] = contents;
				}
			}
			next = stack.pop();
		}
		if(dojo.hostenv.loadedUris[next[0]]){ 
			// dojo.debug("WE ALREADY HAD: "+next[0]);
			dojo.hostenv.unwindUriStack();
			return;
		}
		// push back onto stack
		stack.push(next);
		if(next[0]!=uri){
			//  and then unwind as far as we can
			if(typeof next[2] == "string"){
				dojo.hostenv.unwindUriStack();
			}

		}else{
			if(!contents){ 
				next[1](false);
			}else{
				var deps = dojo.hostenv.getDepsForEval(next[2]);
				if(deps.length>0){
					eval(deps.join(";"));
				}else{
					dojo.hostenv.unwindUriStack();
				}
			}
		}
	}
	this.getText(uri, tcb, true);
}

/**
* loadModule("A.B") first checks to see if symbol A.B is defined. 
* If it is, it is simply returned (nothing to do).
* If it is not defined, it will look for "A/B.js" in the script root directory, followed
* by "A.js".
* It throws if it cannot find a file to load, or if the symbol A.B is not defined after loading.
* It returns the object A.B.
*
* This does nothing about importing symbols into the current package.
* It is presumed that the caller will take care of that. For example, to import
* all symbols:
*
*    with (dojo.hostenv.loadModule("A.B")) {
*       ...
*    }
*
* And to import just the leaf symbol:
*
*    var B = dojo.hostenv.loadModule("A.B");
*    ...
*
* dj_load is an alias for dojo.hostenv.loadModule
*/
dojo.hostenv.loadModule = function(modulename, exact_only, omit_module_check){
	// alert("dojo.hostenv.loadModule('"+modulename+"');");
	var module = this.findModule(modulename, 0);
	if(module){
		return module;
	}

	// dojo.debug("dojo.hostenv.loadModule('"+modulename+"');");

	// protect against infinite recursion from mutual dependencies
	if (typeof this.loading_modules_[modulename] !== 'undefined'){
		// NOTE: this should never throw an exception!! "recursive" includes
		// are normal in the course of app and module building, so blow out of
		// it gracefully, but log it in debug mode

		// dojo.raise("recursive attempt to load module '" + modulename + "'");
		dojo.debug("recursive attempt to load module '" + modulename + "'");
	}else{
		this.addedToLoadingCount.push(modulename);
	}
	this.loading_modules_[modulename] = 1;


	// convert periods to slashes
	var relpath = modulename.replace(/\./g, '/') + '.js';

	var syms = modulename.split(".");
	var nsyms = modulename.split(".");
	if(syms[0]=="dojo"){ // FIXME: need a smarter way to do this!
		syms[0] = "src"; 
	}
	var last = syms.pop();
	syms.push(last);
	// figure out if we're looking for a full package, if so, we want to do
	// things slightly diffrently
	var _this = this;
	var pfn = this.pkgFileName;
	if(last=="*"){
		modulename = (nsyms.slice(0, -1)).join('.');

		var module = this.findModule(modulename, 0);
		// dojo.debug("found: "+modulename+"="+module);
		if(module){
			_this.removedFromLoadingCount.push(modulename);
			return module;
		}

		var nextTry = function(lastStatus){
			if(lastStatus){ 
				module = _this.findModule(modulename, false); // pass in false so we can give better error
				if((!module)&&(syms[syms.length-1]!=pfn)){
					dojo.raise("Module symbol '" + modulename + "' is not defined after loading '" + relpath + "'"); 
				}
				if(module){
					_this.removedFromLoadingCount.push(modulename);
					dojo.hostenv.modulesLoaded();
					return;
				}
			}
			syms.pop();
			syms.push(pfn);
			// dojo.debug("syms: "+syms);
			relpath = syms.join("/") + '.js';
			if(relpath.charAt(0)=="/"){
				relpath = relpath.slice(1);
			}
			// dojo.debug("relpath: "+relpath);
			_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
		}

		nextTry();
	}else{
		relpath = syms.join("/") + '.js';
		modulename = nsyms.join('.');

		var nextTry = function(lastStatus){
			// dojo.debug("lastStatus: "+lastStatus);
			if(lastStatus){ 
				// dojo.debug("inital relpath: "+relpath);
				module = _this.findModule(modulename, false); // pass in false so we can give better error
				// if(!module){
				if((!module)&&(syms[syms.length-1]!=pfn)){
					dojo.raise("Module symbol '" + modulename + "' is not defined after loading '" + relpath + "'"); 
				}
				if(module){
					_this.removedFromLoadingCount.push(modulename);
					dojo.hostenv.modulesLoaded();
					return;
				}
			}
			var setPKG = (syms[syms.length-1]==pfn) ? false : true;
			syms.pop();
			if(setPKG){
				syms.push(pfn);
			}
			relpath = syms.join("/") + '.js';
			if(relpath.charAt(0)=="/"){
				relpath = relpath.slice(1);
			}
			// dojo.debug("relpath: "+relpath);
			_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
		}

		this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
	}
	return;
}

/**
 * Read the contents of the specified uri and return those contents.
 *
 * FIXME: Make sure this is consistent with other implementations of getText
 * @param uri A relative or absolute uri. If absolute, it still must be in the same "domain" as we are.
 * @param async_cb If not specified, returns false as synchronous is not
 * supported. If specified, load asynchronously, and use async_cb as the handler which receives the result of the request.
 * @param fail_ok Default false. If fail_ok and !async_cb and loading fails, return null instead of throwing.
 */ 
dojo.hostenv.async_cb = null;

dojo.hostenv.unWindGetTextStack = function(){
	if(dojo.hostenv.inFlightCount>0){
		setTimeout("dojo.hostenv.unWindGetTextStack()", 100);
		return;
	}
	// we serialize because this goddamned environment is too fucked up
	// to know how to do anything else
	dojo.hostenv.inFlightCount++;
	var next = dojo.hostenv.getTextStack.pop();
	if((!next)&&(dojo.hostenv.getTextStack.length==0)){ 
		dojo.hostenv.inFlightCount--;
		dojo.hostenv.async_cb = function(){};
		return;
	}
	dojo.hostenv.async_cb = next[1];
	// http = window.getURL(uri, dojo.hostenv.anon[cbn]);
	window.getURL(next[0], function(result){ 
		dojo.hostenv.inFlightCount--;
		dojo.hostenv.async_cb(result.content);
		dojo.hostenv.unWindGetTextStack();
	});
}

dojo.hostenv.getText = function(uri, async_cb, fail_ok){
	// dojo.debug("Calling getText()");
	try{
		if(async_cb){
			dojo.hostenv.getTextStack.push([uri, async_cb, fail_ok]);
			dojo.hostenv.unWindGetTextStack();
		}else{
			return dojo.raise("No synchronous XMLHTTP implementation available, for uri " + uri);
		}
	}catch(e){
		return dojo.raise("No XMLHTTP implementation available, for uri " + uri);
	}
}


/**
 * Makes an async post to the specified uri.
 *
 * FIXME: Not sure that we need this, but adding for completeness.
 * More details about the implementation of this are available at 
 * http://wiki.svg.org/index.php/PostUrl
 * @param uri A relative or absolute uri. If absolute, it still must be in the same "domain" as we are.
 * @param async_cb If not specified, returns false as synchronous is not
 * supported. If specified, load asynchronously, and use async_cb as the progress handler which takes the xmlhttp object as its argument. If async_cb, this function returns null.
 * @param text Data to post
 * @param fail_ok Default false. If fail_ok and !async_cb and loading fails, return null instead of throwing.
 * @param mime_type optional MIME type of the posted data (such as "text/plain")
 * @param encoding optional encoding for data. null, 'gzip' and 'deflate' are possible values. If browser does not support binary post this parameter is ignored.
 */ 
dojo.hostenv.postText = function(uri, async_cb, text, fail_ok, mime_type, encoding){
	var http = null;
	
	var async_callback = function(httpResponse){
		if (!httpResponse.success) {
			dojo.raise("Request for uri '" + uri + "' resulted in " + httpResponse.status);
		}
		
		if(!httpResponse.content) {
			if (!fail_ok) dojo.raise("Request for uri '" + uri + "' resulted in no content");
			return null;
		}
		// FIXME: wtf, I'm losing a reference to async_cb
		async_cb(httpResponse.content);
	}
	
	try {
		if(async_cb) {
			http = window.postURL(uri, text, async_callback, mimeType, encoding);
		} else {
		return dojo.raise("No synchronous XMLHTTP post implementation available, for uri " + uri);
		}
	} catch(e) {
		return dojo.raise("No XMLHTTP post implementation available, for uri " + uri);
	}
}

/*
 * It turns out that if we check *right now*, as this script file is being loaded,
 * then the last script element in the window DOM is ourselves.
 * That is because any subsequent script elements haven't shown up in the document
 * object yet.
 */
function dj_last_script_src() {
	var scripts = window.document.getElementsByTagName('script');
	if(scripts.length < 1){ 
		dojo.raise("No script elements in window.document, so can't figure out my script src"); 
	}
	var li = scripts.length-1;
	var xlinkNS = "http://www.w3.org/1999/xlink";
	var src = null;
	var script = null;
	while(!src){
		script = scripts.item(li);
		src = script.getAttributeNS(xlinkNS,"href");
		li--;
		if(li<0){ break; }
		// break;
	}
	if(!src){
		dojo.raise("Last script element (out of " + scripts.length + ") has no src");
	}
	return src;
}

if(!dojo.hostenv["library_script_uri_"]){
	dojo.hostenv.library_script_uri_ = dj_last_script_src();
}

// dojo.hostenv.loadUri = function(uri){
	/* FIXME: adding a script element doesn't seem to be synchronous, and so
	 * checking for namespace or object existance after loadUri using this
	 * method will error out. Need to figure out some other way of handling
	 * this!
	 */
	/*
	var se = document.createElement("script");
	se.src = uri;
	var head = document.getElementsByTagName("head")[0];
	head.appendChild(se);
	// document.write("<script type='text/javascript' src='"+uri+"' />");
	return 1;
}
*/

__CPAN_FILE__ src/hostenv_browser.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

// make jsc shut up (so we can use jsc to sanity check the code even if it will never run it).
/*@cc_on
@if (@_jscript_version >= 7)
var window; var XMLHttpRequest;
@end
@*/

if(typeof window == 'undefined'){
	dojo.raise("no window object");
}

// attempt to figure out the path to dojo if it isn't set in the config
(function() {
	// before we get any further with the config options, try to pick them out
	// of the URL. Most of this code is from NW
	if(djConfig.allowQueryConfig){
		var baseUrl = document.location.toString(); // FIXME: use location.query instead?
		var params = baseUrl.split("?", 2);
		if(params.length > 1){
			var paramStr = params[1];
			var pairs = paramStr.split("&");
			for(var x in pairs){
				var sp = pairs[x].split("=");
				// FIXME: is this eval dangerous?
				if((sp[0].length > 9)&&(sp[0].substr(0, 9) == "djConfig.")){
					var opt = sp[0].substr(9);
					try{
						djConfig[opt]=eval(sp[1]);
					}catch(e){
						djConfig[opt]=sp[1];
					}
				}
			}
		}
	}

	if(((djConfig["baseScriptUri"] == "")||(djConfig["baseRelativePath"] == "")) &&(document && document.getElementsByTagName)){
		var scripts = document.getElementsByTagName("script");
		var rePkg = /(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
		for(var i = 0; i < scripts.length; i++) {
			var src = scripts[i].getAttribute("src");
			if(!src) { continue; }
			var m = src.match(rePkg);
			if(m) {
				root = src.substring(0, m.index);
				if(src.indexOf("bootstrap1") > -1) { root += "../"; }
				if(!this["djConfig"]) { djConfig = {}; }
				if(djConfig["baseScriptUri"] == "") { djConfig["baseScriptUri"] = root; }
				if(djConfig["baseRelativePath"] == "") { djConfig["baseRelativePath"] = root; }
				break;
			}
		}
	}

	// fill in the rendering support information in dojo.render.*
	var dr = dojo.render;
	var drh = dojo.render.html;
	var drs = dojo.render.svg;
	var dua = drh.UA = navigator.userAgent;
	var dav = drh.AV = navigator.appVersion;
	var t = true;
	var f = false;
	drh.capable = t;
	drh.support.builtin = t;

	dr.ver = parseFloat(drh.AV);
	dr.os.mac = dav.indexOf("Macintosh") >= 0;
	dr.os.win = dav.indexOf("Windows") >= 0;
	// could also be Solaris or something, but it's the same browser
	dr.os.linux = dav.indexOf("X11") >= 0;

	drh.opera = dua.indexOf("Opera") >= 0;
	drh.khtml = (dav.indexOf("Konqueror") >= 0)||(dav.indexOf("Safari") >= 0);
	drh.safari = dav.indexOf("Safari") >= 0;
	var geckoPos = dua.indexOf("Gecko");
	drh.mozilla = drh.moz = (geckoPos >= 0)&&(!drh.khtml);
	if (drh.mozilla) {
		// gecko version is YYYYMMDD
		drh.geckoVersion = dua.substring(geckoPos + 6, geckoPos + 14);
	}
	drh.ie = (document.all)&&(!drh.opera);
	drh.ie50 = drh.ie && dav.indexOf("MSIE 5.0")>=0;
	drh.ie55 = drh.ie && dav.indexOf("MSIE 5.5")>=0;
	drh.ie60 = drh.ie && dav.indexOf("MSIE 6.0")>=0;

	dr.vml.capable=drh.ie;
	drs.capable = f;
	drs.support.plugin = f;
	drs.support.builtin = f;
	if (document.implementation
		&& document.implementation.hasFeature
		&& document.implementation.hasFeature("org.w3c.dom.svg", "1.0")
	){
		drs.capable = t;
		drs.support.builtin = t;
		drs.support.plugin = f;
	}
})();

dojo.hostenv.startPackage("dojo.hostenv");

dojo.render.name = dojo.hostenv.name_ = 'browser';
dojo.hostenv.searchIds = [];

// These are in order of decreasing likelihood; this will change in time.
var DJ_XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];

dojo.hostenv.getXmlhttpObject = function(){
    var http = null;
	var last_e = null;
	try{ http = new XMLHttpRequest(); }catch(e){}
    if(!http){
		for(var i=0; i<3; ++i){
			var progid = DJ_XMLHTTP_PROGIDS[i];
			try{
				http = new ActiveXObject(progid);
			}catch(e){
				last_e = e;
			}

			if(http){
				DJ_XMLHTTP_PROGIDS = [progid];  // so faster next time
				break;
			}
		}

		/*if(http && !http.toString) {
			http.toString = function() { "[object XMLHttpRequest]"; }
		}*/
	}

	if(!http){
		return dojo.raise("XMLHTTP not available", last_e);
	}

	return http;
}

/**
 * Read the contents of the specified uri and return those contents.
 *
 * @param uri A relative or absolute uri. If absolute, it still must be in the
 * same "domain" as we are.
 *
 * @param async_cb If not specified, load synchronously. If specified, load
 * asynchronously, and use async_cb as the progress handler which takes the
 * xmlhttp object as its argument. If async_cb, this function returns null.
 *
 * @param fail_ok Default false. If fail_ok and !async_cb and loading fails,
 * return null instead of throwing.
 */
dojo.hostenv.getText = function(uri, async_cb, fail_ok){

	var http = this.getXmlhttpObject();

	if(async_cb){
		http.onreadystatechange = function(){
			if((4==http.readyState)&&(http["status"])){
				if(http.status==200){
					// dojo.debug("LOADED URI: "+uri);
					async_cb(http.responseText);
				}
			}
		}
	}

	http.open('GET', uri, async_cb ? true : false);
	try {
		http.send(null);
	} catch (e) {
		if (fail_ok && !async_cb) {
			return null;
		} else {
			throw e;
		}
	}
	if(async_cb){
		return null;
	}

	return http.responseText;
}

/*
 * It turns out that if we check *right now*, as this script file is being loaded,
 * then the last script element in the window DOM is ourselves.
 * That is because any subsequent script elements haven't shown up in the document
 * object yet.
 */
 /*
function dj_last_script_src() {
    var scripts = window.document.getElementsByTagName('script');
    if(scripts.length < 1){
		dojo.raise("No script elements in window.document, so can't figure out my script src");
	}
    var script = scripts[scripts.length - 1];
    var src = script.src;
    if(!src){
		dojo.raise("Last script element (out of " + scripts.length + ") has no src");
	}
    return src;
}

if(!dojo.hostenv["library_script_uri_"]){
	dojo.hostenv.library_script_uri_ = dj_last_script_src();
}
*/

dojo.hostenv.defaultDebugContainerId = 'dojoDebug';
dojo.hostenv._println_buffer = [];
dojo.hostenv._println_safe = false;
dojo.hostenv.println = function (line){
	if(!dojo.hostenv._println_safe){
		dojo.hostenv._println_buffer.push(line);
	}else{
		try {
			var console = document.getElementById(djConfig.debugContainerId ?
				djConfig.debugContainerId : dojo.hostenv.defaultDebugContainerId);
			if(!console) { console = document.getElementsByTagName("body")[0] || document.body; }

			var div = document.createElement("div");
			div.appendChild(document.createTextNode(line));
			console.appendChild(div);
		} catch (e) {
			try{
				// safari needs the output wrapped in an element for some reason
				document.write("<div>" + line + "</div>");
			}catch(e2){
				window.status = line;
			}
		}
	}
}

dojo.addOnLoad(function(){
	dojo.hostenv._println_safe = true;
	while(dojo.hostenv._println_buffer.length > 0){
		dojo.hostenv.println(dojo.hostenv._println_buffer.shift());
	}
});

function dj_addNodeEvtHdlr (node, evtName, fp, capture){
	var oldHandler = node["on"+evtName] || function(){};
	node["on"+evtName] = function(){
		fp.apply(node, arguments);
		oldHandler.apply(node, arguments);
	}
	return true;
}


/* Uncomment this to allow init after DOMLoad, not after window.onload

// Mozilla exposes the event we could use
if (dojo.render.html.mozilla) {
   document.addEventListener("DOMContentLoaded", dj_load_init, null);
}
// for Internet Explorer. readyState will not be achieved on init call, but dojo doesn't need it
//Tighten up the comments below to allow init after DOMLoad, not after window.onload
/ * @cc_on @ * /
/ * @if (@_win32)
    document.write("<script defer>dj_load_init()<"+"/script>");
/ * @end @ * /
*/

// default for other browsers
// potential TODO: apply setTimeout approach for other browsers
// that will cause flickering though ( document is loaded and THEN is processed)
// maybe show/hide required in this case..
// TODO: other browsers may support DOMContentLoaded/defer attribute. Add them to above.
dj_addNodeEvtHdlr(window, "load", function(){
	// allow multiple calls, only first one will take effect
	if(arguments.callee.initialized){ return; }
	arguments.callee.initialized = true;

	var initFunc = function(){
		//perform initialization
		if(dojo.render.html.ie){
			dojo.hostenv.makeWidgets();
		}
	};

	if(dojo.hostenv.inFlightCount == 0){
		initFunc();
		dojo.hostenv.modulesLoaded();
	}else{
		dojo.addOnLoad(initFunc);
	}
});

dojo.hostenv.makeWidgets = function(){
	// you can put searchIds in djConfig and dojo.hostenv at the moment
	// we should probably eventually move to one or the other
	var sids = [];
	if(djConfig.searchIds && djConfig.searchIds.length > 0) {
		sids = sids.concat(djConfig.searchIds);
	}
	if(dojo.hostenv.searchIds && dojo.hostenv.searchIds.length > 0) {
		sids = sids.concat(dojo.hostenv.searchIds);
	}

	if((djConfig.parseWidgets)||(sids.length > 0)){
		if(dojo.evalObjPath("dojo.widget.Parse")){
			// we must do this on a delay to avoid:
			//	http://www.shaftek.org/blog/archives/000212.html
			// IE is such a tremendous peice of shit.
			try{
				var parser = new dojo.xml.Parse();
				if(sids.length > 0){
					for(var x=0; x<sids.length; x++){
						var tmpNode = document.getElementById(sids[x]);
						if(!tmpNode){ continue; }
						var frag = parser.parseElement(tmpNode, null, true);
						dojo.widget.getParser().createComponents(frag);
					}
				}else if(djConfig.parseWidgets){
					var frag  = parser.parseElement(document.getElementsByTagName("body")[0] || document.body, null, true);
					dojo.widget.getParser().createComponents(frag);
				}
			}catch(e){
				dojo.debug("auto-build-widgets error:", e);
			}
		}
	}
}

dojo.addOnLoad(function(){
	if(!dojo.render.html.ie) {
		dojo.hostenv.makeWidgets();
	}
});

try {
	if (dojo.render.html.ie) {
		//	easier and safer VML addition.  Thanks Emil!
		document.namespaces.add("v", "urn:schemas-microsoft-com:vml");
		document.createStyleSheet().addRule("v\\:*", "behavior:url(#default#VML)");
	}
} catch (e) { }

// stub, over-ridden by debugging code. This will at least keep us from
// breaking when it's not included
dojo.hostenv.writeIncludes = function(){}

dojo.byId = function(id, doc){
	if(id && (typeof id == "string" || id instanceof String)){
		if(!doc){ doc = document; }
		return doc.getElementById(id);
	}
	return id; // assume it's a node
}

__CPAN_FILE__ src/hostenv_dashboard.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.render.name = dojo.hostenv.name_ = "dashboard";

dojo.hostenv.println = function(/*String*/ message){
	// summary: Prints a message to the OS X console
	return alert(message); // null
}

dojo.hostenv.getXmlhttpObject = function(/*Object*/ kwArgs){
	// summary: Returns the appropriate transfer object for the call type
	if(widget.system && kwArgs){
		if((kwArgs.contentType && kwArgs.contentType.indexOf("text/") != 0) || (kwArgs.headers && kwArgs.headers["content-type"] && kwArgs.headers["content-type"].indexOf("text/") != 0)){
			var curl = new dojo.hostenv.CurlRequest;
			curl._save = true;
			return curl;
		}else if(kwArgs.method && kwArgs.method.toUpperCase() == "HEAD"){
			return new dojo.hostenv.CurlRequest;
		}else if(kwArgs.headers && kwArgs.header.referer){
			return new dojo.hostenv.CurlRequest; 
		}
	}
	return new XMLHttpRequest; // XMLHttpRequest
}

dojo.hostenv.CurlRequest = function(){
	// summary: Emulates the XMLHttpRequest Object
	this.onreadystatechange = null;
	this.readyState = 0;
	this.responseText = "";
	this.responseXML = null;
	this.status = 0;
	this.statusText = "";
	this._method = "";
	this._url = "";
	this._async = true;
	this._referrer = "";
	this._headers = [];
	this._save = false;
	this._responseHeader = "";
	this._responseHeaders = {};
	this._fileName = "";
	this._username = "";
	this._password = "";
}

dojo.hostenv.CurlRequest.prototype.open = function(/*String*/ method, /*URL*/ url, /*Boolean?*/ async, /*String?*/ username, /*String?*/ password){
	this._method = method;
	this._url = url;
	if(async){
		this._async = async;
	}
	if(username){
		this._username = username;
	}
	if(password){
		this._password = password;
	}
}

dojo.hostenv.CurlRequest.prototype.setRequestHeader = function(/*String*/ label, /*String*/ value){
	switch(label){
		case "Referer":
			this._referrer = value;
			break;
		case "content-type":
			break;
		default:
			this._headers.push(label + "=" + value);
			break;
	}
}

dojo.hostenv.CurlRequest.prototype.getAllResponseHeaders = function(){
	return this._responseHeader; // String
}

dojo.hostenv.CurlRequest.prototype.getResponseHeader = function(/*String*/ headerLabel){
	return this._responseHeaders[headerLabel]; // String
}

// -sS = Show only errors in errorString
// -i = Display headers with return
// -e = Referrer URI
// -H = Headers
// -d = data to be sent (forces POST)
// -G = forces GET
// -o = Writes to file (in the cache directory)
// -I = Only load headers
// -u = user:password
dojo.hostenv.CurlRequest.prototype.send = function(/*String*/ content){
	this.readyState = 1;
	if(this.onreadystatechange){
		this.onreadystatechange.call(this);
	}
	var query = {sS: ""};
	if(this._referrer){
		query.e = this._referrer;
	}
	if(this._headers.length){
		query.H = this._headers.join("&");
	}
	if(this._username){
		if(this._password){
			query.u = this._username + ":" + this._password;
		}else{
			query.u = this._username;
		}
	}
	if(content){
		query.d = this.content;
		if(this._method != "POST"){
			query.G = "";
		}
	}
	if(this._method == "HEAD"){
		query.I = "";
	}else{
		if(this._save){
			query.I = ""; // Get the headers in the initial query
		}else{
			query.i = "";
		}
	}

	var system = widget.system(dojo.hostenv.CurlRequest._formatCall(query, this._url), null);
	this.readyState = 2;
	if(this.onreadystatechange){
		this.onreadystatechange.call(this);
	}
	if(system.errorString){
		this.responseText = system.errorString;
		this.status = 0;
	}else{
		if(this._save){
			this._responseHeader = system.outputString;
		}else{
			var split = system.outputString.replace(/\r/g, "").split("\n\n", 2);
			this._responseHeader = split[0];
			this.responseText = split[1];
		}
		split = this._responseHeader.split("\n");
		this.statusText = split.shift();
		this.status = this.statusText.split(" ")[1];
		for(var i = 0, header; header = split[i]; i++){
			var header_split = header.split(": ", 2);
			this._responseHeaders[header_split[0]] = header_split[1];
		}
		if(this._save){
			widget.system("/bin/mkdir cache", null);
			// First, make a file name
			this._fileName = this._url.split("/").pop().replace(/\W/g, "");
			// Then, get its extension
			this._fileName += "." + this._responseHeaders["Content-Type"].replace(/[\r\n]/g, "").split("/").pop()
			delete query.I;
			query.o = "cache/" + this._fileName; // Tell it where to be saved.
			system = widget.system(dojo.hostenv.CurlRequest._formatCall(query, this._url), null);
			if(!system.errorString){
				this.responseText = "cache/" + this._fileName;
			}
		}else if(this._method == "HEAD"){
			this.responseText = this._responseHeader;
		}
	}

	this.readyState = 4;
	if(this.onreadystatechange){
		this.onreadystatechange.call(this);
	}
}

dojo.hostenv.CurlRequest._formatCall = function(query, url){
	var call = ["/usr/bin/curl"];
	for(var key in query){
		if(query[key] != ""){
			call.push("-" + key + " '" + query[key].replace(/'/g, "\'") + "'");
		}else{
			call.push("-" + key);
		}
	}
	call.push("'" + url.replace(/'/g, "\'") + "'");
	return call.join(" ");
}

dojo.hostenv.exit = function(){
	if(widget.system){
		widget.system("/bin/rm -rf cache/*", null);
	}
}

__CPAN_FILE__ src/hostenv_jsc.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*
 * JScript .NET jsc
 *
 */

dojo.hostenv.name_ = 'jsc';

// Sanity check this is the right hostenv.
// See the Rotor source code jscript/engine/globalobject.cs for what globals
// are available.
if((typeof ScriptEngineMajorVersion != 'function')||(ScriptEngineMajorVersion() < 7)){
	dojo.raise("attempt to use JScript .NET host environment with inappropriate ScriptEngine"); 
}

// for more than you wanted to know about why this import is required even if
// we fully qualify all symbols, see
// http://groups.google.com/groups?th=f050c7aeefdcbde2&rnum=12
import System;

dojo.hostenv.getText = function(uri){
	if(!System.IO.File.Exists(uri)){
		// dojo.raise("No such file '" + uri + "'");
		return 0;
	}
	var reader = new System.IO.StreamReader(uri);
	var contents : String = reader.ReadToEnd();
	return contents;
}

dojo.hostenv.loadUri = function(uri){
	var contents = this.getText(uri);
	if(!contents){
		dojo.raise("got no back contents from uri '" + uri + "': " + contents);
	}
	// TODO: in JScript .NET, eval will not affect the symbol table of the current code?
	var value = dj_eval(contents);
	dojo.debug("jsc eval of contents returned: ", value);
	return 1;

	// for an example doing runtime code compilation, see:
	// http://groups.google.com/groups?selm=eQ1aeciCBHA.1644%40tkmsftngp05&rnum=6
	// Microsoft.JScript or System.CodeDom.Compiler ?
	// var engine = new Microsoft.JScript.Vsa.VsaEngine()
	// what about loading a js file vs. a dll?
	// GetObject("script:" . uri);
}

/* The System.Environment object is useful:
    print ("CommandLine='" + System.Environment.CommandLine + "' " +
	   "program name='" + System.Environment.GetCommandLineArgs()[0] + "' " +
	   "CurrentDirectory='" + System.Environment.CurrentDirectory + "' " +
	   "StackTrace='" + System.Environment.StackTrace + "'");
*/

// same as System.Console.WriteLine
// sigh; Rotor treats symbol "print" at parse time without actually putting it
// in the builtin symbol table.
// Note that the print symbol is not available if jsc is run with the "/print-"
// option.
dojo.hostenv.println = function(s){
	print(s); // = print
}

dojo.hostenv.getLibraryScriptUri = function(){
	return System.Environment.GetCommandLineArgs()[0];
}

__CPAN_FILE__ src/hostenv_rhino.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*
* Rhino host environment
*/

// make jsc shut up (so we can use jsc for sanity checking) 
/*@cc_on
@if (@_jscript_version >= 7)
var loadClass; var print; var load; var quit; var version; var Packages; var java;
@end
@*/

// TODO: not sure what we gain from the next line, anyone?
//if (typeof loadClass == 'undefined') { dojo.raise("attempt to use Rhino host environment when no 'loadClass' global"); }

dojo.render.name = dojo.hostenv.name_ = 'rhino';
dojo.hostenv.getVersion = function() {return version()};

// see comments in spidermonkey loadUri
dojo.hostenv.loadUri = function(uri, cb){
	dojo.debug("uri: "+uri);
	try{
		// FIXME: what about remote URIs?
		var found = true;
		if(!(new java.io.File(uri)).exists()){
			try{
				// try it as a file first, URL second
				(new java.io.URL(uri)).openStream();
			}catch(e){
				found = false;
			}
		}
		if(!found){
			dojo.debug(uri+" does not exist");
			if(cb){ cb(0); }
			return 0;
		}
		var ok = load(uri);
		// dojo.debug(typeof ok);
		dojo.debug("rhino load('", uri, "') returned. Ok: ", ok);
		if(cb){ cb(1); }
		return 1;
	}catch(e){
		dojo.debug("rhino load('", uri, "') failed");
		if(cb){ cb(0); }
		return 0;
	}
}

dojo.hostenv.println = print;
dojo.hostenv.exit = function(exitcode){ 
	quit(exitcode);
}

// Hack to determine current script...
//
// These initial attempts failed:
//   1. get an EcmaError and look at e.getSourceName(): try {eval ("static in return")} catch(e) { ...
//   Won't work because NativeGlobal.java only does a put of "name" and "message", not a wrapped reflecting object.
//   Even if the EcmaError object had the sourceName set.
//  
//   2. var e = Packages.org.mozilla.javascript.Context.getCurrentContext().reportError('');
//   Won't work because it goes directly to the errorReporter, not the return value.
//   We want context.interpreterSourceFile and context.interpreterLine, which are used in static Context.getSourcePositionFromStack
//   (set by Interpreter.java at interpretation time, if in interpreter mode).
//
//   3. var e = Packages.org.mozilla.javascript.Context.getCurrentContext().reportRuntimeError('');
//   This returns an object, but e.message still does not have source info.
//   In compiler mode, perhaps not set; in interpreter mode, perhaps not used by errorReporter?
//
// What we found works is to do basically the same hack as is done in getSourcePositionFromStack,
// making a new java.lang.Exception() and then calling printStackTrace on a string stream.
// We have to parse the string for the .js files (different from the java files).
// This only works however in compiled mode (-opt 0 or higher).
// In interpreter mode, entire stack is java.
// When compiled, printStackTrace is like:
// java.lang.Exception
//	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
//	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
//	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
//	at java.lang.reflect.Constructor.newInstance(Constructor.java:274)
//	at org.mozilla.javascript.NativeJavaClass.constructSpecific(NativeJavaClass.java:228)
//	at org.mozilla.javascript.NativeJavaClass.construct(NativeJavaClass.java:185)
//	at org.mozilla.javascript.ScriptRuntime.newObject(ScriptRuntime.java:1269)
//	at org.mozilla.javascript.gen.c2.call(/Users/mda/Sites/burstproject/testrhino.js:27)
//    ...
//	at org.mozilla.javascript.tools.shell.Main.main(Main.java:76)
//
// Note may get different answers based on:
//    Context.setOptimizationLevel(-1)
//    Context.setGeneratingDebug(true)
//    Context.setGeneratingSource(true) 
//
// Some somewhat helpful posts:
//    http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=9v9n0g%246gr1%40ripley.netscape.com
//    http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=3BAA2DC4.6010702%40atg.com
//
// Note that Rhino1.5R5 added source name information in some exceptions.
// But this seems not to help in command-line Rhino, because Context.java has an error reporter
// so no EvaluationException is thrown.

// do it by using java java.lang.Exception
function dj_rhino_current_script_via_java(depth) {
    var optLevel = Packages.org.mozilla.javascript.Context.getCurrentContext().getOptimizationLevel();  
    if (optLevel == -1) dojo.unimplemented("getCurrentScriptURI (determine current script path for rhino when interpreter mode)", '');
    var caw = new java.io.CharArrayWriter();
    var pw = new java.io.PrintWriter(caw);
    var exc = new java.lang.Exception();
    var s = caw.toString();
    // we have to exclude the ones with or without line numbers because they put double entries in:
    //   at org.mozilla.javascript.gen.c3._c4(/Users/mda/Sites/burstproject/burst/Runtime.js:56)
    //   at org.mozilla.javascript.gen.c3.call(/Users/mda/Sites/burstproject/burst/Runtime.js)
    var matches = s.match(/[^\(]*\.js\)/gi);
    if(!matches){
		throw Error("cannot parse printStackTrace output: " + s);
	}

    // matches[0] is entire string, matches[1] is this function, matches[2] is caller, ...
    var fname = ((typeof depth != 'undefined')&&(depth)) ? matches[depth + 1] : matches[matches.length - 1];
    var fname = matches[3];
	if(!fname){ fname = matches[1]; }
    // print("got fname '" + fname + "' from stack string '" + s + "'");
    if (!fname) throw Error("could not find js file in printStackTrace output: " + s);
    //print("Rhino getCurrentScriptURI returning '" + fname + "' from: " + s); 
    return fname;
}

// UNUSED: leverage new support in native exception for getSourceName
/*
function dj_rhino_current_script_via_eval_exception() {
    var exc;
    // 'ReferenceError: "undefinedsymbol" is not defined.'
    try {eval ("undefinedsymbol()") } catch(e) {exc = e;}
    // 'Error: whatever'
    // try{throw Error("whatever");} catch(e) {exc = e;}
    // 'SyntaxError: identifier is a reserved word'
    // try {eval ("static in return")} catch(e) { exc = e; }
    print("got exception: '" + exc + "'");
    print("exc.stack=" + (typeof exc.stack));
    var sn = exc.getSourceName();
    print("SourceName=" + sn);
    return sn;
} 
*/

// reading a file from disk in Java is a humiliating experience by any measure.
// Lets avoid that and just get the freaking text
function readText(uri){
	// NOTE: we intentionally avoid handling exceptions, since the caller will
	// want to know
	var jf = new java.io.File(uri);
	var sb = new java.lang.StringBuffer();
	var input = new java.io.BufferedReader(new java.io.FileReader(jf));
	var line = "";
	while((line = input.readLine()) != null){
		sb.append(line);
		sb.append(java.lang.System.getProperty("line.separator"));
	}
	return sb.toString();
}

// call this now because later we may not be on the top of the stack
if(!djConfig.libraryScriptUri.length){
	try{
		djConfig.libraryScriptUri = dj_rhino_current_script_via_java(1);
	}catch(e){
		// otherwise just fake it
		if(djConfig["isDebug"]){
			print("\n");
			print("we have no idea where Dojo is located from.");
			print("Please try loading rhino in a non-interpreted mode or set a");
			print("\n	djConfig.libraryScriptUri\n");
			print("Setting the dojo path to './'");
			print("This is probably wrong!");
			print("\n");
			print("Dojo will try to load anyway");
		}
		djConfig.libraryScriptUri = "./";
	}
}


__CPAN_FILE__ src/hostenv_spidermonkey.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*
 * SpiderMonkey host environment
 */

dojo.hostenv.name_ = 'spidermonkey';

dojo.hostenv.println = print;
dojo.hostenv.exit = function(exitcode){ 
	quit(exitcode); 
}

// version() returns 0, sigh. and build() returns nothing but just prints.
dojo.hostenv.getVersion = function(){ return version(); }

// make jsc shut up (so we can use jsc for sanity checking) 
/*@cc_on
@if (@_jscript_version >= 7)
var line2pc; var print; var load; var quit;
@end
@*/

if(typeof line2pc == 'undefined'){
	dojo.raise("attempt to use SpiderMonkey host environment when no 'line2pc' global");
}

/*
 * This is a hack that determines the current script file by parsing a generated
 * stack trace (relying on the non-standard "stack" member variable of the
 * SpiderMonkey Error object).
 * If param depth is passed in, it'll return the script file which is that far down
 * the stack, but that does require that you know how deep your stack is when you are
 * calling.
 */
function dj_spidermonkey_current_file(depth){
    var s = '';
    try{
		throw Error("whatever");
	}catch(e){
		s = e.stack;
	}
    // lines are like: bu_getCurrentScriptURI_spidermonkey("ScriptLoader.js")@burst/Runtime.js:101
    var matches = s.match(/[^@]*\.js/gi);
    if(!matches){ 
		dojo.raise("could not parse stack string: '" + s + "'");
	}
    var fname = (typeof depth != 'undefined' && depth) ? matches[depth + 1] : matches[matches.length - 1];
    if(!fname){ 
		dojo.raise("could not find file name in stack string '" + s + "'");
	}
    //print("SpiderMonkeyRuntime got fname '" + fname + "' from stack string '" + s + "'");
    return fname;
}

// call this now because later we may not be on the top of the stack
if(!dojo.hostenv.library_script_uri_){ 
	dojo.hostenv.library_script_uri_ = dj_spidermonkey_current_file(0); 
}

dojo.hostenv.loadUri = function(uri){
	// spidermonkey load() evaluates the contents into the global scope (which
	// is what we want).
	// TODO: sigh, load() does not return a useful value. 
	// Perhaps it is returning the value of the last thing evaluated?
	var ok = load(uri);
	// dojo.debug("spidermonkey load(", uri, ") returned ", ok);
	return 1;
}



__CPAN_FILE__ src/hostenv_svg.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

//	hostenv_svg
if(typeof window == 'undefined'){
	dojo.raise("attempt to use adobe svg hostenv when no window object");
}
dojo.debug = function(){ 
	if (!djConfig.isDebug) { return; }
	var args = arguments;
	var isJUM = dj_global["jum"];
	var s = isJUM ? "": "DEBUG: ";
	for (var i = 0; i < args.length; ++i){ s += args[i]; }
	if (isJUM){ // this seems to be the only way to get JUM to "play nice"
		jum.debug(s);
	} else{ 
		dojo.hostenv.println(s);
	}
};

//	set up dojo.render.
dojo.render.name = navigator.appName;
dojo.render.ver = parseFloat(navigator.appVersion, 10);
switch(navigator.platform){
	case "MacOS":
		dojo.render.os.osx =  true;
		break;
	case "Linux":
		dojo.render.os.linux =  true;
		break;
	case "Windows":
		dojo.render.os.win =  true;
		break;
	default:
		dojo.render.os.linux = true;
		break;
};
dojo.render.svg.capable = true;
dojo.render.svg.support.builtin = true;
//	FIXME the following two is a big-ass hack for now.
dojo.render.svg.moz = ((navigator.userAgent.indexOf("Gecko") >= 0) && (!((navigator.appVersion.indexOf("Konqueror") >= 0) || (navigator.appVersion.indexOf("Safari") >= 0))));
dojo.render.svg.adobe = (window.parseXML != null);

//	agent-specific implementations.

//	from old hostenv_adobesvg.
dojo.hostenv.startPackage("dojo.hostenv");
dojo.hostenv.println = function(s){ 
	try {
		var ti = document.createElement("text");
		ti.setAttribute("x","50");
		ti.setAttribute("y", (25 + 15 * document.getElementsByTagName("text").length));
		ti.appendChild(document.createTextNode(s));
		document.documentElement.appendChild(ti);
	} catch(e){ }
};
dojo.hostenv.name_ = "svg";

//	expected/defined by bootstrap1.js
dojo.hostenv.setModulePrefix = function(module, prefix){ };
dojo.hostenv.getModulePrefix = function(module){ };
dojo.hostenv.getTextStack = [];
dojo.hostenv.loadUriStack = [];
dojo.hostenv.loadedUris = [];
dojo.hostenv.modules_ = {};
dojo.hostenv.modulesLoadedFired = false;
dojo.hostenv.modulesLoadedListeners = [];
dojo.hostenv.getText = function(uri, cb, data){ 
	if (!cb) var cb = function(result){ window.alert(result); };
	if (!data) {
		window.getUrl(uri, cb);
	} else {
		window.postUrl(uri, data, cb);
	}
};
dojo.hostenv.getLibaryScriptUri = function(){ };

dojo.hostenv.loadUri = function(uri){ };
dojo.hostenv.loadUriAndCheck = function(uri, module){ };

//	aliased in loader.js, don't ignore
//	we are going to kill loadModule for the first round of SVG stuff, and include shit manually.
dojo.hostenv.loadModule = function(moduleName){
	//	just like startPackage, but this time we're just checking to make sure it exists already.
	var a = moduleName.split(".");
	var currentObj = window;
	var s = [];
	for (var i = 0; i < a.length; i++){
		if (a[i] == "*") continue;
		s.push(a[i]);
		if (!currentObj[a[i]]){
			dojo.raise("dojo.require('" + moduleName + "'): module does not exist.");
		} else currentObj = currentObj[a[i]];
	}
	return; 
};
dojo.hostenv.startPackage = function(moduleName){
	var a = moduleName.split(".");
	var currentObj = window;
	var s = [];
	for (var i = 0; i < a.length; i++){
		if (a[i] == "*") continue;
		s.push(a[i]);
		if (!currentObj[a[i]]) currentObj[a[i]] = {};
		currentObj = currentObj[a[i]];
	}
	return; 
};

//	wrapper objects for ASVG
if (window.parseXML){
	window.XMLSerialzer = function(){
		//	based on WebFX RichTextControl getXHTML() function.
		function nodeToString(n, a) {
			function fixText(s) { return String(s).replace(/\&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;"); }
			function fixAttribute(s) { return fixText(s).replace(/\"/g, "&quot;"); }
			switch (n.nodeType) {
				case 1:	{	//	ELEMENT
					var name = n.nodeName;
					a.push("<" + name);
					for (var i = 0; i < n.attributes.length; i++) {
						if (n.attributes.item(i).specified) {
							a.push(" " + n.attributes.item(i).nodeName.toLowerCase() + "=\"" + fixAttribute(n.attributes.item(i).nodeValue) + "\"");
						}
					}
					if (n.canHaveChildren || n.hasChildNodes()) {
						a.push(">");
						for (var i = 0; i < n.childNodes.length; i++) nodeToString(n.childNodes.item(i), a);
						a.push("</" + name + ">\n");
					} else a.push(" />\n");
					break;
				}
				case 3: {	//	TEXT
					a.push(fixText(n.nodeValue));
					break;
				}
				case 4: {	//	CDATA
					a.push("<![CDA" + "TA[\n" + n.nodeValue + "\n]" + "]>");
					break;
				}
				case 7:{	//	PROCESSING INSTRUCTION
					a.push(n.nodeValue);
					if (/(^<\?xml)|(^<\!DOCTYPE)/.test(n.nodeValue)) a.push("\n");
					break;
				}
				case 8:{	//	COMMENT
					a.push("<!-- " + n.nodeValue + " -->\n");
					break;
				}
				case 9:		//	DOCUMENT
				case 11:{	//	DOCUMENT FRAGMENT
					for (var i = 0; i < n.childNodes.length; i++) nodeToString(n.childNodes.item(i), a);
					break;
				}
				default:{
					a.push("<!--\nNot Supported:\n\n" + "nodeType: " + n.nodeType + "\nnodeName: " + n.nodeName + "\n-->");
				}
			}
		}
		this.serializeToString = function(node){
			var a = [];
			nodeToString(node, a);
			return a.join("");
		};
	};

	window.DOMParser = function(){
		//	mimetype is basically ignored
		this.parseFromString = function(s){
			return parseXML(s, window.document);
		}
	};

	window.XMLHttpRequest = function(){
		//	we ignore the setting and getting of content-type.
		var uri = null;
		var method = "POST";
		var isAsync = true;	
		var cb = function(d){
			this.responseText = d.content;
			try {
				this.responseXML = parseXML(this.responseText, window.document);
			} catch(e){}
			this.status = "200";
			this.statusText = "OK";
			if (!d.success) {
				this.status = "500";
				this.statusText = "Internal Server Error";
			}
			this.onload();
			this.onreadystatechange();
		};
		this.onload = function(){};
		this.readyState = 4;
		this.onreadystatechange = function(){};
		this.status = 0;
		this.statusText = "";
		this.responseBody = null;
		this.responseStream = null;
		this.responseXML = null;
		this.responseText = null;
		this.abort = function(){ return; };
		this.getAllResponseHeaders = function(){ return []; };
		this.getResponseHeader = function(n){ return null; };
		this.setRequestHeader = function(nm, val){ };
		this.open = function(meth, url, async){ 
			method = meth;
			uri = url;
		};
		this.send = function(data){
			var d = data || null;
			if (method == "GET") getURL(uri, cb);
			else postURL(uri, data, cb);
		};
	};
}

__CPAN_FILE__ src/hostenv_wsh.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*
 * WSH
 */

dojo.hostenv.name_ = 'wsh';

// make jsc shut up (so can sanity check)
/*@cc_on
@if (@_jscript_version >= 7)
var WScript;
@end
@*/

// make sure we are in right environment
if(typeof WScript == 'undefined'){
	dojo.raise("attempt to use WSH host environment when no WScript global");
}

dojo.hostenv.println = WScript.Echo;

dojo.hostenv.getCurrentScriptUri = function(){
	return WScript.ScriptFullName();
}

dojo.hostenv.getText = function(fpath){
	var fso = new ActiveXObject("Scripting.FileSystemObject");
	var istream = fso.OpenTextFile(fpath, 1); // iomode==1 means read only
	if(!istream){
		return null;
	}
	var contents = istream.ReadAll();
	istream.Close();
	return contents;
}

dojo.hostenv.exit = function(exitcode){ WScript.Quit(exitcode); }

__CPAN_FILE__ src/html.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.html");

dojo.require("dojo.lang.func");
dojo.require("dojo.dom");
dojo.require("dojo.style");
dojo.require("dojo.string");

dojo.lang.mixin(dojo.html, dojo.dom);
dojo.lang.mixin(dojo.html, dojo.style);

// FIXME: we are going to assume that we can throw any and every rendering
// engine into the IE 5.x box model. In Mozilla, we do this w/ CSS.
// Need to investigate for KHTML and Opera

dojo.html.clearSelection = function(){
	try{
		if(window["getSelection"]){ 
			if(dojo.render.html.safari){
				// pulled from WebCore/ecma/kjs_window.cpp, line 2536
				window.getSelection().collapse();
			}else{
				window.getSelection().removeAllRanges();
			}
		}else if(document.selection){
			if(document.selection.empty){
				document.selection.empty();
			}else if(document.selection.clear){
				document.selection.clear();
			}
		}
		return true;
	}catch(e){
		dojo.debug(e);
		return false;
	}
}

dojo.html.disableSelection = function(element){
	element = dojo.byId(element)||document.body;
	var h = dojo.render.html;
	
	if(h.mozilla){
		element.style.MozUserSelect = "none";
	}else if(h.safari){
		element.style.KhtmlUserSelect = "none"; 
	}else if(h.ie){
		element.unselectable = "on";
	}else{
		return false;
	}
	return true;
}

dojo.html.enableSelection = function(element){
	element = dojo.byId(element)||document.body;
	
	var h = dojo.render.html;
	if(h.mozilla){ 
		element.style.MozUserSelect = ""; 
	}else if(h.safari){
		element.style.KhtmlUserSelect = "";
	}else if(h.ie){
		element.unselectable = "off";
	}else{
		return false;
	}
	return true;
}

dojo.html.selectElement = function(element){
	element = dojo.byId(element);
	if(document.selection && document.body.createTextRange){ // IE
		var range = document.body.createTextRange();
		range.moveToElementText(element);
		range.select();
	}else if(window["getSelection"]){
		var selection = window.getSelection();
		// FIXME: does this work on Safari?
		if(selection["selectAllChildren"]){ // Mozilla
			selection.selectAllChildren(element);
		}
	}
}

dojo.html.selectInputText = function(element){
	element = dojo.byId(element);
	if(document.selection && document.body.createTextRange){ // IE
		var range = element.createTextRange();
		range.moveStart("character", 0);
		range.moveEnd("character", element.value.length);
		range.select();
	}else if(window["getSelection"]){
		var selection = window.getSelection();
		// FIXME: does this work on Safari?
		element.setSelectionRange(0, element.value.length);
	}
	element.focus();
}


dojo.html.isSelectionCollapsed = function(){
	if(document["selection"]){ // IE
		return document.selection.createRange().text == "";
	}else if(window["getSelection"]){
		var selection = window.getSelection();
		if(dojo.lang.isString(selection)){ // Safari
			return selection == "";
		}else{ // Mozilla/W3
			return selection.isCollapsed;
		}
	}
}

dojo.html.getEventTarget = function(evt){
	if(!evt) { evt = window.event || {} };
	var t = (evt.srcElement ? evt.srcElement : (evt.target ? evt.target : null));
	while((t)&&(t.nodeType!=1)){ t = t.parentNode; }
	return t;
}

dojo.html.getDocumentWidth = function(){
	dojo.deprecated("dojo.html.getDocument* has been deprecated in favor of dojo.html.getViewport*");
	return dojo.html.getViewportWidth();
}

dojo.html.getDocumentHeight = function(){
	dojo.deprecated("dojo.html.getDocument* has been deprecated in favor of dojo.html.getViewport*");
	return dojo.html.getViewportHeight();
}

dojo.html.getDocumentSize = function(){
	dojo.deprecated("dojo.html.getDocument* has been deprecated in favor of dojo.html.getViewport*");
	return dojo.html.getViewportSize();
}

dojo.html.getViewportWidth = function(){
	var w = 0;

	if(window.innerWidth){
		w = window.innerWidth;
	}

	if(dojo.exists(document, "documentElement.clientWidth")){
		// IE6 Strict
		var w2 = document.documentElement.clientWidth;
		// this lets us account for scrollbars
		if(!w || w2 && w2 < w) {
			w = w2;
		}
		return w;
	}

	if(document.body){
		// IE
		return document.body.clientWidth;
	}

	return 0;
}

dojo.html.getViewportHeight = function(){
	if (window.innerHeight){
		return window.innerHeight;
	}

	if (dojo.exists(document, "documentElement.clientHeight")){
		// IE6 Strict
		return document.documentElement.clientHeight;
	}

	if (document.body){
		// IE
		return document.body.clientHeight;
	}

	return 0;
}

dojo.html.getViewportSize = function(){
	var ret = [dojo.html.getViewportWidth(), dojo.html.getViewportHeight()];
	ret.w = ret[0];
	ret.h = ret[1];
	return ret;
}

dojo.html.getScrollTop = function(){
	return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
}

dojo.html.getScrollLeft = function(){
	return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
}

dojo.html.getScrollOffset = function(){
	var off = [dojo.html.getScrollLeft(), dojo.html.getScrollTop()];
	off.x = off[0];
	off.y = off[1];
	return off;
}

dojo.html.getParentOfType = function(node, type){
	dojo.deprecated("dojo.html.getParentOfType has been deprecated in favor of dojo.html.getParentByType*");
	return dojo.html.getParentByType(node, type);
}

dojo.html.getParentByType = function(node, type) {
	var parent = dojo.byId(node);
	type = type.toLowerCase();
	while((parent)&&(parent.nodeName.toLowerCase()!=type)){
		if(parent==(document["body"]||document["documentElement"])){
			return null;
		}
		parent = parent.parentNode;
	}
	return parent;
}

// RAR: this function comes from nwidgets and is more-or-less unmodified.
// We should probably look ant Burst and f(m)'s equivalents
dojo.html.getAttribute = function(node, attr){
	node = dojo.byId(node);
	// FIXME: need to add support for attr-specific accessors
	if((!node)||(!node.getAttribute)){
		// if(attr !== 'nwType'){
		//	alert("getAttr of '" + attr + "' with bad node"); 
		// }
		return null;
	}
	var ta = typeof attr == 'string' ? attr : new String(attr);

	// first try the approach most likely to succeed
	var v = node.getAttribute(ta.toUpperCase());
	if((v)&&(typeof v == 'string')&&(v!="")){ return v; }

	// try returning the attributes value, if we couldn't get it as a string
	if(v && v.value){ return v.value; }

	// this should work on Opera 7, but it's a little on the crashy side
	if((node.getAttributeNode)&&(node.getAttributeNode(ta))){
		return (node.getAttributeNode(ta)).value;
	}else if(node.getAttribute(ta)){
		return node.getAttribute(ta);
	}else if(node.getAttribute(ta.toLowerCase())){
		return node.getAttribute(ta.toLowerCase());
	}
	return null;
}
	
/**
 *	Determines whether or not the specified node carries a value for the
 *	attribute in question.
 */
dojo.html.hasAttribute = function(node, attr){
	node = dojo.byId(node);
	return dojo.html.getAttribute(node, attr) ? true : false;
}
	
/**
 * Returns the string value of the list of CSS classes currently assigned
 * directly to the node in question. Returns an empty string if no class attribute
 * is found;
 */
dojo.html.getClass = function(node){
	node = dojo.byId(node);
	if(!node){ return ""; }
	var cs = "";
	if(node.className){
		cs = node.className;
	}else if(dojo.html.hasAttribute(node, "class")){
		cs = dojo.html.getAttribute(node, "class");
	}
	return dojo.string.trim(cs);
}

/**
 * Returns an array of CSS classes currently assigned
 * directly to the node in question. Returns an empty array if no classes
 * are found;
 */
dojo.html.getClasses = function(node) {
	var c = dojo.html.getClass(node);
	return (c == "") ? [] : c.split(/\s+/g);
}

/**
 * Returns whether or not the specified classname is a portion of the
 * class list currently applied to the node. Does not cover cascaded
 * styles, only classes directly applied to the node.
 */
dojo.html.hasClass = function(node, classname){
	return dojo.lang.inArray(dojo.html.getClasses(node), classname);
}

/**
 * Adds the specified class to the beginning of the class list on the
 * passed node. This gives the specified class the highest precidence
 * when style cascading is calculated for the node. Returns true or
 * false; indicating success or failure of the operation, respectively.
 */
dojo.html.prependClass = function(node, classStr){
	classStr += " " + dojo.html.getClass(node);
	return dojo.html.setClass(node, classStr);
}

/**
 * Adds the specified class to the end of the class list on the
 *	passed &node;. Returns &true; or &false; indicating success or failure.
 */
dojo.html.addClass = function(node, classStr){
	if (dojo.html.hasClass(node, classStr)) {
	  return false;
	}
	classStr = dojo.string.trim(dojo.html.getClass(node) + " " + classStr);
	return dojo.html.setClass(node, classStr);
}

/**
 *	Clobbers the existing list of classes for the node, replacing it with
 *	the list given in the 2nd argument. Returns true or false
 *	indicating success or failure.
 */
dojo.html.setClass = function(node, classStr){
	node = dojo.byId(node);
	var cs = new String(classStr);
	try{
		if(typeof node.className == "string"){
			node.className = cs;
		}else if(node.setAttribute){
			node.setAttribute("class", classStr);
			node.className = cs;
		}else{
			return false;
		}
	}catch(e){
		dojo.debug("dojo.html.setClass() failed", e);
	}
	return true;
}

/**
 * Removes the className from the node;. Returns
 * true or false indicating success or failure.
 */ 
dojo.html.removeClass = function(node, classStr, allowPartialMatches){
	var classStr = dojo.string.trim(new String(classStr));

	try{
		var cs = dojo.html.getClasses(node);
		var nca	= [];
		if(allowPartialMatches){
			for(var i = 0; i<cs.length; i++){
				if(cs[i].indexOf(classStr) == -1){ 
					nca.push(cs[i]);
				}
			}
		}else{
			for(var i=0; i<cs.length; i++){
				if(cs[i] != classStr){ 
					nca.push(cs[i]);
				}
			}
		}
		dojo.html.setClass(node, nca.join(" "));
	}catch(e){
		dojo.debug("dojo.html.removeClass() failed", e);
	}

	return true;
}

/**
 * Replaces 'oldClass' and adds 'newClass' to node
 */
dojo.html.replaceClass = function(node, newClass, oldClass) {
	dojo.html.removeClass(node, oldClass);
	dojo.html.addClass(node, newClass);
}

// Enum type for getElementsByClass classMatchType arg:
dojo.html.classMatchType = {
	ContainsAll : 0, // all of the classes are part of the node's class (default)
	ContainsAny : 1, // any of the classes are part of the node's class
	IsOnly : 2 // only all of the classes are part of the node's class
}


/**
 * Returns an array of nodes for the given classStr, children of a
 * parent, and optionally of a certain nodeType
 */
dojo.html.getElementsByClass = function(classStr, parent, nodeType, classMatchType){
	parent = dojo.byId(parent) || document;
	var classes = classStr.split(/\s+/g);
	var nodes = [];
	if( classMatchType != 1 && classMatchType != 2 ) classMatchType = 0; // make it enum
	var reClass = new RegExp("(\\s|^)((" + classes.join(")|(") + "))(\\s|$)");

	// FIXME: doesn't have correct parent support!
	if(!nodeType){ nodeType = "*"; }
	var candidateNodes = parent.getElementsByTagName(nodeType);

	var node, i = 0;
	outer:
	while (node = candidateNodes[i++]) {
		var nodeClasses = dojo.html.getClasses(node);
		if(nodeClasses.length == 0) { continue outer; }
		var matches = 0;

		for(var j = 0; j < nodeClasses.length; j++) {
			if( reClass.test(nodeClasses[j]) ) {
				if( classMatchType == dojo.html.classMatchType.ContainsAny ) {
					nodes.push(node);
					continue outer;
				} else {
					matches++;
				}
			} else {
				if( classMatchType == dojo.html.classMatchType.IsOnly ) {
					continue outer;
				}
			}
		}

		if( matches == classes.length ) {
			if( classMatchType == dojo.html.classMatchType.IsOnly && matches == nodeClasses.length ) {
				nodes.push(node);
			} else if( classMatchType == dojo.html.classMatchType.ContainsAll ) {
				nodes.push(node);
			}
		}
	}
	
	return nodes;
}

dojo.html.getElementsByClassName = dojo.html.getElementsByClass;

/**
 * Returns the mouse position relative to the document (not the viewport).
 * For example, if you have a document that is 10000px tall,
 * but your browser window is only 100px tall,
 * if you scroll to the bottom of the document and call this function it
 * will return {x: 0, y: 10000}
 */
dojo.html.getCursorPosition = function(e){
	e = e || window.event;
	var cursor = {x:0, y:0};
	if(e.pageX || e.pageY){
		cursor.x = e.pageX;
		cursor.y = e.pageY;
	}else{
		var de = document.documentElement;
		var db = document.body;
		cursor.x = e.clientX + ((de||db)["scrollLeft"]) - ((de||db)["clientLeft"]);
		cursor.y = e.clientY + ((de||db)["scrollTop"]) - ((de||db)["clientTop"]);
	}
	return cursor;
}

dojo.html.overElement = function(element, e){
	element = dojo.byId(element);
	var mouse = dojo.html.getCursorPosition(e);

	with(dojo.html){
		var top = getAbsoluteY(element, true);
		var bottom = top + getInnerHeight(element);
		var left = getAbsoluteX(element, true);
		var right = left + getInnerWidth(element);
	}
	
	return (mouse.x >= left && mouse.x <= right &&
		mouse.y >= top && mouse.y <= bottom);
}

dojo.html.setActiveStyleSheet = function(title){
	var i = 0, a, els = document.getElementsByTagName("link");
	while (a = els[i++]) {
		if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")){
			a.disabled = true;
			if (a.getAttribute("title") == title) { a.disabled = false; }
		}
	}
}

dojo.html.getActiveStyleSheet = function(){
	var i = 0, a, els = document.getElementsByTagName("link");
	while (a = els[i++]) {
		if (a.getAttribute("rel").indexOf("style") != -1 &&
			a.getAttribute("title") && !a.disabled) { return a.getAttribute("title"); }
	}
	return null;
}

dojo.html.getPreferredStyleSheet = function(){
	var i = 0, a, els = document.getElementsByTagName("link");
	while (a = els[i++]) {
		if(a.getAttribute("rel").indexOf("style") != -1
			&& a.getAttribute("rel").indexOf("alt") == -1
			&& a.getAttribute("title")) { return a.getAttribute("title"); }
	}
	return null;
}

dojo.html.body = function(){
	dojo.deprecated("dojo.html.body", "use document.body instead");
	return document.body || document.getElementsByTagName("body")[0];
}

/**
 * Like dojo.dom.isTag, except case-insensitive
**/
dojo.html.isTag = function(node /* ... */) {
	node = dojo.byId(node);
	if(node && node.tagName) {
		var arr = dojo.lang.map(dojo.lang.toArray(arguments, 1),
			function(a) { return String(a).toLowerCase(); });
		return arr[ dojo.lang.find(node.tagName.toLowerCase(), arr) ] || "";
	}
	return "";
}

dojo.html._callExtrasDeprecated = function(inFunc, args) {
	var module = "dojo.html.extras";
	dojo.deprecated("dojo.html." + inFunc + " has been moved to " + module);
	dojo["require"](module); // weird syntax to fool list-profile-deps (build)
	return dojo.html[inFunc].apply(dojo.html, args);
}

dojo.html.createNodesFromText = function() {
	return dojo.html._callExtrasDeprecated('createNodesFromText', arguments);
}

dojo.html.gravity = function() {
	return dojo.html._callExtrasDeprecated('gravity', arguments);
}

dojo.html.placeOnScreen = function() {
	return dojo.html._callExtrasDeprecated('placeOnScreen', arguments);
}

dojo.html.placeOnScreenPoint = function() {
	return dojo.html._callExtrasDeprecated('placeOnScreenPoint', arguments);
}

dojo.html.renderedTextContent = function() {
	return dojo.html._callExtrasDeprecated('renderedTextContent', arguments);
}

dojo.html.BackgroundIframe = function() {
	return dojo.html._callExtrasDeprecated('BackgroundIframe', arguments);
}

__CPAN_FILE__ src/iCalendar.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.iCalendar");
dojo.require("dojo.text.textDirectory");
dojo.require("dojo.date");
dojo.require("dojo.lang");


dojo.iCalendar.fromText =  function (/* string */text) {
	// summary
	// Parse text of an iCalendar and return an array of iCalendar objects

	var properties = dojo.textDirectoryTokeniser.tokenise(text);
	var calendars = [];

	//dojo.debug("Parsing iCal String");
	for (var i = 0, begun = false; i < properties.length; i++) {
		var prop = properties[i];
		if (!begun) {
			if (prop.name == 'BEGIN' && prop.value == 'VCALENDAR') {
				begun = true;
				var calbody = [];
			}
		} else if (prop.name == 'END' && prop.value == 'VCALENDAR') {
			calendars.push(new dojo.iCalendar.VCalendar(calbody));
			begun = false;
		} else {
			calbody.push(prop);
		}
	}
	return /* array */calendars;
}


dojo.iCalendar.Component = function (/* string */ body ) {
	// summary
	// A component is the basic container of all this stuff. 

	if (!this.name) {
		this.name = "COMPONENT"
	}

	this.properties = [];
	this.components = [];

	if (body) {
		for (var i = 0, context = ''; i < body.length; i++) {
			if (context == '') {
				if (body[i].name == 'BEGIN') {
					context = body[i].value;
					var childprops = [];
				} else {
					this.addProperty(new dojo.iCalendar.Property(body[i]));
				}
			} else if (body[i].name == 'END' && body[i].value == context) {
				if (context=="VEVENT") {
					this.addComponent(new dojo.iCalendar.VEvent(childprops));
				} else if (context=="VTIMEZONE") {
					this.addComponent(new dojo.iCalendar.VTimeZone(childprops));
				} else if (context=="VTODO") {
					this.addComponent(new dojo.iCalendar.VTodo(childprops));
				} else if (context=="VJOURNAL") {
					this.addComponent(new dojo.iCalendar.VJournal(childprops));
				} else if (context=="VFREEBUSY") {
					this.addComponent(new dojo.iCalendar.VFreeBusy(childprops));
				} else if (context=="STANDARD") {
					this.addComponent(new dojo.iCalendar.Standard(childprops));
				} else if (context=="DAYLIGHT") {
					this.addComponent(new dojo.iCalendar.Daylight(childprops));
				} else if (context=="VALARM") {
					this.addComponent(new dojo.iCalendar.VAlarm(childprops));
				}else {
					dojo.unimplemented("dojo.iCalendar." + context);
				}
				context = '';
			} else {
				childprops.push(body[i]);
			}
		}

		if (this._ValidProperties) {
			this.postCreate();
		}
	}
}

dojo.lang.extend(dojo.iCalendar.Component, {

	addProperty: function (prop) {
		// summary
		// push a new property onto a component.
		this.properties.push(prop);
		this[prop.name.toLowerCase()] = prop;
	},

	addComponent: function (prop) {
		// summary
		// add a component to this components list of children.
		this.components.push(prop);
	},

	postCreate: function() {
		for (var x=0; x<this._ValidProperties.length; x++) {
			var evtProperty = this._ValidProperties[x];
			var found = false;
	
			for (var y=0; y<this.properties.length; y++) {	
				var prop = this.properties[y];
				propName = prop.name.toLowerCase();
				if (dojo.lang.isArray(evtProperty)) {

					var alreadySet = false;
					for (var z=0; z<evtProperty.length; z++) {
						var evtPropertyName = evtProperty[z].name.toLowerCase();
						if((this[evtPropertyName])  && (evtPropertyName != propName )) {
							alreadySet=true;
						} 
					}
					if (!alreadySet) {
						this[propName] = prop;
					}
				} else {
					if (propName == evtProperty.name.toLowerCase()) {
						found = true;
						if (evtProperty.occurance == 1){
							this[propName] = prop;
						} else {
							found = true;
							if (!dojo.lang.isArray(this[propName])) {
							 	this[propName] = [];
							}
							this[propName].push(prop);
						}
					}
				}
			}

			if (evtProperty.required && !found) {	
				dojo.debug("iCalendar - " + this.name + ": Required Property not found: " + evtProperty.name);
			}
		}

		// parse any rrules		
		if (dojo.lang.isArray(this.rrule)) {
			for(var x=0; x<this.rrule.length; x++) {
				var rule = this.rrule[x].value;

				//add a place to cache dates we have checked for recurrance
				this.rrule[x].cache = function() {};
				
				var temp = rule.split(";");
				for (var y=0; y<temp.length; y++) {
					var pair = temp[y].split("=");
					var key = pair[0].toLowerCase();
					var val = pair[1];

					if ((key == "freq") || (key=="interval") || (key=="until")) {
						this.rrule[x][key]= val;
					} else {
						var valArray = val.split(",");
						this.rrule[x][key] = valArray; 
					}
				}	
			}
			this.recurring = true;
		}

	}, 

	toString: function () {
		// summary
		// output a string representation of this component.
		return "[iCalendar.Component; " + this.name + ", " + this.properties.length +
			" properties, " + this.components.length + " components]";
	}
});

dojo.iCalendar.Property = function (prop) {
	// summary
	// A single property of a component.

	// unpack the values
	this.name = prop.name;
	this.group = prop.group;
	this.params = prop.params;
	this.value = prop.value;

}

dojo.lang.extend(dojo.iCalendar.Property, {
	toString: function () {	
		// summary
		// output a string reprensentation of this component.
		return "[iCalenday.Property; " + this.name + ": " + this.value + "]";
	}
});

// This is just a little helper function for the Component Properties
var _P = function (n, oc, req) {
	return {name: n, required: (req) ? true : false,
		occurance: (oc == '*' || !oc) ? -1 : oc}
}

/*
 * VCALENDAR
 */

dojo.iCalendar.VCalendar = function (/* string */ calbody) {
	// summary
	// VCALENDAR Component

	this.name = "VCALENDAR";
	this.recurring = [];
	this.nonRecurringEvents = function(){};
	dojo.iCalendar.Component.call(this, calbody);
}

dojo.inherits(dojo.iCalendar.VCalendar, dojo.iCalendar.Component);

dojo.lang.extend(dojo.iCalendar.VCalendar, {

	addComponent: function (prop) {
		// summary
		// add component to the calenadar that makes it easy to pull them out again later.
		this.components.push(prop);
		if (prop.name.toLowerCase() == "vevent") {
			if (prop.rrule) {
				this.recurring.push(prop);
			} else {
				startDate = prop.getDate();
				month = startDate.getMonth() + 1;
				dateString= month + "-" + startDate.getDate() + "-" + startDate.getFullYear();
				if (!dojo.lang.isArray(this[dateString])) {
					this.nonRecurringEvents[dateString] = [];
				}
				this.nonRecurringEvents[dateString].push(prop);
			}
		}
	},

	preComputeRecurringEvents: function(until) {
		var calculatedEvents = function(){};

		for(var x=0; x<this.recurring.length; x++) {
			var dates = this.recurring[x].getDates(until);
			for (var y=0; y<dates.length;y++) {
				month = dates[y].getMonth() + 1;
				dateStr = month + "-" + dates[y].getDate() + "-" + dates[y].getFullYear();
				if (!dojo.lang.isArray(calculatedEvents[dateStr])) {
					calculatedEvents[dateStr] = [];
				}

				if (!dojo.lang.inArray(calculatedEvents[dateStr], this.recurring[x])) { 
					calculatedEvents[dateStr].push(this.recurring[x]);
				} 
			}
		}
		this.recurringEvents = calculatedEvents;
	
	},

	getEvents: function(/* Date */ date) {
		// summary
		// Gets all events occuring on a particular date
		var events = [];
		var recur = [];
		var nonRecur = [];
		month = date.getMonth() + 1;
		var dateStr= month + "-" + date.getDate() + "-" + date.getFullYear();
		if (dojo.lang.isArray(this.nonRecurringEvents[dateStr])) {
			nonRecur= this.nonRecurringEvents[dateStr];
			dojo.debug("Number of nonRecurring Events: " + nonRecur.length);
		} 
		

		if (dojo.lang.isArray(this.recurringEvents[dateStr])) {
			recur= this.recurringEvents[dateStr];
		} 

		events = recur.concat(nonRecur);

		if (events.length > 0) {
			return events;
		} 

		return null;			
	}
});

/*
 * STANDARD
 */

var StandardProperties = [
	_P("dtstart", 1, true), _P("tzoffsetto", 1, true), _P("tzoffsetfrom", 1, true),
	_P("comment"), _P("rdate"), _P("rrule"), _P("tzname")
];


dojo.iCalendar.Standard = function (/* string */ body) {
	// summary
	// STANDARD Component

	this.name = "STANDARD";
	this._ValidProperties = StandardProperties;
	dojo.iCalendar.Component.call(this, body);
}

dojo.inherits(dojo.iCalendar.Standard, dojo.iCalendar.Component);

/*
 * DAYLIGHT
 */

var DaylightProperties = [
	_P("dtstart", 1, true), _P("tzoffsetto", 1, true), _P("tzoffsetfrom", 1, true),
	_P("comment"), _P("rdate"), _P("rrule"), _P("tzname")
];

dojo.iCalendar.Daylight = function (/* string */ body) {
	// summary
	// Daylight Component
	this.name = "DAYLIGHT";
	this._ValidProperties = DaylightProperties;
	dojo.iCalendar.Component.call(this, body);
}

dojo.inherits(dojo.iCalendar.Daylight, dojo.iCalendar.Component);

/*
 * VEVENT
 */

var VEventProperties = [
	// these can occur once only
	_P("class", 1), _P("created", 1), _P("description", 1), _P("dtstart", 1),
	_P("geo", 1), _P("last-mod", 1), _P("location", 1), _P("organizer", 1),
	_P("priority", 1), _P("dtstamp", 1), _P("seq", 1), _P("status", 1),
	_P("summary", 1), _P("transp", 1), _P("uid", 1), _P("url", 1), _P("recurid", 1),
	// these two are exclusive
	[_P("dtend", 1), _P("duration", 1)],
	// these can occur many times over
	_P("attach"), _P("attendee"), _P("categories"), _P("comment"), _P("contact"),
	_P("exdate"), _P("exrule"), _P("rstatus"), _P("related"), _P("resources"),
	_P("rdate"), _P("rrule")
];

dojo.iCalendar.VEvent = function (/* string */ body) {
	// summary 
	// VEVENT Component
	this._ValidProperties = VEventProperties;
	this.name = "VEVENT";
	dojo.iCalendar.Component.call(this, body);
	this.recurring = false;
	this.startDate = dojo.date.fromIso8601(this.dtstart.value);
}

dojo.inherits(dojo.iCalendar.VEvent, dojo.iCalendar.Component);

dojo.lang.extend(dojo.iCalendar.VEvent, {
		getDates: function(until) {
			var dtstart = this.getDate();

			var recurranceSet = [];
			var weekdays=["su","mo","tu","we","th","fr","sa"];
			var order = { 
				"daily": 1, "weekly": 2, "monthly": 3, "yearly": 4,
				"byday": 1, "bymonthday": 1, "byweekno": 2, "bymonth": 3, "byyearday": 4};

			// expand rrules into the recurrance 
			for (var x=0; x<this.rrule.length; x++) {
				var rrule = this.rrule[x];
				var freq = rrule.freq.toLowerCase();
				var interval = 1;

				if (rrule.interval > interval) {
					interval = rrule.interval;
				}

				var set = [];
				var freqInt = order[freq];

				if (rrule.until) {
					tmpUntil = dojo.date.fromIso8601(rrule.until);
				} else {
					tmpUntil = until
				}

				if (tmpUntil > until) {
					tmpUntil = until
				}


				if (dtstart<tmpUntil) {

					var expandingRules = function(){};
					var cullingRules = function(){};
					expandingRules.length=0;
					cullingRules.length =0;

					switch(freq) {
						case "yearly":
							nextDate = new Date(dtstart);
							set.push(nextDate);
							while(nextDate < tmpUntil) {
								nextDate.setYear(nextDate.getFullYear()+interval);
								tmpDate = new Date(nextDate);
								if(tmpDate < tmpUntil) {
									set.push(tmpDate);
								}
							}
							break;
						case "monthly":
							nextDate = new Date(dtstart);
							set.push(nextDate);
							while(nextDate < tmpUntil) {
								nextDate.setMonth(nextDate.getMonth()+interval);
								var tmpDate = new Date(nextDate);
								if (tmpDate < tmpUntil) {
									set.push(tmpDate);
								}
							}
							break;
						case "weekly":
							nextDate = new Date(dtstart);
							set.push(nextDate);
							while(nextDate < tmpUntil) {
								nextDate.setDate(nextDate.getDate()+(7*interval));
								var tmpDate = new Date(nextDate);
								if (tmpDate < tmpUntil) {
									set.push(tmpDate);
								}
							}
							break;	
						case "daily":
							nextDate = new Date(dtstart);
							set.push(nextDate);
							while(nextDate < tmpUntil) {
								nextDate.setDate(nextDate.getDate()+interval);
								var tmpDate = new Date(nextDate);
								if (tmpDate < tmpUntil) {
									set.push(tmpDate);
								}
							}
							break;
	
					}

					if ((rrule["bymonth"]) && (order["bymonth"]<freqInt))	{
						for (var z=0; z<rrule["bymonth"].length; z++) {
							if (z==0) {
								for (var zz=0; zz < set.length; zz++) {
									set[zz].setMonth(rrule["bymonth"][z]-1);
								}
							} else {
								var subset=[];
								for (var zz=0; zz < set.length; zz++) {
									var newDate = new Date(set[zz]);
									newDate.setMonth(rrule[z]);
									subset.push(newDate);
								}
								tmp = set.concat(subset);
								set = tmp;
							}
						}
					}

					
					// while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time
					// and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web
					if (rrule["byweekno"] && !rrule["bymonth"]) {	
						dojo.debug("TODO: no support for byweekno yet");
					}


					// while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time
					// and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web
					if (rrule["byyearday"] && !rrule["bymonth"] && !rrule["byweekno"] ) {	
						if (rrule["byyearday"].length > 1) {
							var regex = "([+-]?)([0-9]{1,3})";
							for (var z=1; x<rrule["byyearday"].length; z++) {
								var regexResult = rrule["byyearday"][z].match(regex);
								if (z==1) {
									for (var zz=0; zz < set.length; zz++) {
										if (regexResult[1] == "-") {
											dojo.date.setDayOfYear(set[zz],366-regexResult[2]);
										} else {
											dojo.date.setDayOfYear(set[zz],regexResult[2]);
										}
									}
								}	else {
									var subset=[];
									for (var zz=0; zz < set.length; zz++) {
										var newDate = new Date(set[zz]);
										if (regexResult[1] == "-") {
											dojo.date.setDayOfYear(newDate,366-regexResult[2]);
										} else {
											dojo.date.setDayOfYear(newDate,regexResult[2]);
										}
										subset.push(newDate);
									}
									tmp = set.concat(subset);
									set = tmp;
								}
							}
						}
					}

					if (rrule["bymonthday"]  && (order["bymonthday"]<freqInt)) {	
						if (rrule["bymonthday"].length > 0) {
							var regex = "([+-]?)([0-9]{1,3})";
							for (var z=0; z<rrule["bymonthday"].length; z++) {
								var regexResult = rrule["bymonthday"][z].match(regex);
								if (z==0) {
									for (var zz=0; zz < set.length; zz++) {
										if (regexResult[1] == "-") {
											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
												set[zz].setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
											}
										} else {
											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
												set[zz].setDate(regexResult[2]);
											}
										}
									}
								}	else {
									var subset=[];
									for (var zz=0; zz < set.length; zz++) {
										var newDate = new Date(set[zz]);
										if (regexResult[1] == "-") {
											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
												newDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
											}
										} else {
											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
												newDate.setDate(regexResult[2]);
											}
										}
										subset.push(newDate);
									}
									tmp = set.concat(subset);
									set = tmp;
								}
							}
						}
					}

					if (rrule["byday"]  && (order["byday"]<freqInt)) {	
						if (rrule["bymonth"]) {
							if (rrule["byday"].length > 0) {
								var regex = "([+-]?)([0-9]{0,1}?)([A-Za-z]{1,2})";
								for (var z=0; z<rrule["byday"].length; z++) {
									var regexResult = rrule["byday"][z].match(regex);
									var occurance = regexResult[2];
									day = regexResult[3].toLowerCase();


									if (z==0) {
										for (var zz=0; zz < set.length; zz++) {
											if (regexResult[1] == "-") {
												//find the nth to last occurance of date 
												var numDaysFound = 0;
												var lastDayOfMonth = dojo.date.getDaysInMonth(set[zz]);
												daysToSubtract = 1;
												set[zz].setDate(lastDayOfMonth); 
												if (weekdays[set[zz].getDay()] == day) {
													numDaysFound++;
													daysToSubtract=7;
												}
												daysToSubtract = 1;
												while (numDaysFound < occurance) {
													set[zz].setDate(set[zz].getDate()-daysToSubtract);	
													if (weekdays[set[zz].getDay()] == day) {
														numDaysFound++;
														daysToSubtract=7;	
													}
												}
											} else {
												if (occurance) {
													var numDaysFound=0;
													set[zz].setDate(1);
													daysToAdd=1;

													if(weekdays[set[zz].getDay()] == day) {
														numDaysFound++;
														daysToAdd=7;
													}

													while(numDaysFound < occurance) {
														set[zz].setDate(set[zz].getDate()+daysToAdd);
														if(weekdays[set[zz].getDay()] == day) {
															numDaysFound++;
															daysToAdd=7;
														}
													}
												} else {
													//we're gonna expand here to add a date for each of the specified days for each month
													var numDaysFound=0;
													var subset = [];

													lastDayOfMonth = new Date(set[zz]);
													daysInMonth = dojo.date.getDaysInMonth(set[zz]);
													lastDayOfMonth.setDate(daysInMonth);

													set[zz].setDate(1);
												
													if (weekdays[set[zz].getDay()] == day) {
														numDaysFound++;
													}
													var tmpDate = new Date(set[zz]);
													daysToAdd = 1;
													while(tmpDate.getDate() < lastDayOfMonth) {
														if (weekdays[tmpDate.getDay()] == day) {
															numDaysFound++;
															if (numDaysFound==1) {
																set[zz] = tmpDate;
															} else {
																subset.push(tmpDate);
																tmpDate = new Date(tmpDate);
																daysToAdd=7;	
																tmpDate.setDate(tmpDate.getDate() + daysToAdd);
															}
														} else {
															tmpDate.setDate(tmpDate.getDate() + daysToAdd);
														}
													}
													var t = set.concat(subset);
													set = t; 
												}
											}
										}
									}	else {
										var subset=[];
										for (var zz=0; zz < set.length; zz++) {
											var newDate = new Date(set[zz]);
											if (regexResult[1] == "-") {
												if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
													newDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
												}
											} else {
												if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
													newDate.setDate(regexResult[2]);
												}
											}
											subset.push(newDate);
										}
										tmp = set.concat(subset);
										set = tmp;
									}
								}
							}
						} else {
							dojo.debug("TODO: byday within a yearly rule without a bymonth");
						}
					}

					dojo.debug("TODO: Process BYrules for units larger than frequency");
			
					//add this set of events to the complete recurranceSet	
					var tmp = recurranceSet.concat(set);
					recurranceSet = tmp;
				}
			}

			// TODO: add rdates to the recurrance set here

			// TODO: subtract exdates from the recurrance set here

			//TODO:  subtract dates generated by exrules from recurranceSet here

			recurranceSet.push(dtstart);
			return recurranceSet;
		},

		getDate: function() {
			return dojo.date.fromIso8601(this.dtstart.value);
		}
});

/*
 * VTIMEZONE
 */

var VTimeZoneProperties = [
	_P("tzid", 1, true), _P("last-mod", 1), _P("tzurl", 1)

	// one of 'standardc' or 'daylightc' must occur
	// and each may occur more than once.
];

dojo.iCalendar.VTimeZone = function (/* string */ body) {
	// summary
	// VTIMEZONE Component
	this.name = "VTIMEZONE";
	this._ValidProperties = VTimeZoneProperties;
	dojo.iCalendar.Component.call(this, body);
}

dojo.inherits(dojo.iCalendar.VTimeZone, dojo.iCalendar.Component);

/*
 * VTODO
 */

var VTodoProperties = [
	// these can occur once only
	_P("class", 1), _P("completed", 1), _P("created", 1), _P("description", 1),
	_P("dtstart", 1), _P("geo", 1), _P("last-mod", 1), _P("location", 1),
	_P("organizer", 1), _P("percent", 1), _P("priority", 1), _P("dtstamp", 1),
	_P("seq", 1), _P("status", 1), _P("summary", 1), _P("uid", 1), _P("url", 1),
	_P("recurid", 1),
	// these two are exclusive
	[_P("due", 1), _P("duration", 1)],
	// these can occur many times over
	_P("attach"), _P("attendee"), _P("categories"), _P("comment"), _P("contact"),
	_P("exdate"), _P("exrule"), _P("rstatus"), _P("related"), _P("resources"),
	_P("rdate"), _P("rrule")
];

dojo.iCalendar.VTodo= function (/* string */ body) {
	// summary
	// VTODO Componenet
	this.name = "VTODO";
	this._ValidProperties = VTodoProperties;
	dojo.iCalendar.Component.call(this, body);
}

dojo.inherits(dojo.iCalendar.VTodo, dojo.iCalendar.Component);

/*
 * VJOURNAL
 */

var VJournalProperties = [
	// these can occur once only
	_P("class", 1), _P("created", 1), _P("description", 1), _P("dtstart", 1),
	_P("last-mod", 1), _P("organizer", 1), _P("dtstamp", 1), _P("seq", 1),
	_P("status", 1), _P("summary", 1), _P("uid", 1), _P("url", 1), _P("recurid", 1),
	// these can occur many times over
	_P("attach"), _P("attendee"), _P("categories"), _P("comment"), _P("contact"),
	_P("exdate"), _P("exrule"), _P("related"), _P("rstatus"), _P("rdate"), _P("rrule")
];

dojo.iCalendar.VJournal= function (/* string */ body) {
	// summary
	// VJOURNAL Component
	this.name = "VJOURNAL";
	this._ValidProperties = VJournalProperties;
	dojo.iCalendar.Component.call(this, body);
}

dojo.inherits(dojo.iCalendar.VJournal, dojo.iCalendar.Component);

/*
 * VFREEBUSY
 */

var VFreeBusyProperties = [
	// these can occur once only
	_P("contact"), _P("dtstart", 1), _P("dtend"), _P("duration"),
	_P("organizer", 1), _P("dtstamp", 1), _P("uid", 1), _P("url", 1),
	// these can occur many times over
	_P("attendee"), _P("comment"), _P("freebusy"), _P("rstatus")
];

dojo.iCalendar.VFreeBusy= function (/* string */ body) {
	// summary
	// VFREEBUSY Component
	this.name = "VFREEBUSY";
	this._ValidProperties = VFreeBusyProperties;
	dojo.iCalendar.Component.call(this, body);
}

dojo.inherits(dojo.iCalendar.VFreeBusy, dojo.iCalendar.Component);

/*
 * VALARM
 */

var VAlarmProperties = [
	[_P("action", 1, true), _P("trigger", 1, true), [_P("duration", 1), _P("repeat", 1)],
	_P("attach", 1)],

	[_P("action", 1, true), _P("description", 1, true), _P("trigger", 1, true),
	[_P("duration", 1), _P("repeat", 1)]],

	[_P("action", 1, true), _P("description", 1, true), _P("trigger", 1, true),
	_P("summary", 1, true), _P("attendee", "*", true),
	[_P("duration", 1), _P("repeat", 1)],
	_P("attach", 1)],

	[_P("action", 1, true), _P("attach", 1, true), _P("trigger", 1, true),
	[_P("duration", 1), _P("repeat", 1)],
	_P("description", 1)],
];

dojo.iCalendar.VAlarm= function (/* string */ body) {
	// summary
	// VALARM Component
	this.name = "VALARM";
	this._ValidProperties = VAlarmProperties;
	dojo.iCalendar.Component.call(this, body);
}

dojo.inherits(dojo.iCalendar.VAlarm, dojo.iCalendar.Component);


__CPAN_FILE__ src/io.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.io.IO");
dojo.require("dojo.string");
dojo.require("dojo.lang.extras");

/******************************************************************************
 *	Notes about dojo.io design:
 *	
 *	The dojo.io.* package has the unenviable task of making a lot of different
 *	types of I/O feel natural, despite a universal lack of good (or even
 *	reasonable!) I/O capability in the host environment. So lets pin this down
 *	a little bit further.
 *
 *	Rhino:
 *		perhaps the best situation anywhere. Access to Java classes allows you
 *		to do anything one might want in terms of I/O, both synchronously and
 *		async. Can open TCP sockets and perform low-latency client/server
 *		interactions. HTTP transport is available through Java HTTP client and
 *		server classes. Wish it were always this easy.
 *
 *	xpcshell:
 *		XPCOM for I/O. A cluster-fuck to be sure.
 *
 *	spidermonkey:
 *		S.O.L.
 *
 *	Browsers:
 *		Browsers generally do not provide any useable filesystem access. We are
 *		therefore limited to HTTP for moving information to and from Dojo
 *		instances living in a browser.
 *
 *		XMLHTTP:
 *			Sync or async, allows reading of arbitrary text files (including
 *			JS, which can then be eval()'d), writing requires server
 *			cooperation and is limited to HTTP mechanisms (POST and GET).
 *
 *		<iframe> hacks:
 *			iframe document hacks allow browsers to communicate asynchronously
 *			with a server via HTTP POST and GET operations. With significant
 *			effort and server cooperation, low-latency data transit between
 *			client and server can be acheived via iframe mechanisms (repubsub).
 *
 *		SVG:
 *			Adobe's SVG viewer implements helpful primitives for XML-based
 *			requests, but receipt of arbitrary text data seems unlikely w/o
 *			<![CDATA[]]> sections.
 *
 *
 *	A discussion between Dylan, Mark, Tom, and Alex helped to lay down a lot
 *	the IO API interface. A transcript of it can be found at:
 *		http://dojotoolkit.org/viewcvs/viewcvs.py/documents/irc/irc_io_api_log.txt?rev=307&view=auto
 *	
 *	Also referenced in the design of the API was the DOM 3 L&S spec:
 *		http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/load-save.html
 ******************************************************************************/

// a map of the available transport options. Transports should add themselves
// by calling add(name)
dojo.io.transports = [];
dojo.io.hdlrFuncNames = [ "load", "error", "timeout" ]; // we're omitting a progress() event for now

dojo.io.Request = function(url, mimetype, transport, changeUrl){
	if((arguments.length == 1)&&(arguments[0].constructor == Object)){
		this.fromKwArgs(arguments[0]);
	}else{
		this.url = url;
		if(mimetype){ this.mimetype = mimetype; }
		if(transport){ this.transport = transport; }
		if(arguments.length >= 4){ this.changeUrl = changeUrl; }
	}
}

dojo.lang.extend(dojo.io.Request, {

	/** The URL to hit */
	url: "",
	
	/** The mime type used to interrpret the response body */
	mimetype: "text/plain",
	
	/** The HTTP method to use */
	method: "GET",
	
	/** An Object containing key-value pairs to be included with the request */
	content: undefined, // Object
	
	/** The transport medium to use */
	transport: undefined, // String
	
	/** If defined the URL of the page is physically changed */
	changeUrl: undefined, // String
	
	/** A form node to use in the request */
	formNode: undefined, // HTMLFormElement
	
	/** Whether the request should be made synchronously */
	sync: false,
	
	bindSuccess: false,

	/** Cache/look for the request in the cache before attempting to request?
	 *  NOTE: this isn't a browser cache, this is internal and would only cache in-page
	 */
	useCache: false,

	/** Prevent the browser from caching this by adding a query string argument to the URL */
	preventCache: false,
	
	// events stuff
	load: function(type, data, evt){ },
	error: function(type, error){ },
	timeout: function(type){ },
	handle: function(){ },

	//FIXME: change BrowserIO.js to use timeouts? IframeIO?
	// The number of seconds to wait until firing a timeout callback.
	// If it is zero, that means, don't do a timeout check.
	timeoutSeconds: 0,
	
	// the abort method needs to be filled in by the transport that accepts the
	// bind() request
	abort: function(){ },
	
	// backButton: function(){ },
	// forwardButton: function(){ },

	fromKwArgs: function(kwArgs){
		// normalize args
		if(kwArgs["url"]){ kwArgs.url = kwArgs.url.toString(); }
		if(kwArgs["formNode"]) { kwArgs.formNode = dojo.byId(kwArgs.formNode); }
		if(!kwArgs["method"] && kwArgs["formNode"] && kwArgs["formNode"].method) {
			kwArgs.method = kwArgs["formNode"].method;
		}
		
		// backwards compatibility
		if(!kwArgs["handle"] && kwArgs["handler"]){ kwArgs.handle = kwArgs.handler; }
		if(!kwArgs["load"] && kwArgs["loaded"]){ kwArgs.load = kwArgs.loaded; }
		if(!kwArgs["changeUrl"] && kwArgs["changeURL"]) { kwArgs.changeUrl = kwArgs.changeURL; }

		// encoding fun!
		kwArgs.encoding = dojo.lang.firstValued(kwArgs["encoding"], djConfig["bindEncoding"], "");

		kwArgs.sendTransport = dojo.lang.firstValued(kwArgs["sendTransport"], djConfig["ioSendTransport"], false);

		var isFunction = dojo.lang.isFunction;
		for(var x=0; x<dojo.io.hdlrFuncNames.length; x++){
			var fn = dojo.io.hdlrFuncNames[x];
			if(isFunction(kwArgs[fn])){ continue; }
			if(isFunction(kwArgs["handle"])){
				kwArgs[fn] = kwArgs.handle;
			}
			// handler is aliased above, shouldn't need this check
			/* else if(dojo.lang.isObject(kwArgs.handler)){
				if(isFunction(kwArgs.handler[fn])){
					kwArgs[fn] = kwArgs.handler[fn]||kwArgs.handler["handle"]||function(){};
				}
			}*/
		}
		dojo.lang.mixin(this, kwArgs);
	}

});

dojo.io.Error = function(msg, type, num){
	this.message = msg;
	this.type =  type || "unknown"; // must be one of "io", "parse", "unknown"
	this.number = num || 0; // per-substrate error number, not normalized
}

dojo.io.transports.addTransport = function(name){
	this.push(name);
	// FIXME: do we need to handle things that aren't direct children of the
	// dojo.io namespace? (say, dojo.io.foo.fooTransport?)
	this[name] = dojo.io[name];
}

// binding interface, the various implementations register their capabilities
// and the bind() method dispatches
dojo.io.bind = function(request){
	// if the request asks for a particular implementation, use it
	if(!(request instanceof dojo.io.Request)){
		try{
			request = new dojo.io.Request(request);
		}catch(e){ dojo.debug(e); }
	}
	var tsName = "";
	if(request["transport"]){
		tsName = request["transport"];
		// FIXME: it would be good to call the error handler, although we'd
		// need to use setTimeout or similar to accomplish this and we can't
		// garuntee that this facility is available.
		if(!this[tsName]){ return request; }
	}else{
		// otherwise we do our best to auto-detect what available transports
		// will handle 
		for(var x=0; x<dojo.io.transports.length; x++){
			var tmp = dojo.io.transports[x];
			if((this[tmp])&&(this[tmp].canHandle(request))){
				tsName = tmp;
			}
		}
		if(tsName == ""){ return request; }
	}
	this[tsName].bind(request);
	request.bindSuccess = true;
	return request;
}

dojo.io.queueBind = function(request){
	if(!(request instanceof dojo.io.Request)){
		try{
			request = new dojo.io.Request(request);
		}catch(e){ dojo.debug(e); }
	}

	// make sure we get called if/when we get a response
	var oldLoad = request.load;
	request.load = function(){
		dojo.io._queueBindInFlight = false;
		var ret = oldLoad.apply(this, arguments);
		dojo.io._dispatchNextQueueBind();
		return ret;
	}

	var oldErr = request.error;
	request.error = function(){
		dojo.io._queueBindInFlight = false;
		var ret = oldErr.apply(this, arguments);
		dojo.io._dispatchNextQueueBind();
		return ret;
	}

	dojo.io._bindQueue.push(request);
	dojo.io._dispatchNextQueueBind();
	return request;
}

dojo.io._dispatchNextQueueBind = function(){
	if(!dojo.io._queueBindInFlight){
		dojo.io._queueBindInFlight = true;
		if(dojo.io._bindQueue.length > 0){
			dojo.io.bind(dojo.io._bindQueue.shift());
		}else{
			dojo.io._queueBindInFlight = false;
		}
	}
}
dojo.io._bindQueue = [];
dojo.io._queueBindInFlight = false;

dojo.io.argsFromMap = function(map, encoding, last){
	var enc = /utf/i.test(encoding||"") ? encodeURIComponent : dojo.string.encodeAscii;
	var mapped = [];
	var control = new Object();
	for(var name in map){
		var domap = function(elt){
			var val = enc(name)+"="+enc(elt);
			mapped[(last == name) ? "push" : "unshift"](val);
		}
		if(!control[name]){
			var value = map[name];
			// FIXME: should be isArrayLike?
			if (dojo.lang.isArray(value)){
				dojo.lang.forEach(value, domap);
			}else{
				domap(value);
			}
		}
	}
	return mapped.join("&");
}

dojo.io.setIFrameSrc = function(iframe, src, replace){
	try{
		var r = dojo.render.html;
		// dojo.debug(iframe);
		if(!replace){
			if(r.safari){
				iframe.location = src;
			}else{
				frames[iframe.name].location = src;
			}
		}else{
			// Fun with DOM 0 incompatibilities!
			var idoc;
			if(r.ie){
				idoc = iframe.contentWindow.document;
			}else if(r.safari){
				idoc = iframe.document;
			}else{ //  if(r.moz){
				idoc = iframe.contentWindow;
			}
			idoc.location.replace(src);
		}
	}catch(e){ 
		dojo.debug(e); 
		dojo.debug("setIFrameSrc: "+e); 
	}
}

/*
dojo.io.sampleTranport = new function(){
	this.canHandle = function(kwArgs){
		// canHandle just tells dojo.io.bind() if this is a good transport to
		// use for the particular type of request.
		if(	
			(
				(kwArgs["mimetype"] == "text/plain") ||
				(kwArgs["mimetype"] == "text/html") ||
				(kwArgs["mimetype"] == "text/javascript")
			)&&(
				(kwArgs["method"] == "get") ||
				( (kwArgs["method"] == "post") && (!kwArgs["formNode"]) )
			)
		){
			return true;
		}

		return false;
	}

	this.bind = function(kwArgs){
		var hdlrObj = {};

		// set up a handler object
		for(var x=0; x<dojo.io.hdlrFuncNames.length; x++){
			var fn = dojo.io.hdlrFuncNames[x];
			if(typeof kwArgs.handler == "object"){
				if(typeof kwArgs.handler[fn] == "function"){
					hdlrObj[fn] = kwArgs.handler[fn]||kwArgs.handler["handle"];
				}
			}else if(typeof kwArgs[fn] == "function"){
				hdlrObj[fn] = kwArgs[fn];
			}else{
				hdlrObj[fn] = kwArgs["handle"]||function(){};
			}
		}

		// build a handler function that calls back to the handler obj
		var hdlrFunc = function(evt){
			if(evt.type == "onload"){
				hdlrObj.load("load", evt.data, evt);
			}else if(evt.type == "onerr"){
				var errObj = new dojo.io.Error("sampleTransport Error: "+evt.msg);
				hdlrObj.error("error", errObj);
			}
		}

		// the sample transport would attach the hdlrFunc() when sending the
		// request down the pipe at this point
		var tgtURL = kwArgs.url+"?"+dojo.io.argsFromMap(kwArgs.content);
		// sampleTransport.sendRequest(tgtURL, hdlrFunc);
	}

	dojo.io.transports.addTransport("sampleTranport");
}
*/

__CPAN_FILE__ src/json.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.json");
dojo.require("dojo.lang.func");
dojo.require("dojo.string.extras");
dojo.require("dojo.AdapterRegistry");

dojo.json = {
	jsonRegistry: new dojo.AdapterRegistry(),

	register: function(name, check, wrap, /*optional*/ override){
		/***

			Register a JSON serialization function.	 JSON serialization 
			functions should take one argument and return an object
			suitable for JSON serialization:

			- string
			- number
			- boolean
			- undefined
			- object
				- null
				- Array-like (length property that is a number)
				- Objects with a "json" method will have this method called
				- Any other object will be used as {key:value, ...} pairs
			
			If override is given, it is used as the highest priority
			JSON serialization, otherwise it will be used as the lowest.
		***/

		dojo.json.jsonRegistry.register(name, check, wrap, override);
	},

	evalJson: function(/* jsonString */ json){
		// FIXME: should this accept mozilla's optional second arg?
		try {
			return eval("(" + json + ")");
		}catch(e){
			dojo.debug(e);
			return json;
		}
	},

	evalJSON: function (json) {
		dojo.deprecated("dojo.json.evalJSON", "use dojo.json.evalJson", "0.4");
		return this.evalJson(json);
	},

	serialize: function(o){
		/***
			Create a JSON serialization of an object, note that this doesn't
			check for infinite recursion, so don't do that!
		***/

		var objtype = typeof(o);
		if(objtype == "undefined"){
			return "undefined";
		}else if((objtype == "number")||(objtype == "boolean")){
			return o + "";
		}else if(o === null){
			return "null";
		}
		if (objtype == "string") { return dojo.string.escapeString(o); }
		// recurse
		var me = arguments.callee;
		// short-circuit for objects that support "json" serialization
		// if they return "self" then just pass-through...
		var newObj;
		if(typeof(o.__json__) == "function"){
			newObj = o.__json__();
			if(o !== newObj){
				return me(newObj);
			}
		}
		if(typeof(o.json) == "function"){
			newObj = o.json();
			if (o !== newObj) {
				return me(newObj);
			}
		}
		// array
		if(objtype != "function" && typeof(o.length) == "number"){
			var res = [];
			for(var i = 0; i < o.length; i++){
				var val = me(o[i]);
				if(typeof(val) != "string"){
					val = "undefined";
				}
				res.push(val);
			}
			return "[" + res.join(",") + "]";
		}
		// look in the registry
		try {
			window.o = o;
			newObj = dojo.json.jsonRegistry.match(o);
			return me(newObj);
		}catch(e){
			// dojo.debug(e);
		}
		// it's a function with no adapter, bad
		if(objtype == "function"){
			return null;
		}
		// generic object code path
		res = [];
		for (var k in o){
			var useKey;
			if (typeof(k) == "number"){
				useKey = '"' + k + '"';
			}else if (typeof(k) == "string"){
				useKey = dojo.string.escapeString(k);
			}else{
				// skip non-string or number keys
				continue;
			}
			val = me(o[k]);
			if(typeof(val) != "string"){
				// skip non-serializable values
				continue;
			}
			res.push(useKey + ":" + val);
		}
		return "{" + res.join(",") + "}";
	}
};

__CPAN_FILE__ src/lang.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang");
dojo.provide("dojo.lang.Lang");

dojo.require("dojo.lang.common");

__CPAN_FILE__ src/loader.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*
 * loader.js - runs before the hostenv_*.js file. Contains all of the package loading methods.
 */

//A semi-colon is at the start of the line because after doing a build, this function definition
//get compressed onto the same line as the last line in bootstrap1.js. That list line is just a
//curly bracket, and the browser complains about that syntax. The semicolon fixes it. Putting it
//here instead of at the end of bootstrap1.js, since it is more of an issue for this file, (using
//the closure), and bootstrap1.js could change in the future.
;(function(){
	//Additional properties for dojo.hostenv
	var _addHostEnv = {
		pkgFileName: "__package__",
	
		// for recursion protection
		loading_modules_: {},
		loaded_modules_: {},
		addedToLoadingCount: [],
		removedFromLoadingCount: [],
	
		inFlightCount: 0,
	
		// FIXME: it should be possible to pull module prefixes in from djConfig
		modulePrefixes_: {
			dojo: {name: "dojo", value: "src"}
		},
	
	
		setModulePrefix: function(module, prefix){
			this.modulePrefixes_[module] = {name: module, value: prefix};
		},
	
		getModulePrefix: function(module){
			var mp = this.modulePrefixes_;
			if((mp[module])&&(mp[module]["name"])){
				return mp[module].value;
			}
			return module;
		},
	
		getTextStack: [],
		loadUriStack: [],
		loadedUris: [],
	
		//WARNING: This variable is referenced by packages outside of bootstrap: FloatingPane.js and undo/browser.js
		post_load_: false,
		
		//Egad! Lots of test files push on this directly instead of using dojo.addOnLoad.
		modulesLoadedListeners: []
	};
	
	//Add all of these properties to dojo.hostenv
	for(var param in _addHostEnv){
		dojo.hostenv[param] = _addHostEnv[param];
	}
})();

/**
 * Loads and interprets the script located at relpath, which is relative to the
 * script root directory.  If the script is found but its interpretation causes
 * a runtime exception, that exception is not caught by us, so the caller will
 * see it.  We return a true value if and only if the script is found.
 *
 * For now, we do not have an implementation of a true search path.  We
 * consider only the single base script uri, as returned by getBaseScriptUri().
 *
 * @param relpath A relative path to a script (no leading '/', and typically
 * ending in '.js').
 * @param module A module whose existance to check for after loading a path.
 * Can be used to determine success or failure of the load.
 */
dojo.hostenv.loadPath = function(relpath, module /*optional*/, cb /*optional*/){
	if((relpath.charAt(0) == '/')||(relpath.match(/^\w+:/))){
		dojo.raise("relpath '" + relpath + "'; must be relative");
	}
	var uri = this.getBaseScriptUri() + relpath;
	if(djConfig.cacheBust && dojo.render.html.capable) { uri += "?" + String(djConfig.cacheBust).replace(/\W+/g,""); }
	try{
		return ((!module) ? this.loadUri(uri, cb) : this.loadUriAndCheck(uri, module, cb));
	}catch(e){
		dojo.debug(e);
		return false;
	}
}

/**
 * Reads the contents of the URI, and evaluates the contents.
 * Returns true if it succeeded. Returns false if the URI reading failed.
 * Throws if the evaluation throws.
 * The result of the eval is not available to the caller.
 */
dojo.hostenv.loadUri = function(uri, cb){
	if(this.loadedUris[uri]){
		return;
	}
	var contents = this.getText(uri, null, true);
	if(contents == null){ return 0; }
	this.loadedUris[uri] = true;
	var value = dj_eval(contents);
	return 1;
}

// FIXME: probably need to add logging to this method
dojo.hostenv.loadUriAndCheck = function(uri, module, cb){
	var ok = true;
	try{
		ok = this.loadUri(uri, cb);
	}catch(e){
		dojo.debug("failed loading ", uri, " with error: ", e);
	}
	return ((ok)&&(this.findModule(module, false))) ? true : false;
}

dojo.loaded = function(){ }

dojo.hostenv.loaded = function(){
	this.post_load_ = true;
	var mll = this.modulesLoadedListeners;
	//Clear listeners so new ones can be added
	//For other xdomain package loads after the initial load.
	this.modulesLoadedListeners = [];
	for(var x=0; x<mll.length; x++){
		mll[x]();
	}
	dojo.loaded();
}

/*
Call styles:
	dojo.addOnLoad(functionPointer)
	dojo.addOnLoad(object, "functionName")
*/
dojo.addOnLoad = function(obj, fcnName) {
	var dh = dojo.hostenv;
	if(arguments.length == 1) {
		dh.modulesLoadedListeners.push(obj);
	} else if(arguments.length > 1) {
		dh.modulesLoadedListeners.push(function() {
			obj[fcnName]();
		});
	}

	//Added for xdomain loading. dojo.addOnLoad is used to
	//indicate callbacks after doing some dojo.require() statements.
	//In the xdomain case, if all the requires are loaded (after initial
	//page load), then immediately call any listeners.
	if(dh.post_load_ && dh.inFlightCount == 0){
		dh.callLoaded();
	}
}

dojo.hostenv.modulesLoaded = function(){
	if(this.post_load_){ return; }
	if((this.loadUriStack.length==0)&&(this.getTextStack.length==0)){
		if(this.inFlightCount > 0){ 
			dojo.debug("files still in flight!");
			return;
		}
		dojo.hostenv.callLoaded();
	}
}

dojo.hostenv.callLoaded = function(){
	if(typeof setTimeout == "object"){
		setTimeout("dojo.hostenv.loaded();", 0);
	}else{
		dojo.hostenv.loaded();
	}
}

/**
* loadModule("A.B") first checks to see if symbol A.B is defined. 
* If it is, it is simply returned (nothing to do).
*
* If it is not defined, it will look for "A/B.js" in the script root directory,
* followed by "A.js".
*
* It throws if it cannot find a file to load, or if the symbol A.B is not
* defined after loading.
*
* It returns the object A.B.
*
* This does nothing about importing symbols into the current package.
* It is presumed that the caller will take care of that. For example, to import
* all symbols:
*
*    with (dojo.hostenv.loadModule("A.B")) {
*       ...
*    }
*
* And to import just the leaf symbol:
*
*    var B = dojo.hostenv.loadModule("A.B");
*    ...
*
* dj_load is an alias for dojo.hostenv.loadModule
*/
dojo.hostenv._global_omit_module_check = false;
dojo.hostenv.loadModule = function(modulename, exact_only, omit_module_check){
	if(!modulename){ return; }
	omit_module_check = this._global_omit_module_check || omit_module_check;
	var module = this.findModule(modulename, false);
	if(module){
		return module;
	}

	// protect against infinite recursion from mutual dependencies
	if(dj_undef(modulename, this.loading_modules_)){
		this.addedToLoadingCount.push(modulename);
	}
	this.loading_modules_[modulename] = 1;

	// convert periods to slashes
	var relpath = modulename.replace(/\./g, '/') + '.js';

	var syms = modulename.split(".");
	var nsyms = modulename.split(".");
	for (var i = syms.length - 1; i > 0; i--) {
		var parentModule = syms.slice(0, i).join(".");
		var parentModulePath = this.getModulePrefix(parentModule);
		if (parentModulePath != parentModule) {
			syms.splice(0, i, parentModulePath);
			break;
		}
	}
	var last = syms[syms.length - 1];
	// figure out if we're looking for a full package, if so, we want to do
	// things slightly diffrently
	if(last=="*"){
		modulename = (nsyms.slice(0, -1)).join('.');

		while(syms.length){
			syms.pop();
			syms.push(this.pkgFileName);
			relpath = syms.join("/") + '.js';
			if(relpath.charAt(0)=="/"){
				relpath = relpath.slice(1);
			}
			ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
			if(ok){ break; }
			syms.pop();
		}
	}else{
		relpath = syms.join("/") + '.js';
		modulename = nsyms.join('.');
		var ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
		if((!ok)&&(!exact_only)){
			syms.pop();
			while(syms.length){
				relpath = syms.join('/') + '.js';
				ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
				if(ok){ break; }
				syms.pop();
				relpath = syms.join('/') + '/'+this.pkgFileName+'.js';
				if(relpath.charAt(0)=="/"){
					relpath = relpath.slice(1);
				}
				ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
				if(ok){ break; }
			}
		}

		if((!ok)&&(!omit_module_check)){
			dojo.raise("Could not load '" + modulename + "'; last tried '" + relpath + "'");
		}
	}

	// check that the symbol was defined
	//Don't bother if we're doing xdomain (asynchronous) loading.
	if(!omit_module_check && !this["isXDomain"]){
		// pass in false so we can give better error
		module = this.findModule(modulename, false);
		if(!module){
			dojo.raise("symbol '" + modulename + "' is not defined after loading '" + relpath + "'"); 
		}
	}

	return module;
}

/**
* startPackage("A.B") follows the path, and at each level creates a new empty
* object or uses what already exists. It returns the result.
*/
dojo.hostenv.startPackage = function(packname){
	var modref = dojo.evalObjPath((packname.split(".").slice(0, -1)).join('.'));
	this.loaded_modules_[(new String(packname)).toLowerCase()] = modref;

	var syms = packname.split(/\./);
	if(syms[syms.length-1]=="*"){
		syms.pop();
	}
	return dojo.evalObjPath(syms.join("."), true);
}

/**
 * findModule("A.B") returns the object A.B if it exists, otherwise null.
 * @param modulename A string like 'A.B'.
 * @param must_exist Optional, defualt false. throw instead of returning null
 * if the module does not currently exist.
 */
dojo.hostenv.findModule = function(modulename, must_exist){
	// check cache
	/*
	if(!dj_undef(modulename, this.modules_)){
		return this.modules_[modulename];
	}
	*/

	var lmn = (new String(modulename)).toLowerCase();

	if(this.loaded_modules_[lmn]){
		return this.loaded_modules_[lmn];
	}

	// see if symbol is defined anyway
	var module = dojo.evalObjPath(modulename);
	if((modulename)&&(typeof module != 'undefined')&&(module)){
		this.loaded_modules_[lmn] = module;
		return module;
	}

	if(must_exist){
		dojo.raise("no loaded module named '" + modulename + "'");
	}
	return null;
}

//Start of old bootstrap2:

/*
 * This method taks a "map" of arrays which one can use to optionally load dojo
 * modules. The map is indexed by the possible dojo.hostenv.name_ values, with
 * two additional values: "default" and "common". The items in the "default"
 * array will be loaded if none of the other items have been choosen based on
 * the hostenv.name_ item. The items in the "common" array will _always_ be
 * loaded, regardless of which list is chosen.  Here's how it's normally
 * called:
 *
 *	dojo.kwCompoundRequire({
 *		browser: [
 *			["foo.bar.baz", true, true], // an example that passes multiple args to loadModule()
 *			"foo.sample.*",
 *			"foo.test,
 *		],
 *		default: [ "foo.sample.*" ],
 *		common: [ "really.important.module.*" ]
 *	});
 */
dojo.kwCompoundRequire = function(modMap){
	var common = modMap["common"]||[];
	var result = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap["default"]||[]);

	for(var x=0; x<result.length; x++){
		var curr = result[x];
		if(curr.constructor == Array){
			dojo.hostenv.loadModule.apply(dojo.hostenv, curr);
		}else{
			dojo.hostenv.loadModule(curr);
		}
	}
}

dojo.require = function(){
	dojo.hostenv.loadModule.apply(dojo.hostenv, arguments);
}

dojo.requireIf = function(){
	if((arguments[0] === true)||(arguments[0]=="common")||(arguments[0] && dojo.render[arguments[0]].capable)){
		var args = [];
		for (var i = 1; i < arguments.length; i++) { args.push(arguments[i]); }
		dojo.require.apply(dojo, args);
	}
}

dojo.requireAfterIf = dojo.requireIf;

dojo.provide = function(){
	return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);
}

dojo.setModulePrefix = function(module, prefix){
	return dojo.hostenv.setModulePrefix(module, prefix);
}

// determine if an object supports a given method
// useful for longer api chains where you have to test each object in the chain
dojo.exists = function(obj, name){
	var p = name.split(".");
	for(var i = 0; i < p.length; i++){
	if(!(obj[p[i]])) return false;
		obj = obj[p[i]];
	}
	return true;
}

__CPAN_FILE__ src/loader_xd.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

//Cross-domain package loader.

//FIXME: How will xd loading work with debugAtAllCosts? Any bad interactions?
//FIXME: widgets won't work fully (HTML/CSS) and also because of the requireIf() thing.

dojo.hostenv.resetXd = function(){
	//This flag indicates where or not we have crossed into xdomain territory. Once any package says
	//it is cross domain, then the rest of the packages have to be treated as xdomain because we need
	//to evaluate packages in order. If there is a xdomain package followed by a xhr package, we can't load
	//the xhr package until the one before it finishes loading. The text of the xhr package will be converted
	//to match the format for a xd package and put in the xd load queue.
	//You can force all packages to be treated as xd by setting the djConfig.forceXDomain.
	this.isXDomain = djConfig.forceXDomain || false;

	this.xdTimer = 0;
	this.xdInFlight = {};
	this.xdOrderedReqs = [];
	this.xdDepMap = {};
	this.xdContents = [];
}

//Call reset immediately to set the state.
dojo.hostenv.resetXd();

dojo.hostenv.createXdPackage = function(contents){
	//Find dependencies.
	var deps = [];
    var depRegExp = /dojo.(require|requireIf|requireAll|provide|requireAfterIf|requireAfter|kwCompoundRequire|conditionalRequire|hostenv\.conditionalLoadModule|.hostenv\.loadModule|hostenv\.moduleLoaded)\(([\w\W]*?)\)/mg;
    var match;
	while((match = depRegExp.exec(contents)) != null){
		deps.push("\"" + match[1] + "\", " + match[2]);
	}

	//Create package object and the call to packageLoaded.
	var output = [];
	output.push("dojo.hostenv.packageLoaded({\n");

	//Add dependencies
	if(deps.length > 0){
		output.push("depends: [");
		for(var i = 0; i < deps.length; i++){
			if(i > 0){
				output.push(",\n");
			}
			output.push("[" + deps[i] + "]");
		}
		output.push("],");
	}

	//Add the contents of the file inside a function.
	//Pass in dojo as an argument to the function to help with
	//allowing multiple versions of dojo in a page.
	output.push("\ndefinePackage: function(dojo){");
	output.push(contents);
	output.push("\n}});");
	
	return output.join("");
}

dojo.hostenv.loadPath = function(relpath, module /*optional*/, cb /*optional*/){
	//Only do getBaseScriptUri if path does not start with a URL with a protocol.
	//If there is a colon before the first / then, we have a URL with a protocol.
	var colonIndex = relpath.indexOf(":");
	var slashIndex = relpath.indexOf("/");
	var uri;
	var currentIsXDomain = false;
	if(colonIndex > 0 && colonIndex < slashIndex){
		uri = relpath;
		this.isXDomain = currentIsXDomain = true;
	}else{
		uri = this.getBaseScriptUri() + relpath;

		//Is ithe base script URI-based URL a cross domain URL?
		colonIndex = uri.indexOf(":");
		slashIndex = uri.indexOf("/");
		if(colonIndex > 0 && colonIndex < slashIndex && (!location.host || uri.indexOf("http://" + location.host) != 0)){
			this.isXDomain = currentIsXDomain = true;
		}
	}

	if(djConfig.cacheBust && dojo.render.html.capable) { uri += "?" + String(djConfig.cacheBust).replace(/\W+/g,""); }
	try{
		return ((!module || this.isXDomain) ? this.loadUri(uri, cb, currentIsXDomain, module) : this.loadUriAndCheck(uri, module, cb));
	}catch(e){
		dojo.debug(e);
		return false;
	}
}

//Overriding loadUri for now. Wanted to override getText(), but it is used by
//the widget code in too many, synchronous ways right now. This means the xd stuff
//is not suitable for widgets yet.
dojo.hostenv.loadUri = function(uri, cb, currentIsXDomain, module){
	if(this.loadedUris[uri]){
		return 1;
	}

	//Add the module (package) to the list of modules.
	if(this.isXDomain){
		//Curious: is this array going to get whacked with multiple access since scripts
		//load asynchronously and may be accessing the array at the same time?
		//JS is single-threaded supposedly, so it should be ok. And we don't need
		//a precise ordering.
		this.xdOrderedReqs.push(module);

		//Add to waiting packages.
		//If this is a __package__.js file, then this must be
		//a package.* request (since xdomain can only work with the first
		//path in a package search list. However, .* module names are not
		//passed to this function, so do an adjustment here.
		if(uri.indexOf("__package__") != -1){
			module += ".*";
		}

		this.xdInFlight[module] = true;

		//Increment inFlightCount
		//This will stop the modulesLoaded from firing all the way.
		this.inFlightCount++;
				
		//Start timer
		if(!this.xdTimer){
			this.xdTimer = setInterval("dojo.hostenv.watchInFlightXDomain();", 100);
		}
		this.xdStartTime = (new Date()).getTime();
	}

	if (currentIsXDomain){
		//Fix name to be a .xd.fileextension name.
		var lastIndex = uri.lastIndexOf('.');
		if(lastIndex <= 0){
			lastIndex = uri.length - 1;
		}

		var xdUri = uri.substring(0, lastIndex) + ".xd";
		if(lastIndex != uri.length - 1){
			xdUri += uri.substring(lastIndex, uri.length);
		}

		//Add to script src
		var element = document.createElement("script");
		element.type = "text/javascript";
		element.src = xdUri;
		if(!this.headElement){
			this.headElement = document.getElementsByTagName("head")[0];
		}
		this.headElement.appendChild(element);
	}else{
		var contents = this.getText(uri, null, true);
		if(contents == null){ return 0; }
		
		if(this.isXDomain){
			var pkg = this.createXdPackage(contents);
			dj_eval(pkg);
		}else{
			var value = dj_eval(contents);
		}
	}

	//These steps are done in the non-xd loader version of this function.
	//Maintain these steps to fit in with the existing system.
	this.loadedUris[uri] = true;
	return 1;
}

dojo.hostenv.packageLoaded = function(pkg){
	var deps = pkg.depends;
	var requireList = null;
	var provideList = [];
	if(deps && deps.length > 0){
		var dep = null;
		var insertHint = 0;
		var attachedPackage = false;
		for(var i = 0; i < deps.length; i++){
			dep = deps[i];

			//Look for specific dependency indicators.
			if (dep[0] == "provide" || dep[0] == "hostenv.moduleLoaded"){
				provideList.push(dep[1]);
			}else{
				if(!requireList){
					requireList = [];
				}
				requireList = requireList.concat(this.unpackXdDependency(dep));
			}

			//Call the dependency indicator to allow for the normal dojo setup.
			//Only allow for one dot reference, for the hostenv.* type calls.
			var depType = dep[0];
			var objPath = depType.split(".");
			if(objPath.length == 2){
				dojo[objPath[0]][objPath[1]].apply(dojo[objPath[0]], dep.slice(1));
			}else{
				dojo[depType].apply(dojo, dep.slice(1));
			}
		}

		//Save off the package contents for definition later.
		var contentIndex = this.xdContents.push({content: pkg.definePackage, isDefined: false}) - 1;

		//Add provide/requires to dependency map.
		for(var i = 0; i < provideList.length; i++){
			this.xdDepMap[provideList[i]] = { requires: requireList, contentIndex: contentIndex };
		}

		//Now update the inflight status for any provided packages in this loaded package.
		//Do this at the very end (in a *separate* for loop) to avoid shutting down the 
		//inflight timer check too soon.
		for(var i = 0; i < provideList.length; i++){
			this.xdInFlight[provideList[i]] = false;
		}
	}
}

//This is a bit brittle: it has to know about the dojo methods that deal with dependencies
//It would be ideal to intercept the actual methods and do something fancy at that point,
//but I have concern about knowing which provide to match to the dependency in that case,
//since scripts can load whenever they want, and trigger new calls to dojo.hostenv.packageLoaded().
dojo.hostenv.unpackXdDependency = function(dep){
	//Extract the dependency(ies).
	var newDeps = null;
	switch(dep[0]){
		case "requireIf":
		case "requireAfterIf":
		case "conditionalRequire":
			//First arg (dep[1]) is the test. Depedency is dep[2].
			if((dep[1] === true)||(dep[1]=="common")||(dep[1] && dojo.render[dep[1]].capable)){
				newDeps = [{name: dep[2], content: null}];
			}
			break;
		case "requireAll":
			//the arguments are an array, each element a call to require.
			//Get rid of first item, which is "requireAll".
			deps.shift();
			newDeps = deps;
			dojo.hostenv.flattenRequireArray(newDeps);
			break;
		case "kwCompoundRequire":
		case "hostenv.conditionalLoadModule":
			var modMap = dep[1];
			var common = modMap["common"]||[];
			var newDeps = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap["default"]||[]);	
			dojo.hostenv.flattenRequireArray(newDeps);
			break;
		case "require":
		case "requireAfter":
		case "hostenv.loadModule":
			//Just worry about dep[1]
			newDeps = [{name: dep[1], content: null}];
			break;
	}

	return newDeps;
}

//Evaluate package contents for the given provide.
dojo.hostenv.xdResolve = function(provide, pkg){
	var contents = this.xdContents[pkg.contentIndex];
	if(!contents.isDefined){
		//Evaluate the package to bring it into being.
		//Pass dojo in so that later, to support multiple versions of dojo
		//in a page, we can pass which version of dojo to use.
		contents.content(dojo);
		contents.isDefined = true;
	}

	this.xdDepMap[provide] = null;
}

//Walks the requires and evaluates package contents in
//the right order.
dojo.hostenv.xdWalkReqs = function(){
	var reqChain = null;
	var req;
	for(var i = 0; i < this.xdOrderedReqs.length; i++){
		req = this.xdOrderedReqs[i];
		if(this.xdDepMap[req]){
			reqChain = [req];
			reqChain[req] = true; //Allow for fast lookup of the req in the array
			this.xdEvalReqs(reqChain);
		}
	}
}

//Do a depth first, breadth second search and eval or reqs.
dojo.hostenv.xdEvalReqs = function(reqChain){
	if(reqChain.length > 0){
		var req = reqChain[reqChain.length - 1];
		var pkg = this.xdDepMap[req];
		if(pkg){
			//Trace down any dependencies for this package.
			if(pkg.requires && pkg.requires.length > 0){
				var nextReq;
				for(var i = 0; i < pkg.requires.length; i++){
					nextReq = pkg.requires[i].name;
					if(nextReq && !reqChain[nextReq]){
						//New req depedency. Follow it down.
						reqChain.push(nextReq);
						reqChain[nextReq] = true;
						this.xdEvalReqs(reqChain);
					}
				}
			}

			//Evaluate the package.
			this.xdResolve(req, pkg);
		}

		//Done with that require. Remove it and go to the next one.
		reqChain.pop();
		this.xdEvalReqs(reqChain);
	}
}

dojo.hostenv.clearXdInterval = function(){
	clearInterval(this.xdTimer);
	this.xdTimer = 0;
}

dojo.hostenv.watchInFlightXDomain = function(){
	//Make sure we haven't waited timed out.
	var waitInterval = (djConfig.xdWaitSeconds || 30) * 1000;

	if(this.xdStartTime + waitInterval < (new Date()).getTime()){
		this.clearXdInterval();
		var noLoads = "";
		for(var param in this.xdInFlight){
			if(this.xdInFlight[param]){
				noLoads += param + " ";
			}
		}
		dojo.raise("Could not load cross-domain packages: " + noLoads);
	}

	//If any are true, then still waiting.
	//Come back later.	
	for(var param in this.xdInFlight){
		if(this.xdInFlight[param]){
			return;
		}
	}

	//All done loading. Clean up and notify that we are loaded.
	this.clearXdInterval();

	this.xdWalkReqs();

	//Evaluate any packages that were not evaled before.
	//This normally shouldn't happen with proper dojo.provide and dojo.require
	//usage, but providing it just in case. Note that these may not be executed
	//in the original order that the developer intended.
	//Pass dojo in so that later, to support multiple versions of dojo
	//in a page, we can pass which version of dojo to use.
	for(var i = 0; i < this.xdContents.length; i++){
		var current = this.xdContents[i];
		if(current.content && !current.isDefined){
			current.content(dojo);
		}
	}

	//Clean up for the next round of xd loading.
	this.resetXd();

	//Clear inflight count so we will finally do finish work.
	this.inFlightCount = 0; 
	this.callLoaded();
}

dojo.hostenv.flattenRequireArray = function(target){
	//Each result could be an array of 3 elements  (the 3 arguments to dojo.require).
	//We only need the first one.
	if(target){
		for(var i = 0; i < target.length; i++){
			if(target[i] instanceof Array){
				target[i] = {name: target[i][0], content: null};
			}else{
				target[i] = {name: target[i], content: null};
			}
		}
	}
}

__CPAN_FILE__ src/math.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.math");

dojo.math.degToRad = function (x) { return (x*Math.PI) / 180; }
dojo.math.radToDeg = function (x) { return (x*180) / Math.PI; }

dojo.math.factorial = function (n) {
	if(n<1){ return 0; }
	var retVal = 1;
	for(var i=1;i<=n;i++){ retVal *= i; }
	return retVal;
}

//The number of ways of obtaining an ordered subset of k elements from a set of n elements
dojo.math.permutations = function (n,k) {
	if(n==0 || k==0) return 1;
	return (dojo.math.factorial(n) / dojo.math.factorial(n-k));
}

//The number of ways of picking n unordered outcomes from r possibilities
dojo.math.combinations = function (n,r) {
	if(n==0 || r==0) return 1;
	return (dojo.math.factorial(n) / (dojo.math.factorial(n-r) * dojo.math.factorial(r)));
}

dojo.math.bernstein = function (t,n,i) {
	return (dojo.math.combinations(n,i) * Math.pow(t,i) * Math.pow(1-t,n-i));
}

/**
 * Returns random numbers with a Gaussian distribution, with the mean set at
 * 0 and the variance set at 1.
 *
 * @return A random number from a Gaussian distribution
 */
dojo.math.gaussianRandom = function () {
	var k = 2;
	do {
		var i = 2 * Math.random() - 1;
		var j = 2 * Math.random() - 1;
		k = i * i + j * j;
	} while (k >= 1);
	k = Math.sqrt((-2 * Math.log(k)) / k);
	return i * k;
}

/**
 * Calculates the mean of an Array of numbers.
 *
 * @return The mean of the numbers in the Array
 */
dojo.math.mean = function () {
	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
	var mean = 0;
	for (var i = 0; i < array.length; i++) { mean += array[i]; }
	return mean / array.length;
}

/**
 * Extends Math.round by adding a second argument specifying the number of
 * decimal places to round to.
 *
 * @param number The number to round
 * @param places The number of decimal places to round to
 * @return The rounded number
 */
// TODO: add support for significant figures
dojo.math.round = function (number, places) {
	if (!places) { var shift = 1; }
	else { var shift = Math.pow(10, places); }
	return Math.round(number * shift) / shift;
}

/**
 * Calculates the standard deviation of an Array of numbers
 *
 * @return The standard deviation of the numbers
 */
dojo.math.sd = function () {
	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
	return Math.sqrt(dojo.math.variance(array));
}

/**
 * Calculates the variance of an Array of numbers
 *
 * @return The variance of the numbers
 */
dojo.math.variance = function () {
	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
	var mean = 0, squares = 0;
	for (var i = 0; i < array.length; i++) {
		mean += array[i];
		squares += Math.pow(array[i], 2);
	}
	return (squares / array.length)
		- Math.pow(mean / array.length, 2);
}

/**
 * Like range() in python
**/
dojo.math.range = function(a, b, step) {
    if(arguments.length < 2) {
        b = a;
        a = 0;
    }
    if(arguments.length < 3) {
        step = 1;
    }

    var range = [];
    if(step > 0) {
        for(var i = a; i < b; i += step) {
            range.push(i);
        }
    } else if(step < 0) {
        for(var i = a; i > b; i += step) {
            range.push(i);
        }
    } else {
        throw new Error("dojo.math.range: step must be non-zero");
    }
    return range;
}

__CPAN_FILE__ src/profile.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.profile");

dojo.profile = new function(){
	var profiles = {};
	var pns = [];

	this.start = function(name){
		if(!profiles[name]){
			profiles[name] = {iters: 0, total: 0};
			pns[pns.length] = name;
		}else{
			if(profiles[name]["start"]){
				this.end(name);
			}
		}
		profiles[name].end = null;
		profiles[name].start = new Date();
	}

	this.end = function(name){
		var ed = new Date();
		if((profiles[name])&&(profiles[name]["start"])){
			with(profiles[name]){
				end = ed;
				total += (end - start);
				start = null;
				iters++;
			}
		}else{
			// oops! bad call to end(), what should we do here?
			return true;
		}
	}

	this.stop = this.end;

	this.dump = function(appendToDoc){
		var tbl = document.createElement("table");
		with(tbl.style){
			border = "1px solid black";
			borderCollapse = "collapse";
		}
		var hdr = tbl.createTHead();
		var hdrtr = hdr.insertRow(0);
		// document.createElement("tr");
		var cols = ["Identifier","Calls","Total","Avg"];
		for(var x=0; x<cols.length; x++){
			var ntd = hdrtr.insertCell(x);
			with(ntd.style){
				backgroundColor = "#225d94";
				color = "white";
				borderBottom = "1px solid black";
				borderRight = "1px solid black";
				fontFamily = "tahoma";
				fontWeight = "bolder";
				paddingLeft = paddingRight = "5px";
			}
			ntd.appendChild(document.createTextNode(cols[x]));
		}

		for(var x=0; x < pns.length; x++){
			var prf = profiles[pns[x]];
			this.end(pns[x]);
			if(prf.iters>0){
				var bdytr = tbl.insertRow(true);
				var vals = [pns[x], prf.iters, prf.total, parseInt(prf.total/prf.iters)];
				for(var y=0; y<vals.length; y++){
					var cc = bdytr.insertCell(y);
					cc.appendChild(document.createTextNode(vals[y]));
					with(cc.style){
						borderBottom = "1px solid gray";
						paddingLeft = paddingRight = "5px";
						if(x%2){
							backgroundColor = "#e1f1ff";
						}
						if(y>0){
							textAlign = "right";
							borderRight = "1px solid gray";
						}else{
							borderRight = "1px solid black";
						}
					}
				}
			}
		}

		if(appendToDoc){
			var ne = document.createElement("div");
			ne.id = "profileOutputTable";
			with(ne.style){
				fontFamily = "Courier New, monospace";
				fontSize = "12px";
				lineHeight = "16px";
				borderTop = "1px solid black";
				padding = "10px";
			}
			if(document.getElementById("profileOutputTable")){
				document.body.replaceChild(ne, document.getElementById("profileOutputTable"));
			}else{
				document.body.appendChild(ne);
			}
			ne.appendChild(tbl);
		}

		return tbl;
	}
}

__CPAN_FILE__ src/regexp.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.regexp");
dojo.provide("dojo.regexp.us");

// *** Regular Expression Generators ***

/**
  Builds a RE that matches a top-level domain.

  @param flags  An object.
    flags.allowCC  Include 2 letter country code domains.  Default is true.
    flags.allowGeneric  Include the generic domains.  Default is true.
    flags.allowInfra  Include infrastructure domains.  Default is true.

  @return  A string for a regular expression for a top-level domain.
*/
dojo.regexp.tld = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.allowCC != "boolean") { flags.allowCC = true; }
	if (typeof flags.allowInfra != "boolean") { flags.allowInfra = true; }
	if (typeof flags.allowGeneric != "boolean") { flags.allowGeneric = true; }

	// Infrastructure top-level domain - only one at present
	var infraRE = "arpa";

	// Generic top-level domains RE.
	var genericRE = 
		"aero|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|xxx|jobs|mobi|post";
	
	// Country Code top-level domains RE
	var ccRE = 
		"ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|" +
		"bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|" +
		"ec|ee|eg|er|es|et|fi|fj|fk|fm|fo|fr|ga|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|" +
		"hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kr|kw|ky|kz|la|" +
		"lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|" +
		"mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|" +
		"ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sk|sl|sm|sn|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|" +
		"to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw";

	// Build top-level domain RE
	var a = [];
	if (flags.allowInfra) { a.push(infraRE); }
	if (flags.allowGeneric) { a.push(genericRE); }
	if (flags.allowCC) { a.push(ccRE); }

	var tldRE = "";
	if (a.length > 0) {
		tldRE = "(" + a.join("|") + ")";
	}

	return tldRE;
}

/**
  Builds a RE that matches an IP Address.
  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
  Supports 2 formats for Ipv6.

  @param flags  An object.  All flags are boolean with default = true.
    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
      Case insensitive.  Zero padding allowed.
    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d

  @return  A string for a regular expression for an IP address.
*/
dojo.regexp.ipAddress = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.allowDottedDecimal != "boolean") { flags.allowDottedDecimal = true; }
	if (typeof flags.allowDottedHex != "boolean") { flags.allowDottedHex = true; }
	if (typeof flags.allowDottedOctal != "boolean") { flags.allowDottedOctal = true; }
	if (typeof flags.allowDecimal != "boolean") { flags.allowDecimal = true; }
	if (typeof flags.allowHex != "boolean") { flags.allowHex = true; }
	if (typeof flags.allowIPv6 != "boolean") { flags.allowIPv6 = true; }
	if (typeof flags.allowHybrid != "boolean") { flags.allowHybrid = true; }

	// decimal-dotted IP address RE.
	var dottedDecimalRE = 
		// Each number is between 0-255.  Zero padding is not allowed.
		"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

	// dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.
	var dottedHexRE = "(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]";

	// dotted octal IP address RE.  Each number is between 0000-0377.  
	// Zero padding is allowed, but each number must have at least 4 characters.
	var dottedOctalRE = "(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]";

	// decimal IP address RE.  A decimal number between 0-4294967295.  
	var decimalRE =  "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" +
		"4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";

	// hexadecimal IP address RE. 
	// A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.
	var hexRE = "0[xX]0*[\\da-fA-F]{1,8}";

	// IPv6 address RE. 
	// The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,
	// where x is between 0000-ffff. Zero padding is optional. Case insensitive. 
	var ipv6RE = "([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}";

	// IPv6/IPv4 Hybrid address RE. 
	// The format is written as six groups of four hexadecimal digits, 
	// followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d
	var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" + 
		"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

	// Build IP Address RE
	var a = [];
	if (flags.allowDottedDecimal) { a.push(dottedDecimalRE); }
	if (flags.allowDottedHex) { a.push(dottedHexRE); }
	if (flags.allowDottedOctal) { a.push(dottedOctalRE); }
	if (flags.allowDecimal) { a.push(decimalRE); }
	if (flags.allowHex) { a.push(hexRE); }
	if (flags.allowIPv6) { a.push(ipv6RE); }
	if (flags.allowHybrid) { a.push(hybridRE); }

	var ipAddressRE = "";
	if (a.length > 0) {
		ipAddressRE = "(" + a.join("|") + ")";
	}

	return ipAddressRE;
}

/**
  Builds a RE that matches a host.
	A host is a domain name or an IP address, possibly followed by a port number.

  @param flags  An object.
    flags.allowIP  Allow an IP address for hostname.  Default is true.
    flags.allowLocal  Allow the host to be "localhost".  Default is false.
    flags.allowPort  Allow a port number to be present.  Default is true.
    flags in regexp.ipAddress can be applied.
    flags in regexp.tld can be applied.

  @return  A string for a regular expression for a host.
*/
dojo.regexp.host = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.allowIP != "boolean") { flags.allowIP = true; }
	if (typeof flags.allowLocal != "boolean") { flags.allowLocal = false; }
	if (typeof flags.allowPort != "boolean") { flags.allowPort = true; }

	// Domain names can not end with a dash.
	var domainNameRE = "([0-9a-zA-Z]([-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?\\.)+" + dojo.regexp.tld(flags);

	// port number RE
	portRE = ( flags.allowPort ) ? "(\\:" + dojo.regexp.integer({signed: false}) + ")?" : "";

	// build host RE
	var hostNameRE = domainNameRE;
	if (flags.allowIP) { hostNameRE += "|" +  dojo.regexp.ipAddress(flags); }
	if (flags.allowLocal) { hostNameRE += "|localhost"; }

	return "(" + hostNameRE + ")" + portRE;
}

/**
  Builds a regular expression that matches a URL.

  @param flags  An object.
    flags.scheme  Can be true, false, or [true, false]. 
      This means: required, not allowed, or match either one.
    flags in regexp.host can be applied.
    flags in regexp.ipAddress can be applied.
    flags in regexp.tld can be applied.

  @return  A string for a regular expression for a URL.
*/
dojo.regexp.url = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.scheme == "undefined") { flags.scheme = [true, false]; }

	// Scheme RE
	var protocalRE = dojo.regexp.buildGroupRE(flags.scheme,
		function(q) { if (q) { return "(https?|ftps?)\\://"; }  return ""; }
	);

	// Path and query and anchor RE
	var pathRE = "(/([^?#\\s/]+/)*)?([^?#\\s/]+(\\?[^?#\\s/]*)?(#[A-Za-z][\\w.:-]*)?)?";

	return (protocalRE + dojo.regexp.host(flags) + pathRE);
}

/**
  Builds a regular expression that matches an email address.

  @param flags  An object.
    flags.allowCruft  Allow address like <mailto:foo@yahoo.com>.  Default is false.
    flags in regexp.host can be applied.
    flags in regexp.ipAddress can be applied.
    flags in regexp.tld can be applied.

  @return  A string for a regular expression for an email address.
*/
dojo.regexp.emailAddress = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.allowCruft != "boolean") { flags.allowCruft = false; }
	flags.allowPort = false; // invalid in email addresses

	// user name RE - apostrophes are valid if there's not 2 in a row
	var usernameRE = "([\\da-z]+[-._+&'])*[\\da-z]+";

	// build emailAddress RE
	var emailAddressRE = usernameRE + "@" + dojo.regexp.host(flags);

	// Allow email addresses with cruft
	if ( flags.allowCruft ) {
		emailAddressRE = "<?(mailto\\:)?" + emailAddressRE + ">?";
	}

	return emailAddressRE;
}

/**
  Builds a regular expression that matches a list of email addresses.

  @param flags  An object.
    flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
    flags in regexp.emailAddress can be applied.
    flags in regexp.host can be applied.
    flags in regexp.ipAddress can be applied.
    flags in regexp.tld can be applied.

  @return  A string for a regular expression for an email address list.
*/
dojo.regexp.emailAddressList = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.listSeparator != "string") { flags.listSeparator = "\\s;,"; }

	// build a RE for an Email Address List
	var emailAddressRE = dojo.regexp.emailAddress(flags);
	var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" + 
		emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";

	return emailAddressListRE;
}

/**
  Builds a regular expression that matches an integer.

  @param flags  An object.
    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. will match if it is signed or unsigned).
    flags.separator  The character used as the thousands separator.  Default is no separator.
      For more than one symbol use an array, e.g. [",", ""], makes ',' optional.

  @return  A string for a regular expression for an integer.
*/
dojo.regexp.integer = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.signed == "undefined") { flags.signed = [true, false]; }
	if (typeof flags.separator == "undefined") { flags.separator = ""; }

	// build sign RE
	var signRE = dojo.regexp.buildGroupRE(flags.signed,
		function(q) { if (q) { return "[-+]"; }  return ""; }
	);

	// number RE
	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
		function(sep) { 
			if ( sep == "" ) { 
				return "(0|[1-9]\\d*)"; 
			}
			return "(0|[1-9]\\d{0,2}([" + sep + "]\\d{3})*)"; 
		}
	);
	var numberRE;

	// integer RE
	return (signRE + numberRE);
}

/**
  Builds a regular expression to match a real number in exponential notation.

  @param flags  An object.
    flags.places  The integer number of decimal places.
      If not given, the decimal part is optional and the number of places is unlimited.
    flags.decimal  A string for the character used as the decimal point.  Default is ".".
    flags.exponent  Express in exponential notation.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. will match if the exponential part is present are not).
    flags.eSigned  The leading plus-or-minus sign on the exponent.  Can be true, false, 
      or [true, false].  Default is [true, false], (i.e. will match if it is signed or unsigned).
    flags in regexp.integer can be applied.

  @return  A string for a regular expression for a real number.
*/
dojo.regexp.realNumber = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.places != "number") { flags.places = Infinity; }
	if (typeof flags.decimal != "string") { flags.decimal = "."; }
	if (typeof flags.exponent == "undefined") { flags.exponent = [true, false]; }
	if (typeof flags.eSigned == "undefined") { flags.eSigned = [true, false]; }

	// integer RE
	var integerRE = dojo.regexp.integer(flags);

	// decimal RE
	var decimalRE = "";
	if ( flags.places == Infinity) { 
		decimalRE = "(\\" + flags.decimal + "\\d+)?"; 
	}
	else if ( flags.places > 0) { 
		decimalRE = "\\" + flags.decimal + "\\d{" + flags.places + "}"; 
	}

	// exponent RE
	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
		function(q) { 
			if (q) { return "([eE]" + dojo.regexp.integer({signed: flags.eSigned}) + ")"; }
			return ""; 
		}
	);

	// real number RE
	return (integerRE + decimalRE + exponentRE);
}

/**
  Builds a regular expression to match a monetary value.

  @param flags  An object.
    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. will match if it is signed or unsigned).
    flags.symbol  A currency symbol such as Yen "", Pound "", or the Euro sign "".  
      Default is "$".  For more than one symbol use an array, e.g. ["$", ""], makes $ optional.
    flags.placement  The symbol can come "before" the number or "after".  Default is "before".
    flags.separator  The character used as the thousands separator. The default is ",".
    flags.cents  The two decimal places for cents.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. will match if cents are present are not).
    flags.decimal  A string for the character used as the decimal point.  Default is ".".

  @return  A string for a regular expression for a monetary value.
*/
dojo.regexp.currency = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.signed == "undefined") { flags.signed = [true, false]; }
	if (typeof flags.symbol == "undefined") { flags.symbol = "$"; }
	if (typeof flags.placement != "string") { flags.placement = "before"; }
	if (typeof flags.separator != "string") { flags.separator = ","; }
	if (typeof flags.cents == "undefined") { flags.cents = [true, false]; }
	if (typeof flags.decimal != "string") { flags.decimal = "."; }

	// build sign RE
	var signRE = dojo.regexp.buildGroupRE(flags.signed,
		function(q) { if (q) { return "[-+]"; }  return ""; }
	);

	// build symbol RE
	var symbolRE = dojo.regexp.buildGroupRE(flags.symbol,
		function(symbol) { 
			// escape all special characters
			return "\\s?" + symbol.replace( /([.$?*!=:|\\\/^])/g, "\\$1") + "\\s?";
		}
	);

	// number RE
	var numberRE = dojo.regexp.integer( {signed: false, separator: flags.separator} );

	// build cents RE
	var centsRE = dojo.regexp.buildGroupRE(flags.cents,
		function(q) { if (q) { return "(\\" + flags.decimal + "\\d\\d)"; }  return ""; }
	);

	// build currency RE
	var currencyRE;
	if (flags.placement == "before") {
		currencyRE = signRE + symbolRE + numberRE + centsRE;
	}
	else {
		currencyRE = signRE + numberRE + centsRE + symbolRE;
	}

	return currencyRE;
}

/**
  A regular expression to match US state and territory abbreviations.

  @param flags  An object.
    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.

  @return  A string for a regular expression for a US state.
*/
dojo.regexp.us.state = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.allowTerritories != "boolean") { flags.allowTerritories = true; }
	if (typeof flags.allowMilitary != "boolean") { flags.allowMilitary = true; }

	// state RE
	var statesRE = 
		"AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" + 
		"NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";

	// territories RE
	var territoriesRE = "AS|FM|GU|MH|MP|PW|PR|VI";

	// military states RE
	var militaryRE = "AA|AE|AP";

	// Build states and territories RE
	if (flags.allowTerritories) { statesRE += "|" + territoriesRE; }
	if (flags.allowMilitary) { statesRE += "|" + militaryRE; }

	return "(" + statesRE + ")";
}

/**
  Builds a regular expression to match any International format for time.
  The RE can match one format or one of multiple formats.

  Format
  h        12 hour, no zero padding.
  hh       12 hour, has leading zero.
  H        24 hour, no zero padding.
  HH       24 hour, has leading zero.
  m        minutes, no zero padding.
  mm       minutes, has leading zero.
  s        seconds, no zero padding.
  ss       seconds, has leading zero.
  t        am or pm, case insensitive.
  All other characters must appear literally in the expression.

  Example
    "h:m:s t"  ->   2:5:33 PM
    "HH:mm:ss" ->  14:05:33

  @param flags  An object.
    flags.format  A string or an array of strings.  Default is "h:mm:ss t".
    flags.amSymbol  The symbol used for AM.  Default is "AM".
    flags.pmSymbol  The symbol used for PM.  Default is "PM".

  @return  A string for a regular expression for a time value.
*/
dojo.regexp.time = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.format == "undefined") { flags.format = "h:mm:ss t"; }
	if (typeof flags.amSymbol != "string") { flags.amSymbol = "AM"; }
	if (typeof flags.pmSymbol != "string") { flags.pmSymbol = "PM"; }

	// Converts a time format to a RE
	var timeRE = function(format) {
		// escape all special characters
		format = format.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
		var amRE = flags.amSymbol.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
		var pmRE = flags.pmSymbol.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");

		// replace tokens with Regular Expressions
		format = format.replace("hh", "(0[1-9]|1[0-2])");
		format = format.replace("h", "([1-9]|1[0-2])");
		format = format.replace("HH", "([01][0-9]|2[0-3])");
		format = format.replace("H", "([0-9]|1[0-9]|2[0-3])");
		format = format.replace("mm", "([0-5][0-9])");
		format = format.replace("m", "([1-5][0-9]|[0-9])");
		format = format.replace("ss", "([0-5][0-9])");
		format = format.replace("s", "([1-5][0-9]|[0-9])");
		format = format.replace("t", "\\s?(" + amRE + "|" + pmRE + ")\\s?" );

		return format;
	};

	// build RE for multiple time formats
	return dojo.regexp.buildGroupRE(flags.format, timeRE);
}

/**
  Builds a regular expression to match any sort of number based format.
  Use it for phone numbers, social security numbers, zip-codes, etc.
  The RE can match one format or one of multiple formats.

  Format
    #        Stands for a digit, 0-9.
    ?        Stands for an optional digit, 0-9 or nothing.
    All other characters must appear literally in the expression.

  Example   
    "(###) ###-####"       ->   (510) 542-9742
    "(###) ###-#### x#???" ->   (510) 542-9742 x153
    "###-##-####"          ->   506-82-1089       i.e. social security number
    "#####-####"           ->   98225-1649        i.e. zip code

  @param flags  An object.
    flags.format  A string or an Array of strings for multiple formats.
  @return  A string for a regular expression for the number format(s).
*/
dojo.regexp.numberFormat = function(flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	if (typeof flags.format == "undefined") { flags.format = "###-###-####"; }

	// Converts a number format to RE.
	var digitRE = function(format) {
		// escape all special characters, except '?'
		format = format.replace( /([.$*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");

		// Now replace '?' with Regular Expression
		format = format.replace(/\?/g, "\\d?");

		// replace # with Regular Expression
		format = format.replace(/#/g, "\\d");

		return format;
	};

	// build RE for multiple number formats
	return dojo.regexp.buildGroupRE(flags.format, digitRE);
}


/**
  This is basically a utility function used by some of the RE generators.
  Builds a regular expression that groups subexpressions.
  The subexpressions are constructed by the function, re, in the second parameter.
  re builds one subexpression for each elem in the array a, in the first parameter.

  @param a  A single value or an array of values.
  @param re  A function.  Takes one parameter and converts it to a regular expression. 
  @return  A string for a regular expression that groups all the subexpressions.
*/
dojo.regexp.buildGroupRE = function(a, re) {

	// case 1: a is a single value.
	if ( !( a instanceof Array ) ) { 
		return re(a);
	}

	// case 2: a is an array
	var b = [];
	for (var i = 0; i < a.length; i++) {
		// convert each elem to a RE
		b.push(re(a[i]));
	}

	 // join the REs as alternatives in a RE group.
	return "(" + b.join("|") + ")";
}

__CPAN_FILE__ src/storage.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/** 
		FIXME: Write better docs.

		@author Alex Russel, alex@dojotoolkit.org
		@author Brad Neuberg, bkn3@columbia.edu 
*/
dojo.provide("dojo.storage");
dojo.provide("dojo.storage.StorageProvider");

dojo.require("dojo.lang.*");
dojo.require("dojo.event.*");


/** The base class for all storage providers. */

/** 
	 The constructor for a storage provider. You should avoid initialization
	 in the constructor; instead, define initialization in your initialize()
	 method. 
*/
dojo.storage = function(){
}

dojo.lang.extend(dojo.storage, {
	/** A put() call to a storage provider was succesful. */
	SUCCESS: "success",
	
	/** A put() call to a storage provider failed. */
	FAILED: "failed",
	
	/** A put() call to a storage provider is pending user approval. */
	PENDING: "pending",
	
	/** 
	  Returned by getMaximumSize() if this storage provider can not determine
	  the maximum amount of data it can support. 
	*/
	SIZE_NOT_AVAILABLE: "Size not available",
	
	/**
	  Returned by getMaximumSize() if this storage provider has no theoretical
	  limit on the amount of data it can store. 
	*/
	SIZE_NO_LIMIT: "No size limit",
	
	/** 
	  The namespace for all storage operations. This is useful if
	  several applications want access to the storage system from the same
	  domain but want different storage silos. 
	*/
	namespace: "dojoStorage",
	
	/**  
	  If a function is assigned to this property, then 
	  when the settings provider's UI is closed this
	  function is called. Useful, for example, if the
	  user has just cleared out all storage for this
	  provider using the settings UI, and you want to 
	  update your UI.
	*/
	onHideSettingsUI: null,

	/** 
	  Allows this storage provider to initialize itself. This is called
	  after the page has finished loading, so you can not do document.writes(). 
	*/
	initialize: function(){
	 dojo.unimplemented("dojo.storage.initialize");
	},
	
	/** 
	  Returns whether this storage provider is 
	  available on this platform. 
	
	  @returns True or false if this storage 
	  provider is supported.
	*/
	isAvailable: function(){
		dojo.unimplemented("dojo.storage.isAvailable");
	},
	
	/**
	  Puts a key and value into this storage system.

	  @param key A string key to use when retrieving 
	         this value in the future.
	  @param value A value to store; this can be 
	         any JavaScript type.
	  @param resultsHandler A callback function 
	         that will receive three arguments.
	         The first argument is one of three 
	         values: dojo.storage.SUCCESS,
	         dojo.storage.FAILED, or 
	         dojo.storage.PENDING; these values 
	         determine how the put request went. 
	         In some storage systems users can deny
	         a storage request, resulting in a 
	         dojo.storage.FAILED, while in 
	         other storage systems a storage 
	         request must wait for user approval,
	         resulting in a dojo.storage.PENDING 
	         status until the request
	         is either approved or denied, 
	         resulting in another call back
	         with dojo.storage.SUCCESS. 
  
	  The second argument in the call back is the key name
	  that was being stored.
	  
	  The third argument in the call back is an 
	  optional message that details possible error 
	  messages that might have occurred during
	  the storage process.

	  Example:
	    var resultsHandler = function(status, key, message){
	      alert("status="+status+", key="+key+", message="+message);
	    };
	    dojo.storage.put("test", "hello world", 
	                     resultsHandler);	
	*/
	put: function(key, value, resultsHandler){ 
    dojo.unimplemented("dojo.storage.put");
  },

	/**
	  Gets the value with the given key. Returns null
	  if this key is not in the storage system.
	
	  @param key A string key to get the value of.
	  @returns Returns any JavaScript object type; 
	  null if the key is not
	  present. 
	*/
	get: function(key){
    dojo.unimplemented("dojo.storage.get");
  },

	/**
	  Determines whether the storage has the given 
	  key. 
	
	    @returns Whether this key is 
	             present or not. 
	*/
	hasKey: function(key){
		if (this.get(key) != null)
			return true;
		else
			return false;
	},

	/**
	  Enumerates all of the available keys in 
	  this storage system.
	
	  @returns Array of string keys in this 
	           storage system.
	*/
	getKeys: function(){
    dojo.unimplemented("dojo.storage.getKeys");
  },

	/**
	  Completely clears this storage system of all 
	  of it's values and keys. 
	*/
	clear: function(){
    dojo.unimplemented("dojo.storage.clear");
  },
  
  /** Removes the given key from the storage system. */
  remove: function(key){
  	dojo.unimplemented("dojo.storage.remove");
  },

	/**
	  Returns whether this storage provider's 
	  values are persisted when this platform 
	  is shutdown. 
	
	  @returns True or false whether this 
	  storage is permanent. 
	*/
	isPermanent: function(){
		dojo.unimplemented("dojo.storage.isPermanent");
	},

	/**
	  The maximum storage allowed by this provider.
	
	  @returns Returns the maximum storage size 
	           supported by this provider, in 
	           thousands of bytes (i.e., if it 
	           returns 60 then this means that 60K 
	           of storage is supported).
	    
	           If this provider can not determine 
	           it's maximum size, then 
	           dojo.storage.SIZE_NOT_AVAILABLE is 
	           returned; if there is no theoretical
	           limit on the amount of storage 
	           this provider can return, then
	           dojo.storage.SIZE_NO_LIMIT is 
	           returned
	*/
	getMaximumSize: function(){
    dojo.unimplemented("dojo.storage.getMaximumSize");
  },

	/**
	  Determines whether this provider has a 
	  settings UI.
	
	  @returns True or false if this provider has 
	           the ability to show a
	           a settings UI to change it's 
	           values, change the amount of storage
	           available, etc. 
	*/
	hasSettingsUI: function(){
		return false;
	},

	/**
	  If this provider has a settings UI, it is 
	  shown. 
	*/
	showSettingsUI: function(){
	 dojo.unimplemented("dojo.storage.showSettingsUI");
	},

	/**
	  If this provider has a settings UI, hides
	  it.
	*/
	hideSettingsUI: function(){
	 dojo.unimplemented("dojo.storage.hideSettingsUI");
	},
	
	/** 
	  The provider name as a string, such as 
	  "dojo.storage.FlashStorageProvider". 
	*/
	getType: function(){
		dojo.unimplemented("dojo.storage.getType");
	},
	
	/**
	  Subclasses can call this to ensure that the key given is valid in a
	  consistent way across different storage providers. We use the lowest
	  common denominator for key values allowed: only letters, numbers, and
	  underscores are allowed. No spaces. 
	*/
	isValidKey: function(keyName){
		if (keyName == null || typeof keyName == "undefined")
			return false;
			
		return /^[0-9A-Za-z_]*$/.test(keyName);
  }
});




/**
	Initializes the storage systems and figures out the best available 
	storage options on this platform.
*/
dojo.storage.manager = new function(){
	this.currentProvider = null;
	this.available = false;
	this.initialized = false;
	this.providers = new Array();
	
	// TODO: Provide a way for applications to override the default namespace
	this.namespace = "dojo.storage";
	
	/** Initializes the storage system. */
	this.initialize = function(){
		// autodetect the best storage provider we can provide on this platform
		this.autodetect();
	}
	
	/**
	  Registers the existence of a new storage provider; used by subclasses
	  to inform the manager of their existence. 
	
	  @param name The full class name of this provider, such as 
	  "dojo.storage.browser.Flash6StorageProvider".
	  @param instance An instance of this provider, which we will use to
	  call isAvailable() on. 
	*/
	this.register = function(name, instance) {
		this.providers[this.providers.length] = instance;
		this.providers[name] = instance;
	}
	
	/**
	  Instructs the storageManager to use 
	  the given storage class for all storage requests.
	    
	  Example:
	    
	  dojo.storage.setProvider(
	         dojo.storage.browser.IEStorageProvider)
	*/
	this.setProvider = function(storageClass){
	
	}
	
	/** 
	  Autodetects the best possible persistent
	  storage provider available on this platform. 
	*/
	this.autodetect = function(){
		if(this.initialized == true) // already finished
			return;
			
		// go through each provider, seeing if it can be used
		var providerToUse = null;
		for(var i = 0; i < this.providers.length; i++) {
			providerToUse = this.providers[i];
			if(providerToUse.isAvailable()){
				break;
			}
		}	
		
		if(providerToUse == null){ // no provider available
			this.initialized = true;
			this.available = false;
			this.currentProvider = null;
			dojo.raise("No storage provider found for this platform");
		}
			
		// create this provider and copy over it's properties
		this.currentProvider = providerToUse;
	  	for(var i in providerToUse){
	  		dojo.storage[i] = providerToUse[i];
		}
		dojo.storage.manager = this;
		
		// have the provider initialize itself
		dojo.storage.initialize();
		
		this.initialized = true;
		this.available = true;
	}
	
	/** Returns whether any storage options are available. */
	this.isAvailable = function(){
		return this.available;
	}
	
	/** 
	 	Returns whether the storage system is initialized and
	 	ready to be used. 
	*/
	this.isInitialized = function(){
		// FIXME: This should _really_ not be in here, but it fixes a bug
		if(dojo.flash.ready == false){
			return false;
		}else{
			return this.initialized;
		}
	}

	/**
	  Determines if this platform supports
	  the given storage provider.
	
	  Example:
			
	  dojo.storage.manager.supportsProvider(
	    "dojo.storage.browser.InternetExplorerStorageProvider");
	*/
	this.supportsProvider = function(storageClass){
		// construct this class dynamically
		try{
			// dynamically call the given providers class level isAvailable()
			// method
			var provider = eval("new " + storageClass + "()");
			var results = provider.isAvailable();
			if(results == null || typeof results == "undefined")
				return false;
			return results;
		}catch (exception){
			dojo.debug("exception="+exception);
			return false;
		}
	}

	/** Gets the current provider. */
	this.getProvider = function(){
		return this.currentProvider;
	}
	
	/** 
	  The storage provider should call this method when it is loaded and
	  ready to be used. Clients who will use the provider will connect
	  to this method to know when they can use the storage system:
	
	  dojo.connect(dojo.storage.manager, "loaded", someInstance, 
	               someInstance.someMethod);
	*/
	this.loaded = function(){
	}
}

__CPAN_FILE__ src/string.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.string");
dojo.require("dojo.string.common");

__CPAN_FILE__ src/style.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.style");
dojo.require("dojo.graphics.color");
dojo.require("dojo.uri.Uri");
dojo.require("dojo.lang.common");

(function(){
	var h = dojo.render.html;
	var ds = dojo.style;
	var db = document["body"]||document["documentElement"];

	ds.boxSizing = {
		MARGIN_BOX: "margin-box",
		BORDER_BOX: "border-box",
		PADDING_BOX: "padding-box",
		CONTENT_BOX: "content-box"
	};
	var bs = ds.boxSizing;
	
	ds.getBoxSizing = function(node){
		if((h.ie)||(h.opera)){ 
			var cm = document["compatMode"];
			if((cm == "BackCompat")||(cm == "QuirksMode")){ 
				return bs.BORDER_BOX; 
			}else{
				return bs.CONTENT_BOX; 
			}
		}else{
			if(arguments.length == 0){ node = document.documentElement; }
			var sizing = ds.getStyle(node, "-moz-box-sizing");
			if(!sizing){ sizing = ds.getStyle(node, "box-sizing"); }
			return (sizing ? sizing : bs.CONTENT_BOX);
		}
	}

	/*

	The following several function use the dimensions shown below

		+-------------------------+
		|  margin                 |
		| +---------------------+ |
		| |  border             | |
		| | +-----------------+ | |
		| | |  padding        | | |
		| | | +-------------+ | | |
		| | | |   content   | | | |
		| | | +-------------+ | | |
		| | +-|-------------|-+ | |
		| +-|-|-------------|-|-+ |
		+-|-|-|-------------|-|-|-+
		| | | |             | | | |
		| | | |<- content ->| | | |
		| |<------ inner ------>| |
		|<-------- outer -------->|
		+-------------------------+

		* content-box

		|m|b|p|             |p|b|m|
		| |<------ offset ----->| |
		| | |<---- client --->| | |
		| | | |<-- width -->| | | |

		* border-box

		|m|b|p|             |p|b|m|
		| |<------ offset ----->| |
		| | |<---- client --->| | |
		| |<------ width ------>| |
	*/

	/*
		Notes:

		General:
			- Uncomputable values are returned as NaN.
			- setOuterWidth/Height return *false* if the outer size could not
			  be computed, otherwise *true*.
			- (sjmiles) knows no way to find the calculated values for auto-margins. 
			- All returned values are floating point in 'px' units. If a
			  non-zero computed style value is not specified in 'px', NaN is
			  returned.

		FF:
			- styles specified as '0' (unitless 0) show computed as '0pt'.

		IE:
			- clientWidth/Height are unreliable (0 unless the object has 'layout').
			- margins must be specified in px, or 0 (in any unit) for any
			  sizing function to work. Otherwise margins detect as 'auto'.
			- padding can be empty or, if specified, must be in px, or 0 (in
			  any unit) for any sizing function to work.

		Safari:
			- Safari defaults padding values to 'auto'.

		See the unit tests for examples of (un)computable values in a given browser.

	*/

	// FIXME: these work for some elements (e.g. DIV) but not others (e.g. TABLE, TEXTAREA)

	ds.isBorderBox = function(node){
		return (ds.getBoxSizing(node) == bs.BORDER_BOX);
	}

	ds.getUnitValue = function(node, cssSelector, autoIsZero){
		var s = ds.getComputedStyle(node, cssSelector);
		if((!s)||((s == 'auto')&&(autoIsZero))){ return { value: 0, units: 'px' }; }
		if(dojo.lang.isUndefined(s)){return ds.getUnitValue.bad;}
		// FIXME: is regex inefficient vs. parseInt or some manual test? 
		var match = s.match(/(\-?[\d.]+)([a-z%]*)/i);
		if (!match){return ds.getUnitValue.bad;}
		return { value: Number(match[1]), units: match[2].toLowerCase() };
	}
	// FIXME: 'bad' value should be 0?
	ds.getUnitValue.bad = { value: NaN, units: '' };
	
	ds.getPixelValue = function(node, cssSelector, autoIsZero){
		var result = ds.getUnitValue(node, cssSelector, autoIsZero);
		// FIXME: there is serious debate as to whether or not this is the right solution
		if(isNaN(result.value)){ return 0; }
		// FIXME: code exists for converting other units to px (see Dean Edward's IE7) 
		// but there are cross-browser complexities
		if((result.value)&&(result.units != 'px')){ return NaN; }
		return result.value;
	}
	
	// FIXME: deprecated
	ds.getNumericStyle = function() {
		dojo.deprecated('dojo.(style|html).getNumericStyle', 'in favor of dojo.(style|html).getPixelValue', '0.4');
		return ds.getPixelValue.apply(this, arguments); 
	}

	ds.setPositivePixelValue = function(node, selector, value){
		if(isNaN(value)){return false;}
		node.style[selector] = Math.max(0, value) + 'px'; 
		return true;
	}
	
	ds._sumPixelValues = function(node, selectors, autoIsZero){
		var total = 0;
		for(x=0; x<selectors.length; x++){
			total += ds.getPixelValue(node, selectors[x], autoIsZero);
		}
		return total;
	}

	ds.isPositionAbsolute = function(node){
		return (ds.getComputedStyle(node, 'position') == 'absolute');
	}

	ds.getBorderExtent = function(node, side){
		return (ds.getStyle(node, 'border-' + side + '-style') == 'none' ? 0 : ds.getPixelValue(node, 'border-' + side + '-width'));
	}

	ds.getMarginWidth = function(node){
		return ds._sumPixelValues(node, ["margin-left", "margin-right"], ds.isPositionAbsolute(node));
	}

	ds.getBorderWidth = function(node){
		return ds.getBorderExtent(node, 'left') + ds.getBorderExtent(node, 'right');
	}

	ds.getPaddingWidth = function(node){
		return ds._sumPixelValues(node, ["padding-left", "padding-right"], true);
	}

	ds.getPadBorderWidth = function(node) {
		return ds.getPaddingWidth(node) + ds.getBorderWidth(node);
	}
	
	ds.getContentBoxWidth = function(node){
		node = dojo.byId(node);
		return node.offsetWidth - ds.getPadBorderWidth(node);
	}

	ds.getBorderBoxWidth = function(node){
		node = dojo.byId(node);
		return node.offsetWidth;
	}

	ds.getMarginBoxWidth = function(node){
		return ds.getInnerWidth(node) + ds.getMarginWidth(node);
	}

	ds.setContentBoxWidth = function(node, pxWidth){
		node = dojo.byId(node);
		if (ds.isBorderBox(node)){
			pxWidth += ds.getPadBorderWidth(node);
		}
		return ds.setPositivePixelValue(node, "width", pxWidth);
	}

	ds.setMarginBoxWidth = function(node, pxWidth){
		node = dojo.byId(node);
		if (!ds.isBorderBox(node)){
			pxWidth -= ds.getPadBorderWidth(node);
		}
		pxWidth -= ds.getMarginWidth(node);
		return ds.setPositivePixelValue(node, "width", pxWidth);
	}

	// FIXME: deprecate and remove
	ds.getContentWidth = ds.getContentBoxWidth;
	ds.getInnerWidth = ds.getBorderBoxWidth;
	ds.getOuterWidth = ds.getMarginBoxWidth;
	ds.setContentWidth = ds.setContentBoxWidth;
	ds.setOuterWidth = ds.setMarginBoxWidth;

	ds.getMarginHeight = function(node){
		return ds._sumPixelValues(node, ["margin-top", "margin-bottom"], ds.isPositionAbsolute(node));
	}

	ds.getBorderHeight = function(node){
		return ds.getBorderExtent(node, 'top') + ds.getBorderExtent(node, 'bottom');
	}

	ds.getPaddingHeight = function(node){
		return ds._sumPixelValues(node, ["padding-top", "padding-bottom"], true);
	}

	ds.getPadBorderHeight = function(node) {
		return ds.getPaddingHeight(node) + ds.getBorderHeight(node);
	}
	
	ds.getContentBoxHeight = function(node){
		node = dojo.byId(node);
		return node.offsetHeight - ds.getPadBorderHeight(node);
	}

	ds.getBorderBoxHeight = function(node){
		node = dojo.byId(node);
		return node.offsetHeight; // FIXME: does this work?
	}

	ds.getMarginBoxHeight = function(node){
		return ds.getInnerHeight(node) + ds.getMarginHeight(node);
	}

	ds.setContentBoxHeight = function(node, pxHeight){
		node = dojo.byId(node);
		if (ds.isBorderBox(node)){
			pxHeight += ds.getPadBorderHeight(node);
		}
		return ds.setPositivePixelValue(node, "height", pxHeight);
	}

	ds.setMarginBoxHeight = function(node, pxHeight){
		node = dojo.byId(node);
		if (!ds.isBorderBox(node)){
			pxHeight -= ds.getPadBorderHeight(node);
		}
		pxHeight -= ds.getMarginHeight(node);
		return ds.setPositivePixelValue(node, "height", pxHeight);
	}

	// FIXME: deprecate and remove
	ds.getContentHeight = ds.getContentBoxHeight;
	ds.getInnerHeight = ds.getBorderBoxHeight;
	ds.getOuterHeight = ds.getMarginBoxHeight;
	ds.setContentHeight = ds.setContentBoxHeight;
	ds.setOuterHeight = ds.setMarginBoxHeight;

	/**
	 * dojo.style.getAbsolutePosition(xyz, true) returns xyz's position relative to the document.
	 * Itells you where you would position a node
	 * inside document.body such that it was on top of xyz.  Most people set the flag to true when calling
	 * getAbsolutePosition().
	 *
	 * dojo.style.getAbsolutePosition(xyz, false) returns xyz's position relative to the viewport.
	 * It returns the position that would be returned
	 * by event.clientX/Y if the mouse were directly over the top/left of this node.
	 */
	ds.getAbsolutePosition = ds.abs = function(node, includeScroll){
		var ret = [];
		ret.x = ret.y = 0;
		var st = dojo.html.getScrollTop();
		var sl = dojo.html.getScrollLeft();

		if(h.ie){
			with(node.getBoundingClientRect()){
				ret.x = left-2;
				ret.y = top-2;
			}
/**
		}else if(document.getBoxObjectFor){
			// mozilla
			var bo=document.getBoxObjectFor(node);
			ret.x=bo.x-sl;
			ret.y=bo.y-st;
**/		}else{
			if(node["offsetParent"]){
				var endNode;		
				// in Safari, if the node is an absolutely positioned child of
				// the body and the body has a margin the offset of the child
				// and the body contain the body's margins, so we need to end
				// at the body
				if(	(h.safari)&&
					(node.style.getPropertyValue("position") == "absolute")&&
					(node.parentNode == db)){
					endNode = db;
				}else{
					endNode = db.parentNode;
				}
				
				if(node.parentNode != db){
					ret.x -= ds.sumAncestorProperties(node, "scrollLeft");
					ret.y -= ds.sumAncestorProperties(node, "scrollTop");
				}
				do{
					var n = node["offsetLeft"];
					ret.x += isNaN(n) ? 0 : n;
					var m = node["offsetTop"];
					ret.y += isNaN(m) ? 0 : m;
					node = node.offsetParent;
				}while((node != endNode)&&(node != null));
			}else if(node["x"]&&node["y"]){
				ret.x += isNaN(node.x) ? 0 : node.x;
				ret.y += isNaN(node.y) ? 0 : node.y;
			}
		}

		// account for document scrolling!
		if(includeScroll){
			ret.y += st;
			ret.x += sl;
		}

		ret[0] = ret.x;
		ret[1] = ret.y;
		return ret;
	}

	ds.sumAncestorProperties = function(node, prop){
		node = dojo.byId(node);
		if(!node){ return 0; } // FIXME: throw an error?
		
		var retVal = 0;
		while(node){
			var val = node[prop];
			if(val){
				retVal += val - 0;
			}
			node = node.parentNode;
		}
		return retVal;
	}

	ds.getTotalOffset = function(node, type, includeScroll){
		node = dojo.byId(node);
		return ds.abs(node, includeScroll)[(type == "top") ? "y" : "x"];
	}

	ds.getAbsoluteX = ds.totalOffsetLeft = function(node, includeScroll){
		return ds.getTotalOffset(node, "left", includeScroll);
	}

	ds.getAbsoluteY = ds.totalOffsetTop = function(node, includeScroll){
		return ds.getTotalOffset(node, "top", includeScroll);
	}

	ds.styleSheet = null;

	// FIXME: this is a really basic stub for adding and removing cssRules, but
	// it assumes that you know the index of the cssRule that you want to add 
	// or remove, making it less than useful.  So we need something that can 
	// search for the selector that you you want to remove.
	ds.insertCssRule = function(selector, declaration, index) {
		if (!ds.styleSheet) {
			if (document.createStyleSheet) { // IE
				ds.styleSheet = document.createStyleSheet();
			} else if (document.styleSheets[0]) { // rest
				// FIXME: should create a new style sheet here
				// fall back on an exsiting style sheet
				ds.styleSheet = document.styleSheets[0];
			} else { return null; } // fail
		}

		if (arguments.length < 3) { // index may == 0
			if (ds.styleSheet.cssRules) { // W3
				index = ds.styleSheet.cssRules.length;
			} else if (ds.styleSheet.rules) { // IE
				index = ds.styleSheet.rules.length;
			} else { return null; } // fail
		}

		if (ds.styleSheet.insertRule) { // W3
			var rule = selector + " { " + declaration + " }";
			return ds.styleSheet.insertRule(rule, index);
		} else if (ds.styleSheet.addRule) { // IE
			return ds.styleSheet.addRule(selector, declaration, index);
		} else { return null; } // fail
	}

	ds.removeCssRule = function(index){
		if(!ds.styleSheet){
			dojo.debug("no stylesheet defined for removing rules");
			return false;
		}
		if(h.ie){
			if(!index){
				index = ds.styleSheet.rules.length;
				ds.styleSheet.removeRule(index);
			}
		}else if(document.styleSheets[0]){
			if(!index){
				index = ds.styleSheet.cssRules.length;
			}
			ds.styleSheet.deleteRule(index);
		}
		return true;
	}

	// calls css by XmlHTTP and inserts it into DOM as <style [widgetType="widgetType"]> *downloaded cssText*</style>
	ds.insertCssFile = function(URI, doc, checkDuplicates){
		if(!URI){ return; }
		if(!doc){ doc = document; }
		var cssStr = dojo.hostenv.getText(URI);
		cssStr = ds.fixPathsInCssText(cssStr, URI);

		if(checkDuplicates){
			var styles = doc.getElementsByTagName("style");
			var cssText = "";
			for(var i = 0; i<styles.length; i++){
				cssText = (styles[i].styleSheet && styles[i].styleSheet.cssText) ? styles[i].styleSheet.cssText : styles[i].innerHTML;
				if(cssStr == cssText){ return; }
			}
		}

		var style = ds.insertCssText(cssStr);
		// insert custom attribute ex dbgHref="../foo.css" usefull when debugging in DOM inspectors, no?
		if(style && djConfig.isDebug){
			style.setAttribute("dbgHref", URI);
		}
		return style
	}

	// DomNode Style  = insertCssText(String ".dojoMenu {color: green;}"[, DomDoc document, dojo.uri.Uri Url ])
	ds.insertCssText = function(cssStr, doc, URI){
		if(!cssStr){ return; }
		if(!doc){ doc = document; }
		if(URI){// fix paths in cssStr
			cssStr = ds.fixPathsInCssText(cssStr, URI);
		}
		var style = doc.createElement("style");
		style.setAttribute("type", "text/css");
		if(style.styleSheet){// IE
			style.styleSheet.cssText = cssStr;
		} else {// w3c
			var cssText = doc.createTextNode(cssStr);
			style.appendChild(cssText);
		}
		var head = doc.getElementsByTagName("head")[0];
		if(!head){ // must have a head tag 
			dojo.debug("No head tag in document, aborting styles");
		}else{
			head.appendChild(style);
		}
		return style;
	}

	// String cssText = fixPathsInCssText(String cssStr, dojo.uri.Uri URI)
	// usage: cssText comes from dojoroot/src/widget/templates/HtmlFoobar.css
	// 	it has .dojoFoo { background-image: url(images/bar.png);} 
	//	then uri should point to dojoroot/src/widget/templates/
	ds.fixPathsInCssText = function(cssStr, URI){
		if(!cssStr || !URI){ return; }
		var pos = 0; var str = ""; var url = "";
		while(pos!=-1){
			pos = 0;url = "";
			pos = cssStr.indexOf("url(", pos);
			if(pos<0){ break; }
			str += cssStr.slice(0,pos+4);
			cssStr = cssStr.substring(pos+4, cssStr.length);
			url += cssStr.match(/^[\t\s\w()\/.\\'"-:#=&?]*\)/)[0]; // url string
			cssStr = cssStr.substring(url.length-1, cssStr.length); // remove url from css string til next loop
			url = url.replace(/^[\s\t]*(['"]?)([\w()\/.\\'"-:#=&?]*)\1[\s\t]*?\)/,"$2"); // clean string
			if(url.search(/(file|https?|ftps?):\/\//)==-1){
				url = (new dojo.uri.Uri(URI,url).toString());
			}
			str += url;
		};
		return str+cssStr;
	}

	ds.getBackgroundColor = function(node) {
		node = dojo.byId(node);
		var color;
		do{
			color = ds.getStyle(node, "background-color");
			// Safari doesn't say "transparent"
			if(color.toLowerCase() == "rgba(0, 0, 0, 0)") { color = "transparent"; }
			if(node == document.getElementsByTagName("body")[0]) { node = null; break; }
			node = node.parentNode;
		}while(node && dojo.lang.inArray(color, ["transparent", ""]));
		if(color == "transparent"){
			color = [255, 255, 255, 0];
		}else{
			color = dojo.graphics.color.extractRGB(color);
		}
		return color;
	}

	ds.getComputedStyle = function(node, cssSelector, inValue){
		node = dojo.byId(node);
		// cssSelector may actually be in camel case, so force selector version
		var cssSelector = ds.toSelectorCase(cssSelector);
		var property = ds.toCamelCase(cssSelector);
		if(!node || !node.style){
			return inValue;
		}else if(document.defaultView){ // W3, gecko, KHTML
			try{			
				var cs = document.defaultView.getComputedStyle(node, "");
				if (cs){ 
					return cs.getPropertyValue(cssSelector);
				} 
			}catch(e){ // reports are that Safari can throw an exception above
				if (node.style.getPropertyValue){ // W3
					return node.style.getPropertyValue(cssSelector);
				}else return inValue;
			}
		}else if(node.currentStyle){ // IE
			return node.currentStyle[property];
		}if(node.style.getPropertyValue){ // W3
			return node.style.getPropertyValue(cssSelector);
		}else{
			return inValue;
		}
	}

	/** 
	 * Retrieve a property value from a node's style object.
	 */
	ds.getStyleProperty = function(node, cssSelector){
		node = dojo.byId(node);
		// FIXME: should we use node.style.getPropertyValue over style[property]?
		// style[property] works in all (modern) browsers, getPropertyValue is W3 but not supported in IE
		// FIXME: what about runtimeStyle?
		return (node && node.style ? node.style[ds.toCamelCase(cssSelector)] : undefined);
	}

	/** 
	 * Retrieve a property value from a node's style object.
	 */
	ds.getStyle = function(node, cssSelector){
		var value = ds.getStyleProperty(node, cssSelector);
		return (value ? value : ds.getComputedStyle(node, cssSelector));
	}

	ds.setStyle = function(node, cssSelector, value){
		node = dojo.byId(node);
		if(node && node.style){
			var camelCased = ds.toCamelCase(cssSelector);
			node.style[camelCased] = value;
		}
	}

	ds.toCamelCase = function(selector) {
		var arr = selector.split('-'), cc = arr[0];
		for(var i = 1; i < arr.length; i++) {
			cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
		}
		return cc;		
	}

	ds.toSelectorCase = function(selector) {
		return selector.replace(/([A-Z])/g, "-$1" ).toLowerCase() ;
	}

	/* float between 0.0 (transparent) and 1.0 (opaque) */
	ds.setOpacity = function setOpacity(node, opacity, dontFixOpacity) {
		node = dojo.byId(node);
		if(!dontFixOpacity){
			if( opacity >= 1.0){
				if(h.ie){
					ds.clearOpacity(node);
					return;
				}else{
					opacity = 0.999999;
				}
			}else if( opacity < 0.0){ opacity = 0; }
		}
		if(h.ie){
			if(node.nodeName.toLowerCase() == "tr"){
				// FIXME: is this too naive? will we get more than we want?
				var tds = node.getElementsByTagName("td");
				for(var x=0; x<tds.length; x++){
					tds[x].style.filter = "Alpha(Opacity="+opacity*100+")";
				}
			}
			node.style.filter = "Alpha(Opacity="+opacity*100+")";
		}else if(h.moz){
			node.style.opacity = opacity; // ffox 1.0 directly supports "opacity"
			node.style.MozOpacity = opacity;
		}else if(h.safari){
			node.style.opacity = opacity; // 1.3 directly supports "opacity"
			node.style.KhtmlOpacity = opacity;
		}else{
			node.style.opacity = opacity;
		}
	}
		
	ds.getOpacity = function getOpacity (node){
		node = dojo.byId(node);
		if(h.ie){
			var opac = (node.filters && node.filters.alpha &&
				typeof node.filters.alpha.opacity == "number"
				? node.filters.alpha.opacity : 100) / 100;
		}else{
			var opac = node.style.opacity || node.style.MozOpacity ||
				node.style.KhtmlOpacity || 1;
		}
		return opac >= 0.999999 ? 1.0 : Number(opac);
	}

	ds.clearOpacity = function clearOpacity(node){
		node = dojo.byId(node);
		var ns = node.style;
		if(h.ie){
			try {
				if( node.filters && node.filters.alpha ){
					ns.filter = ""; // FIXME: may get rid of other filter effects
				}
			} catch(e) {
				/*
				 * IE7 gives error if node.filters not set;
				 * don't know why or how to workaround (other than this)
				 */
			}
		}else if(h.moz){
			ns.opacity = 1;
			ns.MozOpacity = 1;
		}else if(h.safari){
			ns.opacity = 1;
			ns.KhtmlOpacity = 1;
		}else{
			ns.opacity = 1;
		}
	}

	ds._toggle = function(node, tester, setter){
		node = dojo.byId(node);
		setter(node, !tester(node));
		return tester(node);
	}

	// show/hide are library constructs

	// show() 
	// if the node.style.display == 'none' then 
	// set style.display to '' or the value cached by hide()
	ds.show = function(node){
		node = dojo.byId(node);
		if(ds.getStyleProperty(node, 'display')=='none'){
			ds.setStyle(node, 'display', (node.dojoDisplayCache||''));
			node.dojoDisplayCache = undefined;	// cannot use delete on a node in IE6
		}
	}

	// if the node.style.display == 'none' then 
	// set style.display to '' or the value cached by hide()
	ds.hide = function(node){
		node = dojo.byId(node);
		if(typeof node["dojoDisplayCache"] == "undefined"){ // it could == '', so we cannot say !node.dojoDisplayCount
			var d = ds.getStyleProperty(node, 'display')
			if(d!='none'){
				node.dojoDisplayCache = d;
			}
		}
		ds.setStyle(node, 'display', 'none');
	}

	// setShowing() calls show() if showing is true, hide() otherwise
	ds.setShowing = function(node, showing){
		ds[(showing ? 'show' : 'hide')](node);
	}

	// isShowing() is true if the node.style.display is not 'none'
	// FIXME: returns true if node is bad, isHidden would be easier to make correct
	ds.isShowing = function(node){
		return (ds.getStyleProperty(node, 'display') != 'none');
	}

	// Call setShowing() on node with the complement of isShowing(), then return the new value of isShowing()
	ds.toggleShowing = function(node){
		return ds._toggle(node, ds.isShowing, ds.setShowing);
	}

	// display is a CSS concept

	// Simple mapping of tag names to display values
	// FIXME: simplistic 
	ds.displayMap = { tr: '', td: '', th: '', img: 'inline', span: 'inline', input: 'inline', button: 'inline' };

	// Suggest a value for the display property that will show 'node' based on it's tag
	ds.suggestDisplayByTagName = function(node)
	{
		node = dojo.byId(node);
		if(node && node.tagName){
			var tag = node.tagName.toLowerCase();
			return (tag in ds.displayMap ? ds.displayMap[tag] : 'block');
		}
	}

	// setDisplay() sets the value of style.display to value of 'display' parameter if it is a string.
	// Otherwise, if 'display' is false, set style.display to 'none'.
	// Finally, set 'display' to a suggested display value based on the node's tag
	ds.setDisplay = function(node, display){
		ds.setStyle(node, 'display', (dojo.lang.isString(display) ? display : (display ? ds.suggestDisplayByTagName(node) : 'none')));
	}

	// isDisplayed() is true if the the computed display style for node is not 'none'
	// FIXME: returns true if node is bad, isNotDisplayed would be easier to make correct
	ds.isDisplayed = function(node){
		return (ds.getComputedStyle(node, 'display') != 'none');
	}

	// Call setDisplay() on node with the complement of isDisplayed(), then
	// return the new value of isDisplayed()
	ds.toggleDisplay = function(node){
		return ds._toggle(node, ds.isDisplayed, ds.setDisplay);
	}

	// visibility is a CSS concept

	// setVisibility() sets the value of style.visibility to value of
	// 'visibility' parameter if it is a string.
	// Otherwise, if 'visibility' is false, set style.visibility to 'hidden'.
	// Finally, set style.visibility to 'visible'.
	ds.setVisibility = function(node, visibility){
		ds.setStyle(node, 'visibility', (dojo.lang.isString(visibility) ? visibility : (visibility ? 'visible' : 'hidden')));
	}

	// isVisible() is true if the the computed visibility style for node is not 'hidden'
	// FIXME: returns true if node is bad, isInvisible would be easier to make correct
	ds.isVisible = function(node){
		return (ds.getComputedStyle(node, 'visibility') != 'hidden');
	}

	// Call setVisibility() on node with the complement of isVisible(), then
	// return the new value of isVisible()
	ds.toggleVisibility = function(node){
		return ds._toggle(node, ds.isVisible, ds.setVisibility);
	}

	// in: coordinate array [x,y,w,h] or dom node
	// return: coordinate array
	ds.toCoordinateArray = function(coords, includeScroll) {
		if(dojo.lang.isArray(coords)){
			// coords is already an array (of format [x,y,w,h]), just return it
			while ( coords.length < 4 ) { coords.push(0); }
			while ( coords.length > 4 ) { coords.pop(); }
			var ret = coords;
		} else {
			// coords is an dom object (or dom object id); return it's coordinates
			var node = dojo.byId(coords);
			var pos = ds.getAbsolutePosition(node, includeScroll);
			var ret = [
				pos.x,
				pos.y,
				ds.getBorderBoxWidth(node),
				ds.getBorderBoxHeight(node)
			];
		}
		ret.x = ret[0];
		ret.y = ret[1];
		ret.w = ret[2];
		ret.h = ret[3];
		return ret;
	};
})();

__CPAN_FILE__ src/svg.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.svg");
dojo.require("dojo.lang");
dojo.require("dojo.dom");

dojo.lang.mixin(dojo.svg, dojo.dom);

dojo.svg.graphics=dojo.svg.g=new function(/* DomDocument */ d){
	//	summary
	//	Singleton to encapsulate SVG rendering functions.
	this.suspend=function(){
		//	summary
		//	Suspend the rendering engine
		try { d.documentElement.suspendRedraw(0); } catch(e){ }
	};
	this.resume=function(){
		//	summary
		//	Resume the rendering engine
		try { d.documentElement.unsuspendRedraw(0); } catch(e){ }
	};
	this.force=function(){
		//	summary
		//	Force the render engine to redraw
		try { d.documentElement.forceRedraw(); } catch(e){ }
	};
}(document);

dojo.svg.animations=dojo.svg.anim=new function(/* DOMDocument */ d){
	//	summary
	//	Singleton to encapsulate SVG animation functionality.
	this.arePaused=function(){
		//	summary
		//	check to see if all animations are paused
		try {
			return d.documentElement.animationsPaused();	//	bool
		} catch(e){
			return false;	//	bool
		}
	} ;
	this.pause=function(){
		//	summary
		//	pause all animations
		try { d.documentElement.pauseAnimations(); } catch(e){ }
	};
	this.resume=function(){
		//	summary
		//	resume all animations
		try { d.documentElement.unpauseAnimations(); } catch(e){ }
	};
}(document);

//	fixme: these functions should be mixed in from dojo.style, but dojo.style is HTML-centric and needs to change.
dojo.svg.toCamelCase=function(/* string */ selector){
	//	summary
	//	converts a CSS-style selector to a camelCased one
	var arr=selector.split('-'), cc=arr[0];
	for(var i=1; i < arr.length; i++) {
		cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
	}
	return cc;	// string
};
dojo.svg.toSelectorCase=function(/* string */ selector) {
	//	summary
	//	converts a camelCased selector to a CSS style one
	return selector.replace(/([A-Z])/g, "-$1" ).toLowerCase();	//	string
};
dojo.svg.getStyle=function(/* SVGElement */ node, /* string */ cssSelector){
	//	summary
	//	get the computed style of selector for node.
	return document.defaultView.getComputedStyle(node, cssSelector);	//	object
};
dojo.svg.getNumericStyle=function(/* SVGElement */ node, /* string */ cssSelector){
	//	summary
	//	return the numeric version of the computed style of selector on node.
	return parseFloat(dojo.svg.getStyle(node, cssSelector));
};

//	fixme: there are different ways of doing the following, need to take into account
dojo.svg.getOpacity=function(/* SVGElement */node){
	//	summary
	//	Return the opacity of the passed element
	return Math.min(1.0, dojo.svg.getNumericStyle(node, "fill-opacity"));	//	float
};
dojo.svg.setOpacity=function(/* SVGElement */ node, /* float */ opacity){
	//	summary
	//	set the opacity of node using attributes.
	node.setAttributeNS(this.xmlns.svg, "fill-opacity", opacity);
	node.setAttributeNS(this.xmlns.svg, "stroke-opacity", opacity);
};
dojo.svg.clearOpacity=function(/* SVGElement */ node){
	//	summary
	//	Set any attributes setting opacity to opaque (1.0)
	node.setAttributeNS(this.xmlns.svg, "fill-opacity", "1.0");
	node.setAttributeNS(this.xmlns.svg, "stroke-opacity", "1.0");
};

/**
 *	Coordinates and dimensions.
 */

// TODO ////////////////////////////////////////////////////////// TODO
dojo.svg.getCoords=function(/* SVGElement */ node){
	if (node.getBBox) {
		var box=node.getBBox();
		return { x: box.x, y: box.y };
	}
	return null;
};
dojo.svg.setCoords=function(node, coords){
	var p=dojo.svg.getCoords();
	if (!p) return;
	var dx=p.x - coords.x;
	var dy=p.y - coords.y;
	dojo.svg.translate(node, dx, dy);
};
dojo.svg.getDimensions=function(node){
	if (node.getBBox){
		var box=node.getBBox();
		return { width: box.width, height : box.height };
	}
	return null;
};
dojo.svg.setDimensions=function(node, dim){
	//	will only support shape-based and container elements; path-based elements are ignored.
	if (node.width){
		node.width.baseVal.value=dim.width;
		node.height.baseVal.value=dim.height;
	}
	else if (node.r){
		node.r.baseVal.value=Math.min(dim.width, dim.height)/2;
	}
	else if (node.rx){
		node.rx.baseVal.value=dim.width/2;
		node.ry.baseVal.value=dim.height/2;
	}
};

/**
 *	Transformations.
 */
dojo.svg.translate=function(node, dx, dy){
	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
		var t=node.ownerSVGElement.createSVGTransform();
		t.setTranslate(dx, dy);
		node.transform.baseVal.appendItem(t);
	}
};
dojo.svg.scale=function(node, scaleX, scaleY){
	if (!scaleY) var scaleY=scaleX;
	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
		var t=node.ownerSVGElement.createSVGTransform();
		t.setScale(scaleX, scaleY);
		node.transform.baseVal.appendItem(t);
	}
};
dojo.svg.rotate=function(node, ang, cx, cy){
	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
		var t=node.ownerSVGElement.createSVGTransform();
		if (!cx) t.setMatrix(t.matrix.rotate(ang));
		else t.setRotate(ang, cx, cy);
		node.transform.baseVal.appendItem(t);
	}
};
dojo.svg.skew=function(node, ang, axis){
	var dir=axis || "x";
	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
		var t=node.ownerSVGElement.createSVGTransform();
		if (dir != "x") t.setSkewY(ang);
		else t.setSkewX(ang);
		node.transform.baseVal.appendItem(t);
	}
};
dojo.svg.flip=function(node, axis){
	var dir=axis || "x";
	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
		var t=node.ownerSVGElement.createSVGTransform();
		t.setMatrix((dir != "x") ? t.matrix.flipY() : t.matrix.flipX());
		node.transform.baseVal.appendItem(t);
	}
};
dojo.svg.invert=function(node){
	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
		var t=node.ownerSVGElement.createSVGTransform();
		t.setMatrix(t.matrix.inverse());
		node.transform.baseVal.appendItem(t);
	}
};
dojo.svg.applyMatrix=function(node, a, b, c, d, e, f){
	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
		var m;
		if (b){
			var m=node.ownerSVGElement.createSVGMatrix();
			m.a=a;
			m.b=b;
			m.c=c;
			m.d=d;
			m.e=e;
			m.f=f;
		} else m=a;
		var t=node.ownerSVGElement.createSVGTransform();
		t.setMatrix(m);
		node.transform.baseVal.appendItem(t);
	}
};

/**
 *	Grouping and z-index operations.
 */
dojo.svg.group=function(nodes){
	//	expect an array of nodes, attaches the group to the parent of the first node.
	var p=nodes.item(0).parentNode;
	var g=document.createElementNS(this.xmlns.svg, "g");
	for (var i=0; i < nodes.length; i++) g.appendChild(nodes.item(i));
	p.appendChild(g);
	return g;
};
dojo.svg.ungroup=function(g){
	//	puts the children of the group on the same level as group was.
	var p=g.parentNode;
	while (g.childNodes.length > 0) p.appendChild(g.childNodes.item(0));
	p.removeChild(g);
};
//	if the node is part of a group, return the group, else return null.
dojo.svg.getGroup=function(node){
	//	if the node is part of a group, return the group, else return null.
	var a=this.getAncestors(node);
	for (var i=0; i < a.length; i++){
		if (a[i].nodeType == this.ELEMENT_NODE && a[i].nodeName.toLowerCase() == "g")
			return a[i];
	}
	return null;
};
dojo.svg.bringToFront=function(node){
	var n=this.getGroup(node) || node;
	n.ownerSVGElement.appendChild(n);
};
dojo.svg.sendToBack=function(node){
	var n=this.getGroup(node) || node;
	n.ownerSVGElement.insertBefore(n, n.ownerSVGElement.firstChild);
};

//	TODO: possibly push node up a level in the DOM if it's at the beginning or end of the childNodes list.
dojo.svg.bringForward=function(node){
	var n=this.getGroup(node) || node;
	if (this.getLastChildElement(n.parentNode) != n){
		this.insertAfter(n, this.getNextSiblingElement(n), true);
	}
};
dojo.svg.sendBackward=function(node){
	var n=this.getGroup(node) || node;
	if (this.getFirstChildElement(n.parentNode) != n){
		this.insertBefore(n, this.getPreviousSiblingElement(n), true);
	}
};
// END TODO ////////////////////////////////////////////////////// TODO

dojo.svg.createNodesFromText=function(/* string */ txt, /* bool? */ wrap){
	//	summary
	//	Create a list of nodes from text
	var docFrag=(new DOMParser()).parseFromString(txt, "text/xml").normalize();
	if(wrap){ 
		return [docFrag.firstChild.cloneNode(true)];	//	array
	}
	var nodes=[];
	for(var x=0; x<docFrag.childNodes.length; x++){
		nodes.push(docFrag.childNodes.item(x).cloneNode(true));
	}
	return nodes;	// array
}
// vim:ts=4:noet:tw=0:

__CPAN_FILE__ src/validate.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.validate");
dojo.provide("dojo.validate.us");
dojo.require("dojo.regexp");

// *** Validation Functions ****

/**
  Checks if a string has non whitespace characters. 
  Parameters allow you to constrain the length.

  @param value  A string.
  @param flags  An object.
    flags.length  If set, checks if there are exactly flags.length number of characters.
    flags.minlength  If set, checks if there are at least flags.minlength number of characters.
    flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.
  @return  true or false.
*/
dojo.validate.isText = function(value, flags) {
	flags = (typeof flags == "object") ? flags : {};

	// test for text
	if ( /^\s*$/.test(value) ) { return false; }

	// length tests
	if ( typeof flags.length == "number" && flags.length != value.length ) { return false; }
	if ( typeof flags.minlength == "number" && flags.minlength > value.length ) { return false; }
	if ( typeof flags.maxlength == "number" && flags.maxlength < value.length ) { return false; }

	return true;
}

/**
  Validates an IP address.
  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
  Supports 2 formats for Ipv6.

  @param value  A string.
  @param flags  An object.  All flags are boolean with default = true.
    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
      Case insensitive.  Zero padding allowed.
    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d
  @return  true or false
*/
dojo.validate.isIpAddress = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.ipAddress(flags) + "$", "i");
	return re.test(value);
}

/**
  Checks if a string could be a valid URL.

  @param value  A string.
  @param flags  An object.
    flags.scheme  Can be true, false, or [true, false]. 
      This means: required, not allowed, or either.
    flags in regexp.host can be applied.
    flags in regexp.ipAddress can be applied.
    flags in regexp.tld can be applied.
  @return  true or false
*/
dojo.validate.isUrl = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.url(flags) + "$", "i");
	return re.test(value);
}

/**
  Checks if a string could be a valid email address.

  @param value  A string.
  @param flags  An object.
    flags.allowCruft  Allow address like <mailto:foo@yahoo.com>.  Default is false.
    flags in regexp.host can be applied.
    flags in regexp.ipAddress can be applied.
    flags in regexp.tld can be applied.
  @return  true or false.
*/
dojo.validate.isEmailAddress = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.emailAddress(flags) + "$", "i");
	return re.test(value);
}

/**
  Checks if a string could be a valid email address list.

  @param value  A string.
  @param flags  An object.
    flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
    flags in regexp.emailAddress can be applied.
    flags in regexp.host can be applied.
    flags in regexp.ipAddress can be applied.
    flags in regexp.tld can be applied.
  @return  true or false.
*/
dojo.validate.isEmailAddressList = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.emailAddressList(flags) + "$", "i");
	return re.test(value);
}

/**
  Check if value is an email address list. If an empty list
  is returned, the value didn't pass the test or it was empty.

  @param value	A string
  @param flags	An object (same as isEmailAddressList)
  @return array of emails
*/
dojo.validate.getEmailAddressList = function(value, flags) {
	if(!flags) { flags = {}; }
	if(!flags.listSeparator) { flags.listSeparator = "\\s;,"; }

	if ( dojo.validate.isEmailAddressList(value, flags) ) {
		return value.split(new RegExp("\\s*[" + flags.listSeparator + "]\\s*"));
	}
	return [];
}

/**
  Validates whether a string is in an integer format. 

  @param value  A string.
  @param flags  An object.
    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. sign is optional).
    flags.separator  The character used as the thousands separator.  Default is no separator.
      For more than one symbol use an array, e.g. [",", ""], makes ',' optional.
  @return  true or false.
*/
dojo.validate.isInteger = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.integer(flags) + "$");
	return re.test(value);
}

/**
  Validates whether a string is a real valued number. 
  Format is the usual exponential notation.

  @param value  A string.
  @param flags  An object.
    flags.places  The integer number of decimal places.
      If not given, the decimal part is optional and the number of places is unlimited.
    flags.decimal  The character used for the decimal point.  Default is ".".
    flags.exponent  Express in exponential notation.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. the exponential part is optional).
    flags.eSigned  The leading plus-or-minus sign on the exponent.  Can be true, false, 
      or [true, false].  Default is [true, false], (i.e. sign is optional).
    flags in regexp.integer can be applied.
  @return  true or false.
*/
dojo.validate.isRealNumber = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.realNumber(flags) + "$");
	return re.test(value);
}

/**
  Validates whether a string denotes a monetary value. 

  @param value  A string.
  @param flags  An object.
    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. sign is optional).
    flags.symbol  A currency symbol such as Yen "", Pound "", or the Euro sign "".  
      Default is "$".  For more than one symbol use an array, e.g. ["$", ""], makes $ optional.
    flags.placement  The symbol can come "before" the number or "after".  Default is "before".
    flags.separator  The character used as the thousands separator. The default is ",".
    flags.cents  The two decimal places for cents.  Can be true, false, or [true, false].
      Default is [true, false], (i.e. cents are optional).
    flags.decimal  The character used for the decimal point.  Default is ".".
  @return  true or false.
*/
dojo.validate.isCurrency = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.currency(flags) + "$");
	return re.test(value);
}

/**
  Validates U.S. currency.

  @param value  A string.
  @param flags  An object.
    flags in validate.isCurrency can be applied.
  @return  true or false.
*/
dojo.validate.us.isCurrency = function(value, flags) {
	return dojo.validate.isCurrency(value, flags);
}

/**
  Validates German currency.

  @param value  A string.
  @return  true or false.
*/
dojo.validate.isGermanCurrency = function(value) {
	flags = {
		symbol: "",
		placement: "after",
		decimal: ",",
		separator: "."
	};
	return dojo.validate.isCurrency(value, flags);
}

/**
  Validates Japanese currency.

  @param value  A string.
  @return  true or false.
*/
dojo.validate.isJapaneseCurrency = function(value) {
	flags = {
		symbol: "",
		cents: false
	};
	return dojo.validate.isCurrency(value, flags);
}

/**
  Validates whether a string denoting an integer, 
  real number, or monetary value is between a max and min. 

  @param value  A string.
  @param flags  An object.
    flags.max  A number, which the value must be less than or equal to for the validation to be true.
    flags.min  A number, which the value must be greater than or equal to for the validation to be true.
    flags.decimal  The character used for the decimal point.  Default is ".".
  @return  true or false.
*/
dojo.validate.isInRange = function(value, flags) {
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	var max = (typeof flags.max == "number") ? flags.max : Infinity;
	var min = (typeof flags.min == "number") ? flags.min : -Infinity;
	var dec = (typeof flags.decimal == "string") ? flags.decimal : ".";
	
	// splice out anything not part of a number
	var pattern = "[^" + dec + "\\deE+-]";
	value = value.replace(RegExp(pattern, "g"), "");

	// trim ends of things like e, E, or the decimal character
	value = value.replace(/^([+-]?)(\D*)/, "$1");
	value = value.replace(/(\D*)$/, "");

	// replace decimal with ".". The minus sign '-' could be the decimal!
	pattern = "(\\d)[" + dec + "](\\d)";
	value = value.replace(RegExp(pattern, "g"), "$1.$2");

	value = Number(value);
	if ( value < min || value > max ) { return false; }

	return true;
}

/**
  Validates a time value in any International format.
  The value can be validated against one format or one of multiple formats.

  Format
  h        12 hour, no zero padding.
  hh       12 hour, has leading zero.
  H        24 hour, no zero padding.
  HH       24 hour, has leading zero.
  m        minutes, no zero padding.
  mm       minutes, has leading zero.
  s        seconds, no zero padding.
  ss       seconds, has leading zero.
  All other characters must appear literally in the expression.

  Example
    "h:m:s t"  ->   2:5:33 PM
    "HH:mm:ss" ->  14:05:33

  @param value  A string.
  @param flags  An object.
    flags.format  A string or an array of strings.  Default is "h:mm:ss t".
    flags.amSymbol  The symbol used for AM.  Default is "AM".
    flags.pmSymbol  The symbol used for PM.  Default is "PM".
  @return  true or false
*/
dojo.validate.isValidTime = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.time(flags) + "$", "i");
	return re.test(value);
}

/**
  Validates 12-hour time format.
  Zero-padding is not allowed for hours, required for minutes and seconds.
  Seconds are optional.

  @param value  A string.
  @return  true or false
*/
dojo.validate.is12HourTime = function(value) {
	return dojo.validate.isValidTime(value, {format: ["h:mm:ss t", "h:mm t"]});
}

/**
  Validates 24-hour military time format.
  Zero-padding is required for hours, minutes, and seconds.
  Seconds are optional.

  @param value  A string.
  @return  true or false
*/
dojo.validate.is24HourTime = function(value) {
	return dojo.validate.isValidTime(value, {format: ["HH:mm:ss", "HH:mm"]} );
}

/**
  Returns true if the date conforms to the format given and is a valid date. Otherwise returns false.

  @param dateValue  A string for the date.
  @param format  A string, default is  "MM/DD/YYYY".
  @return  true or false

  Accepts any type of format, including ISO8601.
  All characters in the format string are treated literally except the following tokens:

  YYYY - matches a 4 digit year
  M - matches a non zero-padded month
  MM - matches a zero-padded month
  D -  matches a non zero-padded date
  DD -  matches a zero-padded date
  DDD -  matches an ordinal date, 001-365, and 366 on leapyear
  ww - matches week of year, 01-53
  d - matches day of week, 1-7

  Examples: These are all today's date.

  Date          Format
  2005-W42-3    YYYY-Www-d
  2005-292      YYYY-DDD
  20051019      YYYYMMDD
  10/19/2005    M/D/YYYY
  19.10.2005    D.M.YYYY
*/
dojo.validate.isValidDate = function(dateValue, format) {
	// Default is the American format
	if (typeof format != "string") { format = "MM/DD/YYYY"; }

	// Create a literal regular expression based on format
	var reLiteral = format.replace(/([$^.*+?=!:|\/\\\(\)\[\]\{\}])/g, "\\$1");

	// Convert all the tokens to RE elements
	reLiteral = reLiteral.replace( "YYYY", "([0-9]{4})" );
	reLiteral = reLiteral.replace( "MM", "(0[1-9]|10|11|12)" );
	reLiteral = reLiteral.replace( "M", "([1-9]|10|11|12)" );
	reLiteral = reLiteral.replace( "DDD", "(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])" );
	reLiteral = reLiteral.replace( "DD", "(0[1-9]|[12][0-9]|30|31)" );
	reLiteral = reLiteral.replace( "D", "([1-9]|[12][0-9]|30|31)" );
	reLiteral = reLiteral.replace( "ww", "(0[1-9]|[1-4][0-9]|5[0-3])" );
	reLiteral = reLiteral.replace( "d", "([1-7])" );

	// Anchor pattern to begining and end of string
	reLiteral = "^" + reLiteral + "$";

	// Dynamic RE that parses the original format given
	var re = new RegExp(reLiteral);
	
	// Test if date is in a valid format
	if (!re.test(dateValue))  return false;

	// Parse date to get elements and check if date is valid
	// Assume valid values for date elements not given.
	var year = 0, month = 1, date = 1, dayofyear = 1, week = 1, day = 1;

	// Capture tokens
	var tokens = format.match( /(YYYY|MM|M|DDD|DD|D|ww|d)/g );

	// Capture date values
	var values = re.exec(dateValue);

	// Match up tokens with date values
	for (var i = 0; i < tokens.length; i++) {
		switch (tokens[i]) {
		case "YYYY":
			year = Number(values[i+1]); break;
		case "M":
		case "MM":
			month = Number(values[i+1]); break;
		case "D":
		case "DD":
			date = Number(values[i+1]); break;
		case "DDD":
			dayofyear = Number(values[i+1]); break;
		case "ww":
			week = Number(values[i+1]); break;
		case "d":
			day = Number(values[i+1]); break;
		}
	}

	// Leap years are divisible by 4, but not by 100, unless by 400
	var leapyear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));

	// 31st of a month with 30 days
	if (date == 31 && (month == 4 || month == 6 || month == 9 || month == 11)) return false; 

	// February 30th or 31st
	if (date >= 30 && month == 2) return false; 

	// February 29th outside a leap year
	if (date == 29 && month == 2 && !leapyear) return false; 
	if (dayofyear == 366 && !leapyear)  return false;

	return true;
}

/**
  Validates US state and territory abbreviations.

	@param value  A two character string.
  @param flags  An object.
    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.
  @return  true or false
*/
dojo.validate.us.isState = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.us.state(flags) + "$", "i");
	return re.test(value);
}

/**
  Validates any sort of number based format.
  Use it for phone numbers, social security numbers, zip-codes, etc.
  The value can be validated against one format or one of multiple formats.

  Format
    #        Stands for a digit, 0-9.
    ?        Stands for an optional digit, 0-9 or nothing.
    All other characters must appear literally in the expression.

  Example   
    "(###) ###-####"       ->   (510) 542-9742
    "(###) ###-#### x#???" ->   (510) 542-9742 x153
    "###-##-####"          ->   506-82-1089       i.e. social security number
    "#####-####"           ->   98225-1649        i.e. zip code

  @param value  A string.
  @param flags  An object.
    flags.format  A string or an Array of strings for multiple formats.
  @return  true or false
*/
dojo.validate.isNumberFormat = function(value, flags) {
	var re = new RegExp("^" + dojo.regexp.numberFormat(flags) + "$", "i");
	return re.test(value);
}

/**
  Validates 10 US digit phone number for several common formats:

  @param value The telephone number string
  @return true or false
*/
dojo.validate.us.isPhoneNumber = function(value) {
	flags = {
		format: [
			"###-###-####",
			"(###) ###-####",
			"(###) ### ####",
			"###.###.####",
			"###/###-####",
			"### ### ####",
			"###-###-#### x#???",
			"(###) ###-#### x#???",
			"(###) ### #### x#???",
			"###.###.#### x#???",
			"###/###-#### x#???",
			"### ### #### x#???",
			"##########"
		]
	};

	return dojo.validate.isNumberFormat(value, flags);
}

// Validates social security number
dojo.validate.us.isSocialSecurityNumber = function(value) {
	flags = {
		format: [
			"###-##-####",
			"### ## ####",
			"#########"
		]
	};

	return dojo.validate.isNumberFormat(value, flags);
}

// Validates U.S. zip-code
dojo.validate.us.isZipCode = function(value) {
	flags = {
		format: [
			"#####-####",
			"##### ####",
			"#########",
			"#####"
		]
	};

	return dojo.validate.isNumberFormat(value, flags);
}


/**
	Procedural API Description

		The main aim is to make input validation expressible in a simple format.
		You define profiles which declare the required and optional fields and any constraints they might have.
		The results are provided as an object that makes it easy to handle missing and invalid input.

	Usage

		var results = dojo.validate.check(form, profile);

	Profile Object

		var profile = {
			// filters change the field value and are applied before validation.
			trim: ["tx1", "tx2"],
			uppercase: ["tx9"],
			lowercase: ["tx5", "tx6", "tx7"],
			ucfirst: ["tx10"],
			digit: ["tx11"],

			// required input fields that are blank will be reported missing.
			// required radio button groups and drop-down lists with no selection will be reported missing.
			// checkbox groups and selectboxes can be required to have more than one value selected.
			// List required fields by name and use this notation to require more than one value: {checkboxgroup: 2}, {selectboxname: 3}.
			required: ["tx7", "tx8", "pw1", "ta1", "rb1", "rb2", "cb3", "s1", {"doubledip":2}, {"tripledip":3}],

			// dependant/conditional fields are required if the target field is present and not blank.
			// At present only textbox, password, and textarea fields are supported.
			dependancies:	{
				cc_exp: "cc_no",	
				cc_type: "cc_no",	
			},

			// Fields can be validated using any boolean valued function.  
			// Use arrays to specify parameters in addition to the field value.
			constraints: {
				field_name1: myValidationFunction,
				field_name2: dojo.validate.isInteger,
				field_name3: [myValidationFunction, additional parameters],
				field_name4: [dojo.validate.isValidDate, "YYYY.MM.DD"],
				field_name5: [dojo.validate.isEmailAddress, false, true],
			},

			// Confirm is a sort of conditional validation.
			// It associates each field in its property list with another field whose value should be equal.
			// If the values are not equal, the field in the property list is reported as Invalid. Unless the target field is blank.
			confirm: {
				email_confirm: "email",	
				pw2: "pw1",	
			}
		};

	Results Object

		isSuccessful(): Returns true if there were no invalid or missing fields, else it returns false.
		hasMissing():  Returns true if the results contain any missing fields.
		getMissing():  Returns a list of required fields that have values missing.
		isMissing(field):  Returns true if the field is required and the value is missing.
		hasInvalid():  Returns true if the results contain fields with invalid data.
		getInvalid():  Returns a list of fields that have invalid values.
		isInvalid(field):  Returns true if the field has an invalid value.

*/

/**
  Validates user input of an HTML form based on input profile.

	@param form  The form object to be validated.
	@param profile  The input profile that specifies how the form fields are to be validated.
	@return results  An object that contains several methods summarizing the results of the validation.
*/
dojo.validate.check = function(form, profile) {
	// Essentially private properties of results object
	var missing = [];
	var invalid = [];

	// results object summarizes the validation
	var results = {
		isSuccessful: function() {return ( !this.hasInvalid() && !this.hasMissing() );},
		hasMissing: function() {return ( missing.length > 0 );},
		getMissing: function() {return missing;},
		isMissing: function(elemname) {
			for (var i = 0; i < missing.length; i++) {
				if ( elemname == missing[i] ) { return true; }
			}
			return false;
		},
		hasInvalid: function() {return ( invalid.length > 0 );},
		getInvalid: function() {return invalid;},
		isInvalid: function(elemname) {
			for (var i = 0; i < invalid.length; i++) {
				if ( elemname == invalid[i] ) { return true; }
			}
			return false;
		}
	};

	// Filters are applied before fields are validated.
	// Trim removes white space at the front and end of the fields.
	if ( profile.trim instanceof Array ) {
		for (var i = 0; i < profile.trim.length; i++) {
			var elem = form[profile.trim[i]];
			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
			elem.value = elem.value.replace(/(^\s*|\s*$)/g, "");
		}
	}
	// Convert to uppercase
	if ( profile.uppercase instanceof Array ) {
		for (var i = 0; i < profile.uppercase.length; i++) {
			var elem = form[profile.uppercase[i]];
			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
			elem.value = elem.value.toUpperCase();
		}
	}
	// Convert to lowercase
	if ( profile.lowercase instanceof Array ) {
		for (var i = 0; i < profile.lowercase.length; i++) {
			var elem = form[profile.lowercase[i]];
			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
			elem.value = elem.value.toLowerCase();
		}
	}
	// Uppercase first letter
	if ( profile.ucfirst instanceof Array ) {
		for (var i = 0; i < profile.ucfirst.length; i++) {
			var elem = form[profile.ucfirst[i]];
			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
			elem.value = elem.value.replace(/\b\w+\b/g, function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });
		}
	}
	// Remove non digits characters from the input.
	if ( profile.digit instanceof Array ) {
		for (var i = 0; i < profile.digit.length; i++) {
			var elem = form[profile.digit[i]];
			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
			elem.value = elem.value.replace(/\D/g, "");
		}
	}

	// See if required input fields have values missing.
	if ( profile.required instanceof Array ) {
		for (var i = 0; i < profile.required.length; i++) { 
			if ( typeof profile.required[i] != "string" ) { continue; }
			var elem = form[profile.required[i]];
			// Are textbox, textarea, or password fields blank.
			if ( (elem.type == "text" || elem.type == "textarea" || elem.type == "password") && /^\s*$/.test(elem.value) ) {	
				missing[missing.length] = elem.name;
			}
			// Does drop-down box have option selected.
			else if ( (elem.type == "select-one" || elem.type == "select-multiple") && elem.selectedIndex == -1 ) {
				missing[missing.length] = elem.name;
			}
			// Does radio button group (or check box group) have option checked.
			else if ( elem instanceof Array )  {
				var checked = false;
				for (var j = 0; j < elem.length; j++) {
					if (elem[j].checked) { checked = true; }
				}
				if ( !checked ) {	
					missing[missing.length] = elem[0].name;
				}
			}
		}
	}

	// See if checkbox groups and select boxes have x number of required values.
	if ( profile.required instanceof Array ) {
		for (var i = 0; i < profile.required.length; i++) { 
			if ( typeof profile.required[i] != "object" ) { continue; }
			var elem, numRequired;
			for (var name in profile.required[i]) { 
				elem = form[name]; 
				numRequired = profile.required[i][name];
			}
			// case 1: elem is a check box group
			if ( elem instanceof Array )  {
				var checked = 0;
				for (var j = 0; j < elem.length; j++) {
					if (elem[j].checked) { checked++; }
				}
				if ( checked < numRequired ) {	
					missing[missing.length] = elem[0].name;
				}
			}
			// case 2: elem is a select box
			else if ( elem.type == "select-multiple" ) {
				var selected = 0;
				for (var j = 0; j < elem.options.length; j++) {
					if (elem.options[j].selected) { selected++; }
				}
				if ( selected < numRequired ) {	
					missing[missing.length] = elem.name;
				}
			}
		}
	}

	// Dependant fields are required when the target field is present (not blank).
	// Todo: Support dependant and target fields that are radio button groups, or select drop-down lists.
	// Todo: Make the dependancy based on a specific value of the target field.
	// Todo: allow dependant fields to have several required values, like {checkboxgroup: 3}.
	if ( typeof profile.dependancies == "object" ) {
		// properties of dependancies object are the names of dependant fields to be checked
		for (name in profile.dependancies) {
			var elem = form[name];	// the dependant element
			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; } // limited support
			if ( /\S+/.test(elem.value) ) { continue; }	// has a value already
			if ( results.isMissing(elem.name) ) { continue; }	// already listed as missing
			var target = form[profile.dependancies[name]];
			if ( target.type != "text" && target.type != "textarea" && target.type != "password" ) { continue; }	// limited support
			if ( /^\s*$/.test(target.value) ) { continue; }	// skip if blank
			missing[missing.length] = elem.name;	// ok the dependant field is missing
		}
	}

	// Find invalid input fields.
	if ( typeof profile.constraints == "object" ) {
		// constraint properties are the names of fields to be validated
		for (name in profile.constraints) {
			var elem = form[name];
			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
			// skip if blank - its optional unless required, in which case it is already listed as missing.
			if ( /^\s*$/.test(elem.value) ) { continue; }

			var isValid = true;
			// case 1: constraint value is validation function
			if ( typeof profile.constraints[name] == "function" ) {
				isValid = profile.constraints[name](elem.value);
			}
			// case 2: constraint value is array, first elem is function, tail is parameters
			else if ( profile.constraints[name] instanceof Array ) {
				var isValidSomething = profile.constraints[name][0];
				var params = profile.constraints[name].slice(1);
				params.unshift(elem.value);
				isValid = isValidSomething.apply(null, params);
			}

			if ( !isValid ) {	
				invalid[invalid.length] = elem.name;
			}
		}
	}

	// Find unequal confirm fields and report them as Invalid.
	if ( typeof profile.confirm == "object" ) {
		for (name in profile.confirm) {
			var elem = form[name];	// the confirm element
			var target = form[profile.confirm[name]];
			if ( (elem.type != "text" && elem.type != "textarea" && elem.type != "password") 
				|| target.type != elem.type 
				|| target.value == elem.value		// it's valid
				|| results.isInvalid(elem.name)	// already listed as invalid
				|| /^\s*$/.test(target.value)	)	// skip if blank - only confirm if target has a value
			{
				continue; 
			}	
			invalid[invalid.length] = elem.name;
		}
	}

	return results;
}

__CPAN_DIR__ src/animation
__CPAN_FILE__ src/animation/Animation.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.animation.Animation");
dojo.require("dojo.animation.AnimationEvent");

dojo.require("dojo.lang.func");
dojo.require("dojo.math");
dojo.require("dojo.math.curves");

/*
Animation package based off of Dan Pupius' work on Animations:
http://pupius.co.uk/js/Toolkit.Drawing.js
*/

dojo.animation.Animation = function(/*dojo.math.curves.Line*/ curve, /*int*/ duration, /*Decimal?*/ accel, /*int?*/ repeatCount, /*int?*/ rate) {
	// public properties
	if(dojo.lang.isArray(curve)) {
		// curve: Array
		// id: i
		curve = new dojo.math.curves.Line(curve[0], curve[1]);
	}
	this.curve = curve;
	this.duration = duration;
	this.repeatCount = repeatCount || 0;
	this.rate = rate || 25;
	if(accel) {
		// accel: Decimal
		// id: j
		if(dojo.lang.isFunction(accel.getValue)) {
			// accel: dojo.math.curves.CatmullRom
			// id: k
			this.accel = accel;
		} else {
			var i = 0.35*accel+0.5;	// 0.15 <= i <= 0.85
			this.accel = new dojo.math.curves.CatmullRom([[0], [i], [1]], 0.45);
		}
	}
}

dojo.lang.extend(dojo.animation.Animation, {
	// public properties
	curve: null,
	duration: 0,
	repeatCount: 0,
	accel: null,

	// events
	onBegin: null,
	onAnimate: null,
	onEnd: null,
	onPlay: null,
	onPause: null,
	onStop: null,
	handler: null,

	// "private" properties
	_animSequence: null,
	_startTime: null,
	_endTime: null,
	_lastFrame: null,
	_timer: null,
	_percent: 0,
	_active: false,
	_paused: false,
	_startRepeatCount: 0,

	// public methods
	play: function(gotoStart) {
		if( gotoStart ) {
			clearTimeout(this._timer);
			this._active = false;
			this._paused = false;
			this._percent = 0;
		} else if( this._active && !this._paused ) {
			return;
		}

		this._startTime = new Date().valueOf();
		if( this._paused ) {
			this._startTime -= (this.duration * this._percent / 100);
		}
		this._endTime = this._startTime + this.duration;
		this._lastFrame = this._startTime;

		var e = new dojo.animation.AnimationEvent(this, null, this.curve.getValue(this._percent),
			this._startTime, this._startTime, this._endTime, this.duration, this._percent, 0);

		this._active = true;
		this._paused = false;

		if( this._percent == 0 ) {
			if(!this._startRepeatCount) {
				this._startRepeatCount = this.repeatCount;
			}
			e.type = "begin";
			if(typeof this.handler == "function") { this.handler(e); }
			if(typeof this.onBegin == "function") { this.onBegin(e); }
		}

		e.type = "play";
		if(typeof this.handler == "function") { this.handler(e); }
		if(typeof this.onPlay == "function") { this.onPlay(e); }

		if(this._animSequence) { this._animSequence._setCurrent(this); }

		this._cycle();
	},

	pause: function() {
		clearTimeout(this._timer);
		if( !this._active ) { return; }
		this._paused = true;
		var e = new dojo.animation.AnimationEvent(this, "pause", this.curve.getValue(this._percent),
			this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent, 0);
		if(typeof this.handler == "function") { this.handler(e); }
		if(typeof this.onPause == "function") { this.onPause(e); }
	},

	playPause: function() {
		if( !this._active || this._paused ) {
			this.play();
		} else {
			this.pause();
		}
	},

	gotoPercent: function(pct, andPlay) {
		clearTimeout(this._timer);
		this._active = true;
		this._paused = true;
		this._percent = pct;
		if( andPlay ) { this.play(); }
	},

	stop: function(gotoEnd) {
		clearTimeout(this._timer);
		var step = this._percent / 100;
		if( gotoEnd ) {
			step = 1;
		}
		var e = new dojo.animation.AnimationEvent(this, "stop", this.curve.getValue(step),
			this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent, Math.round(fps));
		if(typeof this.handler == "function") { this.handler(e); }
		if(typeof this.onStop == "function") { this.onStop(e); }
		this._active = false;
		this._paused = false;
	},

	status: function() {
		if( this._active ) {
			return this._paused ? "paused" : "playing";
		} else {
			return "stopped";
		}
	},

	// "private" methods
	_cycle: function() {
		clearTimeout(this._timer);
		if( this._active ) {
			var curr = new Date().valueOf();
			var step = (curr - this._startTime) / (this._endTime - this._startTime);
			fps = 1000 / (curr - this._lastFrame);
			this._lastFrame = curr;

			if( step >= 1 ) {
				step = 1;
				this._percent = 100;
			} else {
				this._percent = step * 100;
			}
			
			// Perform accelleration
			if(this.accel && this.accel.getValue) {
				step = this.accel.getValue(step);
			}

			var e = new dojo.animation.AnimationEvent(this, "animate", this.curve.getValue(step),
				this._startTime, curr, this._endTime, this.duration, this._percent, Math.round(fps));

			if(typeof this.handler == "function") { this.handler(e); }
			if(typeof this.onAnimate == "function") { this.onAnimate(e); }

			if( step < 1 ) {
				this._timer = setTimeout(dojo.lang.hitch(this, "_cycle"), this.rate);
			} else {
				e.type = "end";
				this._active = false;
				if(typeof this.handler == "function") { this.handler(e); }
				if(typeof this.onEnd == "function") { this.onEnd(e); }

				if( this.repeatCount > 0 ) {
					this.repeatCount--;
					this.play(true);
				} else if( this.repeatCount == -1 ) {
					this.play(true);
				} else {
					if(this._startRepeatCount) {
						this.repeatCount = this._startRepeatCount;
						this._startRepeatCount = 0;
					}
					if( this._animSequence ) {
						this._animSequence._playNext();
					}
				}
			}
		}
	}
});

__CPAN_FILE__ src/animation/AnimationEvent.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.animation.AnimationEvent");

dojo.require("dojo.lang");

dojo.animation.AnimationEvent = function(anim, type, coords, sTime, cTime, eTime, dur, pct, fps) {
	this.type = type; // "animate", "begin", "end", "play", "pause", "stop"
	this.animation = anim;

	this.coords = coords;
	this.x = coords[0];
	this.y = coords[1];
	this.z = coords[2];

	this.startTime = sTime;
	this.currentTime = cTime;
	this.endTime = eTime;

	this.duration = dur;
	this.percent = pct;
	this.fps = fps;
};
dojo.lang.extend(dojo.animation.AnimationEvent, {
	coordsAsInts: function() {
		var cints = new Array(this.coords.length);
		for(var i = 0; i < this.coords.length; i++) {
			cints[i] = Math.round(this.coords[i]);
		}
		return cints;
	}
});

__CPAN_FILE__ src/animation/AnimationSequence.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.animation.AnimationSequence");
dojo.require("dojo.animation.AnimationEvent");
dojo.require("dojo.animation.Animation");

dojo.animation.AnimationSequence = function(repeatCount){
	this._anims = [];
	this.repeatCount = repeatCount || 0;
}

dojo.lang.extend(dojo.animation.AnimationSequence, {
	repeateCount: 0,

	_anims: [],
	_currAnim: -1,

	onBegin: null,
	onEnd: null,
	onNext: null,
	handler: null,

	add: function() {
		for(var i = 0; i < arguments.length; i++) {
			this._anims.push(arguments[i]);
			arguments[i]._animSequence = this;
		}
	},

	remove: function(anim) {
		for(var i = 0; i < this._anims.length; i++) {
			if( this._anims[i] == anim ) {
				this._anims[i]._animSequence = null;
				this._anims.splice(i, 1);
				break;
			}
		}
	},

	removeAll: function() {
		for(var i = 0; i < this._anims.length; i++) {
			this._anims[i]._animSequence = null;
		}
		this._anims = [];
		this._currAnim = -1;
	},

	clear: function() {
		this.removeAll();
	},

	play: function(gotoStart) {
		if( this._anims.length == 0 ) { return; }
		if( gotoStart || !this._anims[this._currAnim] ) {
			this._currAnim = 0;
		}
		if( this._anims[this._currAnim] ) {
			if( this._currAnim == 0 ) {
				var e = {type: "begin", animation: this._anims[this._currAnim]};
				if(typeof this.handler == "function") { this.handler(e); }
				if(typeof this.onBegin == "function") { this.onBegin(e); }
			}
			this._anims[this._currAnim].play(gotoStart);
		}
	},

	pause: function() {
		if( this._anims[this._currAnim] ) {
			this._anims[this._currAnim].pause();
		}
	},

	playPause: function() {
		if( this._anims.length == 0 ) { return; }
		if( this._currAnim == -1 ) { this._currAnim = 0; }
		if( this._anims[this._currAnim] ) {
			this._anims[this._currAnim].playPause();
		}
	},

	stop: function() {
		if( this._anims[this._currAnim] ) {
			this._anims[this._currAnim].stop();
		}
	},

	status: function() {
		if( this._anims[this._currAnim] ) {
			return this._anims[this._currAnim].status();
		} else {
			return "stopped";
		}
	},

	_setCurrent: function(anim) {
		for(var i = 0; i < this._anims.length; i++) {
			if( this._anims[i] == anim ) {
				this._currAnim = i;
				break;
			}
		}
	},

	_playNext: function() {
		if( this._currAnim == -1 || this._anims.length == 0 ) { return; }
		this._currAnim++;
		if( this._anims[this._currAnim] ) {
			var e = {type: "next", animation: this._anims[this._currAnim]};
			if(typeof this.handler == "function") { this.handler(e); }
			if(typeof this.onNext == "function") { this.onNext(e); }
			this._anims[this._currAnim].play(true);
		} else {
			var e = {type: "end", animation: this._anims[this._anims.length-1]};
			if(typeof this.handler == "function") { this.handler(e); }
			if(typeof this.onEnd == "function") { this.onEnd(e); }
			if(this.repeatCount > 0) {
				this._currAnim = 0;
				this.repeatCount--;
				this._anims[this._currAnim].play(true);
			} else if(this.repeatCount == -1) {
				this._currAnim = 0;
				this._anims[this._currAnim].play(true);
			} else {
				this._currAnim = -1;
			}
		}
	}
});

__CPAN_FILE__ src/animation/Timer.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.animation.Timer");
dojo.require("dojo.lang.func");

dojo.animation.Timer = function(intvl){
	var timer = null;
	this.isRunning = false;
	this.interval = intvl;

	this.onTick = function(){};
	this.onStart = null;
	this.onStop = null;

	this.setInterval = function(ms){
		if (this.isRunning) window.clearInterval(timer);
		this.interval = ms;
		if (this.isRunning) timer = window.setInterval(dojo.lang.hitch(this, "onTick"), this.interval);
	};

	this.start = function(){
		if (typeof this.onStart == "function") this.onStart();
		this.isRunning = true;
		timer = window.setInterval(this.onTick, this.interval);
	};
	this.stop = function(){
		if (typeof this.onStop == "function") this.onStop();
		this.isRunning = false;
		window.clearInterval(timer);
	};
};

__CPAN_FILE__ src/animation/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		"dojo.animation.AnimationEvent",
		"dojo.animation.Animation",
		"dojo.animation.AnimationSequence"
	]
});
dojo.provide("dojo.animation.*");

__CPAN_DIR__ src/collections
__CPAN_FILE__ src/collections/ArrayList.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.ArrayList");
dojo.require("dojo.collections.Collections");

dojo.collections.ArrayList=function(/* array? */arr){
	//	summary
	//	Returns a new object of type dojo.collections.ArrayList
	var items=[];
	if(arr) items=items.concat(arr);
	this.count=items.length;
	this.add=function(/* object */obj){
		//	summary
		//	Add an element to the collection.
		items.push(obj);
		this.count=items.length;
	};
	this.addRange=function(/* array */a){
		//	summary
		//	Add a range of objects to the ArrayList
		if(a.getIterator){
			var e=a.getIterator();
			while(!e.atEnd()){
				this.add(e.get());
			}
			this.count=items.length;
		}else{
			for(var i=0; i<a.length; i++){
				items.push(a[i]);
			}
			this.count=items.length;
		}
	};
	this.clear=function(){
		//	summary
		//	Clear all elements out of the collection, and reset the count.
		items.splice(0, items.length);
		this.count=0;
	};
	this.clone=function(){
		//	summary
		//	Clone the array list
		return new dojo.collections.ArrayList(items);	//	dojo.collections.ArrayList
	};
	this.contains=function(/* object */obj){
		//	summary
		//	Check to see if the passed object is a member in the ArrayList
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(items, fn, s);
		}else{
			for(var i=0; i<items.length; i++){
				fn.call(s, items[i], i, items);
			}
		}
	};
	this.getIterator=function(){
		//	summary
		//	Get an Iterator for this object
		return new dojo.collections.Iterator(items);	//	dojo.collections.Iterator
	};
	this.indexOf=function(/* object */obj){
		//	summary
		//	Return the numeric index of the passed object; will return -1 if not found.
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return i;	//	int
			}
		}
		return -1;	// int
	};
	this.insert=function(/* int */ i, /* object */ obj){
		//	summary
		//	Insert the passed object at index i
		items.splice(i,0,obj);
		this.count=items.length;
	};
	this.item=function(/* int */ i){
		//	summary
		//	return the element at index i
		return items[i];	//	object
	};
	this.remove=function(/* object */obj){
		//	summary
		//	Look for the passed object, and if found, remove it from the internal array.
		var i=this.indexOf(obj);
		if(i >=0) {
			items.splice(i,1);
		}
		this.count=items.length;
	};
	this.removeAt=function(/* int */ i){
		//	summary
		//	return an array with function applied to all elements
		items.splice(i,1);
		this.count=items.length;
	};
	this.reverse=function(){
		//	summary
		//	Reverse the internal array
		items.reverse();
	};
	this.sort=function(/* function? */ fn){
		//	summary
		//	sort the internal array
		if(fn){
			items.sort(fn);
		}else{
			items.sort();
		}
	};
	this.setByIndex=function(/* int */ i, /* object */ obj){
		//	summary
		//	Set an element in the array by the passed index.
		items[i]=obj;
		this.count=items.length;
	};
	this.toArray=function(){
		//	summary
		//	Return a new array with all of the items of the internal array concatenated.
		return [].concat(items);
	}
	this.toString=function(/* string */ delim){
		//	summary
		//	implementation of toString, follows [].toString();
		return items.join((delim||","));
	};
};

__CPAN_FILE__ src/collections/BinaryTree.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.BinaryTree");
dojo.require("dojo.collections.Collections");
dojo.require("dojo.experimental");

dojo.experimental("dojo.collections.BinaryTree");

dojo.collections.BinaryTree=function(data){
	function node(data, rnode, lnode){
		this.value=data||null;
		this.right=rnode||null;
		this.left=lnode||null;
		this.clone=function(){
			var c=new node();
			if (this.value.value) c.value=this.value.clone();
			else c.value=this.value;
			if (this.left) c.left=this.left.clone();
			if (this.right) c.right=this.right.clone();
		}
		this.compare=function(n){
			if (this.value > n.value) return 1;
			if (this.value < n.value) return -1;
			return 0;
		}
		this.compareData=function(d){
			if (this.value > d) return 1;
			if (this.value < d) return -1;
			return 0;
		}
	}

	function inorderTraversalBuildup(current, a){
		if (current){
			inorderTraversalBuildup(current.left, a);
			a.add(current);
			inorderTraversalBuildup(current.right, a);
		}
	}

	function preorderTraversal(current, sep){
		var s="";
		if (current){
			s=current.value.toString() + sep;
			s += preorderTraversal(current.left, sep);
			s += preorderTraversal(current.right, sep);
		}
		return s;
	}
	function inorderTraversal(current, sep){
		var s="";
		if (current){
			s=inorderTraversal(current.left, sep);
			s += current.value.toString() + sep;
			s += inorderTraversal(current.right, sep);
		}
		return s;
	}
	function postorderTraversal(current, sep){
		var s="";
		if (current){
			s=postorderTraversal(current.left, sep);
			s += postorderTraversal(current.right, sep);
			s += current.value.toString() + sep;
		}
		return s;
	}
	
	function searchHelper(current, data){
		if (!current) return null;
		var i=current.compareData(data);
		if (i == 0) return current;
		if (result > 0) return searchHelper(current.left, data);
		else return searchHelper(current.right, data);
	}

	this.add=function(data){
		var n=new node(data);
		var i;
		var current=root;
		var parent=null;
		while (current){
			i=current.compare(n);
			if (i == 0) return;
			parent=current;
			if (i > 0) current=current.left;
			else current=current.right;
		}
		this.count++;
		if (!parent) root=n;
		else {
			i=parent.compare(n);
			if (i > 0) parent.left=n;
			else parent.right=n;
		}
	};
	this.clear=function(){
		root=null;
		this.count=0;
	};
	this.clone=function(){
		var c=new dojo.collections.BinaryTree();
		c.root=root.clone();
		c.count=this.count;
		return c;
	};
	this.contains=function(data){
		return this.search(data) != null;
	};
	this.deleteData=function(data){
		var current=root;
		var parent=null;
		var i=current.compareData(data);
		while (i != 0 && current != null){
			if (i > 0){
				parent=current;
				current=current.left;
			} else if (i < 0) {
				parent=current;
				current=current.right;
			}
			i=current.compareData(data);
		}
		if (!current) return;
		this.count--;
		if (!current.right) {
			if (!parent) root=current.left;
			else {
				i=parent.compare(current);
				if (i > 0) parent.left=current.left;
				else if (i < 0) parent.right=current.left;
			}
		} else if (!current.right.left){
			if (!parent) root=current.right;
			else {
				i=parent.compare(current);
				if (i > 0) parent.left=current.right;
				else if (i < 0) parent.right=current.right;
			}
		} else {
			var leftmost=current.right.left;
			var lmParent=current.right;
			while (leftmost.left != null){
				lmParent=leftmost;
				leftmost=leftmost.left;
			}
			lmParent.left=leftmost.right;
			leftmost.left=current.left;
			leftmost.right=current.right;
			if (!parent) root=leftmost;
			else {
				i=parent.compare(current);
				if (i > 0) parent.left=leftmost;
				else if (i < 0) parent.right=leftmost;
			}
		}
	};
	this.getIterator=function(){
		var a=[];
		inorderTraversalBuildup(root, a);
		return new dojo.collections.Iterator(a);
	};
	this.search=function(data){
		return searchHelper(root, data);
	};
	this.toString=function(order, sep){
		if (!order) var order=dojo.collections.BinaryTree.TraversalMethods.Inorder;
		if (!sep) var sep=" ";
		var s="";
		switch (order){
			case dojo.collections.BinaryTree.TraversalMethods.Preorder:
				s=preorderTraversal(root, sep);
				break;
			case dojo.collections.BinaryTree.TraversalMethods.Inorder:
				s=inorderTraversal(root, sep);
				break;
			case dojo.collections.BinaryTree.TraversalMethods.Postorder:
				s=postorderTraversal(root, sep);
				break;
		};
		if (s.length == 0) return "";
		else return s.substring(0, s.length - sep.length);
	};

	this.count=0;
	var root=this.root=null;
	if (data) {
		this.add(data);
	}
}
dojo.collections.BinaryTree.TraversalMethods={
	Preorder : 0,
	Inorder : 1,
	Postorder : 2
};

__CPAN_FILE__ src/collections/Collections.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.Collections");

dojo.collections={Collections:true};
dojo.collections.DictionaryEntry=function(/* string */k, /* object */v){
	//	summary
	//	return an object of type dojo.collections.DictionaryEntry
	this.key=k;
	this.value=v;
	this.valueOf=function(){ 
		return this.value; 	//	object
	};
	this.toString=function(){ 
		return String(this.value);	//	string 
	};
}

/*	Iterators
 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
 *	work with the Collections included in this namespace.  However, they *can*
 *	be used with arrays and objects, respectively, should one choose to do so.
 */
dojo.collections.Iterator=function(/* array */arr){
	//	summary
	//	return an object of type dojo.collections.Iterator
	var a=arr;
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		var s=scope||dj_global;
		if(Array.map){
			return Array.map(a,fn,s);	//	array
		}else{
			var arr=[];
			for(var i=0; i<a.length; i++){
				arr.push(fn.call(s,a[i]));
			}
			return arr;		//	array
		}
	};
	this.reset=function(){
		//	summary
		//	reset the internal cursor.
		position=0;
		this.element=a[position];
	};
}

/*	Notes:
 *	The DictionaryIterator no longer supports a key and value property;
 *	the reality is that you can use this to iterate over a JS object
 *	being used as a hashtable.
 */
dojo.collections.DictionaryIterator=function(/* object */obj){
	//	summary
	//	return an object of type dojo.collections.DictionaryIterator
	var a=[];	//	Create an indexing array
	for(var p in obj) {
		a.push(obj[p]);	//	fill it up
	}
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		var s=scope||dj_global;
		if(Array.map){
			return Array.map(a,fn,s);	//	array
		}else{
			var arr=[];
			for(var i=0; i<a.length; i++){
				arr.push(fn.call(s,a[i]));
			}
			return arr;		//	array
		}
	};
	this.reset=function() { 
		//	summary
		//	reset the internal cursor.
		position=0; 
		this.element=a[position];
	};
};

__CPAN_FILE__ src/collections/Dictionary.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.Dictionary");
dojo.require("dojo.collections.Collections");

dojo.collections.Dictionary=function(/* dojo.collections.Dictionary? */dictionary){
	//	summary
	//	Returns an object of type dojo.collections.Dictionary
	var items={};
	this.count=0;

	this.add=function(/* string */k, /* object */v){
		//	summary
		//	Add a new item to the Dictionary.
		var b=(k in items);
		items[k]=new dojo.collections.DictionaryEntry(k,v);
		if(!b){
			this.count++;
		}
	};
	this.clear=function(){
		//	summary
		//	Clears the internal dictionary.
		items={};
		this.count=0;
	};
	this.clone=function(){
		//	summary
		//	Returns a new instance of dojo.collections.Dictionary; note the the dictionary is a clone but items might not be.
		return new dojo.collections.Dictionary(this);	//	dojo.collections.Dictionary
	};
	this.contains=this.containsKey=function(/* string */k){
		//	summary
		//	Check to see if the dictionary has an entry at key "k".
		return (items[k]!=null);	//	bool
	};
	this.containsValue=function(/* object */v){
		//	summary
		//	Check to see if the dictionary has an entry with value "v".
		var e=this.getIterator();
		while(e.get()){
			if(e.element.value==v){
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.entry=function(/* string */k){
		//	summary
		//	Accessor method; similar to dojo.collections.Dictionary.item but returns the actual Entry object.
		return items[k];	//	dojo.collections.DictionaryEntry
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var a=[];	//	Create an indexing array
		for(var p in items) {
			a.push(items[p]);	//	fill it up
		}
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(a, fn, s);
		}else{
			for(var i=0; i<a.length; i++){
				fn.call(s, a[i], i, a);
			}
		}
	};
	this.getKeyList=function(){
		//	summary
		//	Returns an array of the keys in the dictionary.
		return (this.getIterator()).map(function(e){ 
			return e.key; 
		});	//	array
	};
	this.getValueList=function(){
		//	summary
		//	Returns an array of the values in the dictionary.
		return (this.getIterator()).map(function(e){ 
			return e.value; 
		});	//	array
	};
	this.item=function(/* string */k){
		//	summary
		//	Accessor method.
		if(k in items){
			return items[k].valueOf();	//	object
		}
		return undefined;	//	object
	};
	this.getIterator=function(){
		//	summary
		//	Gets a dojo.collections.DictionaryIterator for iteration purposes.
		return new dojo.collections.DictionaryIterator(items);	//	dojo.collections.DictionaryIterator
	};
	this.remove=function(/* string */k){
		//	summary
		//	Removes the item at k from the internal collection.
		if(k in items){
			delete items[k];
			this.count--;
			return true;	//	bool
		}
		return false;	//	bool
	};

	if (dictionary){
		var e=dictionary.getIterator();
		while(e.get()) {
			 this.add(e.element.key, e.element.value);
		}
	}
};

__CPAN_FILE__ src/collections/Graph.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.Graph");
dojo.require("dojo.collections.Collections");

dojo.experimental("dojo.collections.Graph");

dojo.collections.Graph=function(nodes){
	function node(key, data, neighbors) {
		this.key=key;
		this.data=data;
		this.neighbors=neighbors||new adjacencyList();
		this.addDirected=function(){
			if (arguments[0].constructor==edgeToNeighbor){
				this.neighbors.add(arguments[0]);
			}else{
				var n=arguments[0];
				var cost=arguments[1]||0;
				this.neighbors.add(new edgeToNeighbor(n, cost));
			}
		}
	}
	function nodeList(){
		var d=new dojo.collections.Dictionary();
		function nodelistiterator(){
			var o=[] ;	//	Create an indexing array
			var e=d.getIterator();
			while(e.get()){
				o[o.length]=e.element;
			}

			var position=0;
			this.element=o[position]||null;
			this.atEnd=function(){
				return (position>=o.length);
			}
			this.get=function(){
				if(this.atEnd()){
					return null;		//	object
				}
				this.element=o[position++];
				return this.element;	//	object
			};
			this.map=function(/* function */fn, /* object? */scope){
				var s=scope||dj_global;
				if(Array.map){
					return Array.map(o,fn,s);	//	array
				}else{
					var arr=[];
					for(var i=0; i<o.length; i++){
						arr.push(fn.call(s,o[i]));
					}
					return arr;		//	array
				}
			};
			this.reset=function(){
				position=0;
				this.element=o[position];
			};
		}
		
		this.add=function(node){
			d.add(node.key, node);
		};
		this.clear=function(){
			d.clear();
		};
		this.containsKey=function(key){
			return d.containsKey(key);
		};
		this.getIterator=function(){
			return new nodelistiterator(this);
		};
		this.item=function(key){
			return d.item(key);
		};
		this.remove=function(node){
			d.remove(node.key);
		};
	}
	function edgeToNeighbor(node, cost){
		this.neighbor=node;
		this.cost=cost;
	}
	function adjacencyList(){
		var d=[];
		this.add=function(o){
			d.push(o);
		};
		this.item=function(i){
			return d[i];
		};
		this.getIterator=function(){
			return new dojo.collections.Iterator([].concat(d));
		};
	}

	this.nodes=nodes||new nodeList();
	this.count=this.nodes.count;
	this.clear=function(){
		this.nodes.clear();
		this.count=0;
	};
	this.addNode=function(){
		var n=arguments[0];
		if(arguments.length > 1){
			n=new node(arguments[0],arguments[1]);
		}
		if(!this.nodes.containsKey(n.key)){
			this.nodes.add(n);
			this.count++;
		}
	};
	this.addDirectedEdge=function(uKey, vKey, cost){
		var uNode,vNode;
		if(uKey.constructor!= node){
			uNode=this.nodes.item(uKey);
			vNode=this.nodes.item(vKey);
		}else{
			uNode=uKey;
			vNode=vKey;
		}
		var c=cost||0;
		uNode.addDirected(vNode,c);
	};
	this.addUndirectedEdge=function(uKey, vKey, cost){
		var uNode, vNode;
		if(uKey.constructor!=node){
			uNode=this.nodes.item(uKey);
			vNode=this.nodes.item(vKey);
		}else{
			uNode=uKey;
			vNode=vKey;
		}
		var c=cost||0;
		uNode.addDirected(vNode,c);
		vNode.addDirected(uNode,c);
	};
	this.contains=function(n){
		return this.nodes.containsKey(n.key);
	};
	this.containsKey=function(k){
		return this.nodes.containsKey(k);
	};
}

__CPAN_FILE__ src/collections/Queue.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.Queue");
dojo.require("dojo.collections.Collections");

dojo.collections.Queue=function(/* array? */arr){
	//	summary
	//	return an object of type dojo.collections.Queue
	var q=[];
	if (arr){
		q=q.concat(arr);
	}
	this.count=q.length;
	this.clear=function(){
		//	summary
		//	clears the internal collection
		q=[];
		this.count=q.length;
	};
	this.clone=function(){
		//	summary
		//	creates a new Queue based on this one
		return new dojo.collections.Queue(q);	//	dojo.collections.Queue
	};
	this.contains=function(/* object */ o){
		//	summary
		//	Check to see if the passed object is an element in this queue
		for(var i=0; i<q.length; i++){
			if (q[i]==o){
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.copyTo=function(/* array */ arr, /* int */ i){
		//	summary
		//	Copy the contents of this queue into the passed array at index i.
		arr.splice(i,0,q);
	};
	this.dequeue=function(){
		//	summary
		//	shift the first element off the queue and return it
		var r=q.shift();
		this.count=q.length;
		return r;	//	object
	};
	this.enqueue=function(/* object */ o){
		//	summary
		//	put the passed object at the end of the queue
		this.count=q.push(o);
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(q, fn, s);
		}else{
			for(var i=0; i<items.length; i++){
				fn.call(s, q[i], i, q);
			}
		}
	};
	this.getIterator=function(){
		//	summary
		//	get an Iterator based on this queue.
		return new dojo.collections.Iterator(q);	//	dojo.collections.Iterator
	};
	this.peek=function(){
		//	summary
		//	get the next element in the queue without altering the queue.
		return q[0];
	};
	this.toArray=function(){
		//	summary
		//	return an array based on the internal array of the queue.
		return [].concat(q);
	};
};

__CPAN_FILE__ src/collections/Set.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.Set");
dojo.require("dojo.collections.Collections");
dojo.require("dojo.collections.ArrayList");

//	straight up sets are based on arrays or array-based collections.
dojo.collections.Set = new function(){
	this.union = function(setA, setB){
		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
		var result = new dojo.collections.ArrayList(setA.toArray());
		var e = setB.getIterator();
		while(!e.atEnd()){
			var item=e.get();
			if(!result.contains(item)){
				result.add(item);
			}
		}
		return result;
	};
	this.intersection = function(setA, setB){
		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
		var result = new dojo.collections.ArrayList();
		var e = setB.getIterator();
		while(!e.atEnd()){
			var item=e.get();
			if(setA.contains(item)){
				result.add(item);
			}
		}
		return result;
	};
	//	returns everything in setA that is not in setB.
	this.difference = function(setA, setB){
		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
		var result = new dojo.collections.ArrayList();
		var e=setA.getIterator();
		while(!e.atEnd()){
			var item=e.get();
			if(!setB.contains(item)){
				result.add(item);
			}
		}
		return result;
	};
	this.isSubSet = function(setA, setB) {
		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
		var e = setA.getIterator();
		while(!e.atEnd()){
			if(!setB.contains(e.get())){
				return false;
			}
		}
		return true;
	};
	this.isSuperSet = function(setA, setB){
		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
		var e = setB.getIterator();
		while(!e.atEnd()){
			if(!setA.contains(e.get())){
				return false;
			}
		}
		return true;
	};
}();

__CPAN_FILE__ src/collections/SkipList.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.SkipList");
dojo.require("dojo.collections.Collections");
dojo.require("dojo.experimental");

dojo.experimental("dojo.collections.SkipList");

dojo.collections.SkipList = function(){
	function node(height, val){
		this.value = val;
		this.height = height;
		this.nodes = new nodeList(height);
		this.compare = function(val){
			if (this.value > val) return 1;
			if (this.value < val) return -1;
			return 0;
		}
		this.incrementHeight = function(){
			this.nodes.incrementHeight();
			this.height++;
		};
		this.decrementHeight = function(){
			this.nodes.decrementHeight();
			this.height--;
		};
	}
	function nodeList(height){
		var arr = [];
		this.height = height;
		for (var i = 0; i < height; i++) arr[i] = null;
		this.item = function(i){
			return arr[i];
		};
		this.incrementHeight = function(){
			this.height++;
			arr[this.height] = null;
		};
		this.decrementHeight = function(){
			arr.splice(arr.length - 1, 1);
			this.height--;
		};
	}
	function iterator(list){
		this.current = list.head;
		this.atEnd = false;
		this.moveNext = function(){
			if (this.atEnd) return !this.atEnd;
			this.current = this.current.nodes[0];
			this.atEnd = (current == null);
			return !this.atEnd;
		};
		this.reset = function(){
			this.current = null;
		};
	}

	function chooseRandomHeight(max){
		var level = 1;
		while (Math.random() < PROB && level < max) level++;
		return level;
	}

	var PROB = 0.5;
	var comparisons = 0;

	this.head = new node(1);
	this.count = 0;
	this.add = function(val){
		var updates = [];
		var current = this.head;
		for (var i = this.head.height; i >= 0; i--){
			if (!(current.nodes[i] != null && current.nodes[i].compare(val) < 0)) comparisons++;
			while (current.nodes[i] != null && current.nodes[i].compare(val) < 0){
				current = current.nodes[i];
				comparisons++;
			}
			updates[i] = current;
		}
		if (current.nodes[0] != null && current.nodes[0].compare(val) == 0) return;
		var n = new node(val, chooseRandomHeight(head.height + 1));
		this.count++;
		if (n.height > head.height){
			head.incrementHeight();
			head.nodes[head.height - 1] = n;
		}
		for (i = 0; i < n.height; i++){
			if (i < updates.length) {
				n.nodes[i] = updates[i].nodes[i];
				updates[i].nodes[i] = n;
			}
		}
	};
	
	this.contains = function(val){
		var current = this.head;
		var i;
		for (i = head.height - 1; i >= 0; i--) {
			while (current.item(i) != null) {
				comparisons++;
				var result = current.nodes[i].compare(val);
				if (result == 0) return true;
				else if (result < 0) current = current.nodes[i];
				else break;
			}
		}
		return false;
	};
	this.getIterator = function(){
		return new iterator(this);
	};

	this.remove = function(val){
		var updates = [];
		var current = this.head;
		for (var i = this.head.height - 1; i >= 0; i--){
			if (!(current.nodes[i] != null && current.nodes[i].compare(val) < 0)) comparisons++;
			while (current.nodes[i] != null && current.nodes[i].compare(val) < 0) {
				current = current.nodes[i];
				comparisons++;
			}
			updates[i] = current;
		}
		
		current = current.nodes[0];
		if (current != null && current.compare(val) == 0){
			this.count--;
			for (var i = 0; i < head.height; i++){
				if (updates[i].nodes[i] != current) break;
				else updates[i].nodes[i] = current.nodes[i];
			}
			if (head.nodes[head.height - 1] == null) head.decrementHeight();
		}
	};
	this.resetComparisons = function(){ 
		comparisons = 0; 
	};
}

__CPAN_FILE__ src/collections/SortedList.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.SortedList");
dojo.require("dojo.collections.Collections");

dojo.collections.SortedList=function(/* object? */ dictionary){
	//	summary
	//	creates a collection that acts like a dictionary but is also internally sorted.
	//	Note that the act of adding any elements forces an internal resort, making this object potentially slow.
	var _this=this;
	var items={};
	var q=[];
	var sorter=function(a,b){
		if (a.key > b.key) return 1;
		if (a.key < b.key) return -1;
		return 0;
	};
	var build=function(){
		q=[];
		var e=_this.getIterator();
		while (!e.atEnd()){
			q.push(e.get());
		}
		q.sort(sorter);
	};

	this.count=q.length;
	this.add=function(/* string */ k,/* object */v){
		//	summary
		//	add the passed value to the dictionary at location k
		if (!items[k]) {
			items[k]=new dojo.collections.DictionaryEntry(k,v);
			this.count=q.push(items[k]);
			q.sort(sorter);
		}
	};
	this.clear=function(){
		//	summary
		//	clear the internal collections
		items={};
		q=[];
		this.count=q.length;
	};
	this.clone=function(){
		//	summary
		//	create a clone of this sorted list
		return new dojo.collections.SortedList(this);	//	dojo.collections.SortedList
	};
	this.contains=this.containsKey=function(/* string */ k){
		//	summary
		//	Check to see if the list has a location k
		return (items[k]!=null);	//	bool
	};
	this.containsValue=function(/* object */ o){
		//	summary
		//	Check to see if this list contains the passed object
		var e=this.getIterator();
		while (!e.atEnd()){
			var item=e.get();
			if(item.value==o){ 
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.copyTo=function(/* array */ arr, /* int */ i){
		//	summary
		//	copy the contents of the list into array arr at index i
		var e=this.getIterator();
		var idx=i;
		while(!e.atEnd()){
			arr.splice(idx,0,e.get());
			idx++;
		}
	};
	this.entry=function(/* string */ k){
		//	summary
		//	return the object at location k
		return items[k];	//	dojo.collections.DictionaryEntry
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(q, fn, s);
		}else{
			for(var i=0; i<q.length; i++){
				fn.call(s, q[i], i, q);
			}
		}
	};
	this.getByIndex=function(/* int */ i){
		//	summary
		//	return the item at index i
		return q[i].valueOf();	//	object
	};
	this.getIterator=function(){
		//	summary
		//	get an iterator for this object
		return new dojo.collections.DictionaryIterator(items);	//	dojo.collections.DictionaryIterator
	};
	this.getKey=function(/* int */ i){
		//	summary
		//	return the key of the item at index i
		return q[i].key;
	};
	this.getKeyList=function(){
		//	summary
		//	return an array of the keys set in this list
		var arr=[];
		var e=this.getIterator();
		while (!e.atEnd()){
			arr.push(e.get().key);
		}
		return arr;	//	array
	};
	this.getValueList=function(){
		//	summary
		//	return an array of values in this list
		var arr=[];
		var e=this.getIterator();
		while (!e.atEnd()){
			arr.push(e.get().value);
		}
		return arr;	//	array
	};
	this.indexOfKey=function(/* string */ k){
		//	summary
		//	return the index of the passed key.
		for (var i=0; i<q.length; i++){
			if (q[i].key==k){
				return i;	//	int
			}
		}
		return -1;	//	int
	};
	this.indexOfValue=function(/* object */ o){
		//	summary
		//	return the first index of object o
		for (var i=0; i<q.length; i++){
			if (q[i].value==o){
				return i;	//	int
			}
		}
		return -1;	//	int
	};
	this.item=function(/* string */ k){
		// 	summary
		//	return the value of the object at location k.
		if(k in items){
			return items[k].valueOf();	//	object
		}
		return undefined;	//	object
	};
	this.remove=function(/* string */k){
		// 	summary
		//	remove the item at location k and rebuild the internal collections.
		delete items[k];
		build();
		this.count=q.length;
	};
	this.removeAt=function(/* int */ i){
		//	summary
		//	remove the item at index i, and rebuild the internal collections.
		delete items[q[i].key];
		build();
		this.count=q.length;
	};
	this.replace=function(/* string */ k, /* object */ v){
		//	summary
		//	Replace an existing item if it's there, and add a new one if not.
		if (!items[k]){
			//	we're adding a new object, return false
			this.add(k,v);
			return false; // bool
		}else{
			//	we're replacing an object, return true
			items[k]=new dojo.collections.DictionaryEntry(k,v);
			q.sort(sorter);
			return true; // bool
		}
	};
	this.setByIndex=function(/* int */ i, /* object */ o){
		//	summary
		//	set an item by index
		items[q[i].key].value=o;
		build();
		this.count=q.length;
	};
	if (dictionary){
		var e=dictionary.getIterator();
		while (!e.atEnd()){
			var item=e.get();
			q[q.length]=items[item.key]=new dojo.collections.DictionaryEntry(item.key,item.value);
		}
		q.sort(sorter);
	}
}

__CPAN_FILE__ src/collections/Stack.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.collections.Stack");
dojo.require("dojo.collections.Collections");

dojo.collections.Stack=function(/* array? */arr){
	//	summary
	//	returns an object of type dojo.collections.Stack
	var q=[];
	if (arr) q=q.concat(arr);
	this.count=q.length;
	this.clear=function(){
		//	summary
		//	Clear the internal array and reset the count
		q=[];
		this.count=q.length;
	};
	this.clone=function(){
		//	summary
		//	Create and return a clone of this Stack
		return new dojo.collections.Stack(q);
	};
	this.contains=function(/* object */o){
		//	summary
		//	check to see if the stack contains object o
		for (var i=0; i<q.length; i++){
			if (q[i] == o){
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.copyTo=function(/* array */ arr, /* int */ i){
		//	summary
		//	copy the stack into array arr at index i
		arr.splice(i,0,q);
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(q, fn, s);
		}else{
			for(var i=0; i<items.length; i++){
				fn.call(s, q[i], i, q);
			}
		}
	};
	this.getIterator=function(){
		//	summary
		//	get an iterator for this collection
		return new dojo.collections.Iterator(q);	//	dojo.collections.Iterator
	};
	this.peek=function(){
		//	summary
		//	Return the next item without altering the stack itself.
		return q[(q.length-1)];	//	object
	};
	this.pop=function(){
		//	summary
		//	pop and return the next item on the stack
		var r=q.pop();
		this.count=q.length;
		return r;	//	object
	};
	this.push=function(/* object */ o){
		//	summary
		//	Push object o onto the stack
		this.count=q.push(o);
	};
	this.toArray=function(){
		//	summary
		//	create and return an array based on the internal collection
		return [].concat(q);	//	array
	};
}

__CPAN_FILE__ src/collections/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		"dojo.collections.Collections",
		"dojo.collections.SortedList", 
		"dojo.collections.Dictionary", 
		"dojo.collections.Queue", 
		"dojo.collections.ArrayList", 
		"dojo.collections.Stack",
		"dojo.collections.Set"
	]
});
dojo.provide("dojo.collections.*");

__CPAN_DIR__ src/compat
__CPAN_FILE__ src/compat/0.2.2.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*
Compatibility package to get 0.2.2 functionality in later Dojo releases.
*/

//**********************************
//From bootstrap1.js
dj_throw = dj_rethrow = function(m, e){
	dojo.deprecated("dj_throw and dj_rethrow deprecated, use dojo.raise instead");
	dojo.raise(m, e);
}

dj_debug = dojo.debug;
dj_unimplemented = dojo.unimplemented;
dj_deprecated = dojo.deprecated;

dj_inherits = function(subclass, superclass){
	dojo.deprecated("dj_inherits deprecated, use dojo.inherits instead");
	dojo.inherits(subclass, superclass);
}

/**
* Set the base script uri.
*/
// In JScript .NET, see interface System._AppDomain implemented by
// System.AppDomain.CurrentDomain. Members include AppendPrivatePath,
// RelativeSearchPath, BaseDirectory.
dojo.hostenv.setBaseScriptUri = function(uri){ djConfig.baseScriptUri = uri }

//**********************************
//From the old bootstrap2.js
dojo.hostenv.moduleLoaded = function(){
	return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);
}

dojo.hostenv.require = dojo.hostenv.loadModule;
dojo.requireAfter = dojo.require;
dojo.conditionalRequire = dojo.requireIf;

dojo.requireAll = function() {
	for(var i = 0; i < arguments.length; i++) { dojo.require(arguments[i]); }
}

dojo.hostenv.conditionalLoadModule = function(){
	dojo.kwCompoundRequire.apply(dojo, arguments);
}

dojo.hostenv.provide = dojo.hostenv.startPackage;

//**********************************
//From hostenv_browser.js
dojo.hostenv.byId = dojo.byId;

dojo.hostenv.byIdArray = dojo.byIdArray = function(){
	var ids = [];
	for(var i = 0; i < arguments.length; i++){
		if((arguments[i] instanceof Array)||(typeof arguments[i] == "array")){
			for(var j = 0; j < arguments[i].length; j++){
				ids = ids.concat(dojo.hostenv.byIdArray(arguments[i][j]));
			}
		}else{
			ids.push(dojo.hostenv.byId(arguments[i]));
		}
	}
	return ids;
}

__CPAN_DIR__ src/crypto
__CPAN_FILE__ src/crypto/Blowfish.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.crypto");
dojo.provide("dojo.crypto.Blowfish");

/*	Blowfish
 *	Created based on the C# implementation by Marcus Hahn (http://www.hotpixel.net/)
 *	Unsigned math functions derived from Joe Gregorio's SecureSyndication GM script
 *	http://bitworking.org/projects/securesyndication/
 *	(Note that this is *not* an adaption of the above script)
 *
 *	version 1.0 
 *	TRT 
 *	2005-12-08
 */
dojo.crypto.Blowfish = new function(){
	var POW2=Math.pow(2,2);
	var POW3=Math.pow(2,3);
	var POW4=Math.pow(2,4);
	var POW8=Math.pow(2,8);
	var POW16=Math.pow(2,16);
	var POW24=Math.pow(2,24);
	var iv=null;	//	CBC mode initialization vector
	var boxes={
		p:[
			0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 
			0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 
			0x9216d5d9, 0x8979fb1b
		],
		s0:[
			0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
			0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
			0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
			0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
			0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
			0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
			0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
			0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
			0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
			0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
			0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 
			0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 
			0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 
			0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
			0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
			0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
			0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 
			0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 
			0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 
			0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 
			0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
			0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 
			0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
			0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c, 
			0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
			0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
			0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
			0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
			0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
			0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
			0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
			0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
		],
		s1:[
			0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
			0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
			0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
			0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
			0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
			0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
			0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
			0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 
			0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 
			0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
			0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 
			0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
			0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 
			0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 
			0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
			0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 
			0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
			0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 
			0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
			0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 
			0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 
			0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 
			0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
			0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
			0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 
			0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
			0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
			0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
			0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
			0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
			0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
			0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
		],
		s2:[
			0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
			0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
			0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
			0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
			0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
			0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
			0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
			0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
			0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
			0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
			0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
			0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
			0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
			0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
			0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
			0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
			0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
			0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
			0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
			0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
			0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 
			0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
			0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
			0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 
			0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 
			0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 
			0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 
			0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
			0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
			0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 
			0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
			0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
		],
		s3:[
			0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
			0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
			0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 
			0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
			0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 
			0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 
			0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
			0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 
			0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 
			0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 
			0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
			0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 
			0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 
			0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 
			0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
			0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
			0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 
			0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
			0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 
			0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 
			0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 
			0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 
			0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
			0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e, 
			0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
			0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 
			0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 
			0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 
			0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 
			0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
			0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
			0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
		]
	}
////////////////////////////////////////////////////////////////////////////
	function add(x,y){
		var sum=(x+y)&0xffffffff;
		if (sum<0){
			sum=-sum;
			return (0x10000*((sum>>16)^0xffff))+(((sum&0xffff)^0xffff)+1);
		}
		return sum;
	}
	function split(x){
		var r=x&0xffffffff;
		if(r<0) {
			r=-r;
			return [((r&0xffff)^0xffff)+1,(r>>16)^0xffff];
		}
		return [r&0xffff,(r>>16)];
	}
	function xor(x,y){
		var xs=split(x);
		var ys=split(y);
		return (0x10000*(xs[1]^ys[1]))+(xs[0]^ys[0]);
	}
	function $(v, box){
		var d=v&0xff; v>>=8;
		var c=v&0xff; v>>=8;
		var b=v&0xff; v>>=8;
		var a=v&0xff;
		var r=add(box.s0[a],box.s1[b]);
		r=xor(r,box.s2[c]);
		return add(r,box.s3[d]);
	}
////////////////////////////////////////////////////////////////////////////
	function eb(o, box){
		var l=o.left;
		var r=o.right;
		l=xor(l,box.p[0]);
		r=xor(r,xor($(l,box),box.p[1]));
		l=xor(l,xor($(r,box),box.p[2]));
		r=xor(r,xor($(l,box),box.p[3]));
		l=xor(l,xor($(r,box),box.p[4]));
		r=xor(r,xor($(l,box),box.p[5]));
		l=xor(l,xor($(r,box),box.p[6]));
		r=xor(r,xor($(l,box),box.p[7]));
		l=xor(l,xor($(r,box),box.p[8]));
		r=xor(r,xor($(l,box),box.p[9]));
		l=xor(l,xor($(r,box),box.p[10]));
		r=xor(r,xor($(l,box),box.p[11]));
		l=xor(l,xor($(r,box),box.p[12]));
		r=xor(r,xor($(l,box),box.p[13]));
		l=xor(l,xor($(r,box),box.p[14]));
		r=xor(r,xor($(l,box),box.p[15]));
		l=xor(l,xor($(r,box),box.p[16]));
		o.right=l;
		o.left=xor(r,box.p[17]);
	}

	function db(o, box){
		var l=o.left;
		var r=o.right;
		l=xor(l,box.p[17]);
		r=xor(r,xor($(l,box),box.p[16]));
		l=xor(l,xor($(r,box),box.p[15]));
		r=xor(r,xor($(l,box),box.p[14]));
		l=xor(l,xor($(r,box),box.p[13]));
		r=xor(r,xor($(l,box),box.p[12]));
		l=xor(l,xor($(r,box),box.p[11]));
		r=xor(r,xor($(l,box),box.p[10]));
		l=xor(l,xor($(r,box),box.p[9]));
		r=xor(r,xor($(l,box),box.p[8]));
		l=xor(l,xor($(r,box),box.p[7]));
		r=xor(r,xor($(l,box),box.p[6]));
		l=xor(l,xor($(r,box),box.p[5]));
		r=xor(r,xor($(l,box),box.p[4]));
		l=xor(l,xor($(r,box),box.p[3]));
		r=xor(r,xor($(l,box),box.p[2]));
		l=xor(l,xor($(r,box),box.p[1]));
		o.right=l;
		o.left=xor(r,box.p[0]);
	}

	//	Note that we aren't caching contexts here; it might take a little longer
	//	but we should be more secure this way.
	function init(key){
		var k=key;
		if (typeof(k)=="string"){
			var a=[];
			for(var i=0; i<k.length; i++) 
				a.push(k.charCodeAt(i)&0xff);
			k=a;
		}
		//	init the boxes
		var box = { p:[], s0:[], s1:[], s2:[], s3:[] };
		for(var i=0; i<boxes.p.length; i++) box.p.push(boxes.p[i]);
		for(var i=0; i<boxes.s0.length; i++) box.s0.push(boxes.s0[i]);
		for(var i=0; i<boxes.s1.length; i++) box.s1.push(boxes.s1[i]);
		for(var i=0; i<boxes.s2.length; i++) box.s2.push(boxes.s2[i]);
		for(var i=0; i<boxes.s3.length; i++) box.s3.push(boxes.s3[i]);

		//	init p with the key
		var pos=0;
		var data=0;
		for(var i=0; i < box.p.length; i++){
			for (var j=0; j<4; j++){
				data = (data*POW8) | k[pos];
				if(++pos==k.length) pos=0;
			}
			box.p[i] = xor(box.p[i], data);
		}

		//	encrypt p and the s boxes
		var res={ left:0, right:0 };
		for(var i=0; i<box.p.length;){
			eb(res, box);
			box.p[i++]=res.left;
			box.p[i++]=res.right;
		}
		for (var i=0; i<4; i++){
			for(var j=0; j<box["s"+i].length;){
				eb(res, box);
				box["s"+i][j++]=res.left;
				box["s"+i][j++]=res.right;
			}
		}
		return box;
	}

////////////////////////////////////////////////////////////////////////////
//	CONVERSION FUNCTIONS
////////////////////////////////////////////////////////////////////////////
	//	these operate on byte arrays, NOT word arrays.
	function toBase64(ba){ 
		var p="=";
		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var s=[];
		var count=0;
		for (var i =0; i<ba.length;){
			var t=ba[i++]<<16|ba[i++]<<8|ba[i++];
			s.push(tab.charAt((t>>>18)&0x3f)); 
			s.push(tab.charAt((t>>>12)&0x3f));
			s.push(tab.charAt((t>>>6)&0x3f));
			s.push(tab.charAt(t&0x3f));
			count+=4;
		}
		var pa=i-ba.length;
		while((pa--)>0)	s.push(p);	
		return s.join("");
	}
	function fromBase64(str){
		var s=str.split("");
		var p="=";
		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var out=[];
		var l=s.length;
		while(s[--l]==p){ }
		for (var i=0; i<l;){
			var t=tab.indexOf(s[i++])<<18|tab.indexOf(s[i++])<<12|tab.indexOf(s[i++])<<6|tab.indexOf(s[i++]);
			out.push((t>>>16)&0xff);
			out.push((t>>>8)&0xff);
			out.push(t&0xff);
		}
		return out;
	}
////////////////////////////////////////////////////////////////////////////
//	PUBLIC FUNCTIONS
//	0.2: Only supporting ECB mode for now.
////////////////////////////////////////////////////////////////////////////
	this.getIV=function(outputType){
		var out=outputType||dojo.crypto.outputTypes.Base64;
		switch(out){
			case dojo.crypto.outputTypes.Hex:{
				var s=[];
				for(var i=0; i<iv.length; i++)
					s.push((iv[i]).toString(16));
				return s.join("");
			}
			case dojo.crypto.outputTypes.String:{
				return iv.join("");
			}
			case dojo.crypto.outputTypes.Raw:{
				return iv;
			}
			default:{
				return toBase64(iv);
			}
		}
	};
	this.setIV=function(data, inputType){
		var ip=inputType||dojo.crypto.outputTypes.Base64;
		var ba=null;
		switch(ip){
			case dojo.crypto.outputTypes.String:{
				ba=[];
				for (var i=0; i<data.length; i++){
					ba.push(data.charCodeAt(i));
				}
				break;
			}
			case dojo.crypto.outputTypes.Hex:{
				ba=[];
				var i=0;
				while (i+1<data.length){
					ba.push(parseInt(data.substr(i,2),16));
					i+=2;
				}
				break;
			}
			case dojo.crypto.outputTypes.Raw:{
				ba=data;
				break;
			}
			default:{
				ba=fromBase64(data);
				break;
			}
		}
		//	make it a pair of words now
		iv={};
		iv.left=ba[0]*POW24|ba[1]*POW16|ba[2]*POW8|ba[3];
		iv.right=ba[4]*POW24|ba[5]*POW16|ba[6]*POW8|ba[7];
	}
	this.encrypt = function(plaintext, key, ao){
		var out=dojo.crypto.outputTypes.Base64;
		var mode=dojo.crypto.cipherModes.EBC;
		if (ao){
			if (ao.outputType) out=ao.outputType;
			if (ao.cipherMode) mode=ao.cipherMode;
		}

		var bx = init(key);
		var padding = 8-(plaintext.length&7);
		for (var i=0; i<padding; i++) plaintext+=String.fromCharCode(padding);
		var cipher=[];
		var count=plaintext.length >> 3;
		var pos=0;
		var o={};
		var isCBC=(mode==dojo.crypto.cipherModes.CBC);
		var vector={left:iv.left||null, right:iv.right||null};
		for(var i=0; i<count; i++){
			o.left=plaintext.charCodeAt(pos)*POW24
				|plaintext.charCodeAt(pos+1)*POW16
				|plaintext.charCodeAt(pos+2)*POW8
				|plaintext.charCodeAt(pos+3);
			o.right=plaintext.charCodeAt(pos+4)*POW24
				|plaintext.charCodeAt(pos+5)*POW16
				|plaintext.charCodeAt(pos+6)*POW8
				|plaintext.charCodeAt(pos+7);

			if(isCBC){
				o.left=xor(o.left, vector.left);
				o.right=xor(o.right, vector.right);
			}

			eb(o, bx);	//	encrypt the block

			if(isCBC){
				vector.left=o.left;
				vector.right=o.right;dojo.crypto.outputTypes.Hex
			}

			cipher.push((o.left>>24)&0xff); 
			cipher.push((o.left>>16)&0xff); 
			cipher.push((o.left>>8)&0xff);
			cipher.push(o.left&0xff);
			cipher.push((o.right>>24)&0xff); 
			cipher.push((o.right>>16)&0xff); 
			cipher.push((o.right>>8)&0xff);
			cipher.push(o.right&0xff);
			pos+=8;
		}
		switch(out){
			case dojo.crypto.outputTypes.Hex:{
				var s=[];
				for(var i=0; i<cipher.length; i++)
					s.push((cipher[i]).toString(16));
				return s.join("");
			}
			case dojo.crypto.outputTypes.String:{
				return cipher.join("");
			}
			case dojo.crypto.outputTypes.Raw:{
				return cipher;
			}
			default:{
				return toBase64(cipher);
			}
		}
	};

	this.decrypt = function(ciphertext, key, ao){
		var ip=dojo.crypto.outputTypes.Base64;
		var mode=dojo.crypto.cipherModes.EBC;
		if (ao){
			if (ao.outputType) ip=ao.outputType;
			if (ao.cipherMode) mode=ao.cipherMode;
		}
		var bx = init(key);
		var pt=[];
	
		var c=null;
		switch(ip){
			case dojo.crypto.outputTypes.Hex:{
				c=[];
				var i=0;
				while (i+1<ciphertext.length){
					c.push(parseInt(ciphertext.substr(i,2),16));
					i+=2;
				}
				break;
			}
			case dojo.crypto.outputTypes.String:{
				c=[];
				for (var i=0; i<ciphertext.length; i++){
					c.push(ciphertext.charCodeAt(i));
				}
				break;
			}
			case dojo.crypto.outputTypes.Raw:{
				c=ciphertext;	//	should be a byte array
				break;
			}
			default:{
				c=fromBase64(ciphertext);
				break;
			}
		}

		var count=c.length >> 3;
		var pos=0;
		var o={};
		var isCBC=(mode==dojo.crypto.cipherModes.CBC);
		var vector={left:iv.left||null, right:iv.right||null};
		for(var i=0; i<count; i++){
			o.left=c[pos]*POW24|c[pos+1]*POW16|c[pos+2]*POW8|c[pos+3];
			o.right=c[pos+4]*POW24|c[pos+5]*POW16|c[pos+6]*POW8|c[pos+7];

			if(isCBC){
				var left=o.left;
				var right=o.right;
			}

			db(o, bx);	//	decrypt the block

			if(isCBC){
				o.left=xor(o.left, vector.left);
				o.right=xor(o.right, vector.right);
				vector.left=left;
				vector.right=right;
			}

			pt.push((o.left>>24)&0xff);
			pt.push((o.left>>16)&0xff);
			pt.push((o.left>>8)&0xff);
			pt.push(o.left&0xff);
			pt.push((o.right>>24)&0xff);
			pt.push((o.right>>16)&0xff);
			pt.push((o.right>>8)&0xff);
			pt.push(o.right&0xff);
			pos+=8;
		}

		//	check for padding, and remove.
		if(pt[pt.length-1]==pt[pt.length-2]||pt[pt.length-1]==0x01){
			var n=pt[pt.length-1];
			pt.splice(pt.length-n, n);
		}

		//	convert to string
		for(var i=0; i<pt.length; i++)
			pt[i]=String.fromCharCode(pt[i]);
		return pt.join("");
	};

	this.setIV("0000000000000000", dojo.crypto.outputTypes.Hex);
}();

__CPAN_FILE__ src/crypto/LICENSE
License Disclaimer:

All contents of this directory are Copyright (c) the Dojo Foundation, with the
following exceptions:
-------------------------------------------------------------------------------

MD5.js, SHA1.js:
	* Copyright 1998-2005, Paul Johnstone
	  Distributed under the terms of the BSD License



__CPAN_FILE__ src/crypto/MD5.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.crypto");
dojo.provide("dojo.crypto.MD5");

/*	Return to a port of Paul Johnstone's MD5 implementation
 *	http://pajhome.org.uk/crypt/md5/index.html
 *
 *	2005-12-7
 *	All conversions are internalized (no dependencies)
 *	implemented getHMAC for message digest auth.
 */
dojo.crypto.MD5 = new function(){
	var chrsz=8;
	var mask=(1<<chrsz)-1;
	function toWord(s) {
	  var wa=[];
	  for(var i=0; i<s.length*chrsz; i+=chrsz)
		wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
	  return wa;
	}
	function toString(wa){
		var s=[];
		for(var i=0; i<wa.length*32; i+=chrsz)
			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
		return s.join("");
	}
	function toHex(wa) {
		var h="0123456789abcdef";
		var s=[];
		for(var i=0; i<wa.length*4; i++){
			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
		}
		return s.join("");
	}
	function toBase64(wa){
		var p="=";
		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var s=[];
		for(var i=0; i<wa.length*4; i+=3){
			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32) s.push(p);
				else s.push(tab.charAt((t>>6*(3-j))&0x3F));
			}
		}
		return s.join("");
	}
	function add(x,y) {
		var l=(x&0xFFFF)+(y&0xFFFF);
		var m=(x>>16)+(y>>16)+(l>>16);
		return (m<<16)|(l&0xFFFF);
	}
	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function C(q,a,b,x,s,t){ return add(R(add(add(a,q),add(x,t)),s),b); }
	function FF(a,b,c,d,x,s,t){ return C((b&c)|((~b)&d),a,b,x,s,t); }
	function GG(a,b,c,d,x,s,t){ return C((b&d)|(c&(~d)),a,b,x,s,t); }
	function HH(a,b,c,d,x,s,t){ return C(b^c^d,a,b,x,s,t); }
	function II(a,b,c,d,x,s,t){ return C(c^(b|(~d)),a,b,x,s,t); }
	function core(x,len){
		x[len>>5]|=0x80<<((len)%32);
		x[(((len+64)>>>9)<<4)+14]=len;
		var a= 1732584193;
		var b=-271733879;
		var c=-1732584194;
		var d= 271733878;
		for(var i=0; i<x.length; i+=16){
			var olda=a;
			var oldb=b;
			var oldc=c;
			var oldd=d;

			a=FF(a,b,c,d,x[i+ 0],7 ,-680876936);
			d=FF(d,a,b,c,x[i+ 1],12,-389564586);
			c=FF(c,d,a,b,x[i+ 2],17, 606105819);
			b=FF(b,c,d,a,x[i+ 3],22,-1044525330);
			a=FF(a,b,c,d,x[i+ 4],7 ,-176418897);
			d=FF(d,a,b,c,x[i+ 5],12, 1200080426);
			c=FF(c,d,a,b,x[i+ 6],17,-1473231341);
			b=FF(b,c,d,a,x[i+ 7],22,-45705983);
			a=FF(a,b,c,d,x[i+ 8],7 , 1770035416);
			d=FF(d,a,b,c,x[i+ 9],12,-1958414417);
			c=FF(c,d,a,b,x[i+10],17,-42063);
			b=FF(b,c,d,a,x[i+11],22,-1990404162);
			a=FF(a,b,c,d,x[i+12],7 , 1804603682);
			d=FF(d,a,b,c,x[i+13],12,-40341101);
			c=FF(c,d,a,b,x[i+14],17,-1502002290);
			b=FF(b,c,d,a,x[i+15],22, 1236535329);

			a=GG(a,b,c,d,x[i+ 1],5 ,-165796510);
			d=GG(d,a,b,c,x[i+ 6],9 ,-1069501632);
			c=GG(c,d,a,b,x[i+11],14, 643717713);
			b=GG(b,c,d,a,x[i+ 0],20,-373897302);
			a=GG(a,b,c,d,x[i+ 5],5 ,-701558691);
			d=GG(d,a,b,c,x[i+10],9 , 38016083);
			c=GG(c,d,a,b,x[i+15],14,-660478335);
			b=GG(b,c,d,a,x[i+ 4],20,-405537848);
			a=GG(a,b,c,d,x[i+ 9],5 , 568446438);
			d=GG(d,a,b,c,x[i+14],9 ,-1019803690);
			c=GG(c,d,a,b,x[i+ 3],14,-187363961);
			b=GG(b,c,d,a,x[i+ 8],20, 1163531501);
			a=GG(a,b,c,d,x[i+13],5 ,-1444681467);
			d=GG(d,a,b,c,x[i+ 2],9 ,-51403784);
			c=GG(c,d,a,b,x[i+ 7],14, 1735328473);
			b=GG(b,c,d,a,x[i+12],20,-1926607734);

			a=HH(a,b,c,d,x[i+ 5],4 ,-378558);
			d=HH(d,a,b,c,x[i+ 8],11,-2022574463);
			c=HH(c,d,a,b,x[i+11],16, 1839030562);
			b=HH(b,c,d,a,x[i+14],23,-35309556);
			a=HH(a,b,c,d,x[i+ 1],4 ,-1530992060);
			d=HH(d,a,b,c,x[i+ 4],11, 1272893353);
			c=HH(c,d,a,b,x[i+ 7],16,-155497632);
			b=HH(b,c,d,a,x[i+10],23,-1094730640);
			a=HH(a,b,c,d,x[i+13],4 , 681279174);
			d=HH(d,a,b,c,x[i+ 0],11,-358537222);
			c=HH(c,d,a,b,x[i+ 3],16,-722521979);
			b=HH(b,c,d,a,x[i+ 6],23, 76029189);
			a=HH(a,b,c,d,x[i+ 9],4 ,-640364487);
			d=HH(d,a,b,c,x[i+12],11,-421815835);
			c=HH(c,d,a,b,x[i+15],16, 530742520);
			b=HH(b,c,d,a,x[i+ 2],23,-995338651);

			a=II(a,b,c,d,x[i+ 0],6 ,-198630844);
			d=II(d,a,b,c,x[i+ 7],10, 1126891415);
			c=II(c,d,a,b,x[i+14],15,-1416354905);
			b=II(b,c,d,a,x[i+ 5],21,-57434055);
			a=II(a,b,c,d,x[i+12],6 , 1700485571);
			d=II(d,a,b,c,x[i+ 3],10,-1894986606);
			c=II(c,d,a,b,x[i+10],15,-1051523);
			b=II(b,c,d,a,x[i+ 1],21,-2054922799);
			a=II(a,b,c,d,x[i+ 8],6 , 1873313359);
			d=II(d,a,b,c,x[i+15],10,-30611744);
			c=II(c,d,a,b,x[i+ 6],15,-1560198380);
			b=II(b,c,d,a,x[i+13],21, 1309151649);
			a=II(a,b,c,d,x[i+ 4],6 ,-145523070);
			d=II(d,a,b,c,x[i+11],10,-1120210379);
			c=II(c,d,a,b,x[i+ 2],15, 718787259);
			b=II(b,c,d,a,x[i+ 9],21,-343485551);

			a = add(a,olda);
			b = add(b,oldb);
			c = add(c,oldc);
			d = add(d,oldd);
		}
		return [a,b,c,d];
	}
	function hmac(data,key){
		var wa=toWord(key);
		if(wa.length>16) wa=core(wa,key.length*chrsz);
		var l=[], r=[];
		for(var i=0; i<16; i++){
			l[i]=wa[i]^0x36363636;
			r[i]=wa[i]^0x5c5c5c5c;
		}
		var h=core(l.concat(toWord(data)),512+data.length*chrsz);
		return core(r.concat(h),640);
	}

	//	Public functions
	this.compute=function(data,outputType){
		var out=outputType||dojo.crypto.outputTypes.Base64;
		switch(out){
			case dojo.crypto.outputTypes.Hex:{
				return toHex(core(toWord(data),data.length*chrsz));
			}
			case dojo.crypto.outputTypes.String:{
				return toString(core(toWord(data),data.length*chrsz));
			}
			default:{
				return toBase64(core(toWord(data),data.length*chrsz));
			}
		}
	};
	this.getHMAC=function(data,key,outputType){
		var out=outputType||dojo.crypto.outputTypes.Base64;
		switch(out){
			case dojo.crypto.outputTypes.Hex:{
				return toHex(hmac(data,key));
			}
			case dojo.crypto.outputTypes.String:{
				return toString(hmac(data,key));
			}
			default:{
				return toBase64(hmac(data,key));
			}
		}
	};
}();

__CPAN_FILE__ src/crypto/Rijndael.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.crypto.Rijndael");
dojo.require("dojo.crypto");
dojo.require("dojo.experimental");

dojo.experimental("dojo.crypto.Rijndael");

dojo.crypto.Rijndael = new function(){
	this.encrypt=function(plaintext, key){
	};
	this.decrypt=function(ciphertext, key){
	};
}();

__CPAN_FILE__ src/crypto/SHA1.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.crypto");
dojo.provide("dojo.crypto.SHA1");
dojo.require("dojo.experimental");

dojo.experimental("dojo.crypto.SHA1");

dojo.crypto.SHA1 = new function(){
	var chrsz=8;
	var mask=(1<<chrsz)-1;
	function toWord(s) {
	  var wa=[];
	  for(var i=0; i<s.length*chrsz; i+=chrsz)
		wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
	  return wa;
	}
	function toString(wa){
		var s=[];
		for(var i=0; i<wa.length*32; i+=chrsz)
			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
		return s.join("");
	}
	function toHex(wa) {
		var h="0123456789abcdef";
		var s=[];
		for(var i=0; i<wa.length*4; i++){
			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
		}
		return s.join("");
	}
	function toBase64(wa){
		var p="=";
		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var s=[];
		for(var i=0; i<wa.length*4; i+=3){
			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32) s.push(p);
				else s.push(tab.charAt((t>>6*(3-j))&0x3F));
			}
		}
		return s.join("");
	}

	//	math
	function add(x,y){
		var l=(x&0xffff)+(y&0xffff);
		var m=(x>>16)+(y>>16)+(l>>16);
		return (m<<16)|(l&0xffff);
	}
	function r(x,n){  return (x<<n)|(x>>>(32-n)); }
	
	//	SHA rounds
	function f(u,v,w){ return ((u&v)|(~u&w)); }
	function g(u,v,w){ return ((u&v)|(u&w)|(v&w)); }
	function h(u,v,w){ return (u^v^w); }
	
	function fn(i,u,v,w){
		if(i<20) return f(u,v,w);
		if(i<40) return h(u,v,w);
		if(i<60) return g(u,v,w);
		return h(u,v,w);
	}
	function cnst(i){
		if(i<20) return 1518500249;
		if(i<40) return 1859775393;
		if(i<60) return -1894007588;
		return -899497514;
	}

	function core(x,len){
		x[len>>5]|=0x80<<(24-len%32);
		x[((len+64>>9)<<4)+15]=len;

		var w=[];
		var a= 1732584193;		//	0x67452301
		var b=-271733879;		//	0xefcdab89
		var c=-1732584194;		//	0x98badcfe
		var d= 271733878;		//	0x10325476
		var e=-1009589776;		//	0xc3d2e1f0
		
		for(var i=0; i<x.length; i+=16){
			var olda=a;
			var oldb=b;
			var oldc=c;
			var oldd=d;
			var olde=e;

			for(var j=0; j<80; j++){
				if(j<16) w[j]=x[i+j];
				else w[j]=r(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);
				var t=add(add(r(a,5),fn(j,b,c,d)),add(add(e,w[j]),cnst(j)));
				e=d; d=c; c=r(b,30); b=a; a=t;
			}

			a=add(a,olda);
			b=add(b,oldb);
			c=add(c,oldc);
			d=add(d,oldd);
			e=add(e,olde);
		}
		return [a,b,c,d,e];
	}
	function hmac(data,key){
		var wa=toWord(key);
		if(wa.length>16) wa=core(wa,key.length*chrsz);
		var l=[], r=[];
		for(var i=0; i<16; i++){
			l[i]=wa[i]^0x36363636;
			r[i]=wa[i]^0x5c5c5c5c;
		}
		var h=core(l.concat(toWord(data)),512+data.length*chrsz);
		return core(r.concat(h),640);
	}

	this.compute=function(data,outputType){
		var out=outputType||dojo.crypto.outputTypes.Base64;
		switch(out){
			case dojo.crypto.outputTypes.Hex:{
				return toHex(core(toWord(data),data.length*chrsz));
			}
			case dojo.crypto.outputTypes.String:{
				return toString(core(toWord(data),data.length*chrsz));
			}
			default:{
				return toBase64(core(toWord(data),data.length*chrsz));
			}
		}
	};
	this.getHMAC=function(data,key,outputType){
		var out=outputType||dojo.crypto.outputTypes.Base64;
		switch(out){
			case dojo.crypto.outputTypes.Hex:{
				return toHex(hmac(data,key));
			}
			case dojo.crypto.outputTypes.String:{
				return toString(hmac(data,key));
			}
			default:{
				return toBase64(hmac(data,key));
			}
		}
	};
}();

__CPAN_FILE__ src/crypto/SHA256.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.crypto.SHA256");
dojo.require("dojo.crypto");
dojo.require("dojo.experimental");

dojo.experimental("dojo.crypto.SHA256");

dojo.crypto.SHA256 = new function(){
	this.compute=function(s){
	};
}();

__CPAN_FILE__ src/crypto/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		"dojo.crypto",
		"dojo.crypto.MD5"
	]
});
dojo.provide("dojo.crypto.*");

__CPAN_DIR__ src/data
__CPAN_FILE__ src/data/Attribute.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.Attribute");
dojo.require("dojo.data.Item");
dojo.require("dojo.lang.assert");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.Attribute = function(/* dojo.data.provider.Base */ dataProvider, /* string */ attributeId) {
	/**
	 * summary:
	 * An Attribute object represents something like a column in 
	 * a relational database.
	 */
	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, "optional"]);
	dojo.lang.assertType(attributeId, String);
	dojo.data.Item.call(this, dataProvider);
	this._attributeId = attributeId;
};
dojo.inherits(dojo.data.Attribute, dojo.data.Item);

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
dojo.data.Attribute.prototype.toString = function() {
	return this._attributeId; // string
};

dojo.data.Attribute.prototype.getAttributeId = function() {
	/**
	 * summary: 
	 * Returns the string token that uniquely identifies this
	 * attribute within the context of a data provider.
	 * For a data provider that accesses relational databases,
	 * typical attributeIds might be tokens like "name", "age", 
	 * "ssn", or "dept_key".
	 */ 
	return this._attributeId; // string
};

dojo.data.Attribute.prototype.getType = function() {
	/**
	 * summary: Returns the data type of the values of this attribute.
	 */ 
	return this.get('type'); // dojo.data.Type or null
};

dojo.data.Attribute.prototype.setType = function(/* dojo.data.Type or null */ type) {
	/**
	 * summary: Sets the data type for this attribute.
	 */ 
	this.set('type', type);
};

__CPAN_FILE__ src/data/Item.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.Item");
dojo.require("dojo.data.Observable");
dojo.require("dojo.data.Value");
dojo.require("dojo.lang.common");
dojo.require("dojo.lang.assert");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.Item = function(/* dojo.data.provider.Base */ dataProvider) {
	/**
	 * summary:
	 * An Item has attributes and attribute values, sort of like 
	 * a record in a database, or a 'struct' in C.  Instances of
	 * the Item class know how to store and retrieve their
	 * attribute values.
	 */
	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, "optional"]);
	dojo.data.Observable.call(this);
	this._dataProvider = dataProvider;
	this._dictionaryOfAttributeValues = {};
};
dojo.inherits(dojo.data.Item, dojo.data.Observable);

// -------------------------------------------------------------------
// Public class methods
// -------------------------------------------------------------------
dojo.data.Item.compare = function(/* dojo.data.Item */ itemOne, /* dojo.data.Item */ itemTwo) {
	/**
	 * summary:
	 * Given two Items to compare, this method returns 0, 1, or -1.
	 * This method is designed to be used by sorting routines, like
	 * the JavaScript built-in Array sort() method.
	 * 
	 * Example:
	 * <pre>
	 *   var a = dataProvider.newItem("kermit");
	 *   var b = dataProvider.newItem("elmo");
	 *   var c = dataProvider.newItem("grover");
	 *   var array = new Array(a, b, c);
	 *   array.sort(dojo.data.Item.compare);
	 * </pre>
	 */
	dojo.lang.assertType(itemOne, dojo.data.Item);
	if (!dojo.lang.isOfType(itemTwo, dojo.data.Item)) {
		return -1;
	}
	var nameOne = itemOne.getName();
	var nameTwo = itemTwo.getName();
	if (nameOne == nameTwo) {
		var attributeArrayOne = itemOne.getAttributes();
		var attributeArrayTwo = itemTwo.getAttributes();
		if (attributeArrayOne.length != attributeArrayTwo.length) {
			if (attributeArrayOne.length > attributeArrayTwo.length) {
				return 1; 
			} else {
				return -1;
			}
		}
		for (var i in attributeArrayOne) {
			var attribute = attributeArrayOne[i];
			var arrayOfValuesOne = itemOne.getValues(attribute);
			var arrayOfValuesTwo = otherItem.getValues(attribute);
			dojo.lang.assert(arrayOfValuesOne && (arrayOfValuesOne.length > 0));
			if (!arrayOfValuesTwo) {
				return 1;
			}
			if (arrayOfValuesOne.length != arrayOfValuesTwo.length) {
				if (arrayOfValuesOne.length > arrayOfValuesTwo.length) {
					return 1; 
				} else {
					return -1;
				}
			}
			for (var j in arrayOfValuesOne) {
				var value = arrayOfValuesOne[j];
				if (!itemTwo.hasAttributeValue(value)) {
					return 1;
				}
			}
			return 0;
		}
	} else {
		if (nameOne > nameTwo) {
			return 1; 
		} else {
			return -1;  // 0, 1, or -1
		}
	}
};

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
dojo.data.Item.prototype.toString = function() {
	/**
	 * Returns a simple string representation of the item.
	 */
	var arrayOfStrings = [];
	var attributes = this.getAttributes();
	for (var i in attributes) {
		var attribute = attributes[i];
		var arrayOfValues = this.getValues(attribute);
		var valueString;
		if (arrayOfValues.length == 1) {
			valueString = arrayOfValues[0];
		} else {
			valueString = '[';
			valueString += arrayOfValues.join(', ');
			valueString += ']';
		}
		arrayOfStrings.push('  ' + attribute + ': ' + valueString);
	}
	var returnString = '{ ';
	returnString += arrayOfStrings.join(',\n');
	returnString += ' }';
	return returnString; // string
};

dojo.data.Item.prototype.compare = function(/* dojo.data.Item */ otherItem) {
	/**
	 * summary: Compares this Item to another Item, and returns 0, 1, or -1.
	 */ 
	return dojo.data.Item.compare(this, otherItem); // 0, 1, or -1
};

dojo.data.Item.prototype.isEqual = function(/* dojo.data.Item */ otherItem) {
	/**
	 * summary: Returns true if this Item is equal to the otherItem, or false otherwise.
	 */
	return (this.compare(otherItem) == 0); // boolean
};

dojo.data.Item.prototype.getName = function() {
	return this.get('name');
};

dojo.data.Item.prototype.get = function(/* string or dojo.data.Attribute */ attributeId) {
	/**
	 * summary: Returns a single literal value, like "foo" or 33.
	 */ 
	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
		return null; // null
	}
	if (literalOrValueOrArray instanceof dojo.data.Value) {
		return literalOrValueOrArray.getValue(); // literal
	}
	if (dojo.lang.isArray(literalOrValueOrArray)) {
		var dojoDataValue = literalOrValueOrArray[0];
		return dojoDataValue.getValue(); // literal
	}
	return literalOrValueOrArray; // literal
};

dojo.data.Item.prototype.getValue = function(/* string or dojo.data.Attribute */ attributeId) {
	/**
	 * summary: Returns a single instance of dojo.data.Value.
	 */ 
	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
		return null; // null
	}
	if (literalOrValueOrArray instanceof dojo.data.Value) {
		return literalOrValueOrArray; // dojo.data.Value
	}
	if (dojo.lang.isArray(literalOrValueOrArray)) {
		var dojoDataValue = literalOrValueOrArray[0];
		return dojoDataValue; // dojo.data.Value
	}
	var literal = literalOrValueOrArray;
	dojoDataValue = new dojo.data.Value(literal);
	this._dictionaryOfAttributeValues[attributeId] = dojoDataValue;
	return dojoDataValue; // dojo.data.Value
};

dojo.data.Item.prototype.getValues = function(/* string or dojo.data.Attribute */ attributeId) {
	/**
	 * summary: Returns an array of dojo.data.Value objects.
	 */ 
	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
		return null; // null
	}
	if (literalOrValueOrArray instanceof dojo.data.Value) {
		var array = [literalOrValueOrArray];
		this._dictionaryOfAttributeValues[attributeId] = array;
		return array; // Array
	}
	if (dojo.lang.isArray(literalOrValueOrArray)) {
		return literalOrValueOrArray; // Array
	}
	var literal = literalOrValueOrArray;
	var dojoDataValue = new dojo.data.Value(literal);
	array = [dojoDataValue];
	this._dictionaryOfAttributeValues[attributeId] = array;
	return array; // Array
};

dojo.data.Item.prototype.load = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
	/**
	 * summary: 
	 * Used for loading an attribute value into an item when
	 * the item is first being loaded into memory from some
	 * data store (such as a file).
	 */ 
	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
	this._dataProvider.registerAttribute(attributeId);
	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
		this._dictionaryOfAttributeValues[attributeId] = value;
		return;
	}
	if (!(value instanceof dojo.data.Value)) {
		value = new dojo.data.Value(value);
	}
	if (literalOrValueOrArray instanceof dojo.data.Value) {
		var array = [literalOrValueOrArray, value];
		this._dictionaryOfAttributeValues[attributeId] = array;
		return;
	}
	if (dojo.lang.isArray(literalOrValueOrArray)) {
		literalOrValueOrArray.push(value);
		return;
	}
	var literal = literalOrValueOrArray;
	var dojoDataValue = new dojo.data.Value(literal);
	array = [dojoDataValue, value];
	this._dictionaryOfAttributeValues[attributeId] = array;
};

dojo.data.Item.prototype.set = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
	/**
	 * summary: 
	 * Used for setting an attribute value as a result of a
	 * user action.
	 */ 
	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
	this._dataProvider.registerAttribute(attributeId);
	this._dictionaryOfAttributeValues[attributeId] = value;
	this._dataProvider.noteChange(this, attributeId, value);
};

dojo.data.Item.prototype.setValue = function(/* string or dojo.data.Attribute */ attributeId, /* dojo.data.Value */ value) {
	this.set(attributeId, value);
};

dojo.data.Item.prototype.addValue = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
	/**
	 * summary: 
	 * Used for adding an attribute value as a result of a
	 * user action.
	 */ 
	this.load(attributeId, value);
	this._dataProvider.noteChange(this, attributeId, value);
};

dojo.data.Item.prototype.setValues = function(/* string or dojo.data.Attribute */ attributeId, /* Array */ arrayOfValues) {
	/**
	 * summary: 
	 * Used for setting an array of attribute values as a result of a
	 * user action.
	 */
	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
	dojo.lang.assertType(arrayOfValues, Array);
	this._dataProvider.registerAttribute(attributeId);
	var finalArray = [];
	this._dictionaryOfAttributeValues[attributeId] = finalArray;
	for (var i in arrayOfValues) {
		value = arrayOfValues[i];
		if (!(value instanceof dojo.data.Value)) {
			value = new dojo.data.Value(value);
		}
		finalArray.push(value);
		this._dataProvider.noteChange(this, attributeId, value);
	}
};

dojo.data.Item.prototype.getAttributes = function() {
	/**
	 * summary: 
	 * Returns an array containing all of the attributes for which
	 * this item has attribute values.
	 */ 
	var arrayOfAttributes = [];
	for (var key in this._dictionaryOfAttributeValues) {
		arrayOfAttributes.push(this._dataProvider.getAttribute(key));
	}
	return arrayOfAttributes; // Array
};

dojo.data.Item.prototype.hasAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
	/**
	 * summary: Returns true if the given attribute of the item has been assigned any value.
	 */ 
	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
	for (var key in this._dictionaryOfAttributeValues) {
		if (key == attributeId) {
			return true; // boolean
		}
	}
	return false; // boolean
};

dojo.data.Item.prototype.hasAttributeValue = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
	/**
	 * summary: Returns true if the given attribute of the item has been assigned the given value.
	 */ 
	var arrayOfValues = this.getValues(attributeId);
	for (var i in arrayOfValues) {
		var candidateValue = arrayOfValues[i];
		if (candidateValue.isEqual(value)) {
			return true; // boolean
		}
	}
	return false; // boolean
};



__CPAN_FILE__ src/data/Kind.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.Kind");
dojo.require("dojo.data.Item");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.Kind = function(/* dojo.data.provider.Base */ dataProvider) {
	/**
	 * summary:
	 * A Kind represents a kind of item.  In the dojo data model
	 * the item Snoopy might belong to the 'kind' Dog, where in
	 * a Java program the object Snoopy would belong to the 'class'
	 * Dog, and in MySQL the record for Snoopy would be in the 
	 * table Dog.
	 */
	dojo.data.Item.call(this, dataProvider);
};
dojo.inherits(dojo.data.Kind, dojo.data.Item);

__CPAN_FILE__ src/data/Observable.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.Observable");
dojo.require("dojo.lang.common");
dojo.require("dojo.lang.assert");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.Observable = function() {
};

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
dojo.data.Observable.prototype.addObserver = function(/* object */ observer) {
	/**
	 * summary: Registers an object as an observer of this item,
	 * so that the object will be notified when the item changes.
	 */ 
	dojo.lang.assertType(observer, Object);
	dojo.lang.assertType(observer.observedObjectHasChanged, Function);
	if (!this._arrayOfObservers) {
		this._arrayOfObservers = [];
	}
	if (!dojo.lang.inArray(this._arrayOfObservers, observer)) {
		this._arrayOfObservers.push(observer);
	}
};

dojo.data.Observable.prototype.removeObserver = function(/* object */ observer) {
	/**
	 * summary: Removes the observer registration for a previously
	 * registered object.
	 */ 
	if (!this._arrayOfObservers) {
		return;
	}
	var index = dojo.lang.indexOf(this._arrayOfObservers, observer);
	if (index != -1) {
		this._arrayOfObservers.splice(index, 1);
	}
};

dojo.data.Observable.prototype.getObservers = function() {
	/**
	 * summary: Returns an array with all the observers of this item.
	 */ 
	return this._arrayOfObservers; // Array or undefined
};


__CPAN_FILE__ src/data/ResultSet.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.ResultSet");
dojo.require("dojo.lang.assert");
dojo.require("dojo.collections.Collections");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.ResultSet = function(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfItems) {
	/**
	 * summary:
	 * A ResultSet holds a collection of Items.  A data provider
	 * returns a ResultSet in reponse to a query.
	 * (The name "Result Set" comes from the MySQL terminology.)
	 */
	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, "optional"]);
	dojo.lang.assertType(arrayOfItems, [Array, "optional"]);
	dojo.data.Observable.call(this);
	this._dataProvider = dataProvider;
	this._arrayOfItems = [];
	if (arrayOfItems) {
		this._arrayOfItems = arrayOfItems;
	}
};
dojo.inherits(dojo.data.ResultSet, dojo.data.Observable);

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
dojo.data.ResultSet.prototype.toString = function() {
	var returnString = this._arrayOfItems.join(', ');
	return returnString; // string
};

dojo.data.ResultSet.prototype.toArray = function() {
	return this._arrayOfItems; // Array
};

dojo.data.ResultSet.prototype.getIterator = function() {
	return new dojo.collections.Iterator(this._arrayOfItems);
};

dojo.data.ResultSet.prototype.getLength = function() {
	return this._arrayOfItems.length; // integer
};

dojo.data.ResultSet.prototype.getItemAt = function(/* numeric */ index) {
	return this._arrayOfItems[index];
};

dojo.data.ResultSet.prototype.indexOf = function(/* dojo.data.Item */ item) {
	return dojo.lang.indexOf(this._arrayOfItems, item); // integer
};

dojo.data.ResultSet.prototype.contains = function(/* dojo.data.Item */ item) {
	return dojo.lang.inArray(this._arrayOfItems, item); // boolean
};

dojo.data.ResultSet.prototype.getDataProvider = function() {
	return this._dataProvider; // dojo.data.provider.Base
};
__CPAN_FILE__ src/data/to_do.txt
Existing Features
 * can import data from .json or .csv format files
 * can import data from del.icio.us
 * can create and modify data programmatically
 * can bind data to dojo.widget.Chart
 * can bind data to dojo.widget.SortableTable
 * can bind one data set to multiple widgets
 * notifications: widgets are notified when data changes
 * notification available per-item or per-resultSet
 * can create ad-hoc attributes
 * attributes can be loosely-typed 
 * attributes can have meta-data like type and display name
 * half-implemented support for sorting
 * half-implemented support for export to .json
 * API for getting data in simple arrays 
 * API for getting ResultSets with iterators (precursor to support for something like the openrico.org live grid)
 
~~~~~~~~~~~~~~~~~~~~~~~~
To-Do List
 * be able to import data from an html <table></table>
 * think about being able to import data from some type of XML 
 * think about integration with dojo.undo.Manager
 * think more about how to represent the notion of different data types
 * think about what problems we'll run into when we have a MySQL data provider
 * in TableBindingHack, improve support for data types in the SortableTable binding
 * deal with ids (including MySQL multi-field keys)
 * add support for item-references:  employeeItem.set('department', departmentItem);
 * deal with Attributes as instances of Items, not just subclasses of Items
 * unit tests for compare/sort code
 * unit tests for everything
 * implement item.toString('json') and item.toString('xml')
 * implement dataProvider.newItem({name: 'foo', age: 26})
 * deal better with transactions
 * add support for deleting items
 * don't send out multiple notifications to the same observer
 * deal with item versions
 * prototype a Yahoo data provider -- http://developer.yahoo.net/common/json.html
 * prototype a data provider that enforces strong typing
 * prototype a data provider that prevents ad-hoc attributes
 * prototype a data provider that enforces single-kind item
 * prototype a data provider that allows for login/authentication
 * have loosely typed result sets play nicely with widgets that expect strong typing
 * prototype an example of spreadsheet-style formulas or derivation rules
 * experiment with some sort of fetch() that returns only a subset of a data provider's items


__CPAN_FILE__ src/data/Type.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.Type");
dojo.require("dojo.data.Item");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.Type = function(/* dojo.data.provider.Base */ dataProvider) {
	/**
	 * summary:
	 * A Type represents a type of value, like Text, Number, Picture,
	 * or Varchar.
	 */
	dojo.data.Item.call(this, dataProvider);
};
dojo.inherits(dojo.data.Type, dojo.data.Item);

__CPAN_FILE__ src/data/Value.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.Value");
dojo.require("dojo.lang.assert");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.Value = function(/* anything */ value) {
	/**
	 * summary:
	 * A Value represents a simple literal value (like "foo" or 334),
	 * or a reference value (a pointer to an Item).
	 */
	this._value = value;
	this._type = null;
};

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
dojo.data.Value.prototype.toString = function() {
	return this._value.toString(); // string
};

dojo.data.Value.prototype.getValue = function() {
	/**
	 * summary: Returns the value itself.
	 */ 
	return this._value; // anything
};

dojo.data.Value.prototype.getType = function() {
	/**
	 * summary: Returns the data type of the value.
	 */ 
	dojo.unimplemented('dojo.data.Value.prototype.getType');
	return this._type; // dojo.data.Type
};

dojo.data.Value.prototype.compare = function() {
	dojo.unimplemented('dojo.data.Value.prototype.compare');
};

dojo.data.Value.prototype.isEqual = function() {
	dojo.unimplemented('dojo.data.Value.prototype.isEqual');
};

__CPAN_FILE__ src/data/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.experimental");

dojo.experimental("dojo.data.*");
dojo.kwCompoundRequire({
	common: [
		"dojo.data.Item",
		"dojo.data.ResultSet",
		"dojo.data.provider.FlatFile"
	]
});
dojo.provide("dojo.data.*");


__CPAN_DIR__ src/data/format
__CPAN_FILE__ src/data/format/Csv.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.format.Csv");
dojo.require("dojo.lang.assert");


dojo.data.format.Csv = new function() {

	// -------------------------------------------------------------------
	// Public functions
	// -------------------------------------------------------------------
	this.getArrayStructureFromCsvFileContents = function(/* string */ csvFileContents) {
		/**
		 * Given a string containing CSV records, this method parses
		 * the string and returns a data structure containing the parsed
		 * content.  The data structure we return is an array of length
		 * R, where R is the number of rows (lines) in the CSV data.  The 
		 * return array contains one sub-array for each CSV line, and each 
		 * sub-array contains C string values, where C is the number of 
		 * columns in the CSV data.
		 * 
		 * For example, given this CSV string as input:
		 * <pre>
		 *   "Title, Year, Producer \n Alien, 1979, Ridley Scott \n Blade Runner, 1982, Ridley Scott"
		 * </pre>
		 * We will return this data structure:
		 * <pre>
		 *   [["Title", "Year", "Producer"]
		 *    ["Alien", "1979", "Ridley Scott"],  
		 *    ["Blade Runner", "1982", "Ridley Scott"]]
		 * </pre>
		 */
		dojo.lang.assertType(csvFileContents, String);
		
		var lineEndingCharacters = new RegExp("\r\n|\n|\r");
		var leadingWhiteSpaceCharacters = new RegExp("^\\s+",'g');
		var trailingWhiteSpaceCharacters = new RegExp("\\s+$",'g');
		var doubleQuotes = new RegExp('""','g');
		var arrayOfOutputRecords = [];
		
		var arrayOfInputLines = csvFileContents.split(lineEndingCharacters);
		for (var i in arrayOfInputLines) {
			var singleLine = arrayOfInputLines[i];
			if (singleLine.length > 0) {
				var listOfFields = singleLine.split(',');
				var j = 0;
				while (j < listOfFields.length) {
					var space_field_space = listOfFields[j];
					var field_space = space_field_space.replace(leadingWhiteSpaceCharacters, ''); // trim leading whitespace
					var field = field_space.replace(trailingWhiteSpaceCharacters, ''); // trim trailing whitespace
					var firstChar = field.charAt(0);
					var lastChar = field.charAt(field.length - 1);
					var secondToLastChar = field.charAt(field.length - 2);
					var thirdToLastChar = field.charAt(field.length - 3);
					if ((firstChar == '"') && 
							((lastChar != '"') || 
							 ((lastChar == '"') && (secondToLastChar == '"') && (thirdToLastChar != '"')) )) {
						if (j+1 === listOfFields.length) {
							// alert("The last field in record " + i + " is corrupted:\n" + field);
							return null;
						}
						var nextField = listOfFields[j+1];
						listOfFields[j] = field_space + ',' + nextField;
						listOfFields.splice(j+1, 1); // delete element [j+1] from the list
					} else {
						if ((firstChar == '"') && (lastChar == '"')) {
							field = field.slice(1, (field.length - 1)); // trim the " characters off the ends
							field = field.replace(doubleQuotes, '"');   // replace "" with "
						}
						listOfFields[j] = field;
						j += 1;
					}
				}
				arrayOfOutputRecords.push(listOfFields);
			}
		}
		return arrayOfOutputRecords; // Array
	};

	this.loadDataProviderFromFileContents = function(/* dojo.data.provider.Base */ dataProvider, /* string */ csvFileContents) {
		dojo.lang.assertType(dataProvider, dojo.data.provider.Base);
		dojo.lang.assertType(csvFileContents, String);
		var arrayOfArrays = this.getArrayStructureFromCsvFileContents(csvFileContents);
		if (arrayOfArrays) {
			var arrayOfKeys = arrayOfArrays[0];
			for (var i = 1; i < arrayOfArrays.length; ++i) {
				var row = arrayOfArrays[i];
				var item = dataProvider.getNewItemToLoad();
				for (var j in row) {
					var value = row[j];
					var key = arrayOfKeys[j];
					item.load(key, value);
				}
			}
		}
	};
	
	this.getCsvStringFromResultSet = function(/* dojo.data.ResultSet */ resultSet) {
		dojo.unimplemented('dojo.data.format.Csv.getCsvStringFromResultSet');
		var csvString = null;
		return csvString; // String
	};
	
}();

__CPAN_FILE__ src/data/format/Json.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.format.Json");
dojo.require("dojo.lang.assert");

dojo.data.format.Json = new function() {

	// -------------------------------------------------------------------
	// Public functions
	// -------------------------------------------------------------------
	this.loadDataProviderFromFileContents = function(/* dojo.data.provider.Base */ dataProvider, /* string */ jsonFileContents) {
		dojo.lang.assertType(dataProvider, dojo.data.provider.Base);
		dojo.lang.assertType(jsonFileContents, String);
		var arrayOfJsonData = eval("(" + jsonFileContents + ")");
		this.loadDataProviderFromArrayOfJsonData(dataProvider, arrayOfJsonData);
	};
	
	this.loadDataProviderFromArrayOfJsonData = function(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
		dojo.lang.assertType(arrayOfJsonData, [Array, "optional"]);
		if (arrayOfJsonData && (arrayOfJsonData.length > 0)) {
			var firstRow = arrayOfJsonData[0];
			dojo.lang.assertType(firstRow, [Array, "pureobject"]);
			if (dojo.lang.isArray(firstRow)) {
				_loadDataProviderFromArrayOfArrays(dataProvider, arrayOfJsonData);
			} else {
				dojo.lang.assertType(firstRow, "pureobject");
				_loadDataProviderFromArrayOfObjects(dataProvider, arrayOfJsonData);
			}
		}
	};

	this.getJsonStringFromResultSet = function(/* dojo.data.ResultSet */ resultSet) {
		dojo.unimplemented('dojo.data.format.Json.getJsonStringFromResultSet');
		var jsonString = null;
		return jsonString; // String
	};

	// -------------------------------------------------------------------
	// Private functions
	// -------------------------------------------------------------------
	function _loadDataProviderFromArrayOfArrays(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
		/** 
		 * Example: 
		 * var arrayOfJsonStates = [
		 * 	 [ "abbr",  "population",  "name" ]
		 * 	 [  "WA",     5894121,      "Washington"    ],
		 * 	 [  "WV",     1808344,      "West Virginia" ],
		 * 	 [  "WI",     5453896,      "Wisconsin"     ],
		 *   [  "WY",      493782,      "Wyoming"       ] ];
		 * this._loadFromArrayOfArrays(arrayOfJsonStates);
		 */
		var arrayOfKeys = arrayOfJsonData[0];
		for (var i = 1; i < arrayOfJsonData.length; ++i) {
			var row = arrayOfJsonData[i];
			var item = dataProvider.getNewItemToLoad();
			for (var j in row) {
				var value = row[j];
				var key = arrayOfKeys[j];
				item.load(key, value);
			}
		}
	}

	function _loadDataProviderFromArrayOfObjects(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
		/** 
		 * Example: 
		 * var arrayOfJsonStates = [
		 * 	 { abbr: "WA", name: "Washington" },
		 * 	 { abbr: "WV", name: "West Virginia" },
		 * 	 { abbr: "WI", name: "Wisconsin", song: "On, Wisconsin!" },
		 * 	 { abbr: "WY", name: "Wyoming", cities: ["Lander", "Cheyenne", "Laramie"] } ];
		 * this._loadFromArrayOfArrays(arrayOfJsonStates);
		 */
		// dojo.debug("_loadDataProviderFromArrayOfObjects");
		for (var i in arrayOfJsonData) {
			var row = arrayOfJsonData[i];
			var item = dataProvider.getNewItemToLoad();
			for (var key in row) {
				var value = row[key];
				if (dojo.lang.isArray(value)) {
					var arrayOfValues = value;
					for (var j in arrayOfValues) {
						value = arrayOfValues[j];
						item.load(key, value);
						// dojo.debug("loaded: " + key + " = " + value); 
					}
				} else {
					item.load(key, value);
				}
			}
		}
	}
	
}();


__CPAN_DIR__ src/data/provider
__CPAN_FILE__ src/data/provider/Base.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.provider.Base");
dojo.require("dojo.lang.assert");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.provider.Base = function() {
	/**
	 * summary:
	 * A Data Provider serves as a connection to some data source,
	 * like a relational database.  This data provider Base class
	 * serves as an abstract superclass for other data provider
	 * classes.
	 */
	this._countOfNestedTransactions = 0;
	this._changesInCurrentTransaction = null;
};

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
dojo.data.provider.Base.prototype.beginTransaction = function() {
	/**
	 * Marks the beginning of a transaction.
	 *
	 * Each time you call beginTransaction() you open a new transaction, 
	 * which you need to close later using endTransaction().  Transactions
	 * may be nested, but the beginTransaction and endTransaction calls
	 * always need to come in pairs.
	 */
	if (this._countOfNestedTransactions === 0) {
		this._changesInCurrentTransaction = [];
	}
	this._countOfNestedTransactions += 1;
};

dojo.data.provider.Base.prototype.endTransaction = function() {
	/**
	 * Marks the end of a transaction.
	 */
	this._countOfNestedTransactions -= 1;
	dojo.lang.assert(this._countOfNestedTransactions >= 0);

	if (this._countOfNestedTransactions === 0) {
		var listOfChangesMade = this._saveChanges();
		this._changesInCurrentTransaction = null;
		if (listOfChangesMade.length > 0) {
			// dojo.debug("endTransaction: " + listOfChangesMade.length + " changes made");
			this._notifyObserversOfChanges(listOfChangesMade);
		}
	}
};

dojo.data.provider.Base.prototype.getNewItemToLoad = function() {
	return this._newItem(); // dojo.data.Item
};

dojo.data.provider.Base.prototype.newItem = function(/* string */ itemName) {
	/**
	 * Creates a new item.
	 */
	dojo.lang.assertType(itemName, [String, "optional"]);
	var item = this._newItem();
	if (itemName) {
		item.set('name', itemName);
	}
	return item; // dojo.data.Item
};

dojo.data.provider.Base.prototype.newAttribute = function(/* string */ attributeId) {
	/**
	 * Creates a new attribute.
	 */
	dojo.lang.assertType(attributeId, String); // FIXME: should be optional
	var attribute = this._newAttribute(attributeId);
	return attribute; // dojo.data.Attribute
};

dojo.data.provider.Base.prototype.getAttribute = function(/* string */ attributeId) {
	dojo.unimplemented('dojo.data.provider.Base');
	return attribute; // dojo.data.Attribute
};

dojo.data.provider.Base.prototype.getAttributes = function() {
	dojo.unimplemented('dojo.data.provider.Base');
	return this._arrayOfAttributes; // Array
};

dojo.data.provider.Base.prototype.fetchArray = function() {
	dojo.unimplemented('dojo.data.provider.Base');
	return []; // Array
};

dojo.data.provider.Base.prototype.fetchResultSet = function() {
	dojo.unimplemented('dojo.data.provider.Base');
	return resultSet; // dojo.data.ResultSet
};

dojo.data.provider.Base.prototype.noteChange = function(/* dojo.data.Item */ item, /* string or dojo.data.Attribute */ attribute, /* anything */ value) {
	var change = {item: item, attribute: attribute, value: value};
	if (this._countOfNestedTransactions === 0) {
		this.beginTransaction();
		this._changesInCurrentTransaction.push(change);
		this.endTransaction();
	} else {
		this._changesInCurrentTransaction.push(change);
	}
};

dojo.data.provider.Base.prototype.addItemObserver = function(/* dojo.data.Item */ item, /* object */ observer) {
	/**
	 * summary: Registers an object as an observer of an item,
	 * so that the object will be notified when the item changes.
	 */
	dojo.lang.assertType(item, dojo.data.Item);
	item.addObserver(observer);
};

dojo.data.provider.Base.prototype.removeItemObserver = function(/* dojo.data.Item */ item, /* object */ observer) {
	/**
	 * summary: Removes the observer registration for a previously
	 * registered object.
	 */ 
	dojo.lang.assertType(item, dojo.data.Item);
	item.removeObserver(observer);
};

// -------------------------------------------------------------------
// Private instance methods
// -------------------------------------------------------------------
dojo.data.provider.Base.prototype._newItem = function() {
	var item = new dojo.data.Item(this);
	return item; // dojo.data.Item
};

dojo.data.provider.Base.prototype._newAttribute = function(/* String */ attributeId) {
	var attribute = new dojo.data.Attribute(this);
	return attribute; // dojo.data.Attribute
};

dojo.data.provider.Base.prototype._saveChanges = function() {
	var arrayOfChangesMade = this._changesInCurrentTransaction;
	return arrayOfChangesMade; // Array
};

dojo.data.provider.Base.prototype._notifyObserversOfChanges = function(/* Array */ arrayOfChanges) {
	var arrayOfResultSets = this._getResultSets();
	for (var i in arrayOfChanges) {
		var change = arrayOfChanges[i];
		var changedItem = change.item;
		var arrayOfItemObservers = changedItem.getObservers();
		for (var j in arrayOfItemObservers) {
			var observer = arrayOfItemObservers[j];
			observer.observedObjectHasChanged(changedItem, change);
		}
		for (var k in arrayOfResultSets) {
			var resultSet = arrayOfResultSets[k];
			var arrayOfResultSetObservers = resultSet.getObservers();
			for (var m in arrayOfResultSetObservers) {
				observer = arrayOfResultSetObservers[m];
				observer.observedObjectHasChanged(resultSet, change);
			}
		}
	}
};

dojo.data.provider.Base.prototype._getResultSets = function() {
	dojo.unimplemented('dojo.data.provider.Base');
	return []; // Array
};


__CPAN_FILE__ src/data/provider/Delicious.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.provider.Delicious");
dojo.require("dojo.data.provider.FlatFile");
dojo.require("dojo.data.format.Json");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.provider.Delicious = function() {
	/**
	 * summary:
	 * The Delicious Data Provider can be used to take data from
	 * del.icio.us and make it available as dojo.data.Items
	 * In order to use the Delicious Data Provider, you need 
	 * to have loaded a script tag that looks like this:
	 * <script type="text/javascript" src="http://del.icio.us/feeds/json/gumption?count=8"></script>
	 */
	dojo.data.provider.FlatFile.call(this);
	// Delicious = null;
	if (Delicious && Delicious.posts) {
		dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, Delicious.posts);
	} else {
		// document.write("<script type='text/javascript'>dojo.data.provider.Delicious._fetchComplete()</script>");		
		/*
		document.write("<script type='text/javascript'>alert('boo!');</script>");		
		document.write("<script type='text/javascript'>var foo = 'not dojo'; alert('dojo == ' + foo);</script>");		
		document.write("<script type='text/javascript'>var foo = fetchComplete; alert('dojo == ' + foo);</script>");		
		fetchComplete();
		*/
		// dojo.debug("Delicious line 29: constructor");
	}
	var u = this.registerAttribute('u');
	var d = this.registerAttribute('d');
	var t = this.registerAttribute('t');
	
	u.load('name', 'Bookmark');
	d.load('name', 'Description');
	t.load('name', 'Tags');
	
	u.load('type', 'String');
	d.load('type', 'String');
	t.load('type', 'String');
};
dojo.inherits(dojo.data.provider.Delicious, dojo.data.provider.FlatFile);

/********************************************************************
 * FIXME: the rest of this is work in progress
 *
 
dojo.data.provider.Delicious.prototype.getNewItemToLoad = function() {
	var newItem = this._newItem();
	this._currentArray.push(newItem);
	return newItem; // dojo.data.Item
};

dojo.data.provider.Delicious.prototype.fetchArray = function(query) {
	if (!query) {	
		query = "gumption";
	}
	this._currentArray = [];
	alert("Delicious line 60: loadDataProviderFromArrayOfJsonData");
	alert("Delicious line 61: " + dojo);
		var sourceUrl = "http://del.icio.us/feeds/json/" + query + "?count=8";
		document.write("<script type='text/javascript' src='" + sourceUrl + "'></script>");
		document.write("<script type='text/javascript'>alert('line 63: ' + Delicious.posts[0].u);</script>");		
		document.write("<script type='text/javascript'>callMe();</script>");		
	alert("line 66");
	dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, Delicious.posts);
	return this._currentArray; // Array
};

callMe = function() {
	alert("callMe!");
};

*/

__CPAN_FILE__ src/data/provider/FlatFile.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.provider.FlatFile");
dojo.require("dojo.data.provider.Base");
dojo.require("dojo.data.Item");
dojo.require("dojo.data.Attribute");
dojo.require("dojo.data.ResultSet");
dojo.require("dojo.data.format.Json");
dojo.require("dojo.data.format.Csv");
dojo.require("dojo.lang.assert");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.provider.FlatFile = function(/* keywords */ keywordParameters) {
	/**
	 * summary:
	 * A Json Data Provider knows how to read in simple JSON data
	 * tables and make their contents accessable as Items.
	 */
	dojo.lang.assertType(keywordParameters, ["pureobject", "optional"]);
	dojo.data.provider.Base.call(this);
	this._arrayOfItems = [];
	this._resultSet = null;
	this._dictionaryOfAttributes = {};

	if (keywordParameters) {
		var jsonObjects = keywordParameters["jsonObjects"];
		var jsonString  = keywordParameters["jsonString"];
		var fileUrl     = keywordParameters["url"];
		if (jsonObjects) {
			dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, jsonObjects);
		}
		if (jsonString) {
			dojo.data.format.Json.loadDataProviderFromFileContents(this, jsonString);
		}
		if (fileUrl) {
			var arrayOfParts = fileUrl.split('.');
			var lastPart = arrayOfParts[(arrayOfParts.length - 1)];
			var formatParser = null;
			if (lastPart == "json") {
				formatParser = dojo.data.format.Json;
			}
			if (lastPart == "csv") {
				formatParser = dojo.data.format.Csv;
			}
			if (formatParser) {
				var fileContents = dojo.hostenv.getText(fileUrl);
				formatParser.loadDataProviderFromFileContents(this, fileContents);
			} else {
				dojo.lang.assert(false, "new dojo.data.provider.FlatFile({url: }) was passed a file without a .csv or .json suffix");
			}
		}
	}
};
dojo.inherits(dojo.data.provider.FlatFile, dojo.data.provider.Base);

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
dojo.data.provider.FlatFile.prototype.getProviderCapabilities = function(/* string */ keyword) {
	dojo.lang.assertType(keyword, [String, "optional"]);
	if (!this._ourCapabilities) {
		this._ourCapabilities = {
			transactions: false,
			undo: false,
			login: false,
			versioning: false,
			anonymousRead: true,
			anonymousWrite: false,
			permissions: false,
			queries: false,
			strongTyping: false,
			datatypes: [String, Date, Number]
		};
	}
	if (keyword) {
		return this._ourCapabilities[keyword];
	} else {
		return this._ourCapabilities;
	}
};

dojo.data.provider.FlatFile.prototype.registerAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
	var registeredAttribute = this.getAttribute(attributeId);
	if (!registeredAttribute) {
		var newAttribute = new dojo.data.Attribute(this, attributeId);
		this._dictionaryOfAttributes[attributeId] = newAttribute;
		registeredAttribute = newAttribute;
	}
	return registeredAttribute; // dojo.data.Attribute
};

dojo.data.provider.FlatFile.prototype.getAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
	var attribute = (this._dictionaryOfAttributes[attributeId] || null);
	return attribute; // dojo.data.Attribute or null
};

dojo.data.provider.FlatFile.prototype.getAttributes = function() {
	var arrayOfAttributes = [];
	for (var key in this._dictionaryOfAttributes) {
		var attribute = this._dictionaryOfAttributes[key];
		arrayOfAttributes.push(attribute);
	}
	return arrayOfAttributes; // Array
};

dojo.data.provider.FlatFile.prototype.fetchArray = function(query) {
	/**
	 * summary: Returns an Array containing all of the Items.
	 */ 
	return this._arrayOfItems; // Array
};

dojo.data.provider.FlatFile.prototype.fetchResultSet = function(query) {
	/**
	 * summary: Returns a ResultSet containing all of the Items.
	 */ 
	if (!this._resultSet) {
		this._resultSet = new dojo.data.ResultSet(this, this.fetchArray(query));
	}
	return this._resultSet; // dojo.data.ResultSet
};

// -------------------------------------------------------------------
// Private instance methods
// -------------------------------------------------------------------
dojo.data.provider.FlatFile.prototype._newItem = function() {
	var item = new dojo.data.Item(this);
	this._arrayOfItems.push(item);
	return item; // dojo.data.Item
};

dojo.data.provider.FlatFile.prototype._newAttribute = function(/* String */ attributeId) {
	dojo.lang.assertType(attributeId, String);
	dojo.lang.assert(this.getAttribute(attributeId) === null);
	var attribute = new dojo.data.Attribute(this, attributeId);
	this._dictionaryOfAttributes[attributeId] = attribute;
	return attribute; // dojo.data.Attribute
};

dojo.data.provider.Base.prototype._getResultSets = function() {
	return [this._resultSet]; // Array
};


__CPAN_FILE__ src/data/provider/JotSpot.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.provider.JotSpot");
dojo.require("dojo.data.provider.Base");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.provider.JotSpot = function() {
	/**
	 * summary:
	 * A JotSpot Data Provider knows how to read data from a JotSpot data 
	 * store and make the contents accessable as dojo.data.Items.
	 */
	dojo.unimplemented('dojo.data.provider.JotSpot');
};

dojo.inherits(dojo.data.provider.JotSpot, dojo.data.provider.Base);


__CPAN_FILE__ src/data/provider/MySql.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.data.provider.MySql");
dojo.require("dojo.data.provider.Base");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
dojo.data.provider.MySql = function() {
	/**
	 * summary:
	 * A MySql Data Provider knows how to connect to a MySQL database
	 * on a server and and make the content records available as 
	 * dojo.data.Items.
	 */
	dojo.unimplemented('dojo.data.provider.MySql');
};

dojo.inherits(dojo.data.provider.MySql, dojo.data.provider.Base);

__CPAN_DIR__ src/debug
__CPAN_FILE__ src/debug/arrow_hide.gif
GIF89a	 	  )6'7H):K!/=)5%4C$/,9DSb%0)&5EO]kJXg;K[)9J )8HX .;$3Bdp|]jw                           !   ,    	 	   %d9VU1LVDO1c0IDR! ;
__CPAN_FILE__ src/debug/arrow_show.gif
GIF89a	 	  !/=)5*6$.",%4DZgt(8H&6F8HXAP_'3TaofrDSb*;Lhtq|,8!/<p|#1@#.(4                     !   ,    	 	  " QbYFYBbjrTR`"5%0W ;
__CPAN_FILE__ src/debug/deep.html
<html>
<head>
<title>Deep Debugger</title>
<script>

var tableRows = {};
var tableCels = {};
var tableObjs = {};
var tablesBuilt = {};
var tableShows = {};
var tableHides = {};

// IE: nodes w/id need to be redeclared or getElementById is b0rked
var frame = null;

window.onload = function(){
	// if IE loads this page too quickly (instantly) then 
	// window.debugVar might not have been set
	window.setTimeout(startMeUp, 100);
}

function startMeUp(){
	frame = document.getElementById('frame');
	buildTable('root', frame, window.debugVar);
}

function buildTable(path, parent, obj){

	var keys = [];
	var vals = [];
	for(var prop in obj){
		keys.push(prop);
		try {
			vals[prop] = obj[prop];
		} catch(E) {
			vals[prop] = 'ERROR: ' + E.message;
		}
	}
	keys.sort(keySorter);

	if (!keys.length){

		var div = document.createElement('div');
		div.appendChild(document.createTextNode('Object has no properties.'));

		parent.appendChild(div);
		return;
	}


	var t = document.createElement('table');
	t.border = "1";

	var tb = document.createElement('tbody');
	t.appendChild(tb);


	for(var i = 0; i < keys.length; i++) {
		buildTableRow(path+'-'+keys[i], tb, keys[i], vals[keys[i]]);
	}

	if (path == 'root'){
		//t.style.width = '90%';
	}
	t.style.width = '100%';

	parent.appendChild(t);

	tablesBuilt[path] = true;
}

function buildTableRow(path, tb, name, value) {

	var simpleType = typeof(value);
	var createSubrow = (simpleType == 'object');
	var complexType = simpleType;

	if (simpleType == 'object'){
		var cls = getConstructorClass(value);
		if (cls){
			if (cls == 'Object'){
			}else if (cls == 'Array'){
				complexType = 'array';
			}else{
				complexType += ' ('+cls+')';
			}
		}
	}

/*var tr1 = document.createElement('tr');
	var td1 = document.createElement('td');
	var td2 = document.createElement('td');
	var td3 = document.createElement('td');
	var td4 = document.createElement('td');*/

	var row = tb.rows.length;
	var tr1 = tb.insertRow(row++);
	var td1 = tr1.insertCell(0);
	var td2 = tr1.insertCell(1);
	var td3 = tr1.insertCell(2);
	var td4 = tr1.insertCell(3);
	
	tr1.style.verticalAlign = 'top';
	td1.style.verticalAlign = 'middle';

	td1.className = 'propPlus';
	td2.className = 'propName';
	td3.className = 'propType';
	td4.className = 'propVal';

	//tr1.appendChild(td1);
	//tr1.appendChild(td2);
	//tr1.appendChild(td3);
	//tr1.appendChild(td4);

	if (createSubrow){
		var img1 = document.createElement('img');
		img1.width = 9;
		img1.height = 9;
		img1.src = 'arrow_show.gif';
		var a1 = document.createElement('a');
		a1.appendChild(img1);
		a1.href = '#';
		a1.onclick = function(){ showTableRow(path); return false; };

		var img2 = document.createElement('img');
		img2.width = 9;
		img2.height = 9;
		img2.src = 'arrow_hide.gif';
		var a2 = document.createElement('a');
		a2.appendChild(img2);
		a2.href = '#';
		a2.onclick = function(){ hideTableRow(path); return false; };
		a2.style.display = 'none';

		tableShows[path] = a1;
		tableHides[path] = a2;

		td1.appendChild(a1);
		td1.appendChild(a2);
	}else{
		var img = document.createElement('img');
		img.width = 9;
		img.height = 9;
		img.src = 'spacer.gif';

		td1.appendChild(img);
	}

	td2.appendChild(document.createTextNode(name));
	td3.appendChild(document.createTextNode(complexType));
	td4.appendChild(buildPreBlock(value));

	//tb.appendChild(tr1);

	if (createSubrow){
		var tr2 = tb.insertRow(row++);
		var td5 = tr2.insertCell(0);
		var td6 = tr2.insertCell(1);
		
		//var tr2 = document.createElement('tr');
		//var td5 = document.createElement('td');
		//var td6 = document.createElement('td');

		td5.innerHTML = '&nbsp;';
		//td6.innerHTML = '&nbsp;';

		td6.colSpan = '3';

		tr2.appendChild(td5);
		tr2.appendChild(td6);

		tr2.style.display = 'none';

		tb.appendChild(tr2);

		tableRows[path] = tr2;
		tableCels[path] = td6;
		tableObjs[path] = value;
	}
}

function showTableRow(path){

	var tr = tableRows[path];
	var td = tableCels[path];
	var a1 = tableShows[path];
	var a2 = tableHides[path];

	if (!tablesBuilt[path]){

		//alert('building table for '+path);
		buildTable(path, td, tableObjs[path]);
	}

	tr.style.display = 'table-row';

	a1.style.display = 'none';
	a2.style.display = 'inline';
}

function hideTableRow(path){

	var tr = tableRows[path];
	var a1 = tableShows[path];
	var a2 = tableHides[path];

	tr.style.display = 'none';

	a1.style.display = 'inline';
	a2.style.display = 'none';
}

function buildPreBlock(value){

	//
	// how many lines ?
	//

	var s = ''+value;
	s = s.replace("\r\n", "\n");
	s = s.replace("\r", "");
	var lines = s.split("\n");


	if (lines.length < 2){

		if (lines[0].length < 60){

			var pre = document.createElement('pre');
			pre.appendChild(document.createTextNode(s));
			return pre;
		}
	}


	//
	// multiple lines :(
	//

	var preview = lines[0].substr(0, 60) + ' ...';

	var pre1 = document.createElement('pre');
	pre1.appendChild(document.createTextNode(preview));
	pre1.className = 'clicky';

	var pre2 = document.createElement('pre');
	pre2.appendChild(document.createTextNode(s));
	pre2.style.display = 'none';
	pre2.className = 'clicky';

	pre1.onclick = function(){
		pre1.style.display = 'none';
		pre2.style.display = 'block';
	}

	pre2.onclick = function(){
		pre1.style.display = 'block';
		pre2.style.display = 'none';
	}

	var pre = document.createElement('div');

	pre.appendChild(pre1);
	pre.appendChild(pre2);

	return pre;
}

function getConstructorClass(obj){

	if (!obj.constructor || !obj.constructor.toString) return;

	var m = obj.constructor.toString().match(/function\s*(\w+)/);

	if (m && m.length == 2) return m[1];

	return null;
}

function keySorter(a, b){

	if (a == parseInt(a) && b == parseInt(b)){

		return (parseInt(a) > parseInt(b)) ? 1 : ((parseInt(a) < parseInt(b)) ? -1 : 0);
	}

	// sort by lowercase string

	var a2 = String(a).toLowerCase();
	var b2 = String(b).toLowerCase();

	return (a2 > b2) ? 1 : ((a2 < b2) ? -1 : 0);
}

</script>
<style>

body {
	font-family: arial, helvetica, sans-serif;
}

table {
	border-width: 0px;
	border-spacing: 1px;
	border-collapse: separate;
}

td {
	border-width: 0px;
	padding: 2px;
}

img {
	border: 0;
}

pre {
	margin: 0;
	padding: 0;
	white-space: -moz-pre-wrap;  /* Mozilla, supported since 1999 */
	white-space: -pre-wrap;      /* Opera 4 - 6 */
	white-space: -o-pre-wrap;    /* Opera 7 */
	white-space: pre-wrap;       /* CSS3 - Text module (Candidate Recommendation) http://www.w3.org/TR/css3-text/#white-space */
	word-wrap: break-word;       /* IE 5.5+ */
}

pre.clicky {
	cursor: hand;
	cursor: pointer;
}

td.propPlus {
	width: 9px;
	background-color: #ddd;
}

td.propName {
	background-color: #ddd;
}

td.propType {
	background-color: #ddd;
}

td.propVal {
	background-color: #ddd;
}

</style>
</head>
<body>

<h2>Javascript Object Browser</h2>

<div id="frame"></div>

</body>
</html>
__CPAN_FILE__ src/debug/Firebug.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.debug.Firebug");

dojo.debug.firebug = function(){}
dojo.debug.firebug.printfire = function () {
	printfire=function(){}
	printfire.args = arguments;
	var ev = document.createEvent("Events");
	ev.initEvent("printfire", false, true);
	dispatchEvent(ev);
}

if (dojo.render.html.moz) {
	dojo.hostenv.println=dojo.debug.firebug.printfire;
}

__CPAN_FILE__ src/debug/spacer.gif
GIF89a	 	  @@@   g0*  2     P   $0  2  H   L  2  H   $h82         dtuxqu!    p   u,     p  @      $                       @(H        p p,     tH(            @2                @2S`@    H\Qm       QH    QHm     D    0    P   0    l       @   HQ8mHr8H  q  `x     pm	     	     b  b                PHDpm     Hr8H  hHHP \ pDHccEH  Hr8H       pltHH    !   ,    	 	   H*\p`@ ;
__CPAN_DIR__ src/dnd
__CPAN_FILE__ src/dnd/DragAndDrop.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.lang");
dojo.provide("dojo.dnd.DragSource");
dojo.provide("dojo.dnd.DropTarget");
dojo.provide("dojo.dnd.DragObject");
dojo.provide("dojo.dnd.DragAndDrop");

dojo.dnd.DragSource = function(){
	var dm = dojo.dnd.dragManager;
	if(dm["registerDragSource"]){ // side-effect prevention
		dm.registerDragSource(this);
	}
}

dojo.lang.extend(dojo.dnd.DragSource, {
	type: "",

	onDragEnd: function(){
	},

	onDragStart: function(){
	},

	unregister: function(){
		dojo.dnd.dragManager.unregisterDragSource(this);
	},

	reregister: function(){
		dojo.dnd.dragManager.registerDragSource(this);
	}
});

dojo.dnd.DragObject = function(){
	var dm = dojo.dnd.dragManager;
	if(dm["registerDragObject"]){ // side-effect prevention
		dm.registerDragObject(this);
	}
}

dojo.lang.extend(dojo.dnd.DragObject, {
	type: "",

	onDragStart: function(){
		// gets called directly after being created by the DragSource
		// default action is to clone self as icon
	},

	onDragMove: function(){
		// this changes the UI for the drag icon
		//	"it moves itself"
	},

	onDragOver: function(){
	},

	onDragOut: function(){
	},

	onDragEnd: function(){
	},

	// normal aliases
	onDragLeave: this.onDragOut,
	onDragEnter: this.onDragOver,

	// non-camel aliases
	ondragout: this.onDragOut,
	ondragover: this.onDragOver
});

dojo.dnd.DropTarget = function(){
	if (this.constructor == dojo.dnd.DropTarget) { return; } // need to be subclassed
	this.acceptedTypes = [];
	dojo.dnd.dragManager.registerDropTarget(this);
}

dojo.lang.extend(dojo.dnd.DropTarget, {

	acceptsType: function(type){
		if(!dojo.lang.inArray(this.acceptedTypes, "*")){ // wildcard
			if(!dojo.lang.inArray(this.acceptedTypes, type)) { return false; }
		}
		return true;
	},

	accepts: function(dragObjects){
		if(!dojo.lang.inArray(this.acceptedTypes, "*")){ // wildcard
			for (var i = 0; i < dragObjects.length; i++) {
				if (!dojo.lang.inArray(this.acceptedTypes,
					dragObjects[i].type)) { return false; }
			}
		}
		return true;
	},

	onDragOver: function(){
	},

	onDragOut: function(){
	},

	onDragMove: function(){
	},

	onDropStart: function(){
	},

	onDrop: function(){
	},

	onDropEnd: function(){
	}
});

// NOTE: this interface is defined here for the convenience of the DragManager
// implementor. It is expected that in most cases it will be satisfied by
// extending a native event (DOM event in HTML and SVG).
dojo.dnd.DragEvent = function(){
	this.dragSource = null;
	this.dragObject = null;
	this.target = null;
	this.eventStatus = "success";
	//
	// can be one of:
	//	[	"dropSuccess", "dropFailure", "dragMove",
	//		"dragStart", "dragEnter", "dragLeave"]
	//
}

dojo.dnd.DragManager = function(){
	/*
	 *	The DragManager handles listening for low-level events and dispatching
	 *	them to higher-level primitives like drag sources and drop targets. In
	 *	order to do this, it must keep a list of the items.
	 */
}

dojo.lang.extend(dojo.dnd.DragManager, {
	selectedSources: [],
	dragObjects: [],
	dragSources: [],
	registerDragSource: function(){},
	dropTargets: [],
	registerDropTarget: function(){},
	lastDragTarget: null,
	currentDragTarget: null,
	onKeyDown: function(){},
	onMouseOut: function(){},
	onMouseMove: function(){},
	onMouseUp: function(){}
});

// NOTE: despite the existance of the DragManager class, there will be a
// singleton drag manager provided by the renderer-specific D&D support code.
// It is therefore sane for us to assign instance variables to the DragManager
// prototype

// The renderer-specific file will define the following object:
// dojo.dnd.dragManager = null;

__CPAN_FILE__ src/dnd/HtmlDragAndDrop.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.dnd.HtmlDragAndDrop");
dojo.provide("dojo.dnd.HtmlDragSource");
dojo.provide("dojo.dnd.HtmlDropTarget");
dojo.provide("dojo.dnd.HtmlDragObject");

dojo.require("dojo.dnd.HtmlDragManager");
dojo.require("dojo.dnd.DragAndDrop");

dojo.require("dojo.dom");
dojo.require("dojo.style");
dojo.require("dojo.html");
dojo.require("dojo.html.extras");
dojo.require("dojo.lang.extras");
dojo.require("dojo.lfx.*");

dojo.dnd.HtmlDragSource = function(node, type){
	node = dojo.byId(node);
	this.constrainToContainer = false;
	if(node){
		this.domNode = node;
		this.dragObject = node;

		// register us
		dojo.dnd.DragSource.call(this);

		// set properties that might have been clobbered by the mixin
		this.type = type||this.domNode.nodeName.toLowerCase();
	}

}

dojo.inherits(dojo.dnd.HtmlDragSource, dojo.dnd.DragSource);

dojo.lang.extend(dojo.dnd.HtmlDragSource, {
	dragClass: "", // CSS classname(s) applied to node when it is being dragged

	onDragStart: function(){
		var dragObj = new dojo.dnd.HtmlDragObject(this.dragObject, this.type);
		if(this.dragClass) { dragObj.dragClass = this.dragClass; }

		if (this.constrainToContainer) {
			dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
		}

		return dragObj;
	},

	setDragHandle: function(node){
		node = dojo.byId(node);
		dojo.dnd.dragManager.unregisterDragSource(this);
		this.domNode = node;
		dojo.dnd.dragManager.registerDragSource(this);
	},

	setDragTarget: function(node){
		this.dragObject = node;
	},

	constrainTo: function(container) {
		this.constrainToContainer = true;
		if (container) {
			this.constrainingContainer = container;
		}
	}
});

dojo.dnd.HtmlDragObject = function(node, type){
	this.domNode = dojo.byId(node);
	this.type = type;
	this.constrainToContainer = false;
	this.dragSource = null;
}

dojo.inherits(dojo.dnd.HtmlDragObject, dojo.dnd.DragObject);

dojo.lang.extend(dojo.dnd.HtmlDragObject, {
	dragClass: "",
	opacity: 0.5,
	createIframe: true,		// workaround IE6 bug

	// if true, node will not move in X and/or Y direction
	disableX: false,
	disableY: false,

	createDragNode: function() {
		var node = this.domNode.cloneNode(true);
		if(this.dragClass) { dojo.html.addClass(node, this.dragClass); }
		if(this.opacity < 1) { dojo.style.setOpacity(node, this.opacity); }
		if(dojo.render.html.ie && this.createIframe){
			with(node.style) {
				top="0px";
				left="0px";
			}
			var outer = document.createElement("div");
			outer.appendChild(node);
			this.bgIframe = new dojo.html.BackgroundIframe(outer);
			outer.appendChild(this.bgIframe.iframe);
			node = outer;
		}
		node.style.zIndex = 999;
		return node;
	},

	onDragStart: function(e){
		dojo.html.clearSelection();

		this.scrollOffset = dojo.html.getScrollOffset();
		this.dragStartPosition = dojo.style.getAbsolutePosition(this.domNode, true);

		this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
			x: this.dragStartPosition.x - e.pageX};

		this.dragClone = this.createDragNode();

 		if ((this.domNode.parentNode.nodeName.toLowerCase() == 'body') || (dojo.style.getComputedStyle(this.domNode.parentNode,"position") == "static")) {
			this.parentPosition = {y: 0, x: 0};
		} else {
			this.parentPosition = dojo.style.getAbsolutePosition(this.domNode.parentNode, true);
		}

		if (this.constrainToContainer) {
			this.constraints = this.getConstraints();
		}

		// set up for dragging
		with(this.dragClone.style){
			position = "absolute";
			top = this.dragOffset.y + e.pageY + "px";
			left = this.dragOffset.x + e.pageX + "px";
		}

		document.body.appendChild(this.dragClone);
	},

	getConstraints: function() {

		if (this.constrainingContainer.nodeName.toLowerCase() == 'body') {
			width = dojo.html.getViewportWidth();
			height = dojo.html.getViewportHeight();
			padLeft = 0;
			padTop = 0;
		} else {
			width = dojo.style.getContentWidth(this.constrainingContainer);
			height = dojo.style.getContentHeight(this.constrainingContainer);
			padLeft = dojo.style.getPixelValue(this.constrainingContainer, "padding-left", true);
			padTop = dojo.style.getPixelValue(this.constrainingContainer, "padding-top", true);
		}

		return {
			minX: padLeft,
			minY: padTop,
			maxX: padLeft+width - dojo.style.getOuterWidth(this.domNode),
			maxY: padTop+height - dojo.style.getOuterHeight(this.domNode)
		}
	},

	updateDragOffset: function() {
		var scroll = dojo.html.getScrollOffset();
		if(scroll.y != this.scrollOffset.y) {
			var diff = scroll.y - this.scrollOffset.y;
			this.dragOffset.y += diff;
			this.scrollOffset.y = scroll.y;
		}
		if(scroll.x != this.scrollOffset.x) {
			var diff = scroll.x - this.scrollOffset.x;
			this.dragOffset.x += diff;
			this.scrollOffset.x = scroll.x;
		}
	},

	/** Moves the node to follow the mouse */
	onDragMove: function(e){
		this.updateDragOffset();
		var x = this.dragOffset.x + e.pageX;
		var y = this.dragOffset.y + e.pageY;

		if (this.constrainToContainer) {
			if (x < this.constraints.minX) { x = this.constraints.minX; }
			if (y < this.constraints.minY) { y = this.constraints.minY; }
			if (x > this.constraints.maxX) { x = this.constraints.maxX; }
			if (y > this.constraints.maxY) { y = this.constraints.maxY; }
		}

		if(!this.disableY) { this.dragClone.style.top = y + "px"; }
		if(!this.disableX) { this.dragClone.style.left = x + "px"; }
	},

	/**
	 * If the drag operation returned a success we reomve the clone of
	 * ourself from the original position. If the drag operation returned
	 * failure we slide back over to where we came from and end the operation
	 * with a little grace.
	 */
	onDragEnd: function(e){
		switch(e.dragStatus){

			case "dropSuccess":
				dojo.dom.removeNode(this.dragClone);
				this.dragClone = null;
				break;

			case "dropFailure": // slide back to the start
				var startCoords = dojo.style.getAbsolutePosition(this.dragClone, true);
				// offset the end so the effect can be seen
				var endCoords = [this.dragStartPosition.x + 1,
					this.dragStartPosition.y + 1];

				// animate
				var line = new dojo.lfx.Line(startCoords, endCoords);
				var anim = new dojo.lfx.Animation(500, line, dojo.lfx.easeOut);
				var dragObject = this;
				dojo.event.connect(anim, "onAnimate", function(e) {
					dragObject.dragClone.style.left = e[0] + "px";
					dragObject.dragClone.style.top = e[1] + "px";
				});
				dojo.event.connect(anim, "onEnd", function (e) {
					// pause for a second (not literally) and disappear
					dojo.lang.setTimeout(dojo.dom.removeNode, 200,
						dragObject.dragClone);
				});
				anim.play();
				break;
		}

		// shortly the browser will fire an onClick() event,
		// but since this was really a drag, just squelch it
		dojo.event.connect(this.domNode, "onclick", this, "squelchOnClick");
	},

	squelchOnClick: function(e){
		// squelch this onClick() event because it's the result of a drag (it's not a real click)
		e.preventDefault();

		// but if a real click comes along, allow it
		dojo.event.disconnect(this.domNode, "onclick", this, "squelchOnClick");
	},

	constrainTo: function(container) {
		this.constrainToContainer=true;
		if (container) {
			this.constrainingContainer = container;
		} else {
			this.constrainingContainer = this.domNode.parentNode;
		}
	}
});

dojo.dnd.HtmlDropTarget = function(node, types){
	if (arguments.length == 0) { return; }
	this.domNode = dojo.byId(node);
	dojo.dnd.DropTarget.call(this);
	if(types && dojo.lang.isString(types)) {
		types = [types];
	}
	this.acceptedTypes = types || [];
}
dojo.inherits(dojo.dnd.HtmlDropTarget, dojo.dnd.DropTarget);

dojo.lang.extend(dojo.dnd.HtmlDropTarget, {
	onDragOver: function(e){
		if(!this.accepts(e.dragObjects)){ return false; }

		// cache the positions of the child nodes
		this.childBoxes = [];
		for (var i = 0, child; i < this.domNode.childNodes.length; i++) {
			child = this.domNode.childNodes[i];
			if (child.nodeType != dojo.dom.ELEMENT_NODE) { continue; }
			var pos = dojo.style.getAbsolutePosition(child, true);
			var height = dojo.style.getInnerHeight(child);
			var width = dojo.style.getInnerWidth(child);
			this.childBoxes.push({top: pos.y, bottom: pos.y+height,
				left: pos.x, right: pos.x+width, node: child});
		}

		// TODO: use dummy node

		return true;
	},

	_getNodeUnderMouse: function(e){
		// find the child
		for (var i = 0, child; i < this.childBoxes.length; i++) {
			with (this.childBoxes[i]) {
				if (e.pageX >= left && e.pageX <= right &&
					e.pageY >= top && e.pageY <= bottom) { return i; }
			}
		}

		return -1;
	},

	createDropIndicator: function() {
		this.dropIndicator = document.createElement("div");
		with (this.dropIndicator.style) {
			position = "absolute";
			zIndex = 999;
			borderTopWidth = "1px";
			borderTopColor = "black";
			borderTopStyle = "solid";
			width = dojo.style.getInnerWidth(this.domNode) + "px";
			left = dojo.style.getAbsoluteX(this.domNode, true) + "px";
		}
	},

	onDragMove: function(e, dragObjects){
		var i = this._getNodeUnderMouse(e);

		if(!this.dropIndicator){
			this.createDropIndicator();
		}

		if(i < 0) {
			if(this.childBoxes.length) {
				var before = (dojo.html.gravity(this.childBoxes[0].node, e) & dojo.html.gravity.NORTH);
			} else {
				var before = true;
			}
		} else {
			var child = this.childBoxes[i];
			var before = (dojo.html.gravity(child.node, e) & dojo.html.gravity.NORTH);
		}
		this.placeIndicator(e, dragObjects, i, before);

		if(!dojo.html.hasParent(this.dropIndicator)) {
			document.body.appendChild(this.dropIndicator);
		}
	},

	/**
	 * Position the horizontal line that indicates "insert between these two items"
	 */
	placeIndicator: function(e, dragObjects, boxIndex, before) {
		with(this.dropIndicator.style){
			if (boxIndex < 0) {
				if (this.childBoxes.length) {
					top = (before ? this.childBoxes[0].top
						: this.childBoxes[this.childBoxes.length - 1].bottom) + "px";
				} else {
					top = dojo.style.getAbsoluteY(this.domNode, true) + "px";
				}
			} else {
				var child = this.childBoxes[boxIndex];
				top = (before ? child.top : child.bottom) + "px";
			}
		}
	},

	onDragOut: function(e) {
		if(this.dropIndicator) {
			dojo.dom.removeNode(this.dropIndicator);
			delete this.dropIndicator;
		}
	},

	/**
	 * Inserts the DragObject as a child of this node relative to the
	 * position of the mouse.
	 *
	 * @return true if the DragObject was inserted, false otherwise
	 */
	onDrop: function(e){
		this.onDragOut(e);

		var i = this._getNodeUnderMouse(e);

		if (i < 0) {
			if (this.childBoxes.length) {
				if (dojo.html.gravity(this.childBoxes[0].node, e) & dojo.html.gravity.NORTH) {
					return this.insert(e, this.childBoxes[0].node, "before");
				} else {
					return this.insert(e, this.childBoxes[this.childBoxes.length-1].node, "after");
				}
			}
			return this.insert(e, this.domNode, "append");
		}

		var child = this.childBoxes[i];
		if (dojo.html.gravity(child.node, e) & dojo.html.gravity.NORTH) {
			return this.insert(e, child.node, "before");
		} else {
			return this.insert(e, child.node, "after");
		}
	},

	insert: function(e, refNode, position) {
		var node = e.dragObject.domNode;

		if(position == "before") {
			return dojo.html.insertBefore(node, refNode);
		} else if(position == "after") {
			return dojo.html.insertAfter(node, refNode);
		} else if(position == "append") {
			refNode.appendChild(node);
			return true;
		}

		return false;
	}
});

__CPAN_FILE__ src/dnd/HtmlDragManager.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.dnd.HtmlDragManager");
dojo.require("dojo.dnd.DragAndDrop");
dojo.require("dojo.event.*");
dojo.require("dojo.lang.array");
dojo.require("dojo.html");
dojo.require("dojo.style");

// NOTE: there will only ever be a single instance of HTMLDragManager, so it's
// safe to use prototype properties for book-keeping.
dojo.dnd.HtmlDragManager = function(){
}

dojo.inherits(dojo.dnd.HtmlDragManager, dojo.dnd.DragManager);

dojo.lang.extend(dojo.dnd.HtmlDragManager, {
	/**
	 * There are several sets of actions that the DnD code cares about in the
	 * HTML context:
	 *	1.) mouse-down ->
	 *			(draggable selection)
	 *			(dragObject generation)
	 *		mouse-move ->
	 *			(draggable movement)
	 *			(droppable detection)
	 *			(inform droppable)
	 *			(inform dragObject)
	 *		mouse-up
	 *			(inform/destroy dragObject)
	 *			(inform draggable)
	 *			(inform droppable)
	 *	2.) mouse-down -> mouse-down
	 *			(click-hold context menu)
	 *	3.) mouse-click ->
	 *			(draggable selection)
	 *		shift-mouse-click ->
	 *			(augment draggable selection)
	 *		mouse-down ->
	 *			(dragObject generation)
	 *		mouse-move ->
	 *			(draggable movement)
	 *			(droppable detection)
	 *			(inform droppable)
	 *			(inform dragObject)
	 *		mouse-up
	 *			(inform draggable)
	 *			(inform droppable)
	 *	4.) mouse-up
	 *			(clobber draggable selection)
	 */
	disabled: false, // to kill all dragging!
	nestedTargets: false,
	mouseDownTimer: null, // used for click-hold operations
	dsCounter: 0,
	dsPrefix: "dojoDragSource",

	// dimension calculation cache for use durring drag
	dropTargetDimensions: [],

	currentDropTarget: null,
	// currentDropTargetPoints: null,
	previousDropTarget: null,
	_dragTriggered: false,

	selectedSources: [],
	dragObjects: [],

	// mouse position properties
	currentX: null,
	currentY: null,
	lastX: null,
	lastY: null,
	mouseDownX: null,
	mouseDownY: null,
	threshold: 7,

	dropAcceptable: false,

	cancelEvent: function(e){ e.stopPropagation(); e.preventDefault();},

	// method over-rides
	registerDragSource: function(ds){
		if(ds["domNode"]){
			// FIXME: dragSource objects SHOULD have some sort of property that
			// references their DOM node, we shouldn't just be passing nodes and
			// expecting it to work.
			var dp = this.dsPrefix;
			var dpIdx = dp+"Idx_"+(this.dsCounter++);
			ds.dragSourceId = dpIdx;
			this.dragSources[dpIdx] = ds;
			ds.domNode.setAttribute(dp, dpIdx);

			// so we can drag links
			if(dojo.render.html.ie){
				dojo.event.connect(ds.domNode, "ondragstart", this.cancelEvent);
			}
		}
	},

	unregisterDragSource: function(ds){
		if (ds["domNode"]){

			var dp = this.dsPrefix;
			var dpIdx = ds.dragSourceId;
			delete ds.dragSourceId;
			delete this.dragSources[dpIdx];
			ds.domNode.setAttribute(dp, null);
		}
		if(dojo.render.html.ie){
			dojo.event.disconnect(ds.domNode, "ondragstart", this.cancelEvent );
		}
	},

	registerDropTarget: function(dt){
		this.dropTargets.push(dt);
	},

	unregisterDropTarget: function(dt){
		var index = dojo.lang.find(this.dropTargets, dt, true);
		if (index>=0) {
			this.dropTargets.splice(index, 1);
		}
	},

	getDragSource: function(e){
		var tn = e.target;
		if(tn === document.body){ return; }
		var ta = dojo.html.getAttribute(tn, this.dsPrefix);
		while((!ta)&&(tn)){
			tn = tn.parentNode;
			if((!tn)||(tn === document.body)){ return; }
			ta = dojo.html.getAttribute(tn, this.dsPrefix);
		}
		return this.dragSources[ta];
	},

	onKeyDown: function(e){
	},

	onMouseDown: function(e){
		if(this.disabled) { return; }

		// only begin on left click
		if(dojo.render.html.ie) {
			if(e.button != 1) { return; }
		} else if(e.which != 1) {
			return;
		}

		var target = e.target.nodeType == dojo.dom.TEXT_NODE ?
			e.target.parentNode : e.target;

		// do not start drag involvement if the user is interacting with
		// a form element.
		if(dojo.html.isTag(target, "button", "textarea", "input", "select", "option")) {
			return;
		}

		// find a selection object, if one is a parent of the source node
		var ds = this.getDragSource(e);
		
		// this line is important.  if we aren't selecting anything then
		// we need to return now, so preventDefault() isn't called, and thus
		// the event is propogated to other handling code
		if(!ds){ return; }

		if(!dojo.lang.inArray(this.selectedSources, ds)){
			this.selectedSources.push(ds);
		}

 		this.mouseDownX = e.pageX;
 		this.mouseDownY = e.pageY;

		// Must stop the mouse down from being propogated, or otherwise can't
		// drag links in firefox.
		// WARNING: preventing the default action on all mousedown events
		// prevents user interaction with the contents.
		e.preventDefault();

		dojo.event.connect(document, "onmousemove", this, "onMouseMove");
	},

	onMouseUp: function(e, cancel){
		// if we aren't dragging then ignore the mouse-up
		// (in particular, don't call preventDefault(), because other
		// code may need to process this event)
		if(this.selectedSources.length==0){
			return;
		}

		this.mouseDownX = null;
		this.mouseDownY = null;
		this._dragTriggered = false;
 		// e.preventDefault();
		e.dragSource = this.dragSource;
		if((!e.shiftKey)&&(!e.ctrlKey)){
			if(this.currentDropTarget) {
				this.currentDropTarget.onDropStart();
			}
			dojo.lang.forEach(this.dragObjects, function(tempDragObj){
				var ret = null;
				if(!tempDragObj){ return; }
				if(this.currentDropTarget) {
					e.dragObject = tempDragObj;

					// NOTE: we can't get anything but the current drop target
					// here since the drag shadow blocks mouse-over events.
					// This is probelematic for dropping "in" something
					var ce = this.currentDropTarget.domNode.childNodes;
					if(ce.length > 0){
						e.dropTarget = ce[0];
						while(e.dropTarget == tempDragObj.domNode){
							e.dropTarget = e.dropTarget.nextSibling;
						}
					}else{
						e.dropTarget = this.currentDropTarget.domNode;
					}
					if(this.dropAcceptable){
						ret = this.currentDropTarget.onDrop(e);
					}else{
						 this.currentDropTarget.onDragOut(e);
					}
				}

				e.dragStatus = this.dropAcceptable && ret ? "dropSuccess" : "dropFailure";
				tempDragObj.dragSource.onDragEnd(e);
				tempDragObj.onDragEnd(e);
			}, this);

			this.selectedSources = [];
			this.dragObjects = [];
			this.dragSource = null;
			if(this.currentDropTarget) {
				this.currentDropTarget.onDropEnd();
			}
		}

		dojo.event.disconnect(document, "onmousemove", this, "onMouseMove");
		this.currentDropTarget = null;
	},

	onScroll: function(){
		for(var i = 0; i < this.dragObjects.length; i++) {
			if(this.dragObjects[i].updateDragOffset) {
				this.dragObjects[i].updateDragOffset();
			}
		}
		// TODO: do not recalculate, only adjust coordinates
		this.cacheTargetLocations();
	},

	_dragStartDistance: function(x, y){
		if((!this.mouseDownX)||(!this.mouseDownX)){
			return;
		}
		var dx = Math.abs(x-this.mouseDownX);
		var dx2 = dx*dx;
		var dy = Math.abs(y-this.mouseDownY);
		var dy2 = dy*dy;
		return parseInt(Math.sqrt(dx2+dy2), 10);
	},

	cacheTargetLocations: function(){
		this.dropTargetDimensions = [];
		dojo.lang.forEach(this.dropTargets, function(tempTarget){
			var tn = tempTarget.domNode;
			if(!tn){ return; }
			var ttx = dojo.style.getAbsoluteX(tn, true);
			var tty = dojo.style.getAbsoluteY(tn, true);
			this.dropTargetDimensions.push([
				[ttx, tty],	// upper-left
				// lower-right
				[ ttx+dojo.style.getInnerWidth(tn), tty+dojo.style.getInnerHeight(tn) ],
				tempTarget
			]);
			//dojo.debug("Cached for "+tempTarget)
		}, this);
		//dojo.debug("Cache locations")
	},

	onMouseMove: function(e){
		if((dojo.render.html.ie)&&(e.button != 1)){
			// Oooops - mouse up occurred - e.g. when mouse was not over the
			// window. I don't think we can detect this for FF - but at least
			// we can be nice in IE.
			this.currentDropTarget = null;
			this.onMouseUp(e, true);
			return;
		}

		// if we've got some sources, but no drag objects, we need to send
		// onDragStart to all the right parties and get things lined up for
		// drop target detection

		if(	(this.selectedSources.length)&&
			(!this.dragObjects.length) ){
			var dx;
			var dy;
			if(!this._dragTriggered){
				this._dragTriggered = (this._dragStartDistance(e.pageX, e.pageY) > this.threshold);
				if(!this._dragTriggered){ return; }
				dx = e.pageX - this.mouseDownX;
				dy = e.pageY - this.mouseDownY;
			}

			if (this.selectedSources.length == 1) {
				this.dragSource = this.selectedSources[0];
			}

			dojo.lang.forEach(this.selectedSources, function(tempSource){
				if(!tempSource){ return; }
				var tdo = tempSource.onDragStart(e);
				if(tdo){
					tdo.onDragStart(e);

					// "bump" the drag object to account for the drag threshold
					tdo.dragOffset.top += dy;
					tdo.dragOffset.left += dx;
					tdo.dragSource = tempSource;

					this.dragObjects.push(tdo);
				}
			}, this);

			/* clean previous drop target in dragStart */
			this.previousDropTarget = null;

			this.cacheTargetLocations();
		}

		// FIXME: we need to add dragSources and dragObjects to e
		dojo.lang.forEach(this.dragObjects, function(dragObj){
			if(dragObj){ dragObj.onDragMove(e); }
		});

		// if we have a current drop target, check to see if we're outside of
		// it. If so, do all the actions that need doing.
		if(this.currentDropTarget){
			//dojo.debug(dojo.dom.hasParent(this.currentDropTarget.domNode))
			var c = dojo.style.toCoordinateArray(this.currentDropTarget.domNode, true);
			//		var dtp = this.currentDropTargetPoints;
			var dtp = [
				[c[0],c[1]], [c[0]+c[2], c[1]+c[3]]
			];
		}

		if((!this.nestedTargets)&&(dtp)&&(this.isInsideBox(e, dtp))){
			if(this.dropAcceptable){
				this.currentDropTarget.onDragMove(e, this.dragObjects);
			}
		}else{
			// FIXME: need to fix the event object!
			// see if we can find a better drop target
			var bestBox = this.findBestTarget(e);

			if(bestBox.target === null){
				if(this.currentDropTarget){
					this.currentDropTarget.onDragOut(e);
					this.previousDropTarget = this.currentDropTarget;
					this.currentDropTarget = null;
					// this.currentDropTargetPoints = null;
				}
				this.dropAcceptable = false;
				return;
			}

			if(this.currentDropTarget !== bestBox.target){
				if(this.currentDropTarget){
					this.previousDropTarget = this.currentDropTarget;
					this.currentDropTarget.onDragOut(e);
				}
				this.currentDropTarget = bestBox.target;
				// this.currentDropTargetPoints = bestBox.points;
				e.dragObjects = this.dragObjects;
				this.dropAcceptable = this.currentDropTarget.onDragOver(e);

			}else{
				if(this.dropAcceptable){
					this.currentDropTarget.onDragMove(e, this.dragObjects);
				}
			}
		}
	},

	findBestTarget: function(e) {
		var _this = this;
		var bestBox = new Object();
		bestBox.target = null;
		bestBox.points = null;
		dojo.lang.every(this.dropTargetDimensions, function(tmpDA) {
			if(!_this.isInsideBox(e, tmpDA))
				return true;
			bestBox.target = tmpDA[2];
			bestBox.points = tmpDA;
			// continue iterating only if _this.nestedTargets == true
			return Boolean(_this.nestedTargets);
		});

		return bestBox;
	},

	isInsideBox: function(e, coords){
		if(	(e.pageX > coords[0][0])&&
			(e.pageX < coords[1][0])&&
			(e.pageY > coords[0][1])&&
			(e.pageY < coords[1][1]) ){
			return true;
		}
		return false;
	},

	onMouseOver: function(e){
	},

	onMouseOut: function(e){
	}
});

dojo.dnd.dragManager = new dojo.dnd.HtmlDragManager();

// global namespace protection closure
(function(){
	var d = document;
	var dm = dojo.dnd.dragManager;
	// set up event handlers on the document
	dojo.event.connect(d, "onkeydown", 		dm, "onKeyDown");
	dojo.event.connect(d, "onmouseover",	dm, "onMouseOver");
	dojo.event.connect(d, "onmouseout", 	dm, "onMouseOut");
	dojo.event.connect(d, "onmousedown",	dm, "onMouseDown");
	dojo.event.connect(d, "onmouseup",		dm, "onMouseUp");
	// TODO: process scrolling of elements, not only window
	dojo.event.connect(window, "onscroll",	dm, "onScroll");
})();

__CPAN_FILE__ src/dnd/HtmlDragMove.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.dnd.HtmlDragMove");
dojo.provide("dojo.dnd.HtmlDragMoveSource");
dojo.provide("dojo.dnd.HtmlDragMoveObject");
dojo.require("dojo.dnd.*");

dojo.dnd.HtmlDragMoveSource = function(node, type){
	dojo.dnd.HtmlDragSource.call(this, node, type);
}

dojo.inherits(dojo.dnd.HtmlDragMoveSource, dojo.dnd.HtmlDragSource);

dojo.lang.extend(dojo.dnd.HtmlDragMoveSource, {
	onDragStart: function(){
		var dragObj =  new dojo.dnd.HtmlDragMoveObject(this.dragObject, this.type);

		if (this.constrainToContainer) {
			dragObj.constrainTo(this.constrainingContainer);
		}
		return dragObj;
	}
});

dojo.dnd.HtmlDragMoveObject = function(node, type){
	dojo.dnd.HtmlDragObject.call(this, node, type);
}

dojo.inherits(dojo.dnd.HtmlDragMoveObject, dojo.dnd.HtmlDragObject);

dojo.lang.extend(dojo.dnd.HtmlDragMoveObject, {
	onDragEnd: function(e){
		// shortly the browser will fire an onClick() event,
		// but since this was really a drag, just squelch it
		dojo.event.connect(this.domNode, "onclick", this, "squelchOnClick");
	},
	
	onDragStart: function(e){

		dojo.html.clearSelection();

		this.dragClone = this.domNode;

		this.scrollOffset = dojo.html.getScrollOffset();
		this.dragStartPosition = dojo.style.getAbsolutePosition(this.domNode, true);
		
		this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
			x: this.dragStartPosition.x - e.pageX};

		if (this.domNode.parentNode.nodeName.toLowerCase() == 'body') {
			this.parentPosition = {y: 0, x: 0};
		} else {
			this.parentPosition = dojo.style.getAbsolutePosition(this.domNode.parentNode, true);
		}

		this.dragClone.style.position = "absolute";

		if (this.constrainToContainer) {
			this.constraints = this.getConstraints();
		}
	}

});

__CPAN_FILE__ src/dnd/Sortable.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.dnd.Sortable");
dojo.require("dojo.dnd.*");

dojo.dnd.Sortable = function () {}

dojo.lang.extend(dojo.dnd.Sortable, {

	ondragstart: function (e) {
		var dragObject = e.target;
		while (dragObject.parentNode && dragObject.parentNode != this) {
			dragObject = dragObject.parentNode;
		}
		// TODO: should apply HtmlDropTarget interface to self
		// TODO: should apply HtmlDragObject interface?
		return dragObject;
	}

});

__CPAN_FILE__ src/dnd/TreeDragAndDrop.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/**
 * TreeDrag* specialized on managing subtree drags
 * It selects nodes and visualises what's going on,
 * but delegates real actions upon tree to the controller
 *
 * This code is considered a part of controller
*/

dojo.provide("dojo.dnd.TreeDragAndDrop");
dojo.provide("dojo.dnd.TreeDragSource");
dojo.provide("dojo.dnd.TreeDropTarget");
dojo.provide("dojo.dnd.TreeDNDController");

dojo.require("dojo.dnd.HtmlDragAndDrop");
dojo.require("dojo.lang.func");
dojo.require("dojo.lang.array");
dojo.require("dojo.lang.extras");

dojo.dnd.TreeDragSource = function(node, syncController, type, treeNode){
	this.controller = syncController;
	this.treeNode = treeNode;

	dojo.dnd.HtmlDragSource.call(this, node, type);
}

dojo.inherits(dojo.dnd.TreeDragSource, dojo.dnd.HtmlDragSource);

dojo.lang.extend(dojo.dnd.TreeDragSource, {
	onDragStart: function(){
		/* extend adds functions to prototype */
		var dragObject = dojo.dnd.HtmlDragSource.prototype.onDragStart.call(this);
		//dojo.debugShallow(dragObject)

		dragObject.treeNode = this.treeNode;

		dragObject.onDragStart = dojo.lang.hitch(dragObject, function(e) {

			/* save selection */
			this.savedSelectedNode = this.treeNode.tree.selector.selectedNode;
			if (this.savedSelectedNode) {
				this.savedSelectedNode.unMarkSelected();
			}

			var result = dojo.dnd.HtmlDragObject.prototype.onDragStart.apply(this, arguments);


			/* remove background grid from cloned object */
			var cloneGrid = this.dragClone.getElementsByTagName('img');
			for(var i=0; i<cloneGrid.length; i++) {
				cloneGrid.item(i).style.backgroundImage='url()';
			}

			return result;


		});

		dragObject.onDragEnd = function(e) {

			/* restore selection */
			if (this.savedSelectedNode) {
				this.savedSelectedNode.markSelected();
			}
			//dojo.debug(e.dragStatus);

			return dojo.dnd.HtmlDragObject.prototype.onDragEnd.apply(this, arguments);
		}
		//dojo.debug(dragObject.domNode.outerHTML)


		return dragObject;
	},

	onDragEnd: function(e){


		 var res = dojo.dnd.HtmlDragSource.prototype.onDragEnd.call(this, e);


		 return res;
	}
});

// .......................................

dojo.dnd.TreeDropTarget = function(domNode, controller, type, treeNode, DNDMode){

	this.treeNode = treeNode;
	this.controller = controller; // I will sync-ly process drops
	this.DNDMode = DNDMode;

	dojo.dnd.HtmlDropTarget.apply(this, [domNode, type]);
}

dojo.inherits(dojo.dnd.TreeDropTarget, dojo.dnd.HtmlDropTarget);

dojo.lang.extend(dojo.dnd.TreeDropTarget, {

	autoExpandDelay: 1500,
	autoExpandTimer: null,


	position: null,

	indicatorStyle: "2px black solid",

	showIndicator: function(position) {

		// do not change style too often, cause of blinking possible
		if (this.position == position) {
			return;
		}

		//dojo.debug(position)

		this.hideIndicator();

		this.position = position;

		if (position == "before") {
			this.treeNode.labelNode.style.borderTop = this.indicatorStyle;
		} else if (position == "after") {
			this.treeNode.labelNode.style.borderBottom = this.indicatorStyle;
		} else if (position == "onto") {
			this.treeNode.markSelected();
		}


	},

	hideIndicator: function() {
		this.treeNode.labelNode.style.borderBottom="";
		this.treeNode.labelNode.style.borderTop="";
		this.treeNode.unMarkSelected();
		this.position = null;
	},



	// is the target possibly ok ?
	// This function is run on dragOver, but drop possibility is also determined by position over node
	// that's why acceptsWithPosition is called
	// doesnt take index into account ( can change while moving mouse w/o changing target )


	/**
	 * Coarse (tree-level) access check.
	 * We can't determine real accepts status w/o position
	*/
	onDragOver: function(e){
//dojo.debug("onDragOver for "+e);


		var accepts = dojo.dnd.HtmlDropTarget.prototype.onDragOver.apply(this, arguments);

		//dojo.debug("TreeDropTarget.onDragOver accepts:"+accepts)

		if (accepts && this.treeNode.isFolder && !this.treeNode.isExpanded) {
			this.setAutoExpandTimer();
		}

		return accepts;
	},

	/* Parent.onDragOver calls this function to get accepts status */
	accepts: function(dragObjects) {

		var accepts = dojo.dnd.HtmlDropTarget.prototype.accepts.apply(this, arguments);

		if (!accepts) return false;

		var sourceTreeNode = dragObjects[0].treeNode;

		if (dojo.lang.isUndefined(sourceTreeNode) || !sourceTreeNode || !sourceTreeNode.isTreeNode) {
			dojo.raise("Source is not TreeNode or not found");
		}

		if (sourceTreeNode === this.treeNode) return false;

		return true;
	},



	setAutoExpandTimer: function() {
		// set up autoexpand timer
		var _this = this;

		var autoExpand = function () {
			if (dojo.dnd.dragManager.currentDropTarget === _this) {
				_this.controller.expand(_this.treeNode);
			}
		}

		this.autoExpandTimer = dojo.lang.setTimeout(autoExpand, _this.autoExpandDelay);
	},


	getAcceptPosition: function(e, sourceTreeNode) {

		var DNDMode = this.DNDMode;

		if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO &&
			// check if ONTO is allowed localy
			!(
			  !this.treeNode.actionIsDisabled(dojo.widget.TreeNode.prototype.actions.ADDCHILD) // check dynamically cause may change w/o regeneration of dropTarget
			  && sourceTreeNode.parent !== this.treeNode
			  && this.controller.canMove(sourceTreeNode, this.treeNode)
			 )
		) {
			// disable ONTO if can't move
			DNDMode &= ~dojo.widget.Tree.prototype.DNDModes.ONTO;
		}


		var position = this.getPosition(e, DNDMode);

		//dojo.debug(DNDMode & +" : "+position);


		// if onto is here => it was allowed before, no accept check is needed
		if (position=="onto" ||
			(!this.isAdjacentNode(sourceTreeNode, position)
			 && this.controller.canMove(sourceTreeNode, this.treeNode.parent)
			)
		) {
			return position;
		} else {
			return false;
		}

	},

	onDragOut: function(e) {
		this.clearAutoExpandTimer();

		this.hideIndicator();
	},


	clearAutoExpandTimer: function() {
		if (this.autoExpandTimer) {
			clearTimeout(this.autoExpandTimer);
			this.autoExpandTimer = null;
		}
	},



	onDragMove: function(e, dragObjects){

		var sourceTreeNode = dragObjects[0].treeNode;

		var position = this.getAcceptPosition(e, sourceTreeNode);

		if (position) {
			this.showIndicator(position);
		}

	},

	isAdjacentNode: function(sourceNode, position) {

		if (sourceNode === this.treeNode) return true;
		if (sourceNode.getNextSibling() === this.treeNode && position=="before") return true;
		if (sourceNode.getPreviousSibling() === this.treeNode && position=="after") return true;

		return false;
	},


	/* get DNDMode and see which position e fits */
	getPosition: function(e, DNDMode) {
		node = dojo.byId(this.treeNode.labelNode);
		var mousey = e.pageY || e.clientY + document.body.scrollTop;
		var nodey = dojo.html.getAbsoluteY(node);
		var height = dojo.html.getInnerHeight(node);

		var relY = mousey - nodey;
		var p = relY / height;

		var position = ""; // "" <=> forbidden
		if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO
		  && DNDMode & dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
			if (p<=0.3) {
				position = "before";
			} else if (p<=0.7) {
				position = "onto";
			} else {
				position = "after";
			}
		} else if (DNDMode & dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
			if (p<=0.5) {
				position = "before";
			} else {
				position = "after";
			}
		}
		else if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO) {
			position = "onto";
		}


		return position;
	},



	getTargetParentIndex: function(sourceTreeNode, position) {

		var index = position == "before" ? this.treeNode.getParentIndex() : this.treeNode.getParentIndex()+1;
		if (this.treeNode.parent === sourceTreeNode.parent
		  && this.treeNode.getParentIndex() > sourceTreeNode.getParentIndex()) {
		  	index--;  // dragging a node is different for simple move bacause of before-after issues
		}

		return index;
	},


	onDrop: function(e){
		// onDragOut will clean position


		var position = this.position;

//dojo.debug(position);

		this.onDragOut(e);

		var sourceTreeNode = e.dragObject.treeNode;

		if (!dojo.lang.isObject(sourceTreeNode)) {
			dojo.raise("TreeNode not found in dragObject")
		}

		if (position == "onto") {
			return this.controller.move(sourceTreeNode, this.treeNode, 0);
		} else {
			var index = this.getTargetParentIndex(sourceTreeNode, position);
			return this.controller.move(sourceTreeNode, this.treeNode.parent, index);
		}

		//dojo.debug('drop2');



	}


});



dojo.dnd.TreeDNDController = function(treeController) {

	// I use this controller to perform actions
	this.treeController = treeController;

	this.dragSources = {};

	this.dropTargets = {};

}

dojo.lang.extend(dojo.dnd.TreeDNDController, {


	listenTree: function(tree) {
		//dojo.debug("Listen tree "+tree);
		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
		dojo.event.topic.subscribe(tree.eventNames.moveTo, this, "onMoveTo");
		dojo.event.topic.subscribe(tree.eventNames.addChild, this, "onAddChild");
		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
	},


	unlistenTree: function(tree) {
		//dojo.debug("Listen tree "+tree);
		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
		dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, "onMoveTo");
		dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, "onAddChild");
		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
	},

	onTreeDestroy: function(message) {
		this.unlistenTree(message.source);
		// I'm not widget so don't use destroy() call and dieWithTree
	},

	onCreateDOMNode: function(message) {
		this.registerDNDNode(message.source);
	},

	onAddChild: function(message) {
		this.registerDNDNode(message.child);
	},

	onMoveFrom: function(message) {
		var _this = this;
		dojo.lang.forEach(
			message.child.getDescendants(),
			function(node) { _this.unregisterDNDNode(node); }
		);
	},

	onMoveTo: function(message) {
		var _this = this;
		dojo.lang.forEach(
			message.child.getDescendants(),
			function(node) { _this.registerDNDNode(node); }
		);
	},

	/**
	 * Controller(node model) creates DNDNodes because it passes itself to node for synchroneous drops processing
	 * I can't process DnD with events cause an event can't return result success/false
	*/
	registerDNDNode: function(node) {
		if (!node.tree.DNDMode) return;

//dojo.debug("registerDNDNode "+node);

		/* I drag label, not domNode, because large domNodes are very slow to copy and large to drag */

		var source = null;
		var target = null;

		if (!node.actionIsDisabled(node.actions.MOVE)) {
			//dojo.debug("reg source")
			var source = new dojo.dnd.TreeDragSource(node.labelNode, this, node.tree.widgetId, node);
			this.dragSources[node.widgetId] = source;
		}

		var target = new dojo.dnd.TreeDropTarget(node.labelNode, this.treeController, node.tree.DNDAcceptTypes, node, node.tree.DNDMode);

		this.dropTargets[node.widgetId] = target;

	},


	unregisterDNDNode: function(node) {

		if (this.dragSources[node.widgetId]) {
			dojo.dnd.dragManager.unregisterDragSource(this.dragSources[node.widgetId]);
			delete this.dragSources[node.widgetId];
		}

		if (this.dropTargets[node.widgetId]) {
			dojo.dnd.dragManager.unregisterDropTarget(this.dropTargets[node.widgetId]);
			delete this.dropTargets[node.widgetId];
		}
	}





});

__CPAN_FILE__ src/dnd/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.dnd.DragAndDrop"],
	browser: ["dojo.dnd.HtmlDragAndDrop"],
	dashboard: ["dojo.dnd.HtmlDragAndDrop"]
});
dojo.provide("dojo.dnd.*");

__CPAN_DIR__ src/event
__CPAN_FILE__ src/event/browser.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.event.browser");
dojo.require("dojo.event");

dojo_ie_clobber = new function(){
	this.clobberNodes = [];

	function nukeProp(node, prop){
		// try{ node.removeAttribute(prop); 	}catch(e){ /* squelch */ }
		try{ node[prop] = null; 			}catch(e){ /* squelch */ }
		try{ delete node[prop]; 			}catch(e){ /* squelch */ }
		// FIXME: JotLive needs this, but I'm not sure if it's too slow or not
		try{ node.removeAttribute(prop);	}catch(e){ /* squelch */ }
	}

	this.clobber = function(nodeRef){
		var na;
		var tna;
		if(nodeRef){
			tna = nodeRef.all || nodeRef.getElementsByTagName("*");
			na = [nodeRef];
			for(var x=0; x<tna.length; x++){
				// if we're gonna be clobbering the thing, at least make sure
				// we aren't trying to do it twice
				if(tna[x]["__doClobber__"]){
					na.push(tna[x]);
				}
			}
		}else{
			try{ window.onload = null; }catch(e){}
			na = (this.clobberNodes.length) ? this.clobberNodes : document.all;
		}
		tna = null;
		var basis = {};
		for(var i = na.length-1; i>=0; i=i-1){
			var el = na[i];
			if(el["__clobberAttrs__"]){
				for(var j=0; j<el.__clobberAttrs__.length; j++){
					nukeProp(el, el.__clobberAttrs__[j]);
				}
				nukeProp(el, "__clobberAttrs__");
				nukeProp(el, "__doClobber__");
			}
		}
		na = null;
	}
}

if(dojo.render.html.ie){
	window.onunload = function(){
		dojo_ie_clobber.clobber();
		try{
			if((dojo["widget"])&&(dojo.widget["manager"])){
				dojo.widget.manager.destroyAll();
			}
		}catch(e){}
		try{ window.onload = null; }catch(e){}
		try{ window.onunload = null; }catch(e){}
		dojo_ie_clobber.clobberNodes = [];
		// CollectGarbage();
	}
}

dojo.event.browser = new function(){

	var clobberIdx = 0;

	this.clean = function(node){
		if(dojo.render.html.ie){ 
			dojo_ie_clobber.clobber(node);
		}
	}

	this.addClobberNode = function(node){
		if(!node["__doClobber__"]){
			node.__doClobber__ = true;
			dojo_ie_clobber.clobberNodes.push(node);
			// this might not be the most efficient thing to do, but it's
			// much less error prone than other approaches which were
			// previously tried and failed
			node.__clobberAttrs__ = [];
		}
	}

	this.addClobberNodeAttrs = function(node, props){
		this.addClobberNode(node);
		for(var x=0; x<props.length; x++){
			node.__clobberAttrs__.push(props[x]);
		}
	}

	this.removeListener = function(node, evtName, fp, capture){
		if(!capture){ var capture = false; }
		evtName = evtName.toLowerCase();
		if(evtName.substr(0,2)=="on"){ evtName = evtName.substr(2); }
		// FIXME: this is mostly a punt, we aren't actually doing anything on IE
		if(node.removeEventListener){
			node.removeEventListener(evtName, fp, capture);
		}
	}

	this.addListener = function(node, evtName, fp, capture, dontFix){
		if(!node){ return; } // FIXME: log and/or bail?
		if(!capture){ var capture = false; }
		evtName = evtName.toLowerCase();
		if(evtName.substr(0,2)!="on"){ evtName = "on"+evtName; }

		if(!dontFix){
			// build yet another closure around fp in order to inject fixEvent
			// around the resulting event
			var newfp = function(evt){
				if(!evt){ evt = window.event; }
				var ret = fp(dojo.event.browser.fixEvent(evt, this));
				if(capture){
					dojo.event.browser.stopEvent(evt);
				}
				return ret;
			}
		}else{
			newfp = fp;
		}

		if(node.addEventListener){ 
			node.addEventListener(evtName.substr(2), newfp, capture);
			return newfp;
		}else{
			if(typeof node[evtName] == "function" ){
				var oldEvt = node[evtName];
				node[evtName] = function(e){
					oldEvt(e);
					return newfp(e);
				}
			}else{
				node[evtName]=newfp;
			}
			if(dojo.render.html.ie){
				this.addClobberNodeAttrs(node, [evtName]);
			}
			return newfp;
		}
	}

	this.isEvent = function(obj){
		// FIXME: event detection hack ... could test for additional attributes
		// if necessary
		return (typeof obj != "undefined")&&(typeof Event != "undefined")&&(obj.eventPhase);
		// Event does not support instanceof in Opera, otherwise:
		//return (typeof Event != "undefined")&&(obj instanceof Event);
	}

	this.currentEvent = null;
	
	this.callListener = function(listener, curTarget){
		if(typeof listener != 'function'){
			dojo.raise("listener not a function: " + listener);
		}
		dojo.event.browser.currentEvent.currentTarget = curTarget;
		return listener.call(curTarget, dojo.event.browser.currentEvent);
	}

	this.stopPropagation = function(){
		dojo.event.browser.currentEvent.cancelBubble = true;
	}

	this.preventDefault = function(){
	  dojo.event.browser.currentEvent.returnValue = false;
	}

	this.keys = {
		KEY_BACKSPACE: 8,
		KEY_TAB: 9,
		KEY_ENTER: 13,
		KEY_SHIFT: 16,
		KEY_CTRL: 17,
		KEY_ALT: 18,
		KEY_PAUSE: 19,
		KEY_CAPS_LOCK: 20,
		KEY_ESCAPE: 27,
		KEY_SPACE: 32,
		KEY_PAGE_UP: 33,
		KEY_PAGE_DOWN: 34,
		KEY_END: 35,
		KEY_HOME: 36,
		KEY_LEFT_ARROW: 37,
		KEY_UP_ARROW: 38,
		KEY_RIGHT_ARROW: 39,
		KEY_DOWN_ARROW: 40,
		KEY_INSERT: 45,
		KEY_DELETE: 46,
		KEY_LEFT_WINDOW: 91,
		KEY_RIGHT_WINDOW: 92,
		KEY_SELECT: 93,
		KEY_F1: 112,
		KEY_F2: 113,
		KEY_F3: 114,
		KEY_F4: 115,
		KEY_F5: 116,
		KEY_F6: 117,
		KEY_F7: 118,
		KEY_F8: 119,
		KEY_F9: 120,
		KEY_F10: 121,
		KEY_F11: 122,
		KEY_F12: 123,
		KEY_NUM_LOCK: 144,
		KEY_SCROLL_LOCK: 145
	};

	// reverse lookup
	this.revKeys = [];
	for(var key in this.keys){
		this.revKeys[this.keys[key]] = key;
	}

	this.fixEvent = function(evt, sender){
		if((!evt)&&(window["event"])){
			var evt = window.event;
		}
		
		if((evt["type"])&&(evt["type"].indexOf("key") == 0)){ // key events
			evt.keys = this.revKeys;
			// FIXME: how can we eliminate this iteration?
			for(var key in this.keys) {
				evt[key] = this.keys[key];
			}
			if((dojo.render.html.ie)&&(evt["type"] == "keypress")){
				evt.charCode = evt.keyCode;
			}
		}
	
		if(dojo.render.html.ie){
			if(!evt.target){ evt.target = evt.srcElement; }
			if(!evt.currentTarget){ evt.currentTarget = (sender ? sender : evt.srcElement); }
			if(!evt.layerX){ evt.layerX = evt.offsetX; }
			if(!evt.layerY){ evt.layerY = evt.offsetY; }
			// FIXME: scroll position query is duped from dojo.html to avoid dependency on that entire module
			if(!evt.pageX){ evt.pageX = evt.clientX + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0) }
			if(!evt.pageY){ evt.pageY = evt.clientY + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0) }
			// mouseover
			if(evt.type == "mouseover"){ evt.relatedTarget = evt.fromElement; }
			// mouseout
			if(evt.type == "mouseout"){ evt.relatedTarget = evt.toElement; }
			this.currentEvent = evt;
			evt.callListener = this.callListener;
			evt.stopPropagation = this.stopPropagation;
			evt.preventDefault = this.preventDefault;
		}
		return evt;
	}

	this.stopEvent = function(ev) {
		if(window.event){
			ev.returnValue = false;
			ev.cancelBubble = true;
		}else{
			ev.preventDefault();
			ev.stopPropagation();
		}
	}
}

__CPAN_FILE__ src/event/topic.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.event");
dojo.provide("dojo.event.topic");

dojo.event.topic = new function(){
	this.topics = {};

	this.getTopic = function(topicName){
		if(!this.topics[topicName]){
			this.topics[topicName] = new this.TopicImpl(topicName);
		}
		return this.topics[topicName];
	}

	this.registerPublisher = function(topic, obj, funcName){
		var topic = this.getTopic(topic);
		topic.registerPublisher(obj, funcName);
	}

	this.subscribe = function(topic, obj, funcName){
		var topic = this.getTopic(topic);
		topic.subscribe(obj, funcName);
	}

	this.unsubscribe = function(topic, obj, funcName){
		var topic = this.getTopic(topic);
		topic.unsubscribe(obj, funcName);
	}

	this.destroy = function(topic){
		this.getTopic(topic).destroy();
		delete this.topics[topic];
	}

	this.publish = function(topic, message){
		var topic = this.getTopic(topic);
		// if message is an array, we treat it as a set of arguments,
		// otherwise, we just pass on the arguments passed in as-is
		var args = [];
		if(arguments.length == 2 && (dojo.lang.isArray(message) || message.callee)){
			args = message;
		}else{
			var args = [];
			for(var x=1; x<arguments.length; x++){
				args.push(arguments[x]);
			}
		}
		topic.sendMessage.apply(topic, args);
	}
}

dojo.event.topic.TopicImpl = function(topicName){
	this.topicName = topicName;

	this.subscribe = function(listenerObject, listenerMethod){
		var tf = listenerMethod||listenerObject;
		var to = (!listenerMethod) ? dj_global : listenerObject;
		dojo.event.kwConnect({
			srcObj:		this, 
			srcFunc:	"sendMessage", 
			adviceObj:	to,
			adviceFunc: tf
		});
	}

	this.unsubscribe = function(listenerObject, listenerMethod){
		var tf = (!listenerMethod) ? listenerObject : listenerMethod;
		var to = (!listenerMethod) ? null : listenerObject;
		dojo.event.kwDisconnect({
			srcObj:		this, 
			srcFunc:	"sendMessage", 
			adviceObj:	to,
			adviceFunc: tf
		});
	}

	this.destroy = function(){
		dojo.event.MethodJoinPoint.getForMethod(this, "sendMessage").disconnect();
	}

	this.registerPublisher = function(publisherObject, publisherMethod){
		dojo.event.connect(publisherObject, publisherMethod, this, "sendMessage");
	}

	this.sendMessage = function(message){
		// The message has been propagated
	}
}


__CPAN_FILE__ src/event/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.event", "dojo.event.topic"],
	browser: ["dojo.event.browser"],
	dashboard: ["dojo.event.browser"]
});
dojo.provide("dojo.event.*");

__CPAN_DIR__ src/flash
__CPAN_DIR__ src/flash/flash6
__CPAN_FILE__ src/flash/flash6/DojoExternalInterface.as
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/** 
		An implementation of Flash 8's ExternalInterface that works with Flash 6
		and which is source-compatible with Flash 8. 
		
		@author Brad Neuberg, bkn3@columbia.edu 
*/

class DojoExternalInterface{
	public static var available:Boolean;
	public static var _fscommandReady = false;
	public static var _callbacks = new Array();

	public static function initialize(){ 
		//getURL("javascript:dojo.debug('FLASH:DojoExternalInterface initialize')");
		// FIXME: Set available variable by testing for capabilities
		DojoExternalInterface.available = true;
		
		// Sometimes, on IE, the fscommand infrastructure can take a few hundred
		// milliseconds the first time a page loads. Set a timer to keep checking
		// to make sure we can issue fscommands; otherwise, our calls to fscommand
		// for setCallback() and loaded() will just "disappear"
		_root.fscommandReady = false;
		var fsChecker = function(){
			// issue a test fscommand
			fscommand("fscommandReady");
			
			// JavaScript should set _root.fscommandReady if it got the call
			if(_root.fscommandReady == "true"){
				DojoExternalInterface._fscommandReady = true;
				clearInterval(_root.fsTimer);
			}
		};
		_root.fsTimer = setInterval(fsChecker, 100);
	}
	
	public static function addCallback(methodName:String, instance:Object, 
											method:Function) : Boolean{
		// A variable that indicates whether the call below succeeded
		_root._succeeded = null;
		
		// Callbacks are registered with the JavaScript side as follows.
		// On the Flash side, we maintain a lookup table that associates
		// the methodName with the actual instance and method that are
		// associated with this method.
		// Using fscommand, we send over the action "addCallback", with the
		// argument being the methodName to add, such as "foobar".
		// The JavaScript takes these values and registers the existence of
		// this callback point.
		
		// precede the method name with a _ character in case it starts
		// with a number
		_callbacks["_" + methodName] = {_instance: instance, _method: method};
		_callbacks[_callbacks.length] = methodName;
		
		// The API for ExternalInterface says we have to make sure the call
		// succeeded; check to see if there is a value 
		// for _succeeded, which is set by the JavaScript side
		if(_root._succeeded == null){
			return false;
		}else{
			return true;
		}
	}
	
	public static function call(methodName:String, 
								resultsCallback:Function) : Void{
		// FIXME: support full JSON serialization
		
		// First, we pack up all of the arguments to this call and set them
		// as Flash variables, which the JavaScript side will unpack using
		// plugin.GetVariable(). We set the number of arguments as "_numArgs",
		// and add each argument as a variable, such as "_1", "_2", etc., starting
		// from 0.
		// We then execute an fscommand with the action "call" and the
		// argument being the method name. JavaScript takes the method name,
		// retrieves the arguments using GetVariable, executes the method,
		// and then places the return result in a Flash variable
		// named "_returnResult".
		_root._numArgs = arguments.length - 2;
		for(var i = 2; i < arguments.length; i++){
			var argIndex = i - 2;
			_root["_" + argIndex] = arguments[i];
		}
		
		_root._returnResult = undefined;
		fscommand("call", methodName);
		
		// immediately return if the caller is not waiting for return results
		if(resultsCallback == undefined || resultsCallback == null){
			return;
		}
		
		// check at regular intervals for return results	
		var resultsChecker = function(){
			if(_root._returnResult != undefined){
				clearInterval(_root._callbackID);
				resultsCallback.call(null, _root._returnResult);
			}
		};	
		_root._callbackID = setInterval(resultsChecker, 100);
	}
	
	/** 
			Called by Flash to indicate to JavaScript that we are ready to have
			our Flash functions called. Calling loaded()
			will fire the dojo.flash.loaded() event, so that JavaScript can know that
			Flash has finished loading and adding its callbacks, and can begin to
			interact with the Flash file.
	*/
	public static function loaded(){
		//getURL("javascript:dojo.debug('FLASH:loaded')");
		
		// one more step: see if fscommands are ready to be executed; if not,
		// set an interval that will keep running until fscommands are ready;
		// make sure the gateway is loaded as well
		var execLoaded = function(){
			if(DojoExternalInterface._fscommandReady == true){
				clearInterval(_root.loadedInterval);
				
				// initialize the small Flash file that helps gateway JS to Flash
				// calls
				DojoExternalInterface._initializeFlashRunner();
			}	
		};
		
		if(_fscommandReady == true){
			execLoaded();
		}else{
			_root.loadedInterval = setInterval(execLoaded, 50);
		}
	}
	
	/** 
			Handles and executes a JavaScript to Flash method call. Used by
			initializeFlashRunner. 
	*/
	public static function _handleJSCall(){
		// get our parameters
		var numArgs = parseInt(_root._numArgs);
		var jsArgs = new Array();
		for(var i = 0; i < numArgs; i++){
			var currentValue = _root["_" + i];
			jsArgs.push(currentValue);
		}
		
		// get our function name
		var functionName = _root._functionName;
		
		// now get the actual instance and method object to execute on,
		// using our lookup table that was constructed by calls to
		// addCallback on initialization
		var instance = _callbacks["_" + functionName]._instance;
		var method = _callbacks["_" + functionName]._method;
		
		// execute it
		var results = method.apply(instance, jsArgs);
		
		// return the results
		_root._returnResult = results;
	}
	
	/** Called by the flash6_gateway.swf to indicate that it is loaded. */
	public static function _gatewayReady(){
		for(var i = 0; i < _callbacks.length; i++){
			fscommand("addCallback", _callbacks[i]);
		}
		call("dojo.flash.loaded");
	}
	
	/** 
			When JavaScript wants to communicate with Flash it simply sets
			the Flash variable "_execute" to true; this method creates the
			internal Movie Clip, called the Flash Runner, that makes this
			magic happen.
	*/
	public static function _initializeFlashRunner(){
		// figure out where our Flash movie is
		var swfLoc = "../..";
		if(swfLoc.charAt(swfLoc.length - 1) != '/'){
			swfLoc = swfLoc + "/";
		}
		swfLoc = swfLoc + "flash6_gateway.swf";
		
		// load our gateway helper file
		_root.createEmptyMovieClip("_flashRunner", 5000);
		_root._flashRunner._lockroot = true;
		_root._flashRunner.loadMovie(swfLoc);
	}
}

// vim:ts=4:noet:tw=0:

__CPAN_FILE__ src/flash/flash6/flash6_gateway.fla
                >  	                                       R o o t   E n t r y                                                  p|YrRASH              fUajb         C o n t e n t s                                                                                         (   A      P a g e   1                                                                                                                                                                                                                            '   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B   C   D   E   F   G   M   R o o t   E n t r y                                                  p|YrRASH              ppZ	         C o n t e n t s                                                                                            A      P a g e   1                                                                                                                                                                                                                         
                                                                      !   "   #   $   %   &   H   I   J   K   L                           	   
                                         CPicPage  	 CPicLayer  	 CPicFrame                                                          ?s t a r t       2      / * *    
 	 V e r y   s i m p l e   t w o   f r a m e   F l a s h   f i l e ;   f r a m e   1   s a y s   w e   a r e   a l l   l o a d e d ,   w h i l e   f r a m e   2  
 	 s a y s   t o   e x e c u t e   a   J a v a S c r i p t   c a l l .   T h i s   s m a l l   f i l e   i s   n e c e s s a r y   b e c a u s e   A c t i o n S c r i p t  
 	 2 . 0   h a s   n o   w a y   t o   k n o w   w h e n   a   s p e c i f i c   f r a m e   h a s   b e e n   c a l l e d ,   w h i c h   w e   u s e   f o r   a l l  
 	 o f   o u r   c o d e .   H o w e v e r ,   t h e   F l a s h   6   c o m m u n i c a t i o n   w e   u s e   k i c k s   o f f   a   c a l l   b y   j u m p i n g  
 	 t o   a   s p e c i f i c   f r a m e   a n d   t h e n   c a l l i n g   P l a y ( )   o n   t h e   F l a s h   p l a y e r .  
 * /  
  
 D o j o E x t e r n a l I n                         	   
                                       t e r f a c e . _ g a t e w a y R e a d y ( ) ;  
 s t o p ( ) ;  
                                                                                           ?e x e c u t e       }v      /D o j o E x t e r n a l I n t e r f a c e . _ h a n d l e J S C a l l ( ) ;  
 s t o p ( ) ;                                         L a y e r   1   OO                        ( " j a v a s c r i p t : a l e r t ( ' T C a l l L a b e l ' ) " ) ;  
 D o j o E x t e  CPicPage  	 CPicLayer  	 CPicFrame                                                          ?s t a r t       Zz      / * *    
 	 V e r y   s i m p l e   t w o   f r a m e   F l a s h   f i l e ;   f r a m e   1   s a y s   w e   a r e   a l l   l o a d e d ,   w h i l e   f r a m e   2  
 	 s a y s   t o   e x e c u t e   a   J a v a S c r i p t   c a l l .   T h i s   s m a l l   f i l e   i s   n e c e s s a r y   b e c a u s e   A c t i o n S c r i p t  
 	 2 . 0   h a s   n o   w a y   t o   k n o w   w h e n   a   s p e c i f i c   f r a m e   h a s   b e e n   c a l l e d ,   w h i c h   w e   u s e   f o r   a l l  
 	 o f   o u r   c o d e .   H o w e v e r ,   t h e   F l a s h   6   c o m m u n i c a t i o n   w e   u s e   k i c k s   o f f   a   c a l l   b y   j u m p i n g  
 	 t o   a   s p e c i f i c   f r a m e   a n d   t h e n   c a l l i n g   P l a y ( )   o n   t h e   F l a s h   p l a y e r .  
 * /  
  
 D o j o E x t e r n a l I n 8                   CDocumentPageP a g e   1 S c e n e   1                           sC                                    6D                                                                                                                             *      @    h   h  h  h  h                    P r o p S h e e t : : A c t i v e T a b 7 6 2 8     %P u b l i s h F o r m a t P r o p e r t i e s : : h t m l F i l e N a m e f l a s h 6 _ g a t e w a y . h t m l "P u b l i s h H t m l P r o p e r t i e s : : S t a r t P a u s e d 0  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 5 6 K 0 !P u b l i s h G i f P r o p e r t i e s : : P a l e t t e N a m e  P u b l i s h F o r m a t P r o p e r t i e s : : j p e g 0 P u b l i s h H t m l P r o p e r t i e s : : L o o p 1 P u b l i s h P r o f i l e P r o p e r t i e s : : n a m e D e f a u l t V e c t o r : : D e b u g g i n g   P e r m i t t e d 0 "P u b l i s h Q T P r o p e r t i e s : : M a t c h M o v i e D i m 1  P u b l i s h Q T P r o p e r t i e s : : A l p h a O p t i o n   P u b l i s h Q T P r o p e r t i e s : : L a y e r O p t i o n  4P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t A l t e r n a t e F i l e n a m e 1 P u b l i s h H t m l P r o p e r t i e s : : U n i t s 0 %P u b l i s h H t m l P r o p e r t i e s : : s h o w T a g W a r n M s g 1 V e c t o r : : E x t e r n a l   P l a y e r  &P u b l i s h R N W K P r o p e r t i e s : : s i n g l e R a t e A u d i o 0 &P u b l i s h R N W K P r o p e r t i e s : : s p e e d S i n g l e I S D N 0 $P u b l i s h P N G P r o p e r t i e s : : O p t i m i z e C o l o r s 1 P u b l i s h Q T P r o p e r t i e s : : W i d t h 5 5 0 %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c 0 'P u b l i s h F o r m a t P r o p e r t i e s : : g i f D e f a u l t N a m e 1 &P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h F i l e N a m e . . \ . . \ . . \ f l a s h 6 _ g a t e w a y . s w f V e c t o r : : P a c k a g e   P a t h s  V e c t o r : : C o m p r e s s   M o v i e 1 #P u b l i s h R N W K P r o p e r t i e s : : f l a s h B i t R a t e 1 2 0 0 %P u b l i s h R N W K P r o p e r t i e s : : m e d i a C o p y r i g h t ( c )   2 0 0 0 P u b l i s h G i f P r o p e r t i e s : : S m o o t h 1 P u b l i s h F o r m a t P r o p e r t i e s : : h t m l 0 $P u b l i s h F o r m a t P r o p e r t i e s : : p n g F i l e N a m e f l a s h 6 _ g a t e w a y . p n g (P u b l i s h H t m l P r o p e r t i e s : : V e r t i c a l A l i g n m e n t 1 P u b l i s h H t m l P r o p e r t i e s : : Q u a l i t y 4 V e c t o r : : F i r e F o x 0 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t A u d i o 1  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 3 8 4 K 0 !P u b l i s h R N W K P r o p e r t i e s : : e x p o r t S M I L 1 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r O p t i o n  -P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r D e f a u l t N a m e 1 !P u b l i s h H t m l P r o p e r t i e s : : D e v i c e F o n t 0 V e c t o r : : O v e r r i d e   S o u n d s 0 'P u b l i s h R N W K P r o p e r t i e s : : m e d i a D e s c r i p t i o n  "P u b l i s h P N G P r o p e r t i e s : : F i l t e r O p t i o n  P u b l i s h F o r m a t P r o p e r t i e s : : g i f 0 (P u b l i s h F o r m a t P r o p e r t i e s : : j p e g D e f a u l t N a m e 1 (P u b l i s h F o r m a t P r o p e r t i e s : : r n w k D e f a u l t N a m e 1 *P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r F i l e N a m e f l a s h 6 _ g a t e w a y . s w t V e c t o r : : T e m p l a t e 0 2P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n D e t e c t i o n I f A v a i l a b l e 0 *P u b l i s h H t m l P r o p e r t i e s : : H o r i z o n t a l A l i g n m e n t 1 "P u b l i s h H t m l P r o p e r t i e s : : D i s p l a y M e n u 1 V e c t o r : : P r o t e c t 0 V e c t o r : : Q u a l i t y 8 0 P u b l i s h J p e g P r o p e r t i e s : : D P I 4 7 1 8 5 9 2 P u b l i s h G i f P r o p e r t i e s : : I n t e r l a c e 0 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r S o l i d s 0 P u b l i s h P N G P r o p e r t i e s : : S m o o t h 1 P u b l i s h P N G P r o p e r t i e s : : B i t D e p t h 2 4 - b i t   w i t h   A l p h a P u b l i s h Q T P r o p e r t i e s : : F l a t t e n 1 #P u b l i s h F o r m a t P r o p e r t i e s : : q t F i l e N a m e f l a s h 6 _ g a t e w a y . m o v P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 8 K 1 !P u b l i s h R N W K P r o p e r t i e s : : m e d i a T i t l e  $P u b l i s h R N W K P r o p e r t i e s : : m e d i a K e y w o r d s  P u b l i s h G i f P r o p e r t i e s : : W i d t h 5 5 0 P u b l i s h G i f P r o p e r t i e s : : L o o p 1 P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h 1 P u b l i s h J p e g P r o p e r t i e s : : Q u a l i t y 8 0 $P u b l i s h R N W K P r o p e r t i e s : : r e a l V i d e o R a t e 1 0 0 0 0 0 $P u b l i s h R N W K P r o p e r t i e s : : s p e e d D u a l I S D N 0 #P u b l i s h G i f P r o p e r t i e s : : M a t c h M o v i e D i m 1 #P u b l i s h G i f P r o p e r t i e s : : P a l e t t e O p t i o n  "P u b l i s h P N G P r o p e r t i e s : : D i t h e r O p t i o n  0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c D e f a u l t N a m e 1 'P u b l i s h F o r m a t P r o p e r t i e s : : p n g D e f a u l t N a m e 1 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n F i l e N a m e f l a s h 6 _ g a t e w a y . e x e P u b l i s h H t m l P r o p e r t i e s : : A l i g n 0 !P u b l i s h P r o f i l e P r o p e r t i e s : : v e r s i o n 1 V e c t o r : : P a c k a g e   E x p o r t   F r a m e 1 $P u b l i s h J p e g P r o p e r t i e s : : M a t c h M o v i e D i m 1 #P u b l i s h P N G P r o p e r t i e s : : M a t c h M o v i e D i m 1 #P u b l i s h P N G P r o p e r t i e s : : P a l e t t e O p t i o n  )P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h D e f a u l t N a m e 0 %P u b l i s h F o r m a t P r o p e r t i e s : : j p e g F i l e N a m e f l a s h 6 _ g a t e w a y . j p g P u b l i s h H t m l P r o p e r t i e s : : W i d t h 5 5 0 P u b l i s h H t m l P r o p e r t i e s : : H e i g h t 4 0 0 V e c t o r : : O m i t   T r a c e   A c t i o n s 0 V e c t o r : : D e b u g g i n g   P a s s w o r d  "P u b l i s h J p e g P r o p e r t i e s : : P r o g r e s s i v e 0 "P u b l i s h P N G P r o p e r t i e s : : D i t h e r S o l i d s 0 #P u b l i s h Q T P r o p e r t i e s : : P l a y E v e r y F r a m e 0 P u b l i s h F o r m a t P r o p e r t i e s : : p n g 0 P u b l i s h F o r m a t P r o p e r t i e s : : r n w k 0 (P u b l i s h F o r m a t P r o p e r t i e s : : h t m l D e f a u l t N a m e 1 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c F i l e N a m e f l a s h 6 _ g a t e w a y . h q x 2P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t C o n t e n t F i l e n a m e 1 !P u b l i s h H t m l P r o p e r t i e s : : W i n d o w M o d e 0 'P u b l i s h H t m l P r o p e r t i e s : : T e m p l a t e F i l e N a m e C : \ D o c u m e n t s   a n d   S e t t i n g s \ b r a d n e u b e r g \ L o c a l   S e t t i n g s \ A p p l i c a t i o n   D a t a \ M a c r o m e d i a \ F l a s h   M X   2 0 0 4 \ e n \ C o n f i g u r a t i o n \ H t m l \ D e f a u l t . h t m l V e c t o r : : T o p D o w n 0 V e c t o r : : D e v i c e S o u n d 0 P u b l i s h J p e g P r o p e r t i e s : : S i z e 0 P u b l i s h G i f P r o p e r t i e s : : H e i g h t 4 0 0 P u b l i s h P N G P r o p e r t i e s : : I n t e r l a c e 0 "P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r 0 &P u b l i s h H t m l P r o p e r t i e s : : C o n t e n t F i l e n a m e  (P u b l i s h H t m l P r o p e r t i e s : : A l t e r n a t e F i l e n a m e  +P u b l i s h H t m l P r o p e r t i e s : : O w n A l t e r n a t e F i l e n a m e  V e c t o r : : R e p o r t 0 P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 6 K 1 P u b l i s h G i f P r o p e r t i e s : : L o o p C o u n t  'P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t O p t i o n  P u b l i s h G i f P r o p e r t i e s : : M a x C o l o r s 2 5 5 %P u b l i s h P N G P r o p e r t i e s : : R e m o v e G r a d i e n t s 0 P u b l i s h Q T P r o p e r t i e s : : H e i g h t 4 0 0 P u b l i s h F o r m a t P r o p e r t i e s : : q t 0 V e c t o r : : S t r e a m   C o m p r e s s 7 V e c t o r : : E v e n t   F o r m a t 0 V e c t o r : : V e r s i o n 6 "P u b l i s h R N W K P r o p e r t i e s : : a u d i o F o r m a t 0 $P u b l i s h G i f P r o p e r t i e s : : O p t i m i z e C o l o r s 1 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n D e f a u l t N a m e 1 P u b l i s h H t m l P r o p e r t i e s : : S c a l e 0 V e c t o r : : E v e n t   C o m p r e s s 7 V e c t o r : : A c t i o n S c r i p t V e r s i o n 2 P u b l i s h J p e g P r o p e r t i e s : : H e i g h t 4 0 0  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 1 2 K 0 %P u b l i s h G i f P r o p e r t i e s : : R e m o v e G r a d i e n t s 0 P u b l i s h P N G P r o p e r t i e s : : W i d t h 5 5 0 P u b l i s h P N G P r o p e r t i e s : : H e i g h t 4 0 0 &P u b l i s h F o r m a t P r o p e r t i e s : : q t D e f a u l t N a m e 1 $P u b l i s h F o r m a t P r o p e r t i e s : : g i f F i l e N a m e f l a s h 6 _ g a t e w a y . g i f "P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n I n f o  V e c t o r : : S t r e a m   F o r m a t 0 P u b l i s h J p e g P r o p e r t i e s : : W i d t h 5 5 0 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t F l a s h 1 &P u b l i s h R N W K P r o p e r t i e s : : s h o w B i t r a t e D l o g 1 (P u b l i s h R N W K P r o p e r t i e s : : s p e e d C o r p o r a t e L A N 0 "P u b l i s h R N W K P r o p e r t i e s : : m e d i a A u t h o r  P u b l i s h G i f P r o p e r t i e s : : A n i m a t e d 0 &P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t A l p h a 1 2 8 !P u b l i s h P N G P r o p e r t i e s : : T r a n s p a r e n t 0 !P u b l i s h P N G P r o p e r t i e s : : P a l e t t e N a m e  *P u b l i s h Q T P r o p e r t i e s : : U s e Q T S o u n d C o m p r e s s i o n 0 P u b l i s h Q T P r o p e r t i e s : : L o o p i n g 0 %P u b l i s h F o r m a t P r o p e r t i e s : : d e f a u l t N a m e s 0 %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n 0 %P u b l i s h F o r m a t P r o p e r t i e s : : r n w k F i l e N a m e f l a s h 6 _ g a t e w a y . s m i l ,P u b l i s h H t m l P r o p e r t i e s : : U s i n g O w n A l t e r n a t e F i l e 0 P u b l i s h P N G P r o p e r t i e s : : M a x C o l o r s 2 5 5 %P u b l i s h Q T P r o p e r t i e s : : C o n t r o l l e r O p t i o n 0 "P u b l i s h Q T P r o p e r t i e s : : P a u s e d A t S t a r t 0           	 CColorDef                                  3   P    f   P  0     P  H     P  `     P  x 3        33   (   3f   <  0 3   C  H 3   F  ` 3   H  x f       0 f3     0 ff   (  0 f   5  H f   <  ` f   @  x            333      0              3      33  x    f3  d  0  3  ]  H  3  Z  `  3  X  x 3 3     333      0 3f3  P P H 33  P x ` 33  P  x 33  P   f 3    0 f33    P H ff3  ( P H f3  < x ` f3  C  x f3  F              fff      `              f    0  3f    0  ff  x  0  f  k  H  f  d  `  f  `  x 3 f    0 33f   P H 3ff  x P H 3f  d x ` 3f  ]  x 3f  Z   f f    0 f3f   P H fff      ` ff  P 0 x ff  P x  ff  P                                      H  3    H  f    H    x  H    n  `    h  x 3     H 33   x ` 3f   x ` 3  x x ` 3  k  x 3  d   f     H f3   x ` ff   0 x f  x 0 x f  d x  f  ]                                      `  3    `  f    `      `    x  `    p  x 3     ` 33    x 3f    x 3    x 3  x  x 3  n   f     ` f3    x ff   x  f   x  f  x x  f  k                                      x  3    x  f    x      x      x    x  x 3     x 33     3f     3     3     3  x   f     x f3     ff     f     f     f  x                     x                   H 3     H f t e r f a c e . _ g a t e w a y R e a d y ( ) ;  
 s t o p ( ) ;  
                                                                                           ?e x e c u t e              /D o j o E x t e r n a l I n t e r f a c e . _ h a n d l e J S C a l l ( ) ;  
 s t o p ( ) ;                                         L a y e r   1   OO                        ( " j a v a s c r i p t : a l e r t ( ' T C a l l L a b e l ' ) " ) ;  
 D o j o E x t e8                   CDocumentPageP a g e   1 S c e n e   1                           sC                                    DD                                                                                                                                   
    h   h  h  h  h                    P r o p S h e e t : : A c t i v e T a b 7 6 2 8     !P u b l i s h G i f P r o p e r t i e s : : P a l e t t e N a m e   P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 5 6 K 0 "P u b l i s h H t m l P r o p e r t i e s : : S t a r t P a u s e d 0 %P u b l i s h F o r m a t P r o p e r t i e s : : h t m l F i l e N a m e f l a s h 6 _ g a t e w a y . h t m l  P u b l i s h Q T P r o p e r t i e s : : L a y e r O p t i o n   P u b l i s h Q T P r o p e r t i e s : : A l p h a O p t i o n  "P u b l i s h Q T P r o p e r t i e s : : M a t c h M o v i e D i m 1 V e c t o r : : D e b u g g i n g   P e r m i t t e d 0 P u b l i s h P r o f i l e P r o p e r t i e s : : n a m e D e f a u l t P u b l i s h H t m l P r o p e r t i e s : : L o o p 1 P u b l i s h F o r m a t P r o p e r t i e s : : j p e g 0 P u b l i s h Q T P r o p e r t i e s : : W i d t h 5 5 0 $P u b l i s h P N G P r o p e r t i e s : : O p t i m i z e C o l o r s 1 &P u b l i s h R N W K P r o p e r t i e s : : s p e e d S i n g l e I S D N 0 &P u b l i s h R N W K P r o p e r t i e s : : s i n g l e R a t e A u d i o 0 V e c t o r : : E x t e r n a l   P l a y e r  %P u b l i s h H t m l P r o p e r t i e s : : s h o w T a g W a r n M s g 1 P u b l i s h H t m l P r o p e r t i e s : : U n i t s 0 4P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t A l t e r n a t e F i l e n a m e 1 P u b l i s h G i f P r o p e r t i e s : : S m o o t h 1 %P u b l i s h R N W K P r o p e r t i e s : : m e d i a C o p y r i g h t ( c )   2 0 0 0 #P u b l i s h R N W K P r o p e r t i e s : : f l a s h B i t R a t e 1 2 0 0 V e c t o r : : C o m p r e s s   M o v i e 1 V e c t o r : : P a c k a g e   P a t h s  &P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h F i l e N a m e . . \ . . \ . . \ f l a s h 6 _ g a t e w a y . s w f 'P u b l i s h F o r m a t P r o p e r t i e s : : g i f D e f a u l t N a m e 1 %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c 0 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r O p t i o n  !P u b l i s h R N W K P r o p e r t i e s : : e x p o r t S M I L 1  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 3 8 4 K 0 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t A u d i o 1 V e c t o r : : F i r e F o x 0 P u b l i s h H t m l P r o p e r t i e s : : Q u a l i t y 4 (P u b l i s h H t m l P r o p e r t i e s : : V e r t i c a l A l i g n m e n t 1 $P u b l i s h F o r m a t P r o p e r t i e s : : p n g F i l e N a m e f l a s h 6 _ g a t e w a y . p n g P u b l i s h F o r m a t P r o p e r t i e s : : h t m l 0 "P u b l i s h P N G P r o p e r t i e s : : F i l t e r O p t i o n  'P u b l i s h R N W K P r o p e r t i e s : : m e d i a D e s c r i p t i o n  V e c t o r : : O v e r r i d e   S o u n d s 0 !P u b l i s h H t m l P r o p e r t i e s : : D e v i c e F o n t 0 -P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r D e f a u l t N a m e 1 P u b l i s h Q T P r o p e r t i e s : : F l a t t e n 1 P u b l i s h P N G P r o p e r t i e s : : B i t D e p t h 2 4 - b i t   w i t h   A l p h a P u b l i s h P N G P r o p e r t i e s : : S m o o t h 1 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r S o l i d s 0 P u b l i s h G i f P r o p e r t i e s : : I n t e r l a c e 0 P u b l i s h J p e g P r o p e r t i e s : : D P I 4 7 1 8 5 9 2 V e c t o r : : Q u a l i t y 8 0 V e c t o r : : P r o t e c t 0 "P u b l i s h H t m l P r o p e r t i e s : : D i s p l a y M e n u 1 *P u b l i s h H t m l P r o p e r t i e s : : H o r i z o n t a l A l i g n m e n t 1 2P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n D e t e c t i o n I f A v a i l a b l e 0 V e c t o r : : T e m p l a t e 0 *P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r F i l e N a m e f l a s h 6 _ g a t e w a y . s w t (P u b l i s h F o r m a t P r o p e r t i e s : : r n w k D e f a u l t N a m e 1 (P u b l i s h F o r m a t P r o p e r t i e s : : j p e g D e f a u l t N a m e 1 P u b l i s h F o r m a t P r o p e r t i e s : : g i f 0 P u b l i s h G i f P r o p e r t i e s : : L o o p 1 P u b l i s h G i f P r o p e r t i e s : : W i d t h 5 5 0 $P u b l i s h R N W K P r o p e r t i e s : : m e d i a K e y w o r d s  !P u b l i s h R N W K P r o p e r t i e s : : m e d i a T i t l e  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 8 K 1 #P u b l i s h F o r m a t P r o p e r t i e s : : q t F i l e N a m e f l a s h 6 _ g a t e w a y . m o v "P u b l i s h P N G P r o p e r t i e s : : D i t h e r O p t i o n  #P u b l i s h G i f P r o p e r t i e s : : P a l e t t e O p t i o n  #P u b l i s h G i f P r o p e r t i e s : : M a t c h M o v i e D i m 1 $P u b l i s h R N W K P r o p e r t i e s : : s p e e d D u a l I S D N 0 $P u b l i s h R N W K P r o p e r t i e s : : r e a l V i d e o R a t e 1 0 0 0 0 0 P u b l i s h J p e g P r o p e r t i e s : : Q u a l i t y 8 0 P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h 1 #P u b l i s h P N G P r o p e r t i e s : : P a l e t t e O p t i o n  #P u b l i s h P N G P r o p e r t i e s : : M a t c h M o v i e D i m 1 $P u b l i s h J p e g P r o p e r t i e s : : M a t c h M o v i e D i m 1 V e c t o r : : P a c k a g e   E x p o r t   F r a m e 1 !P u b l i s h P r o f i l e P r o p e r t i e s : : v e r s i o n 1 P u b l i s h H t m l P r o p e r t i e s : : A l i g n 0 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n F i l e N a m e f l a s h 6 _ g a t e w a y . e x e 'P u b l i s h F o r m a t P r o p e r t i e s : : p n g D e f a u l t N a m e 1 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c D e f a u l t N a m e 1 #P u b l i s h Q T P r o p e r t i e s : : P l a y E v e r y F r a m e 0 "P u b l i s h P N G P r o p e r t i e s : : D i t h e r S o l i d s 0 "P u b l i s h J p e g P r o p e r t i e s : : P r o g r e s s i v e 0 V e c t o r : : D e b u g g i n g   P a s s w o r d  V e c t o r : : O m i t   T r a c e   A c t i o n s 0 P u b l i s h H t m l P r o p e r t i e s : : H e i g h t 4 0 0 P u b l i s h H t m l P r o p e r t i e s : : W i d t h 5 5 0 %P u b l i s h F o r m a t P r o p e r t i e s : : j p e g F i l e N a m e f l a s h 6 _ g a t e w a y . j p g )P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h D e f a u l t N a m e 0 P u b l i s h P N G P r o p e r t i e s : : I n t e r l a c e 0 P u b l i s h G i f P r o p e r t i e s : : H e i g h t 4 0 0 P u b l i s h J p e g P r o p e r t i e s : : S i z e 0 V e c t o r : : D e v i c e S o u n d 0 V e c t o r : : T o p D o w n 0 'P u b l i s h H t m l P r o p e r t i e s : : T e m p l a t e F i l e N a m e C : \ D o c u m e n t s   a n d   S e t t i n g s \ b r a d n e u b e r g \ L o c a l   S e t t i n g s \ A p p l i c a t i o n   D a t a \ M a c r o m e d i a \ F l a s h   M X   2 0 0 4 \ e n \ C o n f i g u r a t i o n \ H t m l \ D e f a u l t . h t m l !P u b l i s h H t m l P r o p e r t i e s : : W i n d o w M o d e 0 2P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t C o n t e n t F i l e n a m e 1 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c F i l e N a m e f l a s h 6 _ g a t e w a y . h q x (P u b l i s h F o r m a t P r o p e r t i e s : : h t m l D e f a u l t N a m e 1 P u b l i s h F o r m a t P r o p e r t i e s : : r n w k 0 P u b l i s h F o r m a t P r o p e r t i e s : : p n g 0 P u b l i s h Q T P r o p e r t i e s : : H e i g h t 4 0 0 %P u b l i s h P N G P r o p e r t i e s : : R e m o v e G r a d i e n t s 0 P u b l i s h G i f P r o p e r t i e s : : M a x C o l o r s 2 5 5 'P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t O p t i o n  P u b l i s h G i f P r o p e r t i e s : : L o o p C o u n t  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 6 K 1 V e c t o r : : R e p o r t 0 +P u b l i s h H t m l P r o p e r t i e s : : O w n A l t e r n a t e F i l e n a m e  (P u b l i s h H t m l P r o p e r t i e s : : A l t e r n a t e F i l e n a m e  &P u b l i s h H t m l P r o p e r t i e s : : C o n t e n t F i l e n a m e  "P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r 0 $P u b l i s h G i f P r o p e r t i e s : : O p t i m i z e C o l o r s 1 "P u b l i s h R N W K P r o p e r t i e s : : a u d i o F o r m a t 0 V e c t o r : : V e r s i o n 6 V e c t o r : : E v e n t   F o r m a t 0 V e c t o r : : S t r e a m   C o m p r e s s 7 P u b l i s h F o r m a t P r o p e r t i e s : : q t 0 P u b l i s h P N G P r o p e r t i e s : : H e i g h t 4 0 0 P u b l i s h P N G P r o p e r t i e s : : W i d t h 5 5 0 %P u b l i s h G i f P r o p e r t i e s : : R e m o v e G r a d i e n t s 0  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 1 2 K 0 P u b l i s h J p e g P r o p e r t i e s : : H e i g h t 4 0 0 V e c t o r : : A c t i o n S c r i p t V e r s i o n 2 V e c t o r : : E v e n t   C o m p r e s s 7 P u b l i s h H t m l P r o p e r t i e s : : S c a l e 0 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n D e f a u l t N a m e 1 P u b l i s h Q T P r o p e r t i e s : : L o o p i n g 0 *P u b l i s h Q T P r o p e r t i e s : : U s e Q T S o u n d C o m p r e s s i o n 0 !P u b l i s h P N G P r o p e r t i e s : : P a l e t t e N a m e  !P u b l i s h P N G P r o p e r t i e s : : T r a n s p a r e n t 0 &P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t A l p h a 1 2 8 P u b l i s h G i f P r o p e r t i e s : : A n i m a t e d 0 "P u b l i s h R N W K P r o p e r t i e s : : m e d i a A u t h o r  (P u b l i s h R N W K P r o p e r t i e s : : s p e e d C o r p o r a t e L A N 0 &P u b l i s h R N W K P r o p e r t i e s : : s h o w B i t r a t e D l o g 1 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t F l a s h 1 P u b l i s h J p e g P r o p e r t i e s : : W i d t h 5 5 0 V e c t o r : : S t r e a m   F o r m a t 0 "P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n I n f o  $P u b l i s h F o r m a t P r o p e r t i e s : : g i f F i l e N a m e f l a s h 6 _ g a t e w a y . g i f &P u b l i s h F o r m a t P r o p e r t i e s : : q t D e f a u l t N a m e 1 "P u b l i s h Q T P r o p e r t i e s : : P a u s e d A t S t a r t 0 %P u b l i s h Q T P r o p e r t i e s : : C o n t r o l l e r O p t i o n 0 P u b l i s h P N G P r o p e r t i e s : : M a x C o l o r s 2 5 5 ,P u b l i s h H t m l P r o p e r t i e s : : U s i n g O w n A l t e r n a t e F i l e 0 %P u b l i s h F o r m a t P r o p e r t i e s : : r n w k F i l e N a m e f l a s h 6 _ g a t e w a y . s m i l %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n 0 %P u b l i s h F o r m a t P r o p e r t i e s : : d e f a u l t N a m e s 0           	 CColorDef                                  3   P    f   P  0     P  H     P  `     P  x 3        33   (   3f   <  0 3   C  H 3   F  ` 3   H  x f       0 f3     0 ff   (  0 f   5  H f   <  ` f   @  x            333      0              3      33  x    f3  d  0  3  ]  H  3  Z  `  3  X  x 3 3     333      0 3f3  P P H 33  P x ` 33  P  x 33  P   f 3    0 f33    P H ff3  ( P H f3  < x ` f3  C  x f3  F              fff      `              f    0  3f    0  ff  x  0  f  k  H  f  d  `  f  `  x 3 f    0 33f   P H 3ff  x P H 3f  d x ` 3f  ]  x 3f  Z   f f    0 f3f   P H fff      ` ff  P 0 x ff  P x  ff  P                                      H  3    H  f    H    x  H    n  `    h  x 3     H 33   x ` 3f   x ` 3  x x ` 3  k  x 3  d   f     H f3   x ` ff   0 x f  x 0 x f  d x  f  ]                                      `  3    `  f    `      `    x  `    p  x 3     ` 33    x 3f    x 3    x 3  x  x 3  n   f     ` f3    x ff   x  f   x  f  x x  f  k                                      x  3    x  f    x      x      x    x  x 3     x 33     3f     3     3     3  x   f     x f3     ff     f     f     f  x                     x                   H 3     H f     H    (  H    2  `    8  x        ` 3   
  ` f     `      `    (  `    0  x        x 3     x f     x      x       x    (  x                P  x             3    H 33    x ` f3   x ` 3  ( x ` 3  5  x 3  <    3    ` 33     x f3    x 3    x 3  (  x 3  2    3    x 33      f3  
   3     3     3  (                    x             f    H 3f   x ` ff    0 x f  ( 0 x f  < x  f  C    f    ` 3f    x ff    x  f   x  f  ( x  f  5    f    x 3f     ff      f     f     f  (                 (  x                 H 3   x ` f   0 x          P P    P        ` 3    x f   x      P    ( P    <        x 3     f                  (                 x  x                 ` 3    x f   x     P    x P    d        ` 3    x f   x     P           P        x 3     f                  (                   x                 x 3     f                 x        x 3     f                 x        x 3     f                                                                                                                                                                                                          H    (  H    2  `    8  x        ` 3   
  ` f     `      `    (  `    0  x        x 3     x f     x      x       x    (  x                P  x             3    H 33    x ` f3   x ` 3  ( x ` 3  5  x 3  <    3    ` 33     x f3    x 3    x 3  (  x 3  2    3    x 33      f3  
   3     3     3  (                    x             f    H 3f   x ` ff    0 x f  ( 0 x f  < x  f  C    f    ` 3f    x ff    x  f   x  f  ( x  f  5    f    x 3f     ff      f     f     f  (                 (  x                 H 3   x ` f   0 x          P P    P        ` 3    x f   x      P    ( P    <        x 3     f                  (                 x  x                 ` 3    x f   x     P    x P    d        ` 3    x f   x     P           P        x 3     f                  (                   x                 x 3     f                 x        x 3     f                 x        x 3     f                                                                                                                                                                                                                                                         f`zf                                     * ]                                                                 "P u b l i s h Q T P r o p e r t i e s : : Q T S n d S e t t i n g s   CQTAudioSettings                           h                         
   
                                                                                                                                                   f`zf                                     * ]                                                                 "P u b l i s h Q T P r o p e r t i e s : : Q T S n d S e t t i n g s   CQTAudioSettings                           h                         
   
                                                                                                
__CPAN_DIR__ src/flash/flash8
__CPAN_FILE__ src/flash/flash8/DojoExternalInterface.as
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/**
	A wrapper around Flash 8's ExternalInterface; DojoExternalInterface is needed so that we
	can do a Flash 6 implementation of ExternalInterface, and be able
	to support having a single codebase that uses DojoExternalInterface
	across Flash versions rather than having two seperate source bases,
	where one uses ExternalInterface and the other uses DojoExternalInterface.
	
	DojoExternalInterface class does a variety of optimizations to bypass ExternalInterface's
	unbelievably bad performance so that we can have good performance
	on Safari; see the blog post
	http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html
	for details.
	
	@author Brad Neuberg, bkn3@columbia.edu
*/
import flash.external.ExternalInterface;

class DojoExternalInterface{
	public static var available:Boolean;
	
	private static var flashMethods:Array = new Array();
	private static var numArgs:Number;
	private static var argData:Array;
	private static var resultData = null;
	
	public static function initialize(){
		// see if we need to do an express install
		var install:ExpressInstall = new ExpressInstall();
		if(install.needsUpdate){
			install.init();
		}
		
		// register our callback functions
		ExternalInterface.addCallback("startExec", DojoExternalInterface, startExec);
		ExternalInterface.addCallback("setNumberArguments", DojoExternalInterface,
																	setNumberArguments);
		ExternalInterface.addCallback("chunkArgumentData", DojoExternalInterface,
																	chunkArgumentData);
		ExternalInterface.addCallback("exec", DojoExternalInterface, exec);
		ExternalInterface.addCallback("getReturnLength", DojoExternalInterface,
																	getReturnLength);
		ExternalInterface.addCallback("chunkReturnData", DojoExternalInterface,
																	chunkReturnData);
		ExternalInterface.addCallback("endExec", DojoExternalInterface, endExec);
		
		// set whether communication is available
		DojoExternalInterface.available = ExternalInterface.available;
		DojoExternalInterface.call("loaded");
	}
	
	public static function addCallback(methodName:String, instance:Object, 
										 								 method:Function) : Boolean{
		// register DojoExternalInterface methodName with it's instance
		DojoExternalInterface.flashMethods[methodName] = instance;
		
		// tell JavaScript about DojoExternalInterface new method so we can create a proxy
		ExternalInterface.call("dojo.flash.comm._addExternalInterfaceCallback", 
													 methodName);
													 
		return true;
	}
	
	public static function call(methodName:String,
								resultsCallback:Function) : Void{
		// we might have any number of optional arguments, so we have to 
		// pass them in dynamically; strip out the results callback
		var parameters = new Array();
		for(var i = 0; i < arguments.length; i++){
			if(i != 1){ // skip the callback
				parameters.push(arguments[i]);
			}
		}
		
		var results = ExternalInterface.call.apply(ExternalInterface, parameters);
		
		// immediately give the results back, since ExternalInterface is
		// synchronous
		if(resultsCallback != null && typeof resultsCallback != "undefined"){
			resultsCallback.call(null, results);
		}
	}
	
	/** 
			Called by Flash to indicate to JavaScript that we are ready to have
			our Flash functions called. Calling loaded()
			will fire the dojo.flash.loaded() event, so that JavaScript can know that
			Flash has finished loading and adding its callbacks, and can begin to
			interact with the Flash file.
	*/
	public static function loaded(){
		DojoExternalInterface.call("dojo.flash.loaded");
	}
	
	public static function startExec():Void{
		DojoExternalInterface.numArgs = null;
		DojoExternalInterface.argData = null;
		DojoExternalInterface.resultData = null;
	}
	
	public static function setNumberArguments(numArgs):Void{
		DojoExternalInterface.numArgs = numArgs;
		DojoExternalInterface.argData = new Array(DojoExternalInterface.numArgs);
	}
	
	public static function chunkArgumentData(value, argIndex:Number):Void{
		//getURL("javascript:dojo.debug('FLASH: chunkArgumentData, value="+value+", argIndex="+argIndex+"')");
		var currentValue = DojoExternalInterface.argData[argIndex];
		if(currentValue == null || typeof currentValue == "undefined"){
			DojoExternalInterface.argData[argIndex] = value;
		}else{
			DojoExternalInterface.argData[argIndex] += value;
		}
	}
	
	public static function exec(methodName):Void{
		// decode all of the arguments that were passed in
		for(var i = 0; i < DojoExternalInterface.argData.length; i++){
			DojoExternalInterface.argData[i] = 
				DojoExternalInterface.decodeData(DojoExternalInterface.argData[i]);
		}
		
		var instance = DojoExternalInterface.flashMethods[methodName];
		DojoExternalInterface.resultData = instance[methodName].apply(
																			instance, DojoExternalInterface.argData);
		// encode the result data
		DojoExternalInterface.resultData = 
			DojoExternalInterface.encodeData(DojoExternalInterface.resultData);
			
		//getURL("javascript:dojo.debug('FLASH: encoded result data="+DojoExternalInterface.resultData+"')");
	}
	
	public static function getReturnLength():Number{
	 if(DojoExternalInterface.resultData == null || 
	 					typeof DojoExternalInterface.resultData == "undefined"){
	 	return 0;
	 }
	 var segments = Math.ceil(DojoExternalInterface.resultData.length / 1024);
	 return segments;
	}
	
	public static function chunkReturnData(segment:Number):String{
		var numSegments = DojoExternalInterface.getReturnLength();
		var startCut = segment * 1024;
		var endCut = segment * 1024 + 1024;
		if(segment == (numSegments - 1)){
			endCut = segment * 1024 + DojoExternalInterface.resultData.length;
		}
			
		var piece = DojoExternalInterface.resultData.substring(startCut, endCut);
		
		//getURL("javascript:dojo.debug('FLASH: chunking return piece="+piece+"')");
		
		return piece;
	}
	
	public static function endExec():Void{
	}
	
	private static function decodeData(data):String{
		// we have to use custom encodings for certain characters when passing
		// them over; for example, passing a backslash over as //// from JavaScript
		// to Flash doesn't work
		data = DojoExternalInterface.replaceStr(data, "&custom_backslash;", "\\");
		
		data = DojoExternalInterface.replaceStr(data, "\\\'", "\'");
		data = DojoExternalInterface.replaceStr(data, "\\\"", "\"");
		
		return data;
	}
	
	private static function encodeData(data){
		//getURL("javascript:dojo.debug('inside flash, data before="+data+"')");

		// double encode all entity values, or they will be mis-decoded
		// by Flash when returned
		data = DojoExternalInterface.replaceStr(data, "&", "&amp;");
		
		// certain XMLish characters break Flash's wire serialization for
		// ExternalInterface; encode these into a custom encoding, rather than
		// the standard entity encoding, because otherwise we won't be able to
		// differentiate between our own encoding and any entity characters
		// that are being used in the string itself
		data = DojoExternalInterface.replaceStr(data, '<', '&custom_lt;');
		data = DojoExternalInterface.replaceStr(data, '>', '&custom_gt;');
		
		// encode control characters and JavaScript delimiters
		data = DojoExternalInterface.replaceStr(data, "\n", "\\n");
		data = DojoExternalInterface.replaceStr(data, "\r", "\\r");
		data = DojoExternalInterface.replaceStr(data, "\f", "\\f");
		data = DojoExternalInterface.replaceStr(data, "'", "\\'");
		data = DojoExternalInterface.replaceStr(data, '"', '\"');
		
		//getURL("javascript:dojo.debug('inside flash, data after="+data+"')");
		return data;
	}
	
	/** 
			Flash ActionScript has no String.replace method or support for
			Regular Expressions! We roll our own very simple one.
	*/
	private static function replaceStr(inputStr:String, replaceThis:String, 
																		 withThis:String):String {
		var splitStr = inputStr.split(replaceThis)
		inputStr = splitStr.join(withThis)
		return inputStr;
	}
}

// vim:ts=4:noet:tw=0:

__CPAN_FILE__ src/flash/flash8/ExpressInstall.as
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/**
 * Based on the expressinstall.as class created by Geoff Stearns as part
 * of the FlashObject library.
 *
 * Use this file to invoke the Macromedia Flash Player Express Install functionality
 * This file is intended for use with the FlashObject embed script. You can download FlashObject 
 * and this file at the following URL: http://blog.deconcept.com/flashobject/
 *
 * Usage: 
 *          var ExpressInstall = new ExpressInstall();
 *          
 *          // test to see if install is needed:
 *          if (ExpressInstall.needsUpdate) { // returns true if update is needed
 *              ExpressInstall.init(); // starts the update
 *          }
 *
 *	NOTE: Your Flash movie must be at least 214px by 137px in order to use ExpressInstall.
 *
 */

class ExpressInstall {
	public var needsUpdate:Boolean;
	private var updater:MovieClip;
	private var hold:MovieClip;
	
	public function ExpressInstall(){
		// does the user need to update?
		this.needsUpdate = (_root.MMplayerType == undefined) ? false : true;	
	}

	public function init():Void{
		this.loadUpdater();
	}

	public function loadUpdater():Void {
		System.security.allowDomain("fpdownload.macromedia.com");

		// hope that nothing is at a depth of 10000000, you can change this depth if needed, but you want
		// it to be on top of your content if you have any stuff on the first frame
		this.updater = _root.createEmptyMovieClip("expressInstallHolder", 10000000);

		// register the callback so we know if they cancel or there is an error
		var _self = this;
		this.updater.installStatus = _self.onInstallStatus;
		this.hold = this.updater.createEmptyMovieClip("hold", 1);

		// can't use movieClipLoader because it has to work in 6.0.65
		this.updater.onEnterFrame = function():Void {
			if(typeof this.hold.startUpdate == 'function'){
				_self.initUpdater();
				this.onEnterFrame = null;
			}
		}

		var cacheBuster:Number = Math.random();

		this.hold.loadMovie("http://fpdownload.macromedia.com/pub/flashplayer/"
												+"update/current/swf/autoUpdater.swf?"+ cacheBuster);
	}

	private function initUpdater():Void{
		this.hold.redirectURL = _root.MMredirectURL;
		this.hold.MMplayerType = _root.MMplayerType;
		this.hold.MMdoctitle = _root.MMdoctitle;
		this.hold.startUpdate();
	}

	public function onInstallStatus(msg):Void{
		getURL("javascript:dojo.flash.install._onInstallStatus('"+msg+"')");
	}
}

__CPAN_DIR__ src/fx
__CPAN_FILE__ src/fx/html.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.fx.html");

dojo.require("dojo.style");
dojo.require("dojo.math.curves");
dojo.require("dojo.lang.func");
dojo.require("dojo.animation");
dojo.require("dojo.event.*");
dojo.require("dojo.graphics.color");

dojo.fx.duration = 300;

dojo.fx.html._makeFadeable = function(node){
	if(dojo.render.html.ie){
		// only set the zoom if the "tickle" value would be the same as the
		// default
		if( (node.style.zoom.length == 0) &&
			(dojo.style.getStyle(node, "zoom") == "normal") ){
			// make sure the node "hasLayout"
			// NOTE: this has been tested with larger and smaller user-set text
			// sizes and works fine
			node.style.zoom = "1";
			// node.style.zoom = "normal";
		}
		// don't set the width to auto if it didn't already cascade that way.
		// We don't want to f anyones designs
		if(	(node.style.width.length == 0) &&
			(dojo.style.getStyle(node, "width") == "auto") ){
			node.style.width = "auto";
		}
	}
}

dojo.fx.html.fadeOut = function(node, duration, callback, dontPlay) {
	return dojo.fx.html.fade(node, duration, dojo.style.getOpacity(node), 0, callback, dontPlay);
};

dojo.fx.html.fadeIn = function(node, duration, callback, dontPlay) {
	return dojo.fx.html.fade(node, duration, dojo.style.getOpacity(node), 1, callback, dontPlay);
};

dojo.fx.html.fadeHide = function(node, duration, callback, dontPlay) {
	node = dojo.byId(node);
	if(!duration) { duration = 150; } // why not have a default?
	return dojo.fx.html.fadeOut(node, duration, function(node) {
		node.style.display = "none";
		if(typeof callback == "function") { callback(node); }
	});
};

dojo.fx.html.fadeShow = function(node, duration, callback, dontPlay) {
	node = dojo.byId(node);
	if(!duration) { duration = 150; } // why not have a default?
	node.style.display = "block";
	return dojo.fx.html.fade(node, duration, 0, 1, callback, dontPlay);
};

dojo.fx.html.fade = function(node, duration, startOpac, endOpac, callback, dontPlay) {
	node = dojo.byId(node);
	dojo.fx.html._makeFadeable(node);
	var anim = new dojo.animation.Animation(
		new dojo.math.curves.Line([startOpac],[endOpac]),
		duration||dojo.fx.duration, 0);
	dojo.event.connect(anim, "onAnimate", function(e) {
		dojo.style.setOpacity(node, e.x);
	});
	if(callback) {
		dojo.event.connect(anim, "onEnd", function(e) {
			callback(node, anim);
		});
	}
	if(!dontPlay) { anim.play(true); }
	return anim;
};

dojo.fx.html.slideTo = function(node, duration, endCoords, callback, dontPlay) {
	if(!dojo.lang.isNumber(duration)) {
		var tmp = duration;
		duration = endCoords;
		endCoords = tmp;
	}
	node = dojo.byId(node);

	var top = node.offsetTop;
	var left = node.offsetLeft;
	var pos = dojo.style.getComputedStyle(node, 'position');

	if (pos == 'relative' || pos == 'static') {
		top = parseInt(dojo.style.getComputedStyle(node, 'top')) || 0;
		left = parseInt(dojo.style.getComputedStyle(node, 'left')) || 0;
	}

	return dojo.fx.html.slide(node, duration, [left, top],
		endCoords, callback, dontPlay);
};

dojo.fx.html.slideBy = function(node, duration, coords, callback, dontPlay) {
	if(!dojo.lang.isNumber(duration)) {
		var tmp = duration;
		duration = coords;
		coords = tmp;
	}
	node = dojo.byId(node);

	var top = node.offsetTop;
	var left = node.offsetLeft;
	var pos = dojo.style.getComputedStyle(node, 'position');

	if (pos == 'relative' || pos == 'static') {
		top = parseInt(dojo.style.getComputedStyle(node, 'top')) || 0;
		left = parseInt(dojo.style.getComputedStyle(node, 'left')) || 0;
	}

	return dojo.fx.html.slideTo(node, duration, [left+coords[0], top+coords[1]],
		callback, dontPlay);
};

dojo.fx.html.slide = function(node, duration, startCoords, endCoords, callback, dontPlay) {
	if(!dojo.lang.isNumber(duration)) {
		var tmp = duration;
		duration = endCoords;
		endCoords = startCoords;
		startCoords = tmp;
	}
	node = dojo.byId(node);

	if (dojo.style.getComputedStyle(node, 'position') == 'static') {
		node.style.position = 'relative';
	}

	var anim = new dojo.animation.Animation(
		new dojo.math.curves.Line(startCoords, endCoords),
		duration||dojo.fx.duration, 0);
	dojo.event.connect(anim, "onAnimate", function(e) {
		with( node.style ) {
			left = e.x + "px";
			top = e.y + "px";
		}
	});
	if(callback) {
		dojo.event.connect(anim, "onEnd", function(e) {
			callback(node, anim);
		});
	}
	if(!dontPlay) { anim.play(true); }
	return anim;
};

// Fade from startColor to the node's background color
dojo.fx.html.colorFadeIn = function(node, duration, startColor, delay, callback, dontPlay) {
	if(!dojo.lang.isNumber(duration)) {
		var tmp = duration;
		duration = startColor;
		startColor = tmp;
	}
	node = dojo.byId(node);
	var color = dojo.style.getBackgroundColor(node);
	var bg = dojo.style.getStyle(node, "background-color").toLowerCase();
	var wasTransparent = bg == "transparent" || bg == "rgba(0, 0, 0, 0)";
	while(color.length > 3) { color.pop(); }

	var rgb = new dojo.graphics.color.Color(startColor).toRgb();
	var anim = dojo.fx.html.colorFade(node, duration||dojo.fx.duration, startColor, color, callback, true);
	dojo.event.connect(anim, "onEnd", function(e) {
		if( wasTransparent ) {
			node.style.backgroundColor = "transparent";
		}
	});
	if( delay > 0 ) {
		node.style.backgroundColor = "rgb(" + rgb.join(",") + ")";
		if(!dontPlay) { setTimeout(function(){anim.play(true)}, delay); }
	} else {
		if(!dontPlay) { anim.play(true); }
	}
	return anim;
};
// alias for (probably?) common use/terminology
dojo.fx.html.highlight = dojo.fx.html.colorFadeIn;
dojo.fx.html.colorFadeFrom = dojo.fx.html.colorFadeIn;

// Fade from node's background color to endColor
dojo.fx.html.colorFadeOut = function(node, duration, endColor, delay, callback, dontPlay) {
	if(!dojo.lang.isNumber(duration)) {
		var tmp = duration;
		duration = endColor;
		endColor = tmp;
	}
	node = dojo.byId(node);
	var color = new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node)).toRgb();

	var rgb = new dojo.graphics.color.Color(endColor).toRgb();
	var anim = dojo.fx.html.colorFade(node, duration||dojo.fx.duration, color, rgb, callback, delay > 0 || dontPlay);
	if( delay > 0 ) {
		node.style.backgroundColor = "rgb(" + color.join(",") + ")";
		if(!dontPlay) { setTimeout(function(){anim.play(true)}, delay); }
	}
	return anim;
};
// FIXME: not sure which name is better. an alias here may be bad.
dojo.fx.html.unhighlight = dojo.fx.html.colorFadeOut;
dojo.fx.html.colorFadeTo = dojo.fx.html.colorFadeOut;

// Fade node background from startColor to endColor
dojo.fx.html.colorFade = function(node, duration, startColor, endColor, callback, dontPlay) {
	if(!dojo.lang.isNumber(duration)) {
		var tmp = duration;
		duration = endColor;
		endColor = startColor;
		startColor = tmp;
	}
	node = dojo.byId(node);
	var startRgb = new dojo.graphics.color.Color(startColor).toRgb();
	var endRgb = new dojo.graphics.color.Color(endColor).toRgb();
	var anim = new dojo.animation.Animation(
		new dojo.math.curves.Line(startRgb, endRgb),
		duration||dojo.fx.duration, 0);
	dojo.event.connect(anim, "onAnimate", function(e) {
		node.style.backgroundColor = "rgb(" + e.coordsAsInts().join(",") + ")";
	});
	if(callback) {
		dojo.event.connect(anim, "onEnd", function(e) {
			callback(node, anim);
		});
	}
	if( !dontPlay ) { anim.play(true); }
	return anim;
};

dojo.fx.html.wipeIn = function(node, duration, callback, dontPlay) {
	node = dojo.byId(node);
	var overflow = dojo.style.getStyle(node, "overflow");
	if(overflow == "visible") {
		node.style.overflow = "hidden";
	}
	node.style.height = 0;
	dojo.style.show(node);
	var anim = dojo.fx.html.wipe(node, duration, 0, node.scrollHeight, null, true);
	dojo.event.connect(anim, "onEnd", function() {
		node.style.overflow = overflow;
		node.style.visibility = "";
		node.style.height = "auto";
		if(callback) { callback(node, anim); }
	});
	if(!dontPlay) { anim.play(); }
	return anim;
}

dojo.fx.html.wipeOut = function(node, duration, callback, dontPlay) {
	node = dojo.byId(node);
	var overflow = dojo.style.getStyle(node, "overflow");
	if(overflow == "visible") {
		node.style.overflow = "hidden";
	}
	var anim = dojo.fx.html.wipe(node, duration, node.offsetHeight, 0, null, true);
	dojo.event.connect(anim, "onEnd", function() {
		dojo.style.hide(node);
		node.style.visibility = "hidden";
		node.style.overflow = overflow;
		if(callback) { callback(node, anim); }
	});
	if(!dontPlay) { anim.play(); }
	return anim;
}

dojo.fx.html.wipe = function(node, duration, startHeight, endHeight, callback, dontPlay) {
	node = dojo.byId(node);
	var anim = new dojo.animation.Animation([[startHeight], [endHeight]], duration||dojo.fx.duration, 0);
	dojo.event.connect(anim, "onAnimate", function(e) {
		node.style.height = e.x + "px";
	});
	dojo.event.connect(anim, "onEnd", function() {
		if(callback) { callback(node, anim); }
	});
	if(!dontPlay) { anim.play(); }
	return anim;
}

dojo.fx.html.wiper = function(node, controlNode) {
	this.node = dojo.byId(node);
	if(controlNode) {
		dojo.event.connect(dojo.byId(controlNode), "onclick", this, "toggle");
	}
}
dojo.lang.extend(dojo.fx.html.wiper, {
	duration: dojo.fx.duration,
	_anim: null,

	toggle: function() {
		if(!this._anim) {
			var type = "wipe" + (dojo.style.isVisible(this.node) ? "Out" : "In");
			this._anim = dojo.fx[type](this.node, this.duration, dojo.lang.hitch(this, "_callback"));
		}
	},

	_callback: function() {
		this._anim = null;
	}
});

dojo.fx.html.explode = function(start, endNode, duration, callback, dontPlay) {
	var startCoords = dojo.style.toCoordinateArray(start);

	var outline = document.createElement("div");
	with(outline.style) {
		position = "absolute";
		border = "1px solid black";
		display = "none";
	}
	document.body.appendChild(outline);

	endNode = dojo.byId(endNode);
	with(endNode.style) {
		visibility = "hidden";
		display = "block";
	}
	var endCoords = dojo.style.toCoordinateArray(endNode);

	with(endNode.style) {
		display = "none";
		visibility = "visible";
	}

	var anim = new dojo.animation.Animation(
		new dojo.math.curves.Line(startCoords, endCoords),
		duration||dojo.fx.duration, 0
	);
	dojo.event.connect(anim, "onBegin", function(e) {
		outline.style.display = "block";
	});
	dojo.event.connect(anim, "onAnimate", function(e) {
		with(outline.style) {
			left = e.x + "px";
			top = e.y + "px";
			width = e.coords[2] + "px";
			height = e.coords[3] + "px";
		}
	});

	dojo.event.connect(anim, "onEnd", function() {
		endNode.style.display = "block";
		outline.parentNode.removeChild(outline);
		if(callback) { callback(endNode, anim); }
	});
	if(!dontPlay) { anim.play(); }
	return anim;
};

dojo.fx.html.implode = function(startNode, end, duration, callback, dontPlay) {
	var startCoords = dojo.style.toCoordinateArray(startNode);
	var endCoords = dojo.style.toCoordinateArray(end);

	startNode = dojo.byId(startNode);
	var outline = document.createElement("div");
	with(outline.style) {
		position = "absolute";
		border = "1px solid black";
		display = "none";
	}
	document.body.appendChild(outline);

	var anim = new dojo.animation.Animation(
		new dojo.math.curves.Line(startCoords, endCoords),
		duration||dojo.fx.duration, 0
	);
	dojo.event.connect(anim, "onBegin", function(e) {
		startNode.style.display = "none";
		outline.style.display = "block";
	});
	dojo.event.connect(anim, "onAnimate", function(e) {
		with(outline.style) {
			left = e.x + "px";
			top = e.y + "px";
			width = e.coords[2] + "px";
			height = e.coords[3] + "px";
		}
	});

	dojo.event.connect(anim, "onEnd", function() {
		outline.parentNode.removeChild(outline);
		if(callback) { callback(startNode, anim); }
	});
	if(!dontPlay) { anim.play(); }
	return anim;
};

dojo.fx.html.Exploder = function(triggerNode, boxNode) {
	triggerNode = dojo.byId(triggerNode);
	boxNode = dojo.byId(boxNode);
	var _this = this;

	// custom options
	this.waitToHide = 500;
	this.timeToShow = 100;
	this.waitToShow = 200;
	this.timeToHide = 70;
	this.autoShow = false;
	this.autoHide = false;

	var animShow = null;
	var animHide = null;

	var showTimer = null;
	var hideTimer = null;

	var startCoords = null;
	var endCoords = null;

	this.showing = false;

	this.onBeforeExplode = null;
	this.onAfterExplode = null;
	this.onBeforeImplode = null;
	this.onAfterImplode = null;
	this.onExploding = null;
	this.onImploding = null;

	this.timeShow = function() {
		clearTimeout(showTimer);
		showTimer = setTimeout(_this.show, _this.waitToShow);
	}

	this.show = function() {
		clearTimeout(showTimer);
		clearTimeout(hideTimer);
		//triggerNode.blur();

		if( (animHide && animHide.status() == "playing")
			|| (animShow && animShow.status() == "playing")
			|| _this.showing ) { return; }

		if(typeof _this.onBeforeExplode == "function") { _this.onBeforeExplode(triggerNode, boxNode); }
		animShow = dojo.fx.html.explode(triggerNode, boxNode, _this.timeToShow, function(e) {
			_this.showing = true;
			if(typeof _this.onAfterExplode == "function") { _this.onAfterExplode(triggerNode, boxNode); }
		});
		if(typeof _this.onExploding == "function") {
			dojo.event.connect(animShow, "onAnimate", this, "onExploding");
		}
	}

	this.timeHide = function() {
		clearTimeout(showTimer);
		clearTimeout(hideTimer);
		if(_this.showing) {
			hideTimer = setTimeout(_this.hide, _this.waitToHide);
		}
	}

	this.hide = function() {
		clearTimeout(showTimer);
		clearTimeout(hideTimer);
		if( animShow && animShow.status() == "playing" ) {
			return;
		}

		_this.showing = false;
		if(typeof _this.onBeforeImplode == "function") { _this.onBeforeImplode(triggerNode, boxNode); }
		animHide = dojo.fx.html.implode(boxNode, triggerNode, _this.timeToHide, function(e){
			if(typeof _this.onAfterImplode == "function") { _this.onAfterImplode(triggerNode, boxNode); }
		});
		if(typeof _this.onImploding == "function") {
			dojo.event.connect(animHide, "onAnimate", this, "onImploding");
		}
	}

	// trigger events
	dojo.event.connect(triggerNode, "onclick", function(e) {
		if(_this.showing) {
			_this.hide();
		} else {
			_this.show();
		}
	});
	dojo.event.connect(triggerNode, "onmouseover", function(e) {
		if(_this.autoShow) {
			_this.timeShow();
		}
	});
	dojo.event.connect(triggerNode, "onmouseout", function(e) {
		if(_this.autoHide) {
			_this.timeHide();
		}
	});

	// box events
	dojo.event.connect(boxNode, "onmouseover", function(e) {
		clearTimeout(hideTimer);
	});
	dojo.event.connect(boxNode, "onmouseout", function(e) {
		if(_this.autoHide) {
			_this.timeHide();
		}
	});

	// document events
	dojo.event.connect(document.documentElement || document.body, "onclick", function(e) {
		function isDesc(node, ancestor) {
			while(node) {
				if(node == ancestor){ return true; }
				node = node.parentNode;
			}
			return false;
		}
		if(_this.autoHide && _this.showing
			&& !isDesc(e.target, boxNode)
			&& !isDesc(e.target, triggerNode) ) {
			_this.hide();
		}
	});

	return this;
};

/**** 
	Strategies for displaying/hiding objects
	This presents a standard interface for each of the effects
*****/
dojo.fx.html.toggle={}

dojo.fx.html.toggle.plain = {
	show: function(node, duration, explodeSrc, callback){
		dojo.style.show(node);
		if(dojo.lang.isFunction(callback)){ callback(); }
	},

	hide: function(node, duration, explodeSrc, callback){
		dojo.style.hide(node);
		if(dojo.lang.isFunction(callback)){ callback(); }
	}
}

dojo.fx.html.toggle.fade = {
	show: function(node, duration, explodeSrc, callback){
		dojo.fx.html.fadeShow(node, duration, callback);
	},

	hide: function(node, duration, explodeSrc, callback){
		dojo.fx.html.fadeHide(node, duration, callback);
	}
}

dojo.fx.html.toggle.wipe = {
	show: function(node, duration, explodeSrc, callback){
		dojo.fx.html.wipeIn(node, duration, callback);
	},

	hide: function(node, duration, explodeSrc, callback){
		dojo.fx.html.wipeOut(node, duration, callback);
	}
}

dojo.fx.html.toggle.explode = {
	show: function(node, duration, explodeSrc, callback){
		dojo.fx.html.explode(explodeSrc||[0,0,0,0], node, duration, callback);
	},

	hide: function(node, duration, explodeSrc, callback){
		dojo.fx.html.implode(node, explodeSrc||[0,0,0,0], duration, callback);
	}
}

dojo.lang.mixin(dojo.fx, dojo.fx.html);

__CPAN_FILE__ src/fx/svg.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.fx.svg");

dojo.require("dojo.svg");
dojo.require("dojo.animation.*");
dojo.require("dojo.event.*");

dojo.fx.svg.fadeOut = function(node, duration, callback){
	return dojo.fx.svg.fade(node, duration, dojo.svg.getOpacity(node), 0, callback);
};
dojo.fx.svg.fadeIn = function(node, duration, callback){
	return dojo.fx.svg.fade(node, duration, dojo.svg.getOpacity(node), 1, callback);
};
dojo.fx.svg.fadeHide = function(node, duration, callback){
	if(!duration) { duration = 150; } // why not have a default?
	return dojo.fx.svg.fadeOut(node, duration, function(node) {
		if(typeof callback == "function") { callback(node); }
	});
};
dojo.fx.svg.fadeShow = function(node, duration, callback){
	if(!duration) { duration = 150; } // why not have a default?
	return dojo.fx.svg.fade(node, duration, 0, 1, callback);
};
dojo.fx.svg.fade = function(node, duration, startOpac, endOpac, callback){
	var anim = new dojo.animation.Animation(
		new dojo.math.curves.Line([startOpac],[endOpac]),
		duration,
		0
	);
	dojo.event.connect(anim, "onAnimate", function(e){
		dojo.svg.setOpacity(node, e.x);
	});
	if (callback) {
		dojo.event.connect(anim, "onEnd", function(e){
			callback(node, anim);
		});
	};
	anim.play(true);
	return anim;
};

/////////////////////////////////////////////////////////////////////////////////////////
//	TODO
/////////////////////////////////////////////////////////////////////////////////////////

//	SLIDES
dojo.fx.svg.slideTo = function(node, endCoords, duration, callback) { };
dojo.fx.svg.slideBy = function(node, coords, duration, callback) { };
dojo.fx.svg.slide = function(node, startCoords, endCoords, duration, callback) { 
	var anim = new dojo.animation.Animation(
		new dojo.math.curves.Line([startCoords],[endCoords]),
		duration,
		0
	);
	dojo.event.connect(anim, "onAnimate", function(e){
		dojo.svg.setCoords(node, {x: e.x, y: e.y });
	});
	if (callback) {
		dojo.event.connect(anim, "onEnd", function(e){
			callback(node, anim);
		});
	};
	anim.play(true);
	return anim;
};

//	COLORS
dojo.fx.svg.colorFadeIn = function(node, startRGB, duration, delay, callback) { };
dojo.fx.svg.highlight = dojo.fx.svg.colorFadeIn;
dojo.fx.svg.colorFadeFrom = dojo.fx.svg.colorFadeIn;

dojo.fx.svg.colorFadeOut = function(node, endRGB, duration, delay, callback) { };
dojo.fx.svg.unhighlight = dojo.fx.svg.colorFadeOut;
dojo.fx.svg.colorFadeTo = dojo.fx.svg.colorFadeOut;

dojo.fx.svg.colorFade = function(node, startRGB, endRGB, duration, callback, dontPlay) { };

//	WIPES
dojo.fx.svg.wipeIn = function(node, duration, callback, dontPlay) { };
dojo.fx.svg.wipeInToHeight = function(node, duration, height, callback, dontPlay) { }
dojo.fx.svg.wipeOut = function(node, duration, callback, dontPlay) { };

//	Explode and Implode
dojo.fx.svg.explode = function(startNode, endNode, duration, callback) { };
dojo.fx.svg.explodeFromBox = function(startCoords, endNode, duration, callback) { };
dojo.fx.svg.implode = function(startNode, endNode, duration, callback) { };
dojo.fx.svg.implodeToBox = function(startNode, endCoords, duration, callback) { };
dojo.fx.svg.Exploder = function(triggerNode, boxNode) { };

//	html mixes in, we want SVG to remain separate

__CPAN_FILE__ src/fx/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	browser: ["dojo.fx.html"],
	dashboard: ["dojo.fx.html"]
});
dojo.provide("dojo.fx.*");

__CPAN_DIR__ src/graphics
__CPAN_FILE__ src/graphics/color.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.graphics.color");
dojo.require("dojo.lang.array");

// TODO: rewrite the "x2y" methods to take advantage of the parsing
//       abilities of the Color object. Also, beef up the Color
//       object (as possible) to parse most common formats

// takes an r, g, b, a(lpha) value, [r, g, b, a] array, "rgb(...)" string, hex string (#aaa, #aaaaaa, aaaaaaa)
dojo.graphics.color.Color = function(r, g, b, a) {
	// dojo.debug("r:", r[0], "g:", r[1], "b:", r[2]);
	if(dojo.lang.isArray(r)) {
		this.r = r[0];
		this.g = r[1];
		this.b = r[2];
		this.a = r[3]||1.0;
	} else if(dojo.lang.isString(r)) {
		var rgb = dojo.graphics.color.extractRGB(r);
		this.r = rgb[0];
		this.g = rgb[1];
		this.b = rgb[2];
		this.a = g||1.0;
	} else if(r instanceof dojo.graphics.color.Color) {
		this.r = r.r;
		this.b = r.b;
		this.g = r.g;
		this.a = r.a;
	} else {
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}
}

dojo.graphics.color.Color.fromArray = function(arr) {
	return new dojo.graphics.color.Color(arr[0], arr[1], arr[2], arr[3]);
}

dojo.lang.extend(dojo.graphics.color.Color, {
	toRgb: function(includeAlpha) {
		if(includeAlpha) {
			return this.toRgba();
		} else {
			return [this.r, this.g, this.b];
		}
	},

	toRgba: function() {
		return [this.r, this.g, this.b, this.a];
	},

	toHex: function() {
		return dojo.graphics.color.rgb2hex(this.toRgb());
	},

	toCss: function() {
		return "rgb(" + this.toRgb().join() + ")";
	},

	toString: function() {
		return this.toHex(); // decent default?
	},

	blend: function(color, weight) {
		return dojo.graphics.color.blend(this.toRgb(), new Color(color).toRgb(), weight);
	}
});

dojo.graphics.color.named = {
	white:      [255,255,255],
	black:      [0,0,0],
	red:        [255,0,0],
	green:	    [0,255,0],
	blue:       [0,0,255],
	navy:       [0,0,128],
	gray:       [128,128,128],
	silver:     [192,192,192]
};

// blend colors a and b (both as RGB array or hex strings) with weight from -1 to +1, 0 being a 50/50 blend
dojo.graphics.color.blend = function(a, b, weight) {
	if(typeof a == "string") { return dojo.graphics.color.blendHex(a, b, weight); }
	if(!weight) { weight = 0; }
	else if(weight > 1) { weight = 1; }
	else if(weight < -1) { weight = -1; }
	var c = new Array(3);
	for(var i = 0; i < 3; i++) {
		var half = Math.abs(a[i] - b[i])/2;
		c[i] = Math.floor(Math.min(a[i], b[i]) + half + (half * weight));
	}
	return c;
}

// very convenient blend that takes and returns hex values
// (will get called automatically by blend when blend gets strings)
dojo.graphics.color.blendHex = function(a, b, weight) {
	return dojo.graphics.color.rgb2hex(dojo.graphics.color.blend(dojo.graphics.color.hex2rgb(a), dojo.graphics.color.hex2rgb(b), weight));
}

// get RGB array from css-style color declarations
dojo.graphics.color.extractRGB = function(color) {
	var hex = "0123456789abcdef";
	color = color.toLowerCase();
	if( color.indexOf("rgb") == 0 ) {
		var matches = color.match(/rgba*\((\d+), *(\d+), *(\d+)/i);
		var ret = matches.splice(1, 3);
		return ret;
	} else {
		var colors = dojo.graphics.color.hex2rgb(color);
		if(colors) {
			return colors;
		} else {
			// named color (how many do we support?)
			return dojo.graphics.color.named[color] || [255, 255, 255];
		}
	}
}

dojo.graphics.color.hex2rgb = function(hex) {
	var hexNum = "0123456789ABCDEF";
	var rgb = new Array(3);
	if( hex.indexOf("#") == 0 ) { hex = hex.substring(1); }
	hex = hex.toUpperCase();
	if(hex.replace(new RegExp("["+hexNum+"]", "g"), "") != "") {
		return null;
	}
	if( hex.length == 3 ) {
		rgb[0] = hex.charAt(0) + hex.charAt(0)
		rgb[1] = hex.charAt(1) + hex.charAt(1)
		rgb[2] = hex.charAt(2) + hex.charAt(2);
	} else {
		rgb[0] = hex.substring(0, 2);
		rgb[1] = hex.substring(2, 4);
		rgb[2] = hex.substring(4);
	}
	for(var i = 0; i < rgb.length; i++) {
		rgb[i] = hexNum.indexOf(rgb[i].charAt(0)) * 16 + hexNum.indexOf(rgb[i].charAt(1));
	}
	return rgb;
}

dojo.graphics.color.rgb2hex = function(r, g, b) {
	if(dojo.lang.isArray(r)) {
		g = r[1] || 0;
		b = r[2] || 0;
		r = r[0] || 0;
	}
	var ret = dojo.lang.map([r, g, b], function(x) {
		x = new Number(x);
		var s = x.toString(16);
		while(s.length < 2) { s = "0" + s; }
		return s;
	});
	ret.unshift("#");
	return ret.join("");
}

__CPAN_FILE__ src/graphics/Colorspace.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.graphics.Colorspace");

dojo.require("dojo.lang");
dojo.require("dojo.math.matrix");

//
// to convert to YUV:
//   c.whitePoint = 'D65';
//   c.RGBWorkingSpace = 'pal_secam_rgb';
//   var out = c.convert([r,g,b], 'RGB', 'XYZ');
//
// to convert to YIQ:
//   c.whitePoint = 'D65';
//   c.RGBWorkingSpace = 'ntsc_rgb';
//   var out = c.convert([r,g,b], 'RGB', 'XYZ');
//

dojo.graphics.Colorspace =function(){

	this.whitePoint = 'D65';
	this.stdObserver = '10';
	this.chromaticAdaptationAlg = 'bradford';
	this.RGBWorkingSpace = 's_rgb';
	this.useApproxCIELabMapping = 1; // see http://www.brucelindbloom.com/LContinuity.html

	this.chainMaps = {
		'RGB_to_xyY'  : ['XYZ'],
		'xyY_to_RGB'  : ['XYZ'],
		'RGB_to_Lab'  : ['XYZ'],
		'Lab_to_RGB'  : ['XYZ'],
		'RGB_to_LCHab': ['XYZ', 'Lab'],
		'LCHab_to_RGB': ['Lab'],
		'xyY_to_Lab'  : ['XYZ'],
		'Lab_to_xyY'  : ['XYZ'],
		'XYZ_to_LCHab': ['Lab'],
		'LCHab_to_XYZ': ['Lab'],
		'xyY_to_LCHab': ['XYZ', 'Lab'],
		'LCHab_to_xyY': ['Lab', 'XYZ'],
		'RGB_to_Luv'  : ['XYZ'],
		'Luv_to_RGB'  : ['XYZ'],
		'xyY_to_Luv'  : ['XYZ'],
		'Luv_to_xyY'  : ['XYZ'],
		'Lab_to_Luv'  : ['XYZ'],
		'Luv_to_Lab'  : ['XYZ'],
		'LCHab_to_Luv': ['Lab', 'XYZ'],
		'Luv_to_LCHab': ['XYZ', 'Lab'],
		'RGB_to_LCHuv'  : ['XYZ', 'Luv'],
		'LCHuv_to_RGB'  : ['Luv', 'XYZ'],
		'XYZ_to_LCHuv'  : ['Luv'],
		'LCHuv_to_XYZ'  : ['Luv'],
		'xyY_to_LCHuv'  : ['XYZ', 'Luv'],
		'LCHuv_to_xyY'  : ['Luv', 'XYZ'],
		'Lab_to_LCHuv'  : ['XYZ', 'Luv'],
		'LCHuv_to_Lab'  : ['Luv', 'XYZ'],
		'LCHab_to_LCHuv': ['Lab', 'XYZ', 'Luv'],
		'LCHuv_to_LCHab': ['Luv', 'XYZ', 'Lab'],
		'XYZ_to_CMY'    : ['RGB'],
		'CMY_to_XYZ'    : ['RGB'],
		'xyY_to_CMY'    : ['RGB'],
		'CMY_to_xyY'    : ['RGB'],
		'Lab_to_CMY'    : ['RGB'],
		'CMY_to_Lab'    : ['RGB'],
		'LCHab_to_CMY'  : ['RGB'],
		'CMY_to_LCHab'  : ['RGB'],
		'Luv_to_CMY'    : ['RGB'],
		'CMY_to_Luv'    : ['RGB'],
		'LCHuv_to_CMY'  : ['RGB'],
		'CMY_to_LCHuv'  : ['RGB'],
		'XYZ_to_HSL'    : ['RGB'],
		'HSL_to_XYZ'    : ['RGB'],
		'xyY_to_HSL'    : ['RGB'],
		'HSL_to_xyY'    : ['RGB'],
		'Lab_to_HSL'    : ['RGB'],
		'HSL_to_Lab'    : ['RGB'],
		'LCHab_to_HSL'  : ['RGB'],
		'HSL_to_LCHab'  : ['RGB'],
		'Luv_to_HSL'    : ['RGB'],
		'HSL_to_Luv'    : ['RGB'],
		'LCHuv_to_HSL'  : ['RGB'],
		'HSL_to_LCHuv'  : ['RGB'],
		'CMY_to_HSL'    : ['RGB'],
		'HSL_to_CMY'    : ['RGB'],
		'CMYK_to_HSL'   : ['RGB'],
		'HSL_to_CMYK'   : ['RGB'],
		'XYZ_to_HSV'    : ['RGB'],
		'HSV_to_XYZ'    : ['RGB'],
		'xyY_to_HSV'    : ['RGB'],
		'HSV_to_xyY'    : ['RGB'],
		'Lab_to_HSV'    : ['RGB'],
		'HSV_to_Lab'    : ['RGB'],
		'LCHab_to_HSV'  : ['RGB'],
		'HSV_to_LCHab'  : ['RGB'],
		'Luv_to_HSV'    : ['RGB'],
		'HSV_to_Luv'    : ['RGB'],
		'LCHuv_to_HSV'  : ['RGB'],
		'HSV_to_LCHuv'  : ['RGB'],
		'CMY_to_HSV'    : ['RGB'],
		'HSV_to_CMY'    : ['RGB'],
		'CMYK_to_HSV'   : ['RGB'],
		'HSV_to_CMYK'   : ['RGB'],
		'HSL_to_HSV'    : ['RGB'],
		'HSV_to_HSL'    : ['RGB'],
		'XYZ_to_CMYK'   : ['RGB'],
		'CMYK_to_XYZ'   : ['RGB'],
		'xyY_to_CMYK'   : ['RGB'],
		'CMYK_to_xyY'   : ['RGB'],
		'Lab_to_CMYK'   : ['RGB'],
		'CMYK_to_Lab'   : ['RGB'],
		'LCHab_to_CMYK' : ['RGB'],
		'CMYK_to_LCHab' : ['RGB'],
		'Luv_to_CMYK'   : ['RGB'],
		'CMYK_to_Luv'   : ['RGB'],
		'LCHuv_to_CMYK' : ['RGB'],
		'CMYK_to_LCHuv' : ['RGB']
	};


	return this;
}

dojo.graphics.Colorspace.prototype.convert = function(col, model_from, model_to){

	var k = model_from+'_to_'+model_to;

	if (this[k]){
		return this[k](col);
	}else{
		if (this.chainMaps[k]){

			var cur = model_from;
			var models = this.chainMaps[k].concat();
			models.push(model_to);

			for(var i=0; i<models.length; i++){

				col = this.convert(col, cur, models[i]);
				cur = models[i];
			}

			return col;

		}else{

			dojo.debug("Can't convert from "+model_from+' to '+model_to);
		}
	}
}

dojo.graphics.Colorspace.prototype.munge = function(keys, args){

	if (dojo.lang.isArray(args[0])){
		args = args[0];
	}

	var out = new Array();

	for (var i=0; i<keys.length; i++){
		out[keys.charAt(i)] = args[i];
	}

	return out;
}

dojo.graphics.Colorspace.prototype.getWhitePoint = function(){

	var x = 0;
	var y = 0;
	var t = 0;

	// ref: http://en.wikipedia.org/wiki/White_point
	// TODO: i need some good/better white point values

	switch(this.stdObserver){
		case '2' :
			switch(this.whitePoint){
				case 'E'   : x=1/3    ; y=1/3    ; t=5400; break; //Equal energy
				case 'D50' : x=0.34567; y=0.35850; t=5000; break;
				case 'D55' : x=0.33242; y=0.34743; t=5500; break;
				case 'D65' : x=0.31271; y=0.32902; t=6500; break;
				case 'D75' : x=0.29902; y=0.31485; t=7500; break;
				case 'A'   : x=0.44757; y=0.40745; t=2856; break; //Incandescent tungsten
				case 'B'   : x=0.34842; y=0.35161; t=4874; break;
				case 'C'   : x=0.31006; y=0.31616; t=6774; break;
				case '9300': x=0.28480; y=0.29320; t=9300; break; //Blue phosphor monitors
				case 'F2'  : x=0.37207; y=0.37512; t=4200; break; //Cool White Fluorescent
				case 'F7'  : x=0.31285; y=0.32918; t=6500; break; //Narrow Band Daylight Fluorescent
				case 'F11' : x=0.38054; y=0.37691; t=4000; break; //Narrow Band White Fluorescent
				default: dojo.debug('White point '+this.whitePoint+" isn't defined for Std. Observer "+this.strObserver);
			};
			break;
		case '10' :
			switch(this.whitePoint){
				case 'E'   : x=1/3    ; y=1/3    ; t=5400; break; //Equal energy
				case 'D50' : x=0.34773; y=0.35952; t=5000; break;
				case 'D55' : x=0.33411; y=0.34877; t=5500; break;
				case 'D65' : x=0.31382; y=0.33100; t=6500; break;
				case 'D75' : x=0.29968; y=0.31740; t=7500; break;
				case 'A'   : x=0.45117; y=0.40594; t=2856; break; //Incandescent tungsten
				case 'B'   : x=0.3498 ; y=0.3527 ; t=4874; break;
				case 'C'   : x=0.31039; y=0.31905; t=6774; break;
				case 'F2'  : x=0.37928; y=0.36723; t=4200; break; //Cool White Fluorescent
				case 'F7'  : x=0.31565; y=0.32951; t=6500; break; //Narrow Band Daylight Fluorescent
				case 'F11' : x=0.38543; y=0.37110; t=4000; break; //Narrow Band White Fluorescent
				default: dojo.debug('White point '+this.whitePoint+" isn't defined for Std. Observer "+this.strObserver);
			};
			break;
		default:
			dojo.debug("Std. Observer "+this.strObserver+" isn't defined");
	}

	var z = 1 - x - y;

	var wp = {'x':x, 'y':y, 'z':z, 't':t};

	wp.Y = 1;

	var XYZ = this.xyY_to_XYZ([wp.x, wp.y, wp.Y]);

	wp.X = XYZ[0];
	wp.Y = XYZ[1];
	wp.Z = XYZ[2];

	return wp
}

dojo.graphics.Colorspace.prototype.getPrimaries = function(){

	// ref: http://www.fho-emden.de/~hoffmann/ciexyz29082000.pdf
	// ref: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html

	var m = [];

	switch(this.RGBWorkingSpace){

		case 'adobe_rgb_1998'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.297361, 0.2100, 0.7100, 0.627355, 0.1500, 0.0600, 0.075285]; break;
		case 'apple_rgb'	: m = [1.8, 'D65', 0.6250, 0.3400, 0.244634, 0.2800, 0.5950, 0.672034, 0.1550, 0.0700, 0.083332]; break;
		case 'best_rgb'		: m = [2.2, 'D50', 0.7347, 0.2653, 0.228457, 0.2150, 0.7750, 0.737352, 0.1300, 0.0350, 0.034191]; break;
		case 'beta_rgb'		: m = [2.2, 'D50', 0.6888, 0.3112, 0.303273, 0.1986, 0.7551, 0.663786, 0.1265, 0.0352, 0.032941]; break;
		case 'bruce_rgb'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.240995, 0.2800, 0.6500, 0.683554, 0.1500, 0.0600, 0.075452]; break;
		case 'cie_rgb'		: m = [2.2, 'E'  , 0.7350, 0.2650, 0.176204, 0.2740, 0.7170, 0.812985, 0.1670, 0.0090, 0.010811]; break;
		case 'color_match_rgb'	: m = [1.8, 'D50', 0.6300, 0.3400, 0.274884, 0.2950, 0.6050, 0.658132, 0.1500, 0.0750, 0.066985]; break;
		case 'don_rgb_4'	: m = [2.2, 'D50', 0.6960, 0.3000, 0.278350, 0.2150, 0.7650, 0.687970, 0.1300, 0.0350, 0.033680]; break;
		case 'eci_rgb'		: m = [1.8, 'D50', 0.6700, 0.3300, 0.320250, 0.2100, 0.7100, 0.602071, 0.1400, 0.0800, 0.077679]; break;
		case 'ekta_space_ps5'	: m = [2.2, 'D50', 0.6950, 0.3050, 0.260629, 0.2600, 0.7000, 0.734946, 0.1100, 0.0050, 0.004425]; break;
		case 'ntsc_rgb'		: m = [2.2, 'C'  , 0.6700, 0.3300, 0.298839, 0.2100, 0.7100, 0.586811, 0.1400, 0.0800, 0.114350]; break;
		case 'pal_secam_rgb'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.222021, 0.2900, 0.6000, 0.706645, 0.1500, 0.0600, 0.071334]; break;
		case 'pro_photo_rgb'	: m = [1.8, 'D50', 0.7347, 0.2653, 0.288040, 0.1596, 0.8404, 0.711874, 0.0366, 0.0001, 0.000086]; break;
		case 'smpte-c_rgb'	: m = [2.2, 'D65', 0.6300, 0.3400, 0.212395, 0.3100, 0.5950, 0.701049, 0.1550, 0.0700, 0.086556]; break;
		case 's_rgb'		: m = [2.2, 'D65', 0.6400, 0.3300, 0.212656, 0.3000, 0.6000, 0.715158, 0.1500, 0.0600, 0.072186]; break;
		case 'wide_gamut_rgb'	: m = [2.2, 'D50', 0.7350, 0.2650, 0.258187, 0.1150, 0.8260, 0.724938, 0.1570, 0.0180, 0.016875]; break;

		default: dojo.debug("RGB working space "+this.RGBWorkingSpace+" isn't defined");
	}

	var p = {};

	p.name = this.RGBWorkingSpace;
	p.gamma = m[0];
	p.wp = m[1];

	p.xr = m[2];
	p.yr = m[3];
	p.Yr = m[4];

	p.xg = m[5];
	p.yg = m[6];
	p.Yg = m[7];

	p.xb = m[8];
	p.yb = m[9];
	p.Yb = m[10];

	// if WP doesn't match current WP, convert the primaries over

	if (p.wp != this.whitePoint){

		var r = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xr, p.yr, p.Yr]), p.wp, this.whitePoint ) );
		var g = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xg, p.yg, p.Yg]), p.wp, this.whitePoint ) );
		var b = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xb, p.yb, p.Yb]), p.wp, this.whitePoint ) );

		p.xr = r[0];
		p.yr = r[1];
		p.Yr = r[2];

		p.xg = g[0];
		p.yg = g[1];
		p.Yg = g[2];

		p.xb = b[0];
		p.yb = b[1];
		p.Yb = b[2];

		p.wp = this.whitePoint;
	}

	p.zr = 1 - p.xr - p.yr;
	p.zg = 1 - p.xg - p.yg;
	p.zb = 1 - p.xb - p.yb;

	return p;
}

dojo.graphics.Colorspace.prototype.epsilon = function(){

	return this.useApproxCIELabMapping ? 0.008856 : 216 / 24289;
}

dojo.graphics.Colorspace.prototype.kappa = function(){

	return this.useApproxCIELabMapping ? 903.3 : 24389 / 27;
}

dojo.graphics.Colorspace.prototype.XYZ_to_xyY = function(){
	var src = this.munge('XYZ', arguments);

	var sum = src.X + src.Y + src.Z;

	if (sum == 0){

		var wp = this.getWhitePoint();
		var x = wp.x;
		var y = wp.y;
	}else{
		var x = src.X / sum;
		var y = src.Y / sum;
	}

	var Y = src.Y;


	return [x, y, Y];
}

dojo.graphics.Colorspace.prototype.xyY_to_XYZ = function(){
	var src = this.munge('xyY', arguments);

	if (src.y == 0){

		var X = 0;
		var Y = 0;
		var Z = 0;
	}else{
		var X = (src.x * src.Y) / src.y;
		var Y = src.Y;
		var Z = ((1 - src.x - src.y) * src.Y) / src.y;
	}

	return [X, Y, Z];
}

dojo.graphics.Colorspace.prototype.RGB_to_XYZ = function(){
	var src = this.munge('RGB', arguments);

	var m = this.getRGB_XYZ_Matrix();
	var pr = this.getPrimaries();

	if (this.RGBWorkingSpace == 's_rgb'){

		var r = (src.R > 0.04045) ? Math.pow(((src.R + 0.055) / 1.055), 2.4) : src.R / 12.92;
		var g = (src.G > 0.04045) ? Math.pow(((src.G + 0.055) / 1.055), 2.4) : src.G / 12.92;
		var b = (src.B > 0.04045) ? Math.pow(((src.B + 0.055) / 1.055), 2.4) : src.B / 12.92;

	}else{

		var r = Math.pow(src.R, pr.gamma);
		var g = Math.pow(src.G, pr.gamma);
		var b = Math.pow(src.B, pr.gamma);
	}

	var XYZ = dojo.math.matrix.multiply([[r, g, b]], m);

	return [XYZ[0][0], XYZ[0][1], XYZ[0][2]];
}

dojo.graphics.Colorspace.prototype.XYZ_to_RGB = function(){
	var src = this.munge('XYZ', arguments);

	var mi = this.getXYZ_RGB_Matrix();
	var pr = this.getPrimaries();

	var rgb = dojo.math.matrix.multiply([[src.X, src.Y, src.Z]], mi);
	var r = rgb[0][0];
	var g = rgb[0][1];
	var b = rgb[0][2];

	if (this.RGBWorkingSpace == 's_rgb'){

		var R = (r > 0.0031308) ? (1.055 * Math.pow(r, 1.0/2.4)) - 0.055 : 12.92 * r;
		var G = (g > 0.0031308) ? (1.055 * Math.pow(g, 1.0/2.4)) - 0.055 : 12.92 * g;
		var B = (b > 0.0031308) ? (1.055 * Math.pow(b, 1.0/2.4)) - 0.055 : 12.92 * b;
	}else{
		var R = Math.pow(r, 1/pr.gamma);
		var G = Math.pow(g, 1/pr.gamma);
		var B = Math.pow(b, 1/pr.gamma);
	}

	return [R, G, B];
}

dojo.graphics.Colorspace.prototype.XYZ_to_Lab = function(){
	var src = this.munge('XYZ', arguments);

	var wp = this.getWhitePoint();

	var xr = src.X / wp.X;
	var yr = src.Y / wp.Y;
	var zr = src.Z / wp.Z;

	var fx = (xr > this.epsilon()) ? Math.pow(xr, 1/3) : (this.kappa() * xr + 16) / 116;
	var fy = (yr > this.epsilon()) ? Math.pow(yr, 1/3) : (this.kappa() * yr + 16) / 116;
	var fz = (zr > this.epsilon()) ? Math.pow(zr, 1/3) : (this.kappa() * zr + 16) / 116;

	var L = 116 * fy - 16;
	var a = 500 * (fx - fy);
	var b = 200 * (fy - fz);

	return [L, a, b];
}

dojo.graphics.Colorspace.prototype.Lab_to_XYZ = function(){
	var src = this.munge('Lab', arguments);

	var wp = this.getWhitePoint();

	var yr = (src.L > (this.kappa() * this.epsilon())) ? Math.pow((src.L + 16) / 116, 3) : src.L / this.kappa();

	var fy = (yr > this.epsilon()) ? (src.L + 16) / 116 : (this.kappa() * yr + 16) / 116;

	var fx = (src.a / 500) + fy;
	var fz = fy - (src.b / 200);

	var fxcube = Math.pow(fx, 3);
	var fzcube = Math.pow(fz, 3);

	var xr = (fxcube > this.epsilon()) ? fxcube : (116 * fx - 16) / this.kappa();
	var zr = (fzcube > this.epsilon()) ? fzcube : (116 * fz - 16) / this.kappa();

	var X = xr * wp.X;
	var Y = yr * wp.Y;
	var Z = zr * wp.Z;

	return [X, Y, Z];
}

dojo.graphics.Colorspace.prototype.Lab_to_LCHab = function(){
	var src = this.munge('Lab', arguments);

	var L = src.L;
	var C = Math.pow(src.a * src.a + src.b * src.b, 0.5);
	var H = Math.atan2(src.b, src.a) * (180 / Math.PI);

	if (H < 0){ H += 360; }
	if (H > 360){ H -= 360; }

	return [L, C, H];
}

dojo.graphics.Colorspace.prototype.LCHab_to_Lab = function(){
	var src = this.munge('LCH', arguments);

	var H_rad = src.H * (Math.PI / 180);

	var L = src.L;

	var a = src.C / Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);
	if ((90 < src.H) && (src.H < 270)){ a= -a; }

	var b = Math.pow(Math.pow(src.C, 2) - Math.pow(a, 2), 0.5);
	if (src.H > 180){ b = -b; }

	return [L, a, b];
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// this function converts an XYZ color array (col) from one whitepoint (src_w) to another (dst_w)
//

dojo.graphics.Colorspace.prototype.chromaticAdaptation = function(col, src_w, dst_w){

	col = this.munge('XYZ', [col]);

	//
	// gather white point data for the source and dest
	//

	var old_wp = this.whitePoint;

	this.whitePoint = src_w;
	var wp_src = this.getWhitePoint();

	this.whitePoint = dst_w;
	var wp_dst = this.getWhitePoint();

	this.whitePoint = old_wp;


	//
	// get a transformation matricies
	//

	switch(this.chromaticAdaptationAlg){
		case 'xyz_scaling':
			var ma = [[1,0,0],[0,1,0],[0,0,1]];
			var mai = [[1,0,0],[0,1,0],[0,0,1]];
			break;
		case 'bradford':
			var ma = [[0.8951, -0.7502, 0.0389],[0.2664, 1.7135, -0.0685],[-0.1614, 0.0367, 1.0296]];
			var mai = [[0.986993, 0.432305, -0.008529],[-0.147054, 0.518360, 0.040043],[0.159963, 0.049291, 0.968487]];
			break;
		case 'von_kries':
			var ma = [[0.40024, -0.22630, 0.00000],[0.70760, 1.16532, 0.00000],[-0.08081, 0.04570, 0.91822]]
			var mai = [[1.859936, 0.361191, 0.000000],[-1.129382, 0.638812, 0.000000],[0.219897, -0.000006, 1.089064]]
			break;
		default:
			dojo.debug("The "+this.chromaticAdaptationAlg+" chromatic adaptation algorithm matricies are not defined");
	}


	//
	// calculate the cone response domains
	//

	var domain_src = dojo.math.matrix.multiply( [[wp_src.x, wp_src.y, wp_src.z]], ma);
	var domain_dst = dojo.math.matrix.multiply( [[wp_dst.x, wp_dst.y, wp_dst.z]], ma);


	//
	// construct the centre matrix
	//

	var centre = [
		[domain_dst[0][0]/domain_src[0][0], 0, 0],
		[0, domain_dst[0][1]/domain_src[0][1], 0],
		[0, 0, domain_dst[0][2]/domain_src[0][2]]
	];


	//
	// caclulate 'm'
	//

	var m = dojo.math.matrix.multiply( dojo.math.matrix.multiply( ma, centre ), mai );


	//
	// construct source color matrix
	//

	var dst = dojo.math.matrix.multiply( [[ col.X, col.Y, col.Z ]], m );

	return dst[0];
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

dojo.graphics.Colorspace.prototype.getRGB_XYZ_Matrix = function(){

	var wp = this.getWhitePoint();
	var pr = this.getPrimaries();

	var Xr = pr.xr / pr.yr;
	var Yr = 1;
	var Zr = (1 - pr.xr - pr.yr) / pr.yr;

	var Xg = pr.xg / pr.yg;
	var Yg = 1;
	var Zg = (1 - pr.xg - pr.yg) / pr.yg;

	var Xb = pr.xb / pr.yb;
	var Yb = 1;
	var Zb = (1 - pr.xb - pr.yb) / pr.yb;

	var m1 = [[Xr, Yr, Zr],[Xg, Yg, Zg],[Xb, Yb, Zb]];
	var m2 = [[wp.X, wp.Y, wp.Z]];
	var sm = dojo.math.matrix.multiply(m2, dojo.math.matrix.inverse(m1));

	var Sr = sm[0][0];
	var Sg = sm[0][1];
	var Sb = sm[0][2];

	var m4 = [[Sr*Xr, Sr*Yr, Sr*Zr],
		  [Sg*Xg, Sg*Yg, Sg*Zg],
		  [Sb*Xb, Sb*Yb, Sb*Zb]];

	return m4;
}

dojo.graphics.Colorspace.prototype.getXYZ_RGB_Matrix = function(){

	var m = this.getRGB_XYZ_Matrix();

	return dojo.math.matrix.inverse(m);
}

dojo.graphics.Colorspace.prototype.XYZ_to_Luv = function(){

	var src = this.munge('XYZ', arguments);

	var wp = this.getWhitePoint();

	var ud = (4 * src.X) / (src.X + 15 * src.Y + 3 * src.Z);
	var vd = (9 * src.Y) / (src.X + 15 * src.Y + 3 * src.Z);

	var udr = (4 * wp.X) / (wp.X + 15 * wp.Y + 3 * wp.Z);
	var vdr = (9 * wp.Y) / (wp.X + 15 * wp.Y + 3 * wp.Z);

	var yr = src.Y / wp.Y;

	var L = (yr > this.epsilon()) ? 116 * Math.pow(yr, 1/3) - 16 : this.kappa() * yr;
	var u = 13 * L * (ud-udr);
	var v = 13 * L * (vd-vdr);

	return [L, u, v];
}

dojo.graphics.Colorspace.prototype.Luv_to_XYZ = function(){

	var src = this.munge('Luv', arguments);

	var wp = this.getWhitePoint();

	var uz = (4 * wp.X) / (wp.X + 15 * wp.Y + 3 * wp.Z);
	var vz = (9 * wp.Y) / (wp.X + 15 * wp.Y + 3 * wp.Z);

	var Y = (src.L > this.kappa() * this.epsilon()) ? Math.pow((src.L + 16) / 116, 3) : src.L / this.kappa();

	var a = (1 / 3) * (((52 * src.L) / (src.u + 13 * src.L * uz)) - 1);
	var b = -5 * Y;
	var c = - (1 / 3);
	var d = Y * (((39 * src.L) / (src.v + 13 * src.L * vz)) - 5);

	var X = (d - b) / (a - c);
	var Z = X * a + b;

	return [X, Y, Z];
}

dojo.graphics.Colorspace.prototype.Luv_to_LCHuv = function(){

	var src = this.munge('Luv', arguments);

	var L = src.L;
	var C = Math.pow(src.u * src.u + src.v * src.v, 0.5);
	var H = Math.atan2(src.v, src.u) * (180 / Math.PI);

	if (H < 0){ H += 360; }
	if (H > 360){ H -= 360; }

	return [L, C, H];
}

dojo.graphics.Colorspace.prototype.LCHuv_to_Luv = function(){

	var src = this.munge('LCH', arguments);

	var H_rad = src.H * (Math.PI / 180);

	var L = src.L;
	var u = src.C / Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);
	var v = Math.pow(src.C * src.C - u * u, 0.5);

	if ((90 < src.H) && (src.H < 270)){ u *= -1; }
	if (src.H > 180){ v *= -1; }

	return [L, u, v];
}

dojo.graphics.Colorspace.colorTemp_to_whitePoint = function(T){

	if (T < 4000){
		dojo.debug("Can't find a white point for temperatures under 4000K");
		return [0,0];
	}

	if (T > 25000){
		dojo.debug("Can't find a white point for temperatures over 25000K");
		return [0,0];
	}

	var T1 = T;
	var T2 = T * T;
	var T3 = T2 * T;

	var ten9 = Math.pow(10, 9);
	var ten6 = Math.pow(10, 6);
	var ten3 = Math.pow(10, 3);

	if (T <= 7000){

		var x = (-4.6070 * ten9 / T3) + (2.9678 * ten6 / T2) + (0.09911 * ten3 / T) + 0.244063;
	}else{
		var x = (-2.0064 * ten9 / T3) + (1.9018 * ten6 / T2) + (0.24748 * ten3 / T) + 0.237040;
	}

	var y = -3.000 * x * x + 2.870 * x - 0.275;

	return [x, y];
}

dojo.graphics.Colorspace.prototype.RGB_to_CMY = function(){

	var src = this.munge('RGB', arguments);

	var C = 1 - src.R;
	var M = 1 - src.G;
	var Y = 1 - src.B;

	return [C, M, Y];
}

dojo.graphics.Colorspace.prototype.CMY_to_RGB = function(){

	var src = this.munge('CMY', arguments);

	var R = 1 - src.C;
	var G = 1 - src.M;
	var B = 1 - src.Y;

	return [R, G, B];
}

dojo.graphics.Colorspace.prototype.RGB_to_CMYK = function(){

	var src = this.munge('RGB', arguments);

	var K = Math.min(1-src.R, 1-src.G, 1-src.B);
	var C = (1 - src.R - K) / (1 - K);
	var M = (1 - src.G - K) / (1 - K);
	var Y = (1 - src.B - K) / (1 - K);

	return [C, M, Y, K];
}

dojo.graphics.Colorspace.prototype.CMYK_to_RGB = function(){

	var src = this.munge('CMYK', arguments);

	var R = 1 - Math.min(1, src.C * (1-src.K) + src.K);
	var G = 1 - Math.min(1, src.M * (1-src.K) + src.K);
	var B = 1 - Math.min(1, src.Y * (1-src.K) + src.K);

	return [R, G, B];
}

dojo.graphics.Colorspace.prototype.CMY_to_CMYK = function(){

	var src = this.munge('CMY', arguments);

	var K = Math.min(src.C, src.M, src.Y);
	var C = (src.C - K) / (1 - K);
	var M = (src.M - K) / (1 - K);
	var Y = (src.Y - K) / (1 - K);

	return [C, M, Y, K];
}

dojo.graphics.Colorspace.prototype.CMYK_to_CMY = function(){

	var src = this.munge('CMYK', arguments);

	var C = Math.min(1, src.C * (1-src.K) + src.K);
	var M = Math.min(1, src.M * (1-src.K) + src.K);
	var Y = Math.min(1, src.Y * (1-src.K) + src.K);

	return [C, M, Y];
}

dojo.graphics.Colorspace.prototype.RGB_to_HSV = function(){

	var src = this.munge('RGB', arguments);

	// Based on C Code in "Computer Graphics -- Principles and Practice,"
	// Foley et al, 1996, p. 592. 

	var min = Math.min(src.R, src.G, src.B);
	var V = Math.max(src.R, src.G, src.B);

	var delta = V - min;

	var H = null;
	var S = (V == 0) ? 0 : delta / V;

	if (S == 0){
		H = 0;
	}else{
		if (src.R == V){
			H = 60 * (src.G - src.B) / delta;
		}else{
			if (src.G == V){
				H = 120 + 60 * (src.B - src.R) / delta;
			}else{
				if (src.B == V){
					// between magenta and cyan
					H = 240 + 60 * (src.R - src.G) / delta;
				}
			}
		}
		if (H < 0){
			H += 360;
		}
	}

	H = (H == 0) ? 360 : H;

	return [H, S, V];
}

dojo.graphics.Colorspace.prototype.HSV_to_RGB = function(){
 
	var src = this.munge('HSV', arguments);

	if (src.H == 360){ src.H = 0;}

	// Based on C Code in "Computer Graphics -- Principles and Practice,"
	// Foley et al, 1996, p. 593.

	var r = null;
	var g = null;
	var b = null;

	if (src.S == 0){
		// color is on black-and-white center line
		// achromatic: shades of gray
		R = src.V;
		G = src.V;
		B = src.V;
	}else{
		// chromatic color
		var hTemp = src.H / 60;		// h is now IN [0,6]
		var i = Math.floor(hTemp);	// largest integer <= h
		var f = hTemp - i;		// fractional part of h

		var p = src.V * (1 - src.S);
		var q = src.V * (1 - (src.S * f));
		var t = src.V * (1 - (src.S * (1 - f)));

		switch(i){
			case 0: R = src.V; G = t    ; B = p    ; break;
			case 1: R = q    ; G = src.V; B = p    ; break;
			case 2: R = p    ; G = src.V; B = t    ; break;
			case 3: R = p    ; G = q    ; B = src.V; break;
			case 4: R = t    ; G = p    ; B = src.V; break;
			case 5: R = src.V; G = p    ; B = q    ; break;
		}
	}

	return [R, G, B];
}

dojo.graphics.Colorspace.prototype.RGB_to_HSL = function(){

	var src = this.munge('RGB', arguments);

	//
	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
	//


	var min = Math.min(src.R, src.G, src.B);
	var max = Math.max(src.R, src.G, src.B);
	var delta = max - min;

	var H = 0;
	var S = 0;
	var L = (min + max) / 2;

	if ((L > 0) && (L < 1)){
		S = delta / ((L < 0.5) ? (2 * L) : (2 - 2 * L));
	}

	if (delta > 0) {
		if ((max == src.R) && (max != src.G)){
			H += (src.G - src.B) / delta;
		}
		if ((max == src.G) && (max != src.B)){
			H += (2 + (src.B - src.R) / delta);
		}
		if ((max == src.B) && (max != src.R)){
			H += (4 + (src.R - src.G) / delta);
		}
		H *= 60;
	}

	H = (H == 0) ? 360 : H;

	return [H, S, L];
}

dojo.graphics.Colorspace.prototype.HSL_to_RGB = function(){
 
	var src = this.munge('HSL', arguments);

	//
	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
	//

	while (src.H < 0){ src.H += 360; }
	while (src.H >= 360){ src.H -= 360; }

	var R = 0;
	var G = 0;
	var B = 0;

	if (src.H < 120){
		R = (120 - src.H) / 60;
		G = src.H / 60;
		B = 0;
	}else if (src.H < 240){
		R = 0;
		G = (240 - src.H) / 60;
		B = (src.H - 120) / 60;
	}else{
		R = (src.H - 240) / 60;
		G = 0;
		B = (360 - src.H) / 60;
	}

	R = 2 * src.S * Math.min(R, 1) + (1 - src.S);
	G = 2 * src.S * Math.min(G, 1) + (1 - src.S);
	B = 2 * src.S * Math.min(B, 1) + (1 - src.S);

	if (src.L < 0.5){
		R = src.L * R;
		G = src.L * G;
		B = src.L * B;
	}else{
		R = (1 - src.L) * R + 2 * src.L - 1;
		G = (1 - src.L) * G + 2 * src.L - 1;
		B = (1 - src.L) * B + 2 * src.L - 1;
	}

	return [R, G, B];
}

__CPAN_FILE__ src/graphics/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	browser:	["dojo.graphics.htmlEffects"],
	dashboard:	["dojo.graphics.htmlEffects"]
});
dojo.provide("dojo.graphics.*");

__CPAN_DIR__ src/graphics/color
__CPAN_FILE__ src/graphics/color/hsl.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.graphics.color.hsl");
dojo.require("dojo.lang.array");

dojo.lang.extend(dojo.graphics.color.Color, {

	toHsl: function() {
		return dojo.graphics.color.rgb2hsl(this.toRgb());
	}
});

dojo.graphics.color.rgb2hsl = function(r, g, b){

	if (dojo.lang.isArray(r)) {
		b = r[2] || 0;
		g = r[1] || 0;
		r = r[0] || 0;
	}

	r /= 255;
	g /= 255;
	b /= 255;

	//
	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
	//

	var h = null;
	var s = null;
	var l = null;


	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;

	l = (min + max) / 2;

	s = 0;

	if ((l > 0) && (l < 1)){
		s = delta / ((l < 0.5) ? (2 * l) : (2 - 2 * l));
	}

	h = 0;

	if (delta > 0) {
		if ((max == r) && (max != g)){
			h += (g - b) / delta;
		}
		if ((max == g) && (max != b)){
			h += (2 + (b - r) / delta);
		}
		if ((max == b) && (max != r)){
			h += (4 + (r - g) / delta);
		}
		h *= 60;
	}

	h = (h == 0) ? 360 : Math.ceil((h / 360) * 255);
	s = Math.ceil(s * 255);
	l = Math.ceil(l * 255);

	return [h, s, l];
}

dojo.graphics.color.hsl2rgb = function(h, s, l){
 
	if (dojo.lang.isArray(h)) {
		l = h[2] || 0;
		s = h[1] || 0;
		h = h[0] || 0;
	}

	h = (h / 255) * 360;
	if (h == 360){ h = 0;}
	s = s / 255;
	l = l / 255;

	//
	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
	//


	while (h < 0){ h += 360; }
	while (h > 360){ h -= 360; }

	if (h < 120){
		r = (120 - h) / 60;
		g = h / 60;
		b = 0;
	}else if (h < 240){
		r = 0;
		g = (240 - h) / 60;
		b = (h - 120) / 60;
	}else{
		r = (h - 240) / 60;
		g = 0;
		b = (360 - h) / 60;
	}

	r = Math.min(r, 1);
	g = Math.min(g, 1);
	b = Math.min(b, 1);

	r = 2 * s * r + (1 - s);
	g = 2 * s * g + (1 - s);
	b = 2 * s * b + (1 - s);

	if (l < 0.5){
		r = l * r;
		g = l * g;
		b = l * b;
	}else{
		r = (1 - l) * r + 2 * l - 1;
		g = (1 - l) * g + 2 * l - 1;
		b = (1 - l) * b + 2 * l - 1;
	}

	r = Math.ceil(r * 255);
	g = Math.ceil(g * 255);
	b = Math.ceil(b * 255);

	return [r, g, b];
}

dojo.graphics.color.hsl2hex = function(h, s, l){
	var rgb = dojo.graphics.color.hsl2rgb(h, s, l);
	return dojo.graphics.color.rgb2hex(rgb[0], rgb[1], rgb[2]);
}

dojo.graphics.color.hex2hsl = function(hex){
	var rgb = dojo.graphics.color.hex2rgb(hex);
	return dojo.graphics.color.rgb2hsl(rgb[0], rgb[1], rgb[2]);
}

__CPAN_FILE__ src/graphics/color/hsv.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.graphics.color.hsv");
dojo.require("dojo.lang.array");

dojo.lang.extend(dojo.graphics.color.Color, {

	toHsv: function() {
		return dojo.graphics.color.rgb2hsv(this.toRgb());
	}

});

dojo.graphics.color.rgb2hsv = function(r, g, b){

	if (dojo.lang.isArray(r)) {
		b = r[2] || 0;
		g = r[1] || 0;
		r = r[0] || 0;
	}

	// r,g,b, each 0 to 255, to HSV.
	// h = 0.0 to 360.0 (corresponding to 0..360.0 degrees around hexcone)
	// s = 0.0 (shade of gray) to 1.0 (pure color)
	// v = 0.0 (black) to 1.0 {white)
	//
	// Based on C Code in "Computer Graphics -- Principles and Practice,"
	// Foley et al, 1996, p. 592. 
	//
	// our calculatuions are based on 'regular' values (0-360, 0-1, 0-1) 
	// but we return bytes values (0-255, 0-255, 0-255)

	var h = null;
	var s = null;
	var v = null;

	var min = Math.min(r, g, b);
	v = Math.max(r, g, b);

	var delta = v - min;

	// calculate saturation (0 if r, g and b are all 0)

	s = (v == 0) ? 0 : delta/v;

	if (s == 0){
		// achromatic: when saturation is, hue is undefined
		h = 0;
	}else{
		// chromatic
		if (r == v){
			// between yellow and magenta
			h = 60 * (g - b) / delta;
		}else{
			if (g == v){
				// between cyan and yellow
				h = 120 + 60 * (b - r) / delta;
			}else{
				if (b == v){
					// between magenta and cyan
					h = 240 + 60 * (r - g) / delta;
				}
			}
		}
		if (h < 0){
			h += 360;
		}
	}


	h = (h == 0) ? 360 : Math.ceil((h / 360) * 255);
	s = Math.ceil(s * 255);

	return [h, s, v];
}

dojo.graphics.color.hsv2rgb = function(h, s, v){
 
	if (dojo.lang.isArray(h)) {
		v = h[2] || 0;
		s = h[1] || 0;
		h = h[0] || 0;
	}

	h = (h / 255) * 360;
	if (h == 360){ h = 0;}

	s = s / 255;
	v = v / 255;

	// Based on C Code in "Computer Graphics -- Principles and Practice,"
	// Foley et al, 1996, p. 593.
	//
	// H = 0.0 to 360.0 (corresponding to 0..360 degrees around hexcone) 0 for S = 0
	// S = 0.0 (shade of gray) to 1.0 (pure color)
	// V = 0.0 (black) to 1.0 (white)

	var r = null;
	var g = null;
	var b = null;

	if (s == 0){
		// color is on black-and-white center line
		// achromatic: shades of gray
		r = v;
		g = v;
		b = v;
	}else{
		// chromatic color
		var hTemp = h / 60;		// h is now IN [0,6]
		var i = Math.floor(hTemp);	// largest integer <= h
		var f = hTemp - i;		// fractional part of h

		var p = v * (1 - s);
		var q = v * (1 - (s * f));
		var t = v * (1 - (s * (1 - f)));

		switch(i){
			case 0: r = v; g = t; b = p; break;
			case 1: r = q; g = v; b = p; break;
			case 2: r = p; g = v; b = t; break;
			case 3: r = p; g = q; b = v; break;
			case 4: r = t; g = p; b = v; break;
			case 5: r = v; g = p; b = q; break;
		}
	}

	r = Math.ceil(r * 255);
	g = Math.ceil(g * 255);
	b = Math.ceil(b * 255);

	return [r, g, b];
}

__CPAN_DIR__ src/html
__CPAN_FILE__ src/html/extras.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.html");
dojo.provide("dojo.html.extras");
dojo.require("dojo.string.extras"); 

/**
 * Calculates the mouse's direction of gravity relative to the centre
 * of the given node.
 * <p>
 * If you wanted to insert a node into a DOM tree based on the mouse
 * position you might use the following code:
 * <pre>
 * if (gravity(node, e) & gravity.NORTH) { [insert before]; }
 * else { [insert after]; }
 * </pre>
 *
 * @param node The node
 * @param e		The event containing the mouse coordinates
 * @return		 The directions, NORTH or SOUTH and EAST or WEST. These
 *						 are properties of the function.
 */
dojo.html.gravity = function(node, e){
	node = dojo.byId(node);
	var mouse = dojo.html.getCursorPosition(e);

	with (dojo.html) {
		var nodecenterx = getAbsoluteX(node, true) + (getInnerWidth(node) / 2);
		var nodecentery = getAbsoluteY(node, true) + (getInnerHeight(node) / 2);
	}
	
	with (dojo.html.gravity) {
		return ((mouse.x < nodecenterx ? WEST : EAST) |
			(mouse.y < nodecentery ? NORTH : SOUTH));
	}
}

dojo.html.gravity.NORTH = 1;
dojo.html.gravity.SOUTH = 1 << 1;
dojo.html.gravity.EAST = 1 << 2;
dojo.html.gravity.WEST = 1 << 3;


/**
 * Attempts to return the text as it would be rendered, with the line breaks
 * sorted out nicely. Unfinished.
 */
dojo.html.renderedTextContent = function(node){
	node = dojo.byId(node);
	var result = "";
	if (node == null) { return result; }
	for (var i = 0; i < node.childNodes.length; i++) {
		switch (node.childNodes[i].nodeType) {
			case 1: // ELEMENT_NODE
			case 5: // ENTITY_REFERENCE_NODE
				var display = "unknown";
				try {
					display = dojo.style.getStyle(node.childNodes[i], "display");
				} catch(E) {}
				switch (display) {
					case "block": case "list-item": case "run-in":
					case "table": case "table-row-group": case "table-header-group":
					case "table-footer-group": case "table-row": case "table-column-group":
					case "table-column": case "table-cell": case "table-caption":
						// TODO: this shouldn't insert double spaces on aligning blocks
						result += "\n";
						result += dojo.html.renderedTextContent(node.childNodes[i]);
						result += "\n";
						break;
					
					case "none": break;
					
					default:
						if(node.childNodes[i].tagName && node.childNodes[i].tagName.toLowerCase() == "br") {
							result += "\n";
						} else {
							result += dojo.html.renderedTextContent(node.childNodes[i]);
						}
						break;
				}
				break;
			case 3: // TEXT_NODE
			case 2: // ATTRIBUTE_NODE
			case 4: // CDATA_SECTION_NODE
				var text = node.childNodes[i].nodeValue;
				var textTransform = "unknown";
				try {
					textTransform = dojo.style.getStyle(node, "text-transform");
				} catch(E) {}
				switch (textTransform){
					case "capitalize": text = dojo.string.capitalize(text); break;
					case "uppercase": text = text.toUpperCase(); break;
					case "lowercase": text = text.toLowerCase(); break;
					default: break; // leave as is
				}
				// TODO: implement
				switch (textTransform){
					case "nowrap": break;
					case "pre-wrap": break;
					case "pre-line": break;
					case "pre": break; // leave as is
					default:
						// remove whitespace and collapse first space
						text = text.replace(/\s+/, " ");
						if (/\s$/.test(result)) { text.replace(/^\s/, ""); }
						break;
				}
				result += text;
				break;
			default:
				break;
		}
	}
	return result;
}

dojo.html.createNodesFromText = function(txt, trim){
	if(trim) { txt = dojo.string.trim(txt); }

	var tn = document.createElement("div");
	// tn.style.display = "none";
	tn.style.visibility= "hidden";
	document.body.appendChild(tn);
	var tableType = "none";
	if((/^<t[dh][\s\r\n>]/i).test(dojo.string.trimStart(txt))) {
		txt = "<table><tbody><tr>" + txt + "</tr></tbody></table>";
		tableType = "cell";
	} else if((/^<tr[\s\r\n>]/i).test(dojo.string.trimStart(txt))) {
		txt = "<table><tbody>" + txt + "</tbody></table>";
		tableType = "row";
	} else if((/^<(thead|tbody|tfoot)[\s\r\n>]/i).test(dojo.string.trimStart(txt))) {
		txt = "<table>" + txt + "</table>";
		tableType = "section";
	}
	tn.innerHTML = txt;
	if(tn["normalize"]){
		tn.normalize();
	}

	var parent = null;
	switch(tableType) {
		case "cell":
			parent = tn.getElementsByTagName("tr")[0];
			break;
		case "row":
			parent = tn.getElementsByTagName("tbody")[0];
			break;
		case "section":
			parent = tn.getElementsByTagName("table")[0];
			break;
		default:
			parent = tn;
			break;
	}

	/* this doesn't make much sense, I'm assuming it just meant trim() so wrap was replaced with trim
	if(wrap){ 
		var ret = [];
		// start hack
		var fc = tn.firstChild;
		ret[0] = ((fc.nodeValue == " ")||(fc.nodeValue == "\t")) ? fc.nextSibling : fc;
		// end hack
		// tn.style.display = "none";
		document.body.removeChild(tn);
		return ret;
	}
	*/
	var nodes = [];
	for(var x=0; x<parent.childNodes.length; x++){
		nodes.push(parent.childNodes[x].cloneNode(true));
	}
	tn.style.display = "none"; // FIXME: why do we do this?
	document.body.removeChild(tn);
	return nodes;
}

/* TODO: merge placeOnScreen and placeOnScreenPoint to make 1 function that allows you
 * to define which corner(s) you want to bind to. Something like so:
 *
 * kes(node, desiredX, desiredY, "TR")
 * kes(node, [desiredX, desiredY], ["TR", "BL"])
 *
 * TODO: make this function have variable call sigs
 *
 * kes(node, ptArray, cornerArray, padding, hasScroll)
 * kes(node, ptX, ptY, cornerA, cornerB, cornerC, paddingArray, hasScroll)
 */

/**
 * Keeps 'node' in the visible area of the screen while trying to
 * place closest to desiredX, desiredY. The input coordinates are
 * expected to be the desired screen position, not accounting for
 * scrolling. If you already accounted for scrolling, set 'hasScroll'
 * to true. Set padding to either a number or array for [paddingX, paddingY]
 * to put some buffer around the element you want to position.
 * NOTE: node is assumed to be absolutely or relatively positioned.
 *
 * Alternate call sig:
 *  placeOnScreen(node, [x, y], padding, hasScroll)
 *
 * Examples:
 *  placeOnScreen(node, 100, 200)
 *  placeOnScreen("myId", [800, 623], 5)
 *  placeOnScreen(node, 234, 3284, [2, 5], true)
 */
dojo.html.placeOnScreen = function(node, desiredX, desiredY, padding, hasScroll) {
	if(dojo.lang.isArray(desiredX)) {
		hasScroll = padding;
		padding = desiredY;
		desiredY = desiredX[1];
		desiredX = desiredX[0];
	}

	if(!isNaN(padding)) {
		padding = [Number(padding), Number(padding)];
	} else if(!dojo.lang.isArray(padding)) {
		padding = [0, 0];
	}

	var scroll = dojo.html.getScrollOffset();
	var view = dojo.html.getViewportSize();

	node = dojo.byId(node);
	var w = node.offsetWidth + padding[0];
	var h = node.offsetHeight + padding[1];

	if(hasScroll) {
		desiredX -= scroll.x;
		desiredY -= scroll.y;
	}

	var x = desiredX + w;
	if(x > view.w) {
		x = view.w - w;
	} else {
		x = desiredX;
	}
	x = Math.max(padding[0], x) + scroll.x;

	var y = desiredY + h;
	if(y > view.h) {
		y = view.h - h;
	} else {
		y = desiredY;
	}
	y = Math.max(padding[1], y) + scroll.y;

	node.style.left = x + "px";
	node.style.top = y + "px";

	var ret = [x, y];
	ret.x = x;
	ret.y = y;
	return ret;
}

/**
 * Like placeOnScreenPoint except that it attempts to keep one of the node's
 * corners at desiredX, desiredY.  Favors the bottom right position
 *
 * Examples placing node at mouse position (where e = [Mouse event]):
 *  placeOnScreenPoint(node, e.clientX, e.clientY);
 */
dojo.html.placeOnScreenPoint = function(node, desiredX, desiredY, padding, hasScroll) {
	if(dojo.lang.isArray(desiredX)) {
		hasScroll = padding;
		padding = desiredY;
		desiredY = desiredX[1];
		desiredX = desiredX[0];
	}

	if(!isNaN(padding)) {
		padding = [Number(padding), Number(padding)];
	} else if(!dojo.lang.isArray(padding)) {
		padding = [0, 0];
	}

	var scroll = dojo.html.getScrollOffset();
	var view = dojo.html.getViewportSize();

	node = dojo.byId(node);
	var oldDisplay = node.style.display;
	node.style.display="";
	var w = dojo.style.getInnerWidth(node);
	var h = dojo.style.getInnerHeight(node);
	node.style.display=oldDisplay;

	if(hasScroll) {
		desiredX -= scroll.x;
		desiredY -= scroll.y;
	}

	var x = -1, y = -1;
	//dojo.debug((desiredX+padding[0]) + w, "<=", view.w, "&&", (desiredY+padding[1]) + h, "<=", view.h);
	if((desiredX+padding[0]) + w <= view.w && (desiredY+padding[1]) + h <= view.h) { // TL
		x = (desiredX+padding[0]);
		y = (desiredY+padding[1]);
		//dojo.debug("TL", x, y);
	}

	//dojo.debug((desiredX-padding[0]), "<=", view.w, "&&", (desiredY+padding[1]) + h, "<=", view.h);
	if((x < 0 || y < 0) && (desiredX-padding[0]) <= view.w && (desiredY+padding[1]) + h <= view.h) { // TR
		x = (desiredX-padding[0]) - w;
		y = (desiredY+padding[1]);
		//dojo.debug("TR", x, y);
	}

	//dojo.debug((desiredX+padding[0]) + w, "<=", view.w, "&&", (desiredY-padding[1]), "<=", view.h);
	if((x < 0 || y < 0) && (desiredX+padding[0]) + w <= view.w && (desiredY-padding[1]) <= view.h) { // BL
		x = (desiredX+padding[0]);
		y = (desiredY-padding[1]) - h;
		//dojo.debug("BL", x, y);
	}

	//dojo.debug((desiredX-padding[0]), "<=", view.w, "&&", (desiredY-padding[1]), "<=", view.h);
	if((x < 0 || y < 0) && (desiredX-padding[0]) <= view.w && (desiredY-padding[1]) <= view.h) { // BR
		x = (desiredX-padding[0]) - w;
		y = (desiredY-padding[1]) - h;
		//dojo.debug("BR", x, y);
	}

	if(x < 0 || y < 0 || (x + w > view.w) || (y + h > view.h)) {
		return dojo.html.placeOnScreen(node, desiredX, desiredY, padding, hasScroll);
	}

	x += scroll.x;
	y += scroll.y;

	node.style.left = x + "px";
	node.style.top = y + "px";

	var ret = [x, y];
	ret.x = x;
	ret.y = y;
	return ret;
}

/**
 * For IE z-index schenanigans
 * Two possible uses:
 *   1. new dojo.html.BackgroundIframe(node)
 *        Makes a background iframe as a child of node, that fills area (and position) of node
 *
 *   2. new dojo.html.BackgroundIframe()
 *        Attaches frame to document.body.  User must call size() to set size.
 */
dojo.html.BackgroundIframe = function(node) {
	if(dojo.render.html.ie) {
		var html=
				 "<iframe "
				+"style='position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;"
				+        "z-index: -1; filter:Alpha(Opacity=\"0\");' "
				+">";
		this.iframe = document.createElement(html);
		if(node){
			node.appendChild(this.iframe);
			this.domNode=node;
		}else{
			document.body.appendChild(this.iframe);
			this.iframe.style.display="none";
		}
	}
}
dojo.lang.extend(dojo.html.BackgroundIframe, {
	iframe: null,

	// TODO: this function shouldn't be necessary but setting width=height=100% doesn't work!
	onResized: function(){
		if(this.iframe && this.domNode){
			var w = dojo.style.getOuterWidth(this.domNode);
			var h = dojo.style.getOuterHeight(this.domNode);
			if (w  == 0 || h == 0 ){
				dojo.lang.setTimeout(this, this.onResized, 50);
				return;
			}
			var s = this.iframe.style;
			s.width = w + "px";
			s.height = h + "px";
		}
	},

	// Call this function if the iframe is connected to document.body rather
	// than the node being shadowed (TODO: erase)
	size: function(node) {
		if(!this.iframe) { return; }

		coords = dojo.style.toCoordinateArray(node, true);

		var s = this.iframe.style;
		s.width = coords.w + "px";
		s.height = coords.h + "px";
		s.left = coords.x + "px";
		s.top = coords.y + "px";
	},

	setZIndex: function(node /* or number */) {
		if(!this.iframe) { return; }

		if(dojo.dom.isNode(node)) {
			this.iframe.style.zIndex = dojo.html.getStyle(node, "z-index") - 1;
		} else if(!isNaN(node)) {
			this.iframe.style.zIndex = node;
		}
	},

	show: function() {
		if(!this.iframe) { return; }
		this.iframe.style.display = "block";
	},

	hide: function() {
		if(!this.ie) { return; }
		var s = this.iframe.style;
		s.display = "none";
	},

	remove: function() {
		dojo.dom.removeNode(this.iframe);
	}
});

__CPAN_FILE__ src/html/layout.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.html.layout");

dojo.require("dojo.lang");
dojo.require("dojo.string");
dojo.require("dojo.style");
dojo.require("dojo.html");

/**
 * Layout a bunch of child dom nodes within a parent dom node
 * Input is an array of objects like:
 * @ container - parent node
 * @ layoutPriority - "top-bottom" or "left-right"
 * @ children an array like [ {domNode: foo, layoutAlign: "bottom" }, {domNode: bar, layoutAlign: "client"} ]
 */
dojo.html.layout = function(container, children, layoutPriority) {
	dojo.html.addClass(container, "dojoLayoutContainer");

	// copy children array and remove elements w/out layout
	children = dojo.lang.filter(children, function(child){
		return dojo.lang.inArray(["top","bottom","left","right","client","flood"], child.layoutAlign)
	});

	// order the children according to layoutPriority
	if(layoutPriority && layoutPriority!="none"){
		var rank = function(child){
			switch(child.layoutAlign){
				case "flood":
					return 1;
				case "left":
				case "right":
					return (layoutPriority=="left-right") ? 2 : 3;
				case "top":
				case "bottom":
					return (layoutPriority=="left-right") ? 3 : 2;
				default:
					return 4;
			}
		};
		children.sort(function(a,b){ return rank(a)-rank(b); });
	}

	// remaining space (blank area where nothing has been written)
	var f={
		top: dojo.style.getPixelValue(container, "padding-top", true),
		left: dojo.style.getPixelValue(container, "padding-left", true),
		height: dojo.style.getContentHeight(container),
		width: dojo.style.getContentWidth(container)
	};

	// set positions/sizes
	dojo.lang.forEach(children, function(child){
		var elm=child.domNode;
		var pos=child.layoutAlign;

		// set elem to upper left corner of unused space; may move it later
		with(elm.style){
			left = f.left+"px";
			top = f.top+"px";
			bottom = "auto";
			right = "auto";
		}
		dojo.html.addClass(elm, "dojoAlign" + dojo.string.capitalize(pos));

		// set size && adjust record of remaining space.
		// note that setting the width of a <div> may affect it's height.
		// TODO: same is true for widgets but need to implement API to support that
		if ( (pos=="top")||(pos=="bottom") ) {
			dojo.style.setOuterWidth(elm, f.width);
			var h = dojo.style.getOuterHeight(elm);
			f.height -= h;
			if(pos=="top"){
				f.top += h;
			}else{
				elm.style.top = f.top + f.height + "px";
			}
		}else if(pos=="left" || pos=="right"){
			dojo.style.setOuterHeight(elm, f.height);
			var w = dojo.style.getOuterWidth(elm);
			f.width -= w;
			if(pos=="left"){
				f.left += w;
			}else{
				elm.style.left = f.left + f.width + "px";
			}
		} else if(pos=="flood" || pos=="client"){
			dojo.style.setOuterWidth(elm, f.width);
			dojo.style.setOuterHeight(elm, f.height);
		}
		
		// TODO: for widgets I want to call resizeTo(), but for top/bottom
		// alignment I only want to set the width, and have the size determined
		// dynamically.  (The thinner you make a div, the more height it consumes.)
		if(child.onResized){
			child.onResized();
		}
	});
};

// This is essential CSS to make layout work (it isn't "styling" CSS)
// make sure that the position:absolute in dojoAlign* overrides other classes
dojo.style.insertCssText(
	".dojoLayoutContainer{ position: relative; display: block; }\n" +
	"body .dojoAlignTop, body .dojoAlignBottom, body .dojoAlignLeft, body .dojoAlignRight { position: absolute; overflow: hidden; }\n" +
	"body .dojoAlignClient, body .dojoAlignFloat { position: absolute; overflow: auto; }\n"
);


__CPAN_FILE__ src/html/shadow.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.html.shadow");

dojo.require("dojo.lang");
dojo.require("dojo.uri");

dojo.html.shadow = function(node) {
	this.init(node);
}

dojo.lang.extend(dojo.html.shadow, {

	shadowPng: dojo.uri.dojoUri("src/html/images/shadow"),
	shadowThickness: 8,
	shadowOffset: 15,

	init: function(node){
		this.node=node;

		// make all the pieces of the shadow, and position/size them as much
		// as possible (but a lot of the coordinates are set in sizeShadow
		this.pieces={};
		var x1 = -1 * this.shadowThickness;
		var y0 = this.shadowOffset;
		var y1 = this.shadowOffset + this.shadowThickness;
		this._makePiece("tl", "top", y0, "left", x1);
		this._makePiece("l", "top", y1, "left", x1, "scale");
		this._makePiece("tr", "top", y0, "left", 0);
		this._makePiece("r", "top", y1, "left", 0, "scale");
		this._makePiece("bl", "top", 0, "left", x1);
		this._makePiece("b", "top", 0, "left", 0, "crop");
		this._makePiece("br", "top", 0, "left", 0);
	},

	_makePiece: function(name, vertAttach, vertCoord, horzAttach, horzCoord, sizing){
		var img;
		var url = this.shadowPng + name.toUpperCase() + ".png";
		if(dojo.render.html.ie){
			img=document.createElement("div");
			img.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+url+"'"+
			(sizing?", sizingMethod='"+sizing+"'":"") + ")";
		}else{
			img=document.createElement("img");
			img.src=url;
		}
		img.style.position="absolute";
		img.style[vertAttach]=vertCoord+"px";
		img.style[horzAttach]=horzCoord+"px";
		img.style.width=this.shadowThickness+"px";
		img.style.height=this.shadowThickness+"px";
		this.pieces[name]=img;
		this.node.appendChild(img);
	},

	size: function(width, height){
		var sideHeight = height - (this.shadowOffset+this.shadowThickness+1);
		with(this.pieces){
			l.style.height = sideHeight+"px";
			r.style.height = sideHeight+"px";
			b.style.width = (width-1)+"px";
			bl.style.top = (height-1)+"px";
			b.style.top = (height-1)+"px";
			br.style.top = (height-1)+"px";
			tr.style.left = (width-1)+"px";
			r.style.left = (width-1)+"px";
			br.style.left = (width-1)+"px";
		}
	}
});


__CPAN_FILE__ src/html/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.html", "dojo.html.extras", "dojo.html.shadow"]
});
dojo.provide("dojo.html.*");

__CPAN_DIR__ src/html/images
__CPAN_FILE__ src/html/images/shadowB.png
PNG

   IHDR        d   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<  hIDATx1n0
Q}C<%:>Am jZv   pFtum  -"  iG][6 Y7~ NAs~l 6 r7.9yk[;k6e6m@ <wj ,  j[;3gS{>J[DBm];s_ y@ (|o^&[jM1@AGnmM  K_  -lj7v^_Zo&||3 x YvMm{d{  31Ws C7} ` |fZoN    IENDB`
__CPAN_FILE__ src/html/images/shadowBL.png
PNG

   IHDR            gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   IDATx4 D!DH"c<1zZ~_j84	8|!UnHs ^S\NGD8pGY)q%	d4M"Ny.LeYxS_ =5bd5    IENDB`
__CPAN_FILE__ src/html/images/shadowBR.png
PNG

   IHDR            gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   IDATx4OI <sEZ1u]"r*v O{cqiZ*(bU	q1r ) sB^K'Z+w`oZJicL3K'M ?    IENDB`
__CPAN_FILE__ src/html/images/shadowL.png
PNG

   IHDR          C   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   &IDATxbLHHfee0(fdd4@ 
Zu    IENDB`
__CPAN_FILE__ src/html/images/shadowR.png
PNG

   IHDR          C   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   'IDATxbLII)g``#H  @@    IENDB`
__CPAN_FILE__ src/html/images/shadowT.png
PNG

   IHDR         8A   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   *IDATxbHOOdb``b?%"Lqb\  7)    IENDB`
__CPAN_FILE__ src/html/images/shadowTL.png
PNG

   IHDR            gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   IDATx,A0e[.qA(QveY;rVkEymy8(R=v][kIpHf.}c,Zf	>q&WG57=;@S	)O 9uc    IENDB`
__CPAN_FILE__ src/html/images/shadowTR..png
PNG

   IHDR         ;J   bKGD      	pHYs        tIME0^   tEXtComment Created with The GIMPd%n   IDATx@D?o&"-LD4[NfM:Z	+03<GEPKyF=P7r[um/iCy.6vO9\7yPH {,pB7TkS<	vd~N:{nW[XaJq    IENDB`
__CPAN_FILE__ src/html/images/shadowTR.png
PNG

   IHDR            gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   IDATx D(b%x]=Xt4Iqy&VJR;SZkh.`}':"`<1m[;+3Z+bKB`*@{_%YZY >x{i>&n]^`,04 `    IENDB`
__CPAN_DIR__ src/io
__CPAN_FILE__ src/io/BrowserIO.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.io.BrowserIO");

dojo.require("dojo.io");
dojo.require("dojo.lang.array");
dojo.require("dojo.lang.func");
dojo.require("dojo.string.extras");
dojo.require("dojo.dom");
dojo.require("dojo.undo.browser");

dojo.io.checkChildrenForFile = function(node){
	var hasFile = false;
	var inputs = node.getElementsByTagName("input");
	dojo.lang.forEach(inputs, function(input){
		if(hasFile){ return; }
		if(input.getAttribute("type")=="file"){
			hasFile = true;
		}
	});
	return hasFile;
}

dojo.io.formHasFile = function(formNode){
	return dojo.io.checkChildrenForFile(formNode);
}

dojo.io.updateNode = function(node, urlOrArgs){
	node = dojo.byId(node);
	var args = urlOrArgs;
	if(dojo.lang.isString(urlOrArgs)){
		args = { url: urlOrArgs };
	}
	args.mimetype = "text/html";
	args.load = function(t, d, e){
		while(node.firstChild){
			if(dojo["event"]){
				try{
					dojo.event.browser.clean(node.firstChild);
				}catch(e){}
			}
			node.removeChild(node.firstChild);
		}
		node.innerHTML = d;
	};
	dojo.io.bind(args);
}

dojo.io.formFilter = function(node) {
	var type = (node.type||"").toLowerCase();
	return !node.disabled && node.name
		&& !dojo.lang.inArray(type, ["file", "submit", "image", "reset", "button"]);
}

// TODO: Move to htmlUtils
dojo.io.encodeForm = function(formNode, encoding, formFilter){
	if((!formNode)||(!formNode.tagName)||(!formNode.tagName.toLowerCase() == "form")){
		dojo.raise("Attempted to encode a non-form element.");
	}
	if(!formFilter) { formFilter = dojo.io.formFilter; }
	var enc = /utf/i.test(encoding||"") ? encodeURIComponent : dojo.string.encodeAscii;
	var values = [];

	for(var i = 0; i < formNode.elements.length; i++){
		var elm = formNode.elements[i];
		if(!elm || elm.tagName.toLowerCase() == "fieldset" || !formFilter(elm)) { continue; }
		var name = enc(elm.name);
		var type = elm.type.toLowerCase();

		if(type == "select-multiple"){
			for(var j = 0; j < elm.options.length; j++){
				if(elm.options[j].selected) {
					values.push(name + "=" + enc(elm.options[j].value));
				}
			}
		}else if(dojo.lang.inArray(type, ["radio", "checkbox"])){
			if(elm.checked){
				values.push(name + "=" + enc(elm.value));
			}
		}else{
			values.push(name + "=" + enc(elm.value));
		}
	}

	// now collect input type="image", which doesn't show up in the elements array
	var inputs = formNode.getElementsByTagName("input");
	for(var i = 0; i < inputs.length; i++) {
		var input = inputs[i];
		if(input.type.toLowerCase() == "image" && input.form == formNode
			&& formFilter(input)) {
			var name = enc(input.name);
			values.push(name + "=" + enc(input.value));
			values.push(name + ".x=0");
			values.push(name + ".y=0");
		}
	}
	return values.join("&") + "&";
}

dojo.io.FormBind = function(args) {
	this.bindArgs = {};

	if(args && args.formNode) {
		this.init(args);
	} else if(args) {
		this.init({formNode: args});
	}
}
dojo.lang.extend(dojo.io.FormBind, {
	form: null,

	bindArgs: null,

	clickedButton: null,

	init: function(args) {
		var form = dojo.byId(args.formNode);

		if(!form || !form.tagName || form.tagName.toLowerCase() != "form") {
			throw new Error("FormBind: Couldn't apply, invalid form");
		} else if(this.form == form) {
			return;
		} else if(this.form) {
			throw new Error("FormBind: Already applied to a form");
		}

		dojo.lang.mixin(this.bindArgs, args);
		this.form = form;

		this.connect(form, "onsubmit", "submit");

		for(var i = 0; i < form.elements.length; i++) {
			var node = form.elements[i];
			if(node && node.type && dojo.lang.inArray(node.type.toLowerCase(), ["submit", "button"])) {
				this.connect(node, "onclick", "click");
			}
		}

		var inputs = form.getElementsByTagName("input");
		for(var i = 0; i < inputs.length; i++) {
			var input = inputs[i];
			if(input.type.toLowerCase() == "image" && input.form == form) {
				this.connect(input, "onclick", "click");
			}
		}
	},

	onSubmit: function(form) {
		return true;
	},

	submit: function(e) {
		e.preventDefault();
		if(this.onSubmit(this.form)) {
			dojo.io.bind(dojo.lang.mixin(this.bindArgs, {
				formFilter: dojo.lang.hitch(this, "formFilter")
			}));
		}
	},

	click: function(e) {
		var node = e.currentTarget;
		if(node.disabled) { return; }
		this.clickedButton = node;
	},

	formFilter: function(node) {
		var type = (node.type||"").toLowerCase();
		var accept = false;
		if(node.disabled || !node.name) {
			accept = false;
		} else if(dojo.lang.inArray(type, ["submit", "button", "image"])) {
			if(!this.clickedButton) { this.clickedButton = node; }
			accept = node == this.clickedButton;
		} else {
			accept = !dojo.lang.inArray(type, ["file", "submit", "reset", "button"]);
		}
		return accept;
	},

	// in case you don't have dojo.event.* pulled in
	connect: function(srcObj, srcFcn, targetFcn) {
		if(dojo.evalObjPath("dojo.event.connect")) {
			dojo.event.connect(srcObj, srcFcn, this, targetFcn);
		} else {
			var fcn = dojo.lang.hitch(this, targetFcn);
			srcObj[srcFcn] = function(e) {
				if(!e) { e = window.event; }
				if(!e.currentTarget) { e.currentTarget = e.srcElement; }
				if(!e.preventDefault) { e.preventDefault = function() { window.event.returnValue = false; } }
				fcn(e);
			}
		}
	}
});

dojo.io.XMLHTTPTransport = new function(){
	var _this = this;

	var _cache = {}; // FIXME: make this public? do we even need to?
	this.useCache = false; // if this is true, we'll cache unless kwArgs.useCache = false
	this.preventCache = false; // if this is true, we'll always force GET requests to cache

	// FIXME: Should this even be a function? or do we just hard code it in the next 2 functions?
	function getCacheKey(url, query, method) {
		return url + "|" + query + "|" + method.toLowerCase();
	}

	function addToCache(url, query, method, http) {
		_cache[getCacheKey(url, query, method)] = http;
	}

	function getFromCache(url, query, method) {
		return _cache[getCacheKey(url, query, method)];
	}

	this.clearCache = function() {
		_cache = {};
	}

	// moved successful load stuff here
	function doLoad(kwArgs, http, url, query, useCache) {
		if((http.status==200)||(http.status==304)||(http.status==204)||
			(location.protocol=="file:" && (http.status==0 || http.status==undefined))||
			(location.protocol=="chrome:" && (http.status==0 || http.status==undefined))
		){
			var ret;
			if(kwArgs.method.toLowerCase() == "head"){
				var headers = http.getAllResponseHeaders();
				ret = {};
				ret.toString = function(){ return headers; }
				var values = headers.split(/[\r\n]+/g);
				for(var i = 0; i < values.length; i++) {
					var pair = values[i].match(/^([^:]+)\s*:\s*(.+)$/i);
					if(pair) {
						ret[pair[1]] = pair[2];
					}
				}
			}else if(kwArgs.mimetype == "text/javascript"){
				try{
					ret = dj_eval(http.responseText);
				}catch(e){
					dojo.debug(e);
					dojo.debug(http.responseText);
					ret = null;
				}
			}else if(kwArgs.mimetype == "text/json"){
				try{
					ret = dj_eval("("+http.responseText+")");
				}catch(e){
					dojo.debug(e);
					dojo.debug(http.responseText);
					ret = false;
				}
			}else if((kwArgs.mimetype == "application/xml")||
						(kwArgs.mimetype == "text/xml")){
				ret = http.responseXML;
				if(!ret || typeof ret == "string") {
					ret = dojo.dom.createDocumentFromText(http.responseText);
				}
			}else{
				ret = http.responseText;
			}

			if(useCache){ // only cache successful responses
				addToCache(url, query, kwArgs.method, http);
			}
			kwArgs[(typeof kwArgs.load == "function") ? "load" : "handle"]("load", ret, http, kwArgs);
		}else{
			var errObj = new dojo.io.Error("XMLHttpTransport Error: "+http.status+" "+http.statusText);
			kwArgs[(typeof kwArgs.error == "function") ? "error" : "handle"]("error", errObj, http, kwArgs);
		}
	}

	// set headers (note: Content-Type will get overriden if kwArgs.contentType is set)
	function setHeaders(http, kwArgs){
		if(kwArgs["headers"]) {
			for(var header in kwArgs["headers"]) {
				if(header.toLowerCase() == "content-type" && !kwArgs["contentType"]) {
					kwArgs["contentType"] = kwArgs["headers"][header];
				} else {
					http.setRequestHeader(header, kwArgs["headers"][header]);
				}
			}
		}
	}

	this.inFlight = [];
	this.inFlightTimer = null;

	this.startWatchingInFlight = function(){
		if(!this.inFlightTimer){
			this.inFlightTimer = setInterval("dojo.io.XMLHTTPTransport.watchInFlight();", 10);
		}
	}

	this.watchInFlight = function(){
		var now = null;
		for(var x=this.inFlight.length-1; x>=0; x--){
			var tif = this.inFlight[x];
			if(!tif){ this.inFlight.splice(x, 1); continue; }
			if(4==tif.http.readyState){
				// remove it so we can clean refs
				this.inFlight.splice(x, 1);
				doLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);
			}else if (tif.startTime){
				//See if this is a timeout case.
				if(!now){
					now = (new Date()).getTime();
				}
				if(tif.startTime + (tif.req.timeoutSeconds * 1000) < now){
					//Stop the request.
					if(typeof tif.http.abort == "function"){
						tif.http.abort();
					}

					// remove it so we can clean refs
					this.inFlight.splice(x, 1);
					tif.req[(typeof tif.req.timeout == "function") ? "timeout" : "handle"]("timeout", null, tif.http, tif.req);
				}
			}
		}

		if(this.inFlight.length == 0){
			clearInterval(this.inFlightTimer);
			this.inFlightTimer = null;
		}
	}

	var hasXmlHttp = dojo.hostenv.getXmlhttpObject() ? true : false;
	this.canHandle = function(kwArgs){
		// canHandle just tells dojo.io.bind() if this is a good transport to
		// use for the particular type of request.

		// FIXME: we need to determine when form values need to be
		// multi-part mime encoded and avoid using this transport for those
		// requests.
		return hasXmlHttp
			&& dojo.lang.inArray((kwArgs["mimetype"].toLowerCase()||""), ["text/plain", "text/html", "application/xml", "text/xml", "text/javascript", "text/json"])
			&& !( kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"]) );
	}

	this.multipartBoundary = "45309FFF-BD65-4d50-99C9-36986896A96F";	// unique guid as a boundary value for multipart posts

	this.bind = function(kwArgs){
		if(!kwArgs["url"]){
			// are we performing a history action?
			if( !kwArgs["formNode"]
				&& (kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"] || kwArgs["watchForURL"])
				&& (!djConfig.preventBackButtonFix)) {
        dojo.deprecated("Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request is deprecated. Use dojo.undo.browser.addToHistory() instead.");
				dojo.undo.browser.addToHistory(kwArgs);
				return true;
			}
		}

		// build this first for cache purposes
		var url = kwArgs.url;
		var query = "";
		if(kwArgs["formNode"]){
			var ta = kwArgs.formNode.getAttribute("action");
			if((ta)&&(!kwArgs["url"])){ url = ta; }
			var tp = kwArgs.formNode.getAttribute("method");
			if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
		}

		if(url.indexOf("#") > -1) {
			dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
			url = url.split("#")[0];
		}

		if(kwArgs["file"]){
			// force post for file transfer
			kwArgs.method = "post";
		}

		if(!kwArgs["method"]){
			kwArgs.method = "get";
		}

		// guess the multipart value		
		if(kwArgs.method.toLowerCase() == "get"){
			// GET cannot use multipart
			kwArgs.multipart = false;
		}else{
			if(kwArgs["file"]){
				// enforce multipart when sending files
				kwArgs.multipart = true;
			}else if(!kwArgs["multipart"]){
				// default 
				kwArgs.multipart = false;
			}
		}

		if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
			dojo.undo.browser.addToHistory(kwArgs);
		}

		var content = kwArgs["content"] || {};

		if(kwArgs.sendTransport) {
			content["dojo.transport"] = "xmlhttp";
		}

		do { // break-block
			if(kwArgs.postContent){
				query = kwArgs.postContent;
				break;
			}

			if(content) {
				query += dojo.io.argsFromMap(content, kwArgs.encoding);
			}
			
			if(kwArgs.method.toLowerCase() == "get" || !kwArgs.multipart){
				break;
			}

			var	t = [];
			if(query.length){
				var q = query.split("&");
				for(var i = 0; i < q.length; ++i){
					if(q[i].length){
						var p = q[i].split("=");
						t.push(	"--" + this.multipartBoundary,
								"Content-Disposition: form-data; name=\"" + p[0] + "\"", 
								"",
								p[1]);
					}
				}
			}

			if(kwArgs.file){
				if(dojo.lang.isArray(kwArgs.file)){
					for(var i = 0; i < kwArgs.file.length; ++i){
						var o = kwArgs.file[i];
						t.push(	"--" + this.multipartBoundary,
								"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
								"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
								"",
								o.content);
					}
				}else{
					var o = kwArgs.file;
					t.push(	"--" + this.multipartBoundary,
							"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
							"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
							"",
							o.content);
				}
			}

			if(t.length){
				t.push("--"+this.multipartBoundary+"--", "");
				query = t.join("\r\n");
			}
		}while(false);

		// kwArgs.Connection = "close";

		var async = kwArgs["sync"] ? false : true;

		var preventCache = kwArgs["preventCache"] ||
			(this.preventCache == true && kwArgs["preventCache"] != false);
		var useCache = kwArgs["useCache"] == true ||
			(this.useCache == true && kwArgs["useCache"] != false );

		// preventCache is browser-level (add query string junk), useCache
		// is for the local cache. If we say preventCache, then don't attempt
		// to look in the cache, but if useCache is true, we still want to cache
		// the response
		if(!preventCache && useCache){
			var cachedHttp = getFromCache(url, query, kwArgs.method);
			if(cachedHttp){
				doLoad(kwArgs, cachedHttp, url, query, false);
				return;
			}
		}

		// much of this is from getText, but reproduced here because we need
		// more flexibility
		var http = dojo.hostenv.getXmlhttpObject(kwArgs);	
		var received = false;

		// build a handler function that calls back to the handler obj
		if(async){
			var startTime = 
			// FIXME: setting up this callback handler leaks on IE!!!
			this.inFlight.push({
				"req":		kwArgs,
				"http":		http,
				"url":	 	url,
				"query":	query,
				"useCache":	useCache,
				"startTime": kwArgs.timeoutSeconds ? (new Date()).getTime() : 0
			});
			this.startWatchingInFlight();
		}

		if(kwArgs.method.toLowerCase() == "post"){
			// FIXME: need to hack in more flexible Content-Type setting here!
			http.open("POST", url, async);
			setHeaders(http, kwArgs);
			http.setRequestHeader("Content-Type", kwArgs.multipart ? ("multipart/form-data; boundary=" + this.multipartBoundary) : 
				(kwArgs.contentType || "application/x-www-form-urlencoded"));
			try{
				http.send(query);
			}catch(e){
				if(typeof http.abort == "function"){
					http.abort();
				}
				doLoad(kwArgs, {status: 404}, url, query, useCache);
			}
		}else{
			var tmpUrl = url;
			if(query != "") {
				tmpUrl += (tmpUrl.indexOf("?") > -1 ? "&" : "?") + query;
			}
			if(preventCache) {
				tmpUrl += (dojo.string.endsWithAny(tmpUrl, "?", "&")
					? "" : (tmpUrl.indexOf("?") > -1 ? "&" : "?")) + "dojo.preventCache=" + new Date().valueOf();
			}
			http.open(kwArgs.method.toUpperCase(), tmpUrl, async);
			setHeaders(http, kwArgs);
			try {
				http.send(null);
			}catch(e)	{
				if(typeof http.abort == "function"){
					http.abort();
				}
				doLoad(kwArgs, {status: 404}, url, query, useCache);
			}
		}

		if( !async ) {
			doLoad(kwArgs, http, url, query, useCache);
		}

		kwArgs.abort = function(){
			return http.abort();
		}

		return;
	}
	dojo.io.transports.addTransport("XMLHTTPTransport");
}

__CPAN_FILE__ src/io/cookie.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.io.cookie");

dojo.io.cookie.setCookie = function(name, value, days, path, domain, secure) {
	var expires = -1;
	if(typeof days == "number" && days >= 0) {
		var d = new Date();
		d.setTime(d.getTime()+(days*24*60*60*1000));
		expires = d.toGMTString();
	}
	value = escape(value);
	document.cookie = name + "=" + value + ";"
		+ (expires != -1 ? " expires=" + expires + ";" : "")
		+ (path ? "path=" + path : "")
		+ (domain ? "; domain=" + domain : "")
		+ (secure ? "; secure" : "");
}

dojo.io.cookie.set = dojo.io.cookie.setCookie;

dojo.io.cookie.getCookie = function(name) {
	// FIXME: Which cookie should we return?
	//        If there are cookies set for different sub domains in the current
	//        scope there could be more than one cookie with the same name.
	//        I think taking the last one in the list takes the one from the
	//        deepest subdomain, which is what we're doing here.
	var idx = document.cookie.lastIndexOf(name+'=');
	if(idx == -1) { return null; }
	value = document.cookie.substring(idx+name.length+1);
	var end = value.indexOf(';');
	if(end == -1) { end = value.length; }
	value = value.substring(0, end);
	value = unescape(value);
	return value;
}

dojo.io.cookie.get = dojo.io.cookie.getCookie;

dojo.io.cookie.deleteCookie = function(name) {
	dojo.io.cookie.setCookie(name, "-", 0);
}

dojo.io.cookie.setObjectCookie = function(name, obj, days, path, domain, secure, clearCurrent) {
	if(arguments.length == 5) { // for backwards compat
		clearCurrent = domain;
		domain = null;
		secure = null;
	}
	var pairs = [], cookie, value = "";
	if(!clearCurrent) { cookie = dojo.io.cookie.getObjectCookie(name); }
	if(days >= 0) {
		if(!cookie) { cookie = {}; }
		for(var prop in obj) {
			if(prop == null) {
				delete cookie[prop];
			} else if(typeof obj[prop] == "string" || typeof obj[prop] == "number") {
				cookie[prop] = obj[prop];
			}
		}
		prop = null;
		for(var prop in cookie) {
			pairs.push(escape(prop) + "=" + escape(cookie[prop]));
		}
		value = pairs.join("&");
	}
	dojo.io.cookie.setCookie(name, value, days, path, domain, secure);
}

dojo.io.cookie.getObjectCookie = function(name) {
	var values = null, cookie = dojo.io.cookie.getCookie(name);
	if(cookie) {
		values = {};
		var pairs = cookie.split("&");
		for(var i = 0; i < pairs.length; i++) {
			var pair = pairs[i].split("=");
			var value = pair[1];
			if( isNaN(value) ) { value = unescape(pair[1]); }
			values[ unescape(pair[0]) ] = value;
		}
	}
	return values;
}

dojo.io.cookie.isSupported = function() {
	if(typeof navigator.cookieEnabled != "boolean") {
		dojo.io.cookie.setCookie("__TestingYourBrowserForCookieSupport__",
			"CookiesAllowed", 90, null);
		var cookieVal = dojo.io.cookie.getCookie("__TestingYourBrowserForCookieSupport__");
		navigator.cookieEnabled = (cookieVal == "CookiesAllowed");
		if(navigator.cookieEnabled) {
			// FIXME: should we leave this around?
			this.deleteCookie("__TestingYourBrowserForCookieSupport__");
		}
	}
	return navigator.cookieEnabled;
}

// need to leave this in for backwards-compat from 0.1 for when it gets pulled in by dojo.io.*
if(!dojo.io.cookies) { dojo.io.cookies = dojo.io.cookie; }

__CPAN_FILE__ src/io/cookies.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.deprecated("dojo.io.cookies has been replaced by dojo.io.cookie");
dojo.require("dojo.io.cookie");
if(!dojo.io.cookies) { dojo.io.cookies = dojo.io.cookie; }
dojo.provide("dojo.io.cookies");

__CPAN_FILE__ src/io/IframeIO.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.io.IframeIO");
dojo.require("dojo.io.BrowserIO");
dojo.require("dojo.uri.*");

// FIXME: is it possible to use the Google htmlfile hack to prevent the
// background click with this transport?

dojo.io.createIFrame = function(fname, onloadstr){
	if(window[fname]){ return window[fname]; }
	if(window.frames[fname]){ return window.frames[fname]; }
	var r = dojo.render.html;
	var cframe = null;
	var turi = dojo.uri.dojoUri("iframe_history.html?noInit=true");
	var ifrstr = ((r.ie)&&(dojo.render.os.win)) ? "<iframe name='"+fname+"' src='"+turi+"' onload='"+onloadstr+"'>" : "iframe";
	cframe = document.createElement(ifrstr);
	with(cframe){
		name = fname;
		setAttribute("name", fname);
		id = fname;
	}
	(document.body||document.getElementsByTagName("body")[0]).appendChild(cframe);
	window[fname] = cframe;
	with(cframe.style){
		position = "absolute";
		left = top = "0px";
		height = width = "1px";
		visibility = "hidden";
		/*
		if(djConfig.isDebug){
			position = "relative";
			height = "300px";
			width = "600px";
			visibility = "visible";
		}
		*/
	}

	if(!r.ie){
		dojo.io.setIFrameSrc(cframe, turi, true);
		cframe.onload = new Function(onloadstr);
	}
	return cframe;
}

// thanks burstlib!
dojo.io.iframeContentWindow = function(iframe_el) {
	var win = iframe_el.contentWindow || // IE
		dojo.io.iframeContentDocument(iframe_el).defaultView || // Moz, opera
		// Moz. TODO: is this available when defaultView isn't?
		dojo.io.iframeContentDocument(iframe_el).__parent__ || 
		(iframe_el.name && document.frames[iframe_el.name]) || null;
	return win;
}

dojo.io.iframeContentDocument = function(iframe_el){
	var doc = iframe_el.contentDocument || // W3
		(
			(iframe_el.contentWindow)&&(iframe_el.contentWindow.document)
		) ||  // IE
		(
			(iframe_el.name)&&(document.frames[iframe_el.name])&&
			(document.frames[iframe_el.name].document)
		) || null;
	return doc;
}

dojo.io.IframeTransport = new function(){
	var _this = this;
	this.currentRequest = null;
	this.requestQueue = [];
	this.iframeName = "dojoIoIframe";

	this.fireNextRequest = function(){
		if((this.currentRequest)||(this.requestQueue.length == 0)){ return; }
		// dojo.debug("fireNextRequest");
		var cr = this.currentRequest = this.requestQueue.shift();
		cr._contentToClean = [];
		var fn = cr["formNode"];
		var content = cr["content"] || {};
		if(cr.sendTransport) {
			content["dojo.transport"] = "iframe";
		}
		if(fn){
			if(content){
				// if we have things in content, we need to add them to the form
				// before submission
				for(var x in content){
					if(!fn[x]){
						var tn;
						if(dojo.render.html.ie){
							tn = document.createElement("<input type='hidden' name='"+x+"' value='"+content[x]+"'>");
							fn.appendChild(tn);
						}else{
							tn = document.createElement("input");
							fn.appendChild(tn);
							tn.type = "hidden";
							tn.name = x;
							tn.value = content[x];
						}
						cr._contentToClean.push(x);
					}else{
						fn[x].value = content[x];
					}
				}
			}
			if(cr["url"]){
				cr._originalAction = fn.getAttribute("action");
				fn.setAttribute("action", cr.url);
			}
			if(!fn.getAttribute("method")){
				fn.setAttribute("method", (cr["method"]) ? cr["method"] : "post");
			}
			cr._originalTarget = fn.getAttribute("target");
			fn.setAttribute("target", this.iframeName);
			fn.target = this.iframeName;
			fn.submit();
		}else{
			// otherwise we post a GET string by changing URL location for the
			// iframe
			var query = dojo.io.argsFromMap(this.currentRequest.content);
			var tmpUrl = (cr.url.indexOf("?") > -1 ? "&" : "?") + query;
			dojo.io.setIFrameSrc(this.iframe, tmpUrl, true);
		}
	}

	this.canHandle = function(kwArgs){
		return (
			(
				// FIXME: can we really handle text/plain and
				// text/javascript requests?
				dojo.lang.inArray(kwArgs["mimetype"], 
				[	"text/plain", "text/html", 
					"application/xml", "text/xml", 
					"text/javascript", "text/json"])
			)&&(
				// make sur we really only get used in file upload cases	
				(kwArgs["formNode"])&&(dojo.io.checkChildrenForFile(kwArgs["formNode"]))
			)&&(
				dojo.lang.inArray(kwArgs["method"].toLowerCase(), ["post", "get"])
			)&&(
				// never handle a sync request
				!  ((kwArgs["sync"])&&(kwArgs["sync"] == true))
			)
		);
	}

	this.bind = function(kwArgs){
		if(!this["iframe"]){ this.setUpIframe(); }
		this.requestQueue.push(kwArgs);
		this.fireNextRequest();
		return;
	}

	this.setUpIframe = function(){

		// NOTE: IE 5.0 and earlier Mozilla's don't support an onload event for
		//       iframes. OTOH, we don't care.
		this.iframe = dojo.io.createIFrame(this.iframeName, "dojo.io.IframeTransport.iframeOnload();");
	}

	this.iframeOnload = function(){
		if(!_this.currentRequest){
			_this.fireNextRequest();
			return;
		}

		var req = _this.currentRequest;

		// remove all the hidden content inputs
		var toClean = req._contentToClean;
		for(var i = 0; i < toClean.length; i++) {
			var key = toClean[i];
			var input = req.formNode[key];
			req.formNode.removeChild(input);
			req.formNode[key] = null;
		}
		// restore original action + target
		if(req["_originalAction"]){
			req.formNode.setAttribute("action", req._originalAction);
		}
		req.formNode.setAttribute("target", req._originalTarget);
		req.formNode.target = req._originalTarget;

		var ifr = _this.iframe;
		var ifw = dojo.io.iframeContentWindow(ifr);
		// handle successful returns
		// FIXME: how do we determine success for iframes? Is there an equiv of
		// the "status" property?
		var value;
		var success = false;

		try{
			var cmt = req.mimetype;
			if((cmt == "text/javascript")||(cmt == "text/json")){
				// FIXME: not sure what to do here? try to pull some evalulable
				// text from a textarea or cdata section? 
				// how should we set up the contract for that?
				var cd = dojo.io.iframeContentDocument(_this.iframe);
				var js = cd.getElementsByTagName("textarea")[0].value;
				if(cmt == "text/json") { js = "(" + js + ")"; }
				value = dj_eval(js);
			}else if((cmt == "application/xml")||(cmt == "text/xml")){
				value = dojo.io.iframeContentDocument(_this.iframe);
			}else{ // text/plain
				value = ifw.innerHTML;
			}
			success = true;
		}catch(e){ 
			// looks like we didn't get what we wanted!
			var errObj = new dojo.io.Error("IframeTransport Error");
			if(dojo.lang.isFunction(req["error"])){
				req.error("error", errObj, req);
			}
		}

		// don't want to mix load function errors with processing errors, thus
		// a separate try..catch
		try {
			if(success && dojo.lang.isFunction(req["load"])){
				req.load("load", value, req);
			}
		} catch(e) {
			throw e;
		} finally {
			_this.currentRequest = null;
			_this.fireNextRequest();
		}
	}

	dojo.io.transports.addTransport("IframeTransport");
}

__CPAN_FILE__ src/io/RepubsubIO.js
//	Copyright (c) 2004 Friendster Inc., Licensed under the Academic Free
//	License version 2.0 or later 

dojo.require("dojo.event.Event");
dojo.require("dojo.event.BrowserEvent");
dojo.require("dojo.io.BrowserIO");

dojo.provide("dojo.io.RepubsubIO");
dojo.provide("dojo.io.repubsub");
dojo.provide("dojo.io.repubsubTransport");

dojo.io.repubsubTranport = new function(){
	var rps = dojo.io.repubsub;
	this.canHandle = function(kwArgs){
		if((kwArgs["mimetype"] == "text/javascript")&&(kwArgs["method"] == "repubsub")){
			return true;
		}
		return false;
	}

	this.bind = function(kwArgs){
		if(!rps.isInitialized){
			// open up our tunnel, queue up requests anyway
			rps.init();
		}
		// FIXME: we need to turn this into a topic subscription
		// var tgtURL = kwArgs.url+"?"+dojo.io.argsFromMap(kwArgs.content);
		// sampleTransport.sendRequest(tgtURL, hdlrFunc);

		// a normal "bind()" call in a request-response transport layer is
		// something that (usually) encodes most of it's payload with the
		// request. Multi-event systems like repubsub are a bit more complex,
		// and repubsub in particular distinguishes the publish and subscribe
		// portions of thep rocess with different method calls to handle each.
		// Therefore, a "bind" in the sense of repubsub must first determine if
		// we have an open subscription to a channel provided by the server,
		// and then "publish" the request payload if there is any. We therefore
		// must take care not to incorrectly or too agressively register or
		// file event handlers which are provided with the kwArgs method.

		// NOTE: we ONLY pay attention to those event handlers that are
		// registered with the bind request that subscribes to the channel. If
		// event handlers are provided with subsequent requests, we might in
		// the future support some additive or replacement syntax, but for now
		// they get dropped on the floor.

		// NOTE: in this case, url MUST be the "topic" to which we
		// subscribe/publish for this channel
		if(!rps.topics[kwArgs.url]){
			kwArgs.rpsLoad = function(evt){
				kwArgs.load("load", evt);
			}
			rps.subscribe = function(kwArgs.url, kwArgs, "rpsLoad");
		}

		if(kwArgs["content"]){
			// what we wanted to send
			var cEvt = dojo.io.repubsubEvent.initFromProperties(kwArgs.content);
			rps.publish(kwArgs.url, cEvt);
		}
	}

	dojo.io.transports.addTransport("repubsubTranport");
}

dojo.io.repubsub = new function(){
	this.initDoc = "init.html";
	this.isInitialized = false;
	this.subscriptionBacklog = [];
	this.debug = true;
	this.rcvNodeName = null;
	this.sndNodeName = null;
	this.rcvNode = null;
	this.sndNode = null;
	this.canRcv = false;
	this.canSnd = false;
	this.canLog = false;
	this.sndTimer = null;
	this.windowRef = window;
	this.backlog = [];
	this.tunnelInitCount = 0;
	this.tunnelFrameKey = "tunnel_frame";
	this.serverBaseURL = location.protocol+"//"+location.host+location.pathname;
	this.logBacklog = [];
	this.getRandStr = function(){
		return Math.random().toString().substring(2, 10);
	}
	this.userid = "guest";
	this.tunnelID = this.getRandStr();
	this.attachPathList = [];
	this.topics = []; // list of topics we have listeners to

	// actually, now that I think about it a little bit more, it would sure be
	// useful to parse out the <script> src attributes. We're looking for
	// something with a "do_method=lib", since that's what would have included
	// us in the first place (in the common case).
	this.parseGetStr = function(){
		var baseUrl = document.location.toString();
		var params = baseUrl.split("?", 2);
		if(params.length > 1){
			var paramStr = params[1];
			var pairs = paramStr.split("&");
			var opts = [];
			for(var x in pairs){
				var sp = pairs[x].split("=");
				// FIXME: is this eval dangerous?
				try{
					opts[sp[0]]=eval(sp[1]);
				}catch(e){
					opts[sp[0]]=sp[1];
				}
			}
			return opts;
		}else{
			return [];
		}
	}

	// parse URL params and use them as default vals
	var getOpts = this.parseGetStr();
	for(var x in getOpts){
		// FIXME: should I be checking for undefined here before setting? Does
		//        that buy me anything?
		this[x] = getOpts[x];
	}

	if(!this["tunnelURI"]){
		this.tunnelURI = [	"/who/", escape(this.userid), "/s/", 
							this.getRandStr(), "/kn_journal"].join("");
		// this.tunnelURI = this.absoluteTopicURI(this.tunnelURI);
	}

	/*
	if (self.kn_tunnelID) kn.tunnelID = self.kn_tunnelID; // the server says
	if (kn._argv.kn_tunnelID) kn.tunnelID = kn._argv.kn_tunnelID; // the url says
	*/

	// check the options object if it exists and use its properties as an
	// over-ride
	if(window["repubsubOpts"]||window["rpsOpts"]){
		var optObj = window["repubsubOpts"]||window["rpsOpts"];
		for(var x in optObj){
			this[x] = optObj[x]; // copy the option object properties
		}
	}

	// things that get called directly from our iframe to inform us of events
	this.tunnelCloseCallback = function(){
		// when we get this callback, we should immediately attempt to re-start
		// our tunnel connection
		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc+"?callback=repubsub.rcvNodeReady&domain="+document.domain);
	}

	this.receiveEventFromTunnel = function(evt, srcWindow){
		// we should never be getting events from windows we didn't create
		// NOTE: events sourced from the local window are also supported for
		// 		 debugging purposes

		// any event object MUST have a an "elements" property
		if(!evt["elements"]){
			this.log("bailing! event received without elements!", "error");
			return;
		}

		// if the event passes some minimal sanity tests, we need to attempt to
		// dispatch it!

		// first, it seems we have to munge the event object a bit
		var e = {};
		for(var i=0; i<evt.elements.length; i++){
			var ee = evt.elements[i];
			e[ee.name||ee.nameU] = (ee.value||ee.valueU);
			// FIXME: need to enable this only in some extreme debugging mode!
			this.log("[event]: "+(ee.name||ee.nameU)+": "+e[ee.name||ee.nameU]);
		}

		// NOTE: the previous version of this library put a bunch of code here
		// to manage state that tried to make sure that we never, ever, lost
		// any info about an event. If we unload RIGHT HERE, I don't think it's
		// going to make a huge difference one way or another. Time will tell.

		// and with THAT out of the way, dispatch it!
		this.dispatch(e);

		// TODO: remove the script block that created the event obj to save
		// memory, etc.
	}

	this.widenDomain = function(domainStr){
		// the purpose of this is to set the most liberal domain policy
		// available
		var cd = domainStr||document.domain;
		if(cd.indexOf(".")==-1){ return; } // probably file:/// or localhost
		var dps = cd.split(".");
		if(dps.length<=2){ return; } // probably file:/// or an RFC 1918 address
		dps = dps.slice(dps.length-2);
		document.domain = dps.join(".");
	}

	// FIXME: parseCookie and setCookie should be methods that are more broadly
	// available. Perhaps in htmlUtils?

	this.parseCookie = function(){
		var cs = document.cookie;
		var keypairs = cs.split(";");
		for(var x=0; x<keypairs.length; x++){
			keypairs[x] = keypairs[x].split("=");
			if(x!=keypairs.length-1){ cs+=";"; }
		}
		return keypairs;
	}

	this.setCookie = function(keypairs, clobber){
		// NOTE: we want to only ever set session cookies, so never provide an
		// 		 expires date
		if((clobber)&&(clobber==true)){ document.cookie = ""; }
		var cs = "";
		for(var x=0; x<keypairs.length; x++){
			cs += keypairs[x][0]+"="+keypairs[x][1];
			if(x!=keypairs.length-1){ cs+=";"; }
		}
		document.cookie = cs;
	}

	// FIXME: need to replace w/ dojo.log.*
	this.log = function(str, lvl){
		if(!this.debug){ return; } // we of course only care if we're in debug mode
		while(this.logBacklog.length>0){
			if(!this.canLog){ break; }
			var blo = this.logBacklog.shift();
			this.writeLog("["+blo[0]+"]: "+blo[1], blo[2]);
		}
		this.writeLog(str, lvl);
	}

	this.writeLog = function(str, lvl){
		dojo.debug(((new Date()).toLocaleTimeString())+": "+str);
	}

	this.init = function(){
		this.widenDomain();
		// this.findPeers();
		this.openTunnel();
		this.isInitialized = true;
		// FIXME: this seems like entirely the wrong place to replay the backlog
		while(this.subscriptionBacklog.length){
			this.subscribe.apply(this, this.subscriptionBacklog.shift());
		}
	}

	this.clobber = function(){
		if(this.rcvNode){
			this.setCookie( [
					[this.tunnelFrameKey,"closed"],
					["path","/"]
				], false 
			);
		}
	}

	this.openTunnel = function(){
		// We create two iframes here:

		// one for getting data
		this.rcvNodeName = "rcvIFrame_"+this.getRandStr();
		// set cookie that can be used to find the receiving iframe
		this.setCookie( [
				[this.tunnelFrameKey,this.rcvNodeName],
				["path","/"]
			], false
		);

		this.rcvNode = dojo.io.createIFrame(this.rcvNodeName);
		// FIXME: set the src attribute here to the initialization URL
		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc+"?callback=repubsub.rcvNodeReady&domain="+document.domain);

		// the other for posting data in reply

		this.sndNodeName = "sndIFrame_"+this.getRandStr();
		this.sndNode = dojo.io.createIFrame(this.sndNodeName);
		// FIXME: set the src attribute here to the initialization URL
		dojo.io.setIFrameSrc(this.sndNode, this.initDoc+"?callback=repubsub.sndNodeReady&domain="+document.domain);

	}

	this.rcvNodeReady = function(){
		// FIXME: why is this sequence number needed? Why isn't the UID gen
		// 		  function enough?
        var statusURI = [this.tunnelURI, '/kn_status/', this.getRandStr(), '_', 
						 String(this.tunnelInitCount++)].join(""); 
            // (kn._seqNum++); // FIXME: !!!!
		// this.canRcv = true;
		this.log("rcvNodeReady");
		// FIXME: initialize receiver and request the base topic
		// dojo.io.setIFrameSrc(this.rcvNode, this.serverBaseURL+"/kn?do_method=blank");
		var initURIArr = [	this.serverBaseURL, "/kn?kn_from=", escape(this.tunnelURI),
							"&kn_id=", escape(this.tunnelID), "&kn_status_from=", 
							escape(statusURI)];
		// FIXME: does the above really need a kn_response_flush? won't the
		// 		  server already know? If not, what good is it anyway?
		dojo.io.setIFrameSrc(this.rcvNode, initURIArr.join(""));

		// setup a status path listener, but don't tell the server about it,
		// since it already knows we're itnerested in our own tunnel status
		this.subscribe(statusURI, this, "statusListener", true);

		this.log(initURIArr.join(""));
	}

	this.sndNodeReady = function(){
		this.canSnd = true;
		this.log("sndNodeReady");
		this.log(this.backlog.length);
		// FIXME: handle any pent-up send commands
		if(this.backlog.length > 0){
			this.dequeueEvent();
		}
	}

	this.statusListener = function(evt){
		this.log("status listener called");
		this.log(evt.status, "info");
	}

	// this handles local event propigation
	this.dispatch = function(evt){
		// figure out what topic it came from
		if(evt["to"]||evt["kn_routed_from"]){
			var rf = evt["to"]||evt["kn_routed_from"];
			// split off the base server URL
			var topic = rf.split(this.serverBaseURL, 2)[1];
			if(!topic){
				// FIXME: how do we recover when we don't get a sane "from"? Do
				// we try to route to it anyway?
				topic = rf;
			}
			this.log("[topic] "+topic);
			if(topic.length>3){
				if(topic.slice(0, 3)=="/kn"){
					topic = topic.slice(3);
				}
			}
			if(this.attachPathList[topic]){
				this.attachPathList[topic](evt);
			}
		}
	}

	this.subscribe = function(	topic /* kn_from in the old terminilogy */, 
								toObj, toFunc, dontTellServer){
		if(!this.isInitialized){
			this.subscriptionBacklog.push([topic, toObj, toFunc, dontTellServer]);
			return;
		}
		if(!this.attachPathList[topic]){
			this.attachPathList[topic] = function(){ return true; }
			this.log("subscribing to: "+topic);
			this.topics.push(topic);
		}
		var revt = new dojo.io.repubsubEvent(this.tunnelURI, topic, "route");
		var rstr = [this.serverBaseURL+"/kn", revt.toGetString()].join("");
		dojo.event.kwConnect({
			once: true,
			srcObj: this.attachPathList, 
			srcFunc: topic, 
			adviceObj: toObj, 
			adviceFunc: toFunc
		});
		// NOTE: the above is a local mapping, if we're not the leader, we
		// 		 should connect our mapping to the topic handler of the peer
		// 		 leader, this ensures that not matter what happens to the
		// 		 leader, we don't really loose our heads if/when the leader
		// 		 goes away.
		if(!this.rcvNode){ /* this should be an error! */ }
		if(dontTellServer){
			return;
		}
		this.log("sending subscription to: "+topic);
		// create a subscription event object and give it all the props we need
		// to updates on the specified topic

		// FIXME: we should only enqueue if this is our first subscription!
		this.sendTopicSubToServer(topic, rstr);
	}

	this.sendTopicSubToServer = function(topic, str){
		if(!this.attachPathList[topic]["subscriptions"]){
			this.enqueueEventStr(str);
			this.attachPathList[topic].subscriptions = 0;
		}
		this.attachPathList[topic].subscriptions++;
	}

	this.unSubscribe = function(topic, toObj, toFunc){
		// first, locally disconnect
		dojo.event.kwDisconnect({
			srcObj: this.attachPathList, 
			srcFunc: topic, 
			adviceObj: toObj, 
			adviceFunc: toFunc
		});
		
		// FIXME: figure out if there are any remaining listeners to the topic,
		// 		  and if not, inform the server of our desire not to be
		// 		  notified of updates to the topic
	}

	// the "publish" method is really a misnomer, since it really means "take
	// this event and send it to the server". Note that the "dispatch" method
	// handles local event promigulation, and therefore we emulate both sides
	// of a real event router without having to swallow all of the complexity.
	this.publish = function(topic, event){
		var evt = dojo.io.repubsubEvent.initFromProperties(event);
		// FIXME: need to make sure we have from and to set correctly
		// 		  before we serialize and send off to the great blue
		// 		  younder.
		evt.to = topic;
		// evt.from = this.tunnelURI;

		var evtURLParts = [];
		evtURLParts.push(this.serverBaseURL+"/kn");

		// serialize the event to a string and then post it to the correct
		// topic
		evtURLParts.push(evt.toGetString());
		this.enqueueEventStr(evtURLParts.join(""));
	}

	this.enqueueEventStr = function(evtStr){
		this.log("enqueueEventStr");
		this.backlog.push(evtStr);
		this.dequeueEvent();
	}

	this.dequeueEvent = function(force){
		this.log("dequeueEvent");
		if(this.backlog.length <= 0){ return; }
		if((this.canSnd)||(force)){
			dojo.io.setIFrameSrc(this.sndNode, this.backlog.shift()+"&callback=repubsub.sndNodeReady");
			this.canSnd = false;
		}else{
			this.log("sndNode not available yet!", "debug");
		}
	}
}

dojo.io.repubsubEvent = function(to, from, method, id, routeURI, payload, dispname, uid){
	this.to = to;
	this.from = from;
	this.method = method||"route";
	this.id = id||repubsub.getRandStr();
	this.uri = routeURI;
	this.displayname = dispname||repubsub.displayname;
	this.userid = uid||repubsub.userid;
	this.payload = payload||"";
	this.flushChars = 4096;

	this.initFromProperties = function(evt){
		if(evt.constructor = dojo.io.repubsubEvent){ 
			for(var x in evt){
				this[x] = evt[x];
			}
		}else{
			// we want to copy all the properties of the evt object, and transform
			// those that are "stock" properties of dojo.io.repubsubEvent. All others should
			// be copied as-is
			for(var x in evt){
				if(typeof this.forwardPropertiesMap[x] == "string"){
					this[this.forwardPropertiesMap[x]] = evt[x];
				}else{
					this[x] = evt[x];
				}
			}
		}
	}

	this.toGetString = function(noQmark){
		var qs = [ ((noQmark) ? "" : "?") ];
		for(var x=0; x<this.properties.length; x++){
			var tp = this.properties[x];
			if(this[tp[0]]){
				qs.push(tp[1]+"="+encodeURIComponent(String(this[tp[0]])));
			}
			// FIXME: we need to be able to serialize non-stock properties!!!
		}
		return qs.join("&");
	}

}

dojo.io.repubsubEvent.prototype.properties = [["from", "kn_from"], ["to", "kn_to"], 
									["method", "do_method"], ["id", "kn_id"], 
									["uri", "kn_uri"], 
									["displayname", "kn_displayname"], 
									["userid", "kn_userid"], 
									["payload", "kn_payload"],
									["flushChars", "kn_response_flush"],
									["responseFormat", "kn_response_format"] ];

// maps properties from their old names to their new names...
dojo.io.repubsubEvent.prototype.forwardPropertiesMap = {};
// ...and vice versa...
dojo.io.repubsubEvent.prototype.reversePropertiesMap = {};

// and we then populate them both from the properties list
for(var x=0; x<dojo.io.repubsubEvent.prototype.properties.length; x++){
	var tp = dojo.io.repubsubEvent.prototype.properties[x];
	dojo.io.repubsubEvent.prototype.reversePropertiesMap[tp[0]] = tp[1];
	dojo.io.repubsubEvent.prototype.forwardPropertiesMap[tp[1]] = tp[0];
}
// static version of initFromProperties, creates new event and object and
// returns it after init
dojo.io.repubsubEvent.initFromProperties = function(evt){
	var eventObj = new dojo.io.repubsubEvent();
	eventObj.initFromProperties(evt);
	return eventObj;
}

__CPAN_FILE__ src/io/RhinoIO.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.io.RhinoIO");

// TODO: this doesn't execute
/*dojo.io.SyncHTTPRequest = function(){
	dojo.io.SyncRequest.call(this);

	this.send = function(URI){
	}
}

dojo.inherits(dojo.io.SyncHTTPRequest, dojo.io.SyncRequest);
*/

__CPAN_FILE__ src/io/ScriptSrcIO.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.io.ScriptSrcIO");
dojo.require("dojo.io.BrowserIO");
dojo.require("dojo.undo.browser");

//FIXME: should constantParams be JS object?
//FIXME: check dojo.io calls. Can we move the BrowserIO defined calls somewhere
//       else so that we don't depend on BrowserIO at all? The dependent calls
//       have to do with dealing with forms and making query params from JS object.
/**
 * See test_ScriptSrcIO.html for usage information.
 * Notes:
 * - The watchInFlight timer is set to 100 ms instead of 10ms (which is what BrowserIO.js uses).
 */
dojo.io.ScriptSrcTransport = new function(){
	this.preventCache = false; // if this is true, we'll always force GET requests to not cache
	this.maxUrlLength = 1000; //Used to calculate if script request should be multipart.
	this.inFlightTimer = null;

	this.DsrStatusCodes = {
		Continue: 100,
		Ok: 200,
		Error: 500
	};

	this.startWatchingInFlight = function(){
		if(!this.inFlightTimer){
			this.inFlightTimer = setInterval("dojo.io.ScriptSrcTransport.watchInFlight();", 100);
		}
	}

	this.watchInFlight = function(){
		var totalCount = 0;
		var doneCount = 0;
		for(var param in this._state){
			totalCount++;
			var currentState = this._state[param];
			if(currentState.isDone){
				doneCount++;
				delete this._state[param];
			}else{
				var listener = currentState.kwArgs;
				try{
					if(currentState.checkString && eval("typeof(" + currentState.checkString + ") != 'undefined'")){
						this._finish(currentState, "load");
						doneCount++;
						delete this._state[param];
					}else if(listener.timeoutSeconds && listener.timeout){
						if(currentState.startTime + (listener.timeoutSeconds * 1000) < (new Date()).getTime()){
							this._finish(currentState, "timeout");
							doneCount++;
							delete this._state[param];
						}
					}else if(!listener.timeoutSeconds){
						//Increment the done count if no timeout is specified, so
						//that we turn off the timer if all that is left in the state
						//list are things we can't clean up because they fail without
						//getting a callback.
						doneCount++;
					}
				}catch(e){
					this._finish(currentState, "error", {status: this.DsrStatusCodes.Error, response: e});
				}
			}
		}
	
		if(doneCount == totalCount){
			clearInterval(this.inFlightTimer);
			this.inFlightTimer = null;
		}
	}

	this.canHandle = function(kwArgs){
		return dojo.lang.inArray((kwArgs["mimetype"].toLowerCase()), ["text/javascript", "text/json"])
			&& (kwArgs["method"].toLowerCase() == "get")
			&& !(kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"]))
			&& (!kwArgs["sync"] || kwArgs["sync"] == false)
			&& !kwArgs["file"]
			&& !kwArgs["multipart"];
	}

	/**
	 * Removes any script tags from the DOM that may have been added by ScriptSrcTransport.
	 * Be careful though, by removing them from the script, you may invalidate some
	 * script objects that were defined by the js file that was pulled in as the
	 * src of the script tag. Test carefully if you decide to call this method.
	 * 
	 * In MSIE 6 (and probably 5.x), if you removed the script element while 
	 * part of the script is still executing, the browser will crash.
	 */
	this.removeScripts = function(){
		var scripts = document.getElementsByTagName("script");
		for(var i = 0; scripts && i < scripts.length; i++){
			var scriptTag = scripts[i];
			if(scriptTag.className == "ScriptSrcTransport"){
				var parent = scriptTag.parentNode;
				parent.removeChild(scriptTag);
				i--; //Set the index back one since we removed an item.
			}
		}
	}

	this.bind = function(kwArgs){
		//START duplication from BrowserIO.js (some changes made)
		var url = kwArgs.url;
		var query = "";
		
		if(kwArgs["formNode"]){
			var ta = kwArgs.formNode.getAttribute("action");
			if((ta)&&(!kwArgs["url"])){ url = ta; }
			var tp = kwArgs.formNode.getAttribute("method");
			if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
		}

		if(url.indexOf("#") > -1) {
			dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
			url = url.split("#")[0];
		}

		//Break off the domain/path of the URL.
		var urlParts = url.split("?");
		if(urlParts && urlParts.length == 2){
			url = urlParts[0];
			query += (query ? "&" : "") + urlParts[1];
		}

		if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
			dojo.undo.browser.addToHistory(kwArgs);
		}

		//Create an ID for the request.
		var id = kwArgs["apiId"] ? kwArgs["apiId"] : "id" + this._counter++;

		//Fill out any other content pieces.
		var content = kwArgs["content"];
		var jsonpName = kwArgs.jsonParamName;
		if(kwArgs.sendTransport || jsonpName) {
			if (!content){
				content = {};
			}
			if(kwArgs.sendTransport){
				content["dojo.transport"] = "scriptsrc";
			}

			if(jsonpName){
				content[jsonpName] = "dojo.io.ScriptSrcTransport._state." + id + ".jsonpCall";
			}
		}

		if(kwArgs.postContent){
			query = kwArgs.postContent;
		}else if(content){
			query += ((query) ? "&" : "") + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);
		}
		//END duplication from BrowserIO.js

		//START DSR

		//If an apiId is specified, then we want to make sure useRequestId is true.
		if(kwArgs["apiId"]){
			kwArgs["useRequestId"] = true;
		}

		//Set up the state for this request.
		var state = {
			"id": id,
			"idParam": "_dsrid=" + id,
			"url": url,
			"query": query,
			"kwArgs": kwArgs,
			"startTime": (new Date()).getTime()
		};

		if(!url){
			//Error. An URL is needed.
			this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.none"});
			return;
		}

		//If this is a jsonp request, intercept the jsonp callback
		if(content && content[jsonpName]){
			state.jsonp = content[jsonpName];
			state.jsonpCall = function(data){
				if(data["Error"]||data["error"]){
					dojo.debug(dojo.json.serialize(data));
					dojo.io.ScriptSrcTransport._finish(this, "error", data);
				}else{
					dojo.io.ScriptSrcTransport._finish(this, "load", data);
				}
			};
		}

		//Only store the request state on the state tracking object if a callback
		//is expected or if polling on a checkString will be done.
		if(kwArgs["useRequestId"] || kwArgs["checkString"] || state["jsonp"]){
			this._state[id] = state;
		}

		//A checkstring is a string that if evaled will not be undefined once the
		//script src loads. Used as an alternative to depending on a callback from
		//the script file. If this is set, then multipart is not assumed to be used,
		//since multipart requires a specific callback. With checkString we will be doing
		//polling.
		if(kwArgs["checkString"]){
			state.checkString = kwArgs["checkString"];
		}

		//Constant params are parameters that should always be sent with each
		//part of a multipart URL.
		state.constantParams = (kwArgs["constantParams"] == null ? "" : kwArgs["constantParams"]);
	
		if(kwArgs["preventCache"] ||
			(this.preventCache == true && kwArgs["preventCache"] != false)){
			state.nocacheParam = "dojo.preventCache=" + new Date().valueOf();
		}else{
			state.nocacheParam = "";
		}

		//Get total length URL, if we were to do it as one URL.
		//Add some padding, extra & separators.
		var urlLength = state.url.length + state.query.length + state.constantParams.length 
				+ state.nocacheParam.length + this._extraPaddingLength;

		if(kwArgs["useRequestId"]){
			urlLength += state.idParam.length;
		}
		
		if(!kwArgs["checkString"] && kwArgs["useRequestId"] 
			&& !state["jsonp"] && !kwArgs["forceSingleRequest"]
			&& urlLength > this.maxUrlLength){
			if(url > this.maxUrlLength){
				//Error. The URL domain and path are too long. We can't
				//segment that, so return an error.
				this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.tooBig"});
				return;
			}else{
				//Start the multiple requests.
				this._multiAttach(state, 1);
			}
		}else{
			//Send one URL.
			var queryParams = [state.constantParams, state.nocacheParam, state.query];
			if(kwArgs["useRequestId"] && !state["jsonp"]){
				queryParams.unshift(state.idParam);
			}
			var finalUrl = this._buildUrl(state.url, queryParams);

			//Track the final URL in case we need to use that instead of api ID when receiving
			//the load callback.
			state.finalUrl = finalUrl;
			
			this._attach(state.id, finalUrl);
		}
		//END DSR

		this.startWatchingInFlight();
	}
	
	//Private properties/methods
	this._counter = 1;
	this._state = {};
	this._extraPaddingLength = 16;

	//Is there a dojo function for this already?
	this._buildUrl = function(url, nameValueArray){
		var finalUrl = url;
		var joiner = "?";
		for(var i = 0; i < nameValueArray.length; i++){
			if(nameValueArray[i]){
				finalUrl += joiner + nameValueArray[i];
				joiner = "&";
			}
		}

		return finalUrl;
	}

	this._attach = function(id, url){
		//Attach the script to the DOM.
		var element = document.createElement("script");
		element.type = "text/javascript";
		element.src = url;
		element.id = id;
		element.className = "ScriptSrcTransport";
		document.getElementsByTagName("head")[0].appendChild(element);
	}

	this._multiAttach = function(state, part){
		//Check to make sure we still have a query to send up. This is mostly
		//a protection from a goof on the server side when it sends a part OK
		//response instead of a final response.
		if(state.query == null){
			this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "query.null"});
			return;
		}

		if(!state.constantParams){
			state.constantParams = "";
		}

		//How much of the query can we take?
		//Add a padding constant to account for _part and a couple extra amperstands.
		//Also add space for id since we'll need it now.
		var queryMax = this.maxUrlLength - state.idParam.length
					 - state.constantParams.length - state.url.length
					 - state.nocacheParam.length - this._extraPaddingLength;
		
		//Figure out if this is the last part.
		var isDone = state.query.length < queryMax;
	
		//Break up the query string if necessary.
		var currentQuery;
		if(isDone){
			currentQuery = state.query;
			state.query = null;
		}else{
			//Find the & or = nearest the max url length.
			var ampEnd = state.query.lastIndexOf("&", queryMax - 1);
			var eqEnd = state.query.lastIndexOf("=", queryMax - 1);

			//See if & is closer, or if = is right at the edge,
			//which means we should put it on the next URL.
			if(ampEnd > eqEnd || eqEnd == queryMax - 1){
				//& is nearer the end. So just chop off from there.
				currentQuery = state.query.substring(0, ampEnd);
				state.query = state.query.substring(ampEnd + 1, state.query.length) //strip off amperstand with the + 1.
			}else{
				//= is nearer the end. Take the max amount possible. 
				currentQuery = state.query.substring(0, queryMax);
			 
				//Find the last query name in the currentQuery so we can prepend it to
				//ampEnd. Could be -1 (not there), so account for that.
				var queryName = currentQuery.substring((ampEnd == -1 ? 0 : ampEnd + 1), eqEnd);
				state.query = queryName + "=" + state.query.substring(queryMax, state.query.length);
			}
		}
		
		//Now send a part of the script
		var queryParams = [currentQuery, state.idParam, state.constantParams, state.nocacheParam];
		if(!isDone){
			queryParams.push("_part=" + part);
		}

		var url = this._buildUrl(state.url, queryParams);

		this._attach(state.id + "_" + part, url);
	}

	this._finish = function(state, callback, event){
		if(callback != "partOk" && !state.kwArgs[callback] && !state.kwArgs["handle"]){
			//Ignore "partOk" because that is an internal callback.
			if(callback == "error"){
				state.isDone = true;
				throw event;
			}
		}else{
			switch(callback){
				case "load":
					var response = event ? event.response : null;
					if(!response){
						response = event;
					}
					state.kwArgs[(typeof state.kwArgs.load == "function") ? "load" : "handle"]("load", response, event, state.kwArgs);
					state.isDone = true;
					break;
				case "partOk":
					var part = parseInt(event.response.part, 10) + 1;
					//Update the constant params, if any.
					if(event.response.constantParams){
						state.constantParams = event.response.constantParams;
					}
					this._multiAttach(state, part);
					state.isDone = false;
					break;
				case "error":
					state.kwArgs[(typeof state.kwArgs.error == "function") ? "error" : "handle"]("error", event.response, event, state.kwArgs);
					state.isDone = true;
					break;
				default:
					state.kwArgs[(typeof state.kwArgs[callback] == "function") ? callback : "handle"](callback, event, event, state.kwArgs);
					state.isDone = true;
			}
		}
	}

	dojo.io.transports.addTransport("ScriptSrcTransport");
}

//Define callback handler.
window.onscriptload = function(event){
	var state = null;
	var transport = dojo.io.ScriptSrcTransport;
	
	//Find the matching state object for event ID.
	if(transport._state[event.id]){
		state = transport._state[event.id];
	}else{
		//The ID did not match directly to an entry in the state list.
		//Try searching the state objects for a matching original URL.
		var tempState;
		for(var param in transport._state){
			tempState = transport._state[param];
			if(tempState.finalUrl && tempState.finalUrl == event.id){
				state = tempState;
				break;
			}
		}

		//If no matching original URL is found, then use the URL that was actually used
		//in the SCRIPT SRC attribute.
		if(state == null){
			var scripts = document.getElementsByTagName("script");
			for(var i = 0; scripts && i < scripts.length; i++){
				var scriptTag = scripts[i];
				if(scriptTag.getAttribute("class") == "ScriptSrcTransport"
					&& scriptTag.src == event.id){
					state = transport._state[scriptTag.id];
					break;
				}
			}
		}
		
		//If state is still null, then throw an error.
		if(state == null){
			throw "No matching state for onscriptload event.id: " + event.id;
		}
	}

	var callbackName = "error";
	switch(event.status){
		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Continue:
			//A part of a multipart request.
			callbackName = "partOk";
			break;
		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Ok:
			//Successful reponse.
			callbackName = "load";
			break;
	}

	transport._finish(state, callbackName, event);
};

__CPAN_FILE__ src/io/ShortBusInit.html
<html>
<script type="text/javascript">
	if(window!=window.parent){
		function callByDeRef(fname){
			if(!fname){ return null; }
			// if someone inadvertently passed in "foo(...)", we make it "foo"
			fname = String(fname).split("(")[0];
			// get a real array of arguments
			var aa = [];
			for(var x=1; x<arguments.length; x++){
				aa.push(arguments[x]);
			}

			var parts = String(fname).split(".");
			var obj = window;
			for(var x=0; x<parts.length-1; x++){
				obj = obj[parts[x]];
			}
			var fn = parts.pop(); // the last element is the function name
			// exec the function in the specified namespace
			return obj[fn].apply(obj, aa);
		}

		function widenDomain(domainStr){
			// the purpose of this is to set the most liberal domain policy
			var cd = domainStr||document.domain;
			if(cd.indexOf(".")==-1){ 
				document.domain = cd;
				return;
			}
			var dps = cd.split(".");
			if(dps.length>2){ 
				dps = dps.slice(dps.length-2);
			}
			document.domain = dps.join(".");
		}

		function doInit(){

			widenDomain();

			var baseUrl = document.location.toString();
			var params = baseUrl.split("?", 2);
			if(params.length > 1){
				var paramStr = params[1];
				var pairs = paramStr.split("&");
				var opts = [];
				for(var x in pairs){
					// alert(pairs[x]);
					var sp = pairs[x].split("=");
					opts[sp[0]]=sp[1];
					if(sp[0]=="true"){
						sp[0] = true;
					}else if(sp[0]=="false"){
						sp[0] = false;
					}
				}
				if(opts["callback"]){
					callByDeRef("parent."+opts["callback"]);
				}
			}
		}
		doInit();
	}
</script>
</html>

__CPAN_FILE__ src/io/ShortBusIO.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.io.ShortBusIO");
dojo.require("dojo.io"); // io.js provides setIFrameSrc
// FIXME: determine if we can use XMLHTTP to make x-domain posts despite not
//        being able to hear back about the result
dojo.require("dojo.io.IframeIO"); // for posting across domains
dojo.require("dojo.io.cookie"); // for peering
dojo.require("dojo.event.*");

/*
 * this file defines a "forever-frame" style Comet client. It passes opaque
 * JSON data structures to/from the client. Both styles of request provide a
 * topic for the event to be sent to and a payload object to be acted upon.
 *
 * All outbound events are sent via dojo.io.bind() and all inbound requests are
 * processed by Dojo topic dispatch.
 *
 * ShortBusIO packets have the basic format:
 *
 *	{
 *	 	topic: "/destination/topic/name",
 *		body: {
 * 			// ...
 *		}
 * 	}
 * 
 * Packets bound for the event router (not one of it's clients) or generated
 * from it are prefixed with the special "/meta" topic. Meta-topic events
 * either inform the client to take an action or inform the server of a system
 * event.
 *
 * Upon tunnel creation, the server might therefore send the following meta
 * topic packet to the client to inform the client of it's assigned identity:
 *
 *	// client <-- server
 *	{
 *	 	topic: "/meta",
 *		body: {
 * 			action: "setClientId",
 *			clientId: "fooBar23",
 *			tunnelId: "fooBarTunnel4",
 *			tunnelExpiration: "...", // some date in the future
 *		}
 * 	}
 *
 * The client may then respond with a confirmation:
 * 
 *	// client --> server
 *	{
 *	 	topic: "/meta",
 *		body: {
 * 			action: "confirmClientId",
 *			from: "fooBar23"
 *		}
 * 	}
 *
 * The client must implement a basic vocabulary of /meta topic verbs in order
 * to participate as a ShortBus endpoint. These are TBD.
 *
 * NOTE: this example elides any authentication or authorization steps the
 * client and server may have undertaken prior to tunnel setup.
 */

// TODO: unlike repubsubio we don't handle any sort of connection
// subscription/publishing backlog. Should we?

dojo.io.ShortBusTransport = new function(){

	var initialized = false;
	var connected = false;

	// this class is similar to RepubsubIO save that we don't have the
	// externalized protocol handler code. Our messages are simpler so our code
	// can be as well.

	this.rcvNode = null;
	this.rcvNodeName = "";
	this.topicRoot = null;

	this.getRandStr = function(){
		return Math.random().toString().substring(2, 10);
	}

	this.widenDomain = function(domainStr){
		// allow us to make reqests to the TLD
		var cd = domainStr||document.domain;
		if(cd.indexOf(".")==-1){ return; } // probably file:/// or localhost
		var dps = cd.split(".");
		if(dps.length<=2){ return; } // probably file:/// or an RFC 1918 address
		dps = dps.slice(dps.length-2);
		document.domain = dps.join(".");
	}

	this.canHandle = function(kwArgs){
		return (
			(connected)			&&
			(kwArgs["topic"])	&&
			(! // async only!
				((kwArgs["sync"])&&(kwArgs["sync"] == true))
			)
		);
	}

	this.buildConnection = function(){
		// NOTE: we require the server to cooperate by hosting
		// ShortBusInit.html at the designated endpoint
		this.rcvNodeName = "ShortBusRcv_"+this.getRandStr();
		// the "forever frame" approach
		if(dojo.render.html.ie){
			// use the "htmlfile hack" to prevent the background click junk
			this.rcvNode = new ActiveXObject("htmlfile");
			this.rcvNode.open();
			this.rcvNode.write("<html>");
			this.rcvNode.write("<script>document.domain = '"+document.domain+"'");
			this.rcvNode.write("</html>");
			this.rcvNode.close();

			var ifrDiv = this.rcvNode.createElement("div");
			this.rcvNode.appendChild(ifrDiv);
			this.rcvNode.parentWindow.dojo = dojo;
			ifrDiv.innerHTML = "<iframe src='"+this.topicRoot+"/?tunntelType=htmlfile'></iframe>"
			// and we're ready to go!
			connected = true;
		}else{
			this.rcvNode = dojo.io.createIFrame(this.rcvNodeName);
			dojo.io.setIFrameSrc(this.rcvNode, this.topicRoot+"/?tunnelType=iframe");
			// we're still waiting on this one to call back up and advertise
			// that it's been initialized
		}
	}

	this.iframeConnectionInit = function(){
		connected = true;
	}

	this.dispatchServerEvent function(eObj){
		// FIXME: implement basic /meta topic semantics here!
	}

	this.init = function(){
		if(initialized){
			return;
		}
		initialized = true;

		this.widenDomain();

		// we want to set up a connection to the designated server. Grab the
		// server location out of djConfig.
		this.topicRoot = djConfig["ShortBusRoot"];
		if(!this.topicRoot){
			dojo.debug("no topic root specified in djConfig.ShortBusRoot");
			return;
		}
	}

	this.dispatch = function(evt){
		// dipatch events along the specified path
	}

    dojo.io.transports.addTransport("ShortBusTransport");
}

__CPAN_FILE__ src/io/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.io"],
	rhino: ["dojo.io.RhinoIO"],
	browser: ["dojo.io.BrowserIO", "dojo.io.cookie"],
	dashboard: ["dojo.io.BrowserIO", "dojo.io.cookie"]
});
dojo.provide("dojo.io.*");

__CPAN_DIR__ src/lang
__CPAN_FILE__ src/lang/array.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.array");

dojo.require("dojo.lang.common");

// FIXME: Is this worthless since you can do: if(name in obj)
// is this the right place for this?
dojo.lang.has = function(obj, name){
	try{
		return (typeof obj[name] != "undefined");
	}catch(e){ return false; }
}

dojo.lang.isEmpty = function(obj) {
	if(dojo.lang.isObject(obj)) {
		var tmp = {};
		var count = 0;
		for(var x in obj){
			if(obj[x] && (!tmp[x])){
				count++;
				break;
			} 
		}
		return (count == 0);
	} else if(dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)) {
		return obj.length == 0;
	}
}

dojo.lang.map = function(arr, obj, unary_func){
	var isString = dojo.lang.isString(arr);
	if(isString){
		arr = arr.split("");
	}
	if(dojo.lang.isFunction(obj)&&(!unary_func)){
		unary_func = obj;
		obj = dj_global;
	}else if(dojo.lang.isFunction(obj) && unary_func){
		// ff 1.5 compat
		var tmpObj = obj;
		obj = unary_func;
		unary_func = tmpObj;
	}
	if(Array.map){
	 	var outArr = Array.map(arr, unary_func, obj);
	}else{
		var outArr = [];
		for(var i=0;i<arr.length;++i){
			outArr.push(unary_func.call(obj, arr[i]));
		}
	}
	if(isString) {
		return outArr.join("");
	} else {
		return outArr;
	}
}

// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:forEach
dojo.lang.forEach = function(anArray /* Array */, callback /* Function */, thisObject /* Object */){
	if(dojo.lang.isString(anArray)){ 
		anArray = anArray.split(""); 
	}
	if(Array.forEach){
		Array.forEach(anArray, callback, thisObject);
	}else{
		// FIXME: there are several ways of handilng thisObject. Is dj_global always the default context?
		if(!thisObject){
			thisObject=dj_global;
		}
		for(var i=0,l=anArray.length; i<l; i++){ 
			callback.call(thisObject, anArray[i], i, anArray);
		}
	}
}

dojo.lang._everyOrSome = function(every, arr, callback, thisObject){
	if(dojo.lang.isString(arr)){ 
		arr = arr.split(""); 
	}
	if(Array.every){
		return Array[ (every) ? "every" : "some" ](arr, callback, thisObject);
	}else{
		if(!thisObject){
			thisObject = dj_global;
		}
		for(var i=0,l=arr.length; i<l; i++){
			var result = callback.call(thisObject, arr[i], i, arr);
			if((every)&&(!result)){
				return false;
			}else if((!every)&&(result)){
				return true;
			}
		}
		return (every) ? true : false;
	}
}

dojo.lang.every = function(arr, callback, thisObject){
	return this._everyOrSome(true, arr, callback, thisObject);
}

dojo.lang.some = function(arr, callback, thisObject){
	return this._everyOrSome(false, arr, callback, thisObject);
}

dojo.lang.filter = function(arr, callback, thisObject) {
	var isString = dojo.lang.isString(arr);
	if(isString) { arr = arr.split(""); }
	if(Array.filter) {
		var outArr = Array.filter(arr, callback, thisObject);
	} else {
		if(!thisObject) {
			if(arguments.length >= 3) { dojo.raise("thisObject doesn't exist!"); }
			thisObject = dj_global;
		}

		var outArr = [];
		for(var i = 0; i < arr.length; i++) {
			if(callback.call(thisObject, arr[i], i, arr)) {
				outArr.push(arr[i]);
			}
		}
	}
	if(isString) {
		return outArr.join("");
	} else {
		return outArr;
	}
}

/**
 * Creates a 1-D array out of all the arguments passed,
 * unravelling any array-like objects in the process
 *
 * Ex:
 * unnest(1, 2, 3) ==> [1, 2, 3]
 * unnest(1, [2, [3], [[[4]]]]) ==> [1, 2, 3, 4]
 */
dojo.lang.unnest = function(/* ... */) {
	var out = [];
	for(var i = 0; i < arguments.length; i++) {
		if(dojo.lang.isArrayLike(arguments[i])) {
			var add = dojo.lang.unnest.apply(this, arguments[i]);
			out = out.concat(add);
		} else {
			out.push(arguments[i]);
		}
	}
	return out;
}

/**
 * Converts an array-like object (i.e. arguments, DOMCollection)
 * to an array
**/
dojo.lang.toArray = function(arrayLike, startOffset) {
	var array = [];
	for(var i = startOffset||0; i < arrayLike.length; i++) {
		array.push(arrayLike[i]);
	}
	return array;
}

__CPAN_FILE__ src/lang/assert.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.assert");

dojo.require("dojo.lang.common");
dojo.require("dojo.lang.array");
dojo.require("dojo.lang.type");

// -------------------------------------------------------------------
// Assertion methods
// -------------------------------------------------------------------

/**
 * Throws an exception if the assertion fails.
 *
 * If the asserted condition is true, this method does nothing. If the
 * condition is false, we throw an error with a error message.  
 *
 * @param	booleanValue	A boolean value, which needs to be true for the assertion to succeed.
 * @param	message	Optional. A string describing the assertion.
 * @throws	Throws an Error if 'booleanValue' is false.
 */
dojo.lang.assert = function(booleanValue, message){
	if(!booleanValue){
		var errorMessage = "An assert statement failed.\n" +
			"The method dojo.lang.assert() was called with a 'false' value.\n";
		if(message){
			errorMessage += "Here's the assert message:\n" + message + "\n";
		}
		// Use throw instead of dojo.raise, until bug #264 is fixed:
		// dojo.raise(errorMessage);
		throw new Error(errorMessage);
	}
}

/**
 * Given a value and a data type, this method checks the type of the value
 * to make sure it matches the data type, and throws an exception if there
 * is a mismatch.
 *
 * Examples:
 * <pre>
 *   dojo.lang.assertType("foo", String);
 *   dojo.lang.assertType(12345, Number);
 *   dojo.lang.assertType(false, Boolean);
 *   dojo.lang.assertType([6, 8], Array);
 *   dojo.lang.assertType(dojo.lang.assertType, Function);
 *   dojo.lang.assertType({foo: "bar"}, Object);
 *   dojo.lang.assertType(new Date(), Date);
 * </pre>
 *
 * @scope	public function
 * @param	value	Any literal value or object instance.
 * @param	type	A class of object, or a literal type, or the string name of a type, or an array with a list of types.
 * @param	message	Optional. A string describing the assertion.
 * @throws	Throws an Error if 'value' is not of type 'type'.
 */
dojo.lang.assertType = function(value, type, message){
	if(!dojo.lang.isOfType(value, type)){
		if(!message){
			if(!dojo.lang.assertType._errorMessage){
				dojo.lang.assertType._errorMessage = "Type mismatch: dojo.lang.assertType() failed.";
			}
			message = dojo.lang.assertType._errorMessage;
		}
		dojo.lang.assert(false, message);
	}
}

/**
 * Given an anonymous object and a list of expected property names, this
 * method check to make sure the object does not have any properties
 * that aren't on the list of expected properties, and throws an Error
 * if there are unexpected properties. This is useful for doing error
 * checking on keyword arguments, to make sure there aren't typos.
 *
 * Examples:
 * <pre>
 *   dojo.lang.assertValidKeywords({a: 1, b: 2}, ["a", "b"]);
 *   dojo.lang.assertValidKeywords({a: 1, b: 2}, ["a", "b", "c"]);
 *   dojo.lang.assertValidKeywords({foo: "iggy"}, ["foo"]);
 *   dojo.lang.assertValidKeywords({foo: "iggy"}, ["foo", "bar"]);
 *   dojo.lang.assertValidKeywords({foo: "iggy"}, {foo: null, bar: null});
 * </pre>
 *
 * @scope	public function
 * @param	object	An anonymous object.
 * @param	expectedProperties	An array of strings (or an object with all the expected properties).
 * @param	message	Optional. A string describing the assertion.
 * @throws	Throws an Error if 'value' is not of type 'type'.
 */
dojo.lang.assertValidKeywords = function(object, expectedProperties, message){
	var key;
	if(!message){
		if(!dojo.lang.assertValidKeywords._errorMessage){
			dojo.lang.assertValidKeywords._errorMessage = "In dojo.lang.assertValidKeywords(), found invalid keyword:";
		}
		message = dojo.lang.assertValidKeywords._errorMessage;
	}
	if(dojo.lang.isArray(expectedProperties)){
		for(key in object){
			if(!dojo.lang.inArray(expectedProperties, key)){
				dojo.lang.assert(false, message + " " + key);
			}
		}
	}else{
		for(key in object){
			if(!(key in expectedProperties)){
				dojo.lang.assert(false, message + " " + key);
			}
		}
	}
}

__CPAN_FILE__ src/lang/common.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.common");

dojo.require("dojo.lang");

/*
 * Adds the given properties/methods to the specified object
 */
dojo.lang.mixin = function(obj, props){
	var tobj = {};
	for(var x in props){
		// the "tobj" condition avoid copying properties in "props"
		// inherited from Object.prototype.  For example, if obj has a custom
		// toString() method, don't overwrite it with the toString() method
		// that props inherited from Object.protoype
		if(typeof tobj[x] == "undefined" || tobj[x] != props[x]) {
			obj[x] = props[x];
		}
	}
	// IE doesn't recognize custom toStrings in for..in
	if(dojo.render.html.ie && dojo.lang.isFunction(props["toString"]) && props["toString"] != obj["toString"]) {
		obj.toString = props.toString;
	}
	return obj;
}

/*
 * Adds the given properties/methods to the specified object's prototype
 */
dojo.lang.extend = function(ctor, props){
	this.mixin(ctor.prototype, props);
}

/**
 * See if val is in arr. Call signatures:
 *  find(array, value, identity) // recommended
 *  find(value, array, identity)
**/
dojo.lang.find = function(	/*Array*/	arr, 
							/*Object*/	val,
							/*boolean*/	identity,
							/*boolean*/	findLast){
	// support both (arr, val) and (val, arr)
	if(!dojo.lang.isArrayLike(arr) && dojo.lang.isArrayLike(val)) {
		var a = arr;
		arr = val;
		val = a;
	}
	var isString = dojo.lang.isString(arr);
	if(isString) { arr = arr.split(""); }

	if(findLast) {
		var step = -1;
		var i = arr.length - 1;
		var end = -1;
	} else {
		var step = 1;
		var i = 0;
		var end = arr.length;
	}
	if(identity){
		while(i != end) {
			if(arr[i] === val){ return i; }
			i += step;
		}
	}else{
		while(i != end) {
			if(arr[i] == val){ return i; }
			i += step;
		}
	}
	return -1;
}

dojo.lang.indexOf = dojo.lang.find;

dojo.lang.findLast = function(/*Array*/ arr, /*Object*/ val, /*boolean*/ identity){
	return dojo.lang.find(arr, val, identity, true);
}

dojo.lang.lastIndexOf = dojo.lang.findLast;

dojo.lang.inArray = function(arr /*Array*/, val /*Object*/){
	return dojo.lang.find(arr, val) > -1; // return: boolean
}

/**
 * Partial implmentation of is* functions from
 * http://www.crockford.com/javascript/recommend.html
 * NOTE: some of these may not be the best thing to use in all situations
 * as they aren't part of core JS and therefore can't work in every case.
 * See WARNING messages inline for tips.
 *
 * The following is* functions are fairly "safe"
 */

dojo.lang.isObject = function(wh) {
	return typeof wh == "object" || dojo.lang.isArray(wh) || dojo.lang.isFunction(wh);
}

dojo.lang.isArray = function(wh) {
	return (wh instanceof Array || typeof wh == "array");
}

dojo.lang.isArrayLike = function(wh) {
	if(dojo.lang.isString(wh)){ return false; }
	if(dojo.lang.isFunction(wh)){ return false; } // keeps out built-in ctors (Number, String, ...) which have length properties
	if(dojo.lang.isArray(wh)){ return true; }
	if(typeof wh != "undefined" && wh
		&& dojo.lang.isNumber(wh.length) && isFinite(wh.length)){ return true; }
	return false;
}

dojo.lang.isFunction = function(wh) {
	return (wh instanceof Function || typeof wh == "function");
}

dojo.lang.isString = function(wh) {
	return (wh instanceof String || typeof wh == "string");
}

dojo.lang.isAlien = function(wh) {
	return !dojo.lang.isFunction() && /\{\s*\[native code\]\s*\}/.test(String(wh));
}

dojo.lang.isBoolean = function(wh) {
	return (wh instanceof Boolean || typeof wh == "boolean");
}

/**
 * The following is***() functions are somewhat "unsafe". Fortunately,
 * there are workarounds the the language provides and are mentioned
 * in the WARNING messages.
 *
 * WARNING: In most cases, isNaN(wh) is sufficient to determine whether or not
 * something is a number or can be used as such. For example, a number or string
 * can be used interchangably when accessing array items (arr["1"] is the same as
 * arr[1]) and isNaN will return false for both values ("1" and 1). Should you
 * use isNumber("1"), that will return false, which is generally not too useful.
 * Also, isNumber(NaN) returns true, again, this isn't generally useful, but there
 * are corner cases (like when you want to make sure that two things are really
 * the same type of thing). That is really where isNumber "shines".
 *
 * RECOMMENDATION: Use isNaN(wh) when possible
 */
dojo.lang.isNumber = function(wh) {
	return (wh instanceof Number || typeof wh == "number");
}

/**
 * WARNING: In some cases, isUndefined will not behave as you
 * might expect. If you do isUndefined(foo) and there is no earlier
 * reference to foo, an error will be thrown before isUndefined is
 * called. It behaves correctly if you scope yor object first, i.e.
 * isUndefined(foo.bar) where foo is an object and bar isn't a
 * property of the object.
 *
 * RECOMMENDATION: Use `typeof foo == "undefined"` when possible
 *
 * FIXME: Should isUndefined go away since it is error prone?
 */
dojo.lang.isUndefined = function(wh) {
	return ((wh == undefined)&&(typeof wh == "undefined"));
}

// end Crockford functions

__CPAN_FILE__ src/lang/declare.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.declare");

dojo.require("dojo.lang.common");
dojo.require("dojo.lang.extras");

/*
 * Creates a constructor: inherit and extend
 *
 * - inherits from "superclass" (via dojo.inherits, null is ok)
 * - "props" are mixed-in to the prototype (via dojo.lang.extend)
 * - can have an initializer function that fires when the class is created. 
 * - name of the class ("className" argument) is stored in "clasName" property
 * 
 * The initializer function works just like a constructor, except it has the following benefits:
 * - it doesn't fire at inheritance time (when prototyping)
 * - properties set in the initializer do not become part of subclass prototypes
 *
 * The initializer can be specified in the "init" argument, or by including a function called
 * "initializer" in "props".
 *
 * Superclass methods (inherited methods) can be invoked using "inherited" method:
 * this.inherited(<method name>[, <argument array>]);
 * - inherited will continue up the prototype chain until it finds an implementation of method
 * - nested calls to inherited are supported (i.e. inherited method "A" can succesfully call inherited("A"), and so on)
 *
 * Aliased as "dojo.declare"
 *
 * Usage:
 *
 * dojo.declare("my.classes.bar", my.classes.foo, {
 *	initializer: function() {
 *		this.myComplicatedObject = new ReallyComplicatedObject(); 
 *	},
 *	someValue: 2,
 *	aMethod: function() { doStuff(); }
 * });
 *
 */
dojo.lang.declare = function(className /*string*/, superclass /*function*/ , props /*object*/, init /*function*/){
	var ctor = function(){ 
		// get the generational context (which object [or prototype] should be constructed)
		var self = this._getPropContext();
		var s = self.constructor.superclass;
		if((s)&&(s.constructor)){
			// if this constructor is invoked directly by some constructor (my.ancestor.call(this))
			if(s.constructor==arguments.callee){
				this.inherited("constructor", arguments);
			}else{
				this._inherited(s, "constructor", arguments);
			}
		}
		if((!this.prototyping)&&(self.initializer)){
			self.initializer.apply(this, arguments);
		}
	}
	var scp = (superclass ? superclass.prototype : null);
	if(scp){
		scp.prototyping = true;
		ctor.prototype = new superclass();
		scp.prototyping = false; 
	}
	ctor.prototype.constructor = ctor;
	ctor.superclass = scp;
	dojo.lang.extend(ctor, dojo.lang.declare.base);
	props=(props||{});
	props.initializer = (props.initializer)||(init)||(function(){ });
	props.className = className;
	dojo.lang.extend(ctor, props);
	dojo.lang.setObjPathValue(className, ctor, null, true);
}
dojo.lang.declare.base = {
	_getPropContext: function() { return (this.___proto||this); },
	// cache ptype context and call method on it
	_inherited: function(ptype, method, args){
		var stack = this.___proto;
		this.___proto = ptype;
		var result = ptype[method].apply(this, (args||[]));
		this.___proto = stack;
		return result;
	},
	// searches backward thru prototype chain to find nearest ancestral iplementation of method
	inherited: function(prop, args){
		var p = this._getPropContext();
		do{
			if((!p.constructor)||(!p.constructor.superclass)){return;}
			p = p.constructor.superclass;
		}while(!(prop in p));
		return (typeof p[prop] == 'function' ? this._inherited(p, prop, args) : p[prop]);
	}
}
dojo.declare = dojo.lang.declare;

__CPAN_FILE__ src/lang/extras.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.extras");

dojo.require("dojo.lang.common");

/**
 * Sets a timeout in milliseconds to execute a function in a given context
 * with optional arguments.
 *
 * setTimeout (Object context, function func, number delay[, arg1[, ...]]);
 * setTimeout (function func, number delay[, arg1[, ...]]);
 */
dojo.lang.setTimeout = function(func, delay){
	var context = window, argsStart = 2;
	if(!dojo.lang.isFunction(func)){
		context = func;
		func = delay;
		delay = arguments[2];
		argsStart++;
	}

	if(dojo.lang.isString(func)){
		func = context[func];
	}
	
	var args = [];
	for (var i = argsStart; i < arguments.length; i++) {
		args.push(arguments[i]);
	}
	return setTimeout(function () { func.apply(context, args); }, delay);
}

dojo.lang.getNameInObj = function(ns, item){
	if(!ns){ ns = dj_global; }

	for(var x in ns){
		if(ns[x] === item){
			return new String(x);
		}
	}
	return null;
}

dojo.lang.shallowCopy = function(obj) {
	var ret = {}, key;
	for(key in obj) {
		if(dojo.lang.isUndefined(ret[key])) {
			ret[key] = obj[key];
		}
	}
	return ret;
}

/**
 * Return the first argument that isn't undefined
 */
dojo.lang.firstValued = function(/* ... */) {
	for(var i = 0; i < arguments.length; i++) {
		if(typeof arguments[i] != "undefined") {
			return arguments[i];
		}
	}
	return undefined;
}

/**
 * Get a value from a reference specified as a string descriptor,
 * (e.g. "A.B") in the given context.
 * 
 * getObjPathValue(String objpath [, Object context, Boolean create])
 *
 * If context is not specified, dj_global is used
 * If create is true, undefined objects in the path are created.
 */
dojo.lang.getObjPathValue = function(objpath, context, create){
	with(dojo.parseObjPath(objpath, context, create)){
		return dojo.evalProp(prop, obj, create);
	}
}

/**
 * Set a value on a reference specified as a string descriptor. 
 * (e.g. "A.B") in the given context.
 * 
 * setObjPathValue(String objpath, value [, Object context, Boolean create])
 *
 * If context is not specified, dj_global is used
 * If create is true, undefined objects in the path are created.
 */
dojo.lang.setObjPathValue = function(objpath, value, context, create){
	if(arguments.length < 4){
		create = true;
	}
	with(dojo.parseObjPath(objpath, context, create)){
		if(obj && (create || (prop in obj))){
			obj[prop] = value;
		}
	}
}

__CPAN_FILE__ src/lang/func.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.func");

dojo.require("dojo.lang.common");

/**
 * Runs a function in a given scope (thisObject), can
 * also be used to preserve scope.
 *
 * hitch(foo, "bar"); // runs foo.bar() in the scope of foo
 * hitch(foo, myFunction); // runs myFunction in the scope of foo
 */
dojo.lang.hitch = function(thisObject, method) {
	if(dojo.lang.isString(method)) {
		var fcn = thisObject[method];
	} else {
		var fcn = method;
	}

	return function() {
		return fcn.apply(thisObject, arguments);
	}
}

dojo.lang.anonCtr = 0;
dojo.lang.anon = {};
dojo.lang.nameAnonFunc = function(anonFuncPtr, namespaceObj){
	var nso = (namespaceObj || dojo.lang.anon);
	if((dj_global["djConfig"])&&(djConfig["slowAnonFuncLookups"] == true)){
		for(var x in nso){
			if(nso[x] === anonFuncPtr){
				return x;
			}
		}
	}
	var ret = "__"+dojo.lang.anonCtr++;
	while(typeof nso[ret] != "undefined"){
		ret = "__"+dojo.lang.anonCtr++;
	}
	nso[ret] = anonFuncPtr;
	return ret;
}

dojo.lang.forward = function(funcName){
	// Returns a function that forwards a method call to this.func(...)
	return function(){
		return this[funcName].apply(this, arguments);
	};
}

dojo.lang.curry = function(ns, func /* args ... */){
	var outerArgs = [];
	ns = ns||dj_global;
	if(dojo.lang.isString(func)){
		func = ns[func];
	}
	for(var x=2; x<arguments.length; x++){
		outerArgs.push(arguments[x]);
	}
	// since the event system replaces the original function with a new
	// join-point runner with an arity of 0, we check to see if it's left us
	// any clues about the original arity in lieu of the function's actual
	// length property
	var ecount = (func["__preJoinArity"]||func.length) - outerArgs.length;
	// borrowed from svend tofte
	function gather(nextArgs, innerArgs, expected){
		var texpected = expected;
		var totalArgs = innerArgs.slice(0); // copy
		for(var x=0; x<nextArgs.length; x++){
			totalArgs.push(nextArgs[x]);
		}
		// check the list of provided nextArgs to see if it, plus the
		// number of innerArgs already supplied, meets the total
		// expected.
		expected = expected-nextArgs.length;
		if(expected<=0){
			var res = func.apply(ns, totalArgs);
			expected = texpected;
			return res;
		}else{
			return function(){
				return gather(arguments,// check to see if we've been run
										// with enough args
							totalArgs,	// a copy
							expected);	// how many more do we need to run?;
			}
		}
	}
	return gather([], outerArgs, ecount);
}

dojo.lang.curryArguments = function(ns, func, args, offset){
	var targs = [];
	var x = offset||0;
	for(x=offset; x<args.length; x++){
		targs.push(args[x]); // ensure that it's an arr
	}
	return dojo.lang.curry.apply(dojo.lang, [ns, func].concat(targs));
}

dojo.lang.tryThese = function(){
	for(var x=0; x<arguments.length; x++){
		try{
			if(typeof arguments[x] == "function"){
				var ret = (arguments[x]());
				if(ret){
					return ret;
				}
			}
		}catch(e){
			dojo.debug(e);
		}
	}
}

dojo.lang.delayThese = function(farr, cb, delay, onend){
	/**
	 * alternate: (array funcArray, function callback, function onend)
	 * alternate: (array funcArray, function callback)
	 * alternate: (array funcArray)
	 */
	if(!farr.length){ 
		if(typeof onend == "function"){
			onend();
		}
		return;
	}
	if((typeof delay == "undefined")&&(typeof cb == "number")){
		delay = cb;
		cb = function(){};
	}else if(!cb){
		cb = function(){};
		if(!delay){ delay = 0; }
	}
	setTimeout(function(){
		(farr.shift())();
		cb();
		dojo.lang.delayThese(farr, cb, delay, onend);
	}, delay);
}

__CPAN_FILE__ src/lang/Lang.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.lang");
dojo.deprecated("dojo.lang.Lang is deprecated, use dojo.lang instead");

__CPAN_FILE__ src/lang/repr.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.repr");

dojo.require("dojo.lang.common");
dojo.require("dojo.AdapterRegistry");
dojo.require("dojo.string.extras");

dojo.lang.reprRegistry = new dojo.AdapterRegistry();
dojo.lang.registerRepr = function(name, check, wrap, /*optional*/ override){
        /***
			Register a repr function.  repr functions should take
			one argument and return a string representation of it
			suitable for developers, primarily used when debugging.

			If override is given, it is used as the highest priority
			repr, otherwise it will be used as the lowest.
        ***/
        dojo.lang.reprRegistry.register(name, check, wrap, override);
    };

dojo.lang.repr = function(obj){
	/***
		Return a "programmer representation" for an object
	***/
	if(typeof(obj) == "undefined"){
		return "undefined";
	}else if(obj === null){
		return "null";
	}

	try{
		if(typeof(obj["__repr__"]) == 'function'){
			return obj["__repr__"]();
		}else if((typeof(obj["repr"]) == 'function')&&(obj.repr != arguments.callee)){
			return obj["repr"]();
		}
		return dojo.lang.reprRegistry.match(obj);
	}catch(e){
		if(typeof(obj.NAME) == 'string' && (
				obj.toString == Function.prototype.toString ||
				obj.toString == Object.prototype.toString
			)){
			return o.NAME;
		}
	}

	if(typeof(obj) == "function"){
		obj = (obj + "").replace(/^\s+/, "");
		var idx = obj.indexOf("{");
		if(idx != -1){
			obj = obj.substr(0, idx) + "{...}";
		}
	}
	return obj + "";
}

dojo.lang.reprArrayLike = function(arr){
	try{
		var na = dojo.lang.map(arr, dojo.lang.repr);
		return "[" + na.join(", ") + "]";
	}catch(e){ }
};

dojo.lang.reprString = function(str){ 
	dojo.deprecated("dojo.lang.reprNumber", "use `String(num)` instead", "0.4");
	return dojo.string.escapeString(str);
};

dojo.lang.reprNumber = function(num){
	dojo.deprecated("dojo.lang.reprNumber", "use `String(num)` instead", "0.4");
	return num + "";
};

(function(){
	var m = dojo.lang;
	m.registerRepr("arrayLike", m.isArrayLike, m.reprArrayLike);
	m.registerRepr("string", m.isString, m.reprString);
	m.registerRepr("numbers", m.isNumber, m.reprNumber);
	m.registerRepr("boolean", m.isBoolean, m.reprNumber);
	// m.registerRepr("numbers", m.typeMatcher("number", "boolean"), m.reprNumber);
})();

__CPAN_FILE__ src/lang/type.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lang.type");

dojo.require("dojo.lang.common");

dojo.lang.whatAmI = function(wh) {
	try {
		if(dojo.lang.isArray(wh)) { return "array"; }
		if(dojo.lang.isFunction(wh)) { return "function"; }
		if(dojo.lang.isString(wh)) { return "string"; }
		if(dojo.lang.isNumber(wh)) { return "number"; }
		if(dojo.lang.isBoolean(wh)) { return "boolean"; }
		if(dojo.lang.isAlien(wh)) { return "alien"; }
		if(dojo.lang.isUndefined(wh)) { return "undefined"; }
		// FIXME: should this go first?
		for(var name in dojo.lang.whatAmI.custom) {
			if(dojo.lang.whatAmI.custom[name](wh)) {
				return name;
			}
		}
		if(dojo.lang.isObject(wh)) { return "object"; }
	} catch(E) {}
	return "unknown";
}
/*
 * dojo.lang.whatAmI.custom[typeName] = someFunction
 * will return typeName is someFunction(wh) returns true
 */
dojo.lang.whatAmI.custom = {};

/**
 * Returns true for values that commonly represent numbers.
 *
 * Examples:
 * <pre>
 *   dojo.lang.isNumeric(3);                 // returns true
 *   dojo.lang.isNumeric("3");               // returns true
 *   dojo.lang.isNumeric(new Number(3));     // returns true
 *   dojo.lang.isNumeric(new String("3"));   // returns true
 *
 *   dojo.lang.isNumeric(3/0);               // returns false
 *   dojo.lang.isNumeric("foo");             // returns false
 *   dojo.lang.isNumeric(new Number("foo")); // returns false
 *   dojo.lang.isNumeric(false);             // returns false
 *   dojo.lang.isNumeric(true);              // returns false
 * </pre>
 */
dojo.lang.isNumeric = function(wh){
	return (!isNaN(wh) && isFinite(wh) && (wh != null) &&
			!dojo.lang.isBoolean(wh) && !dojo.lang.isArray(wh));
}

/**
 * Returns true for any literal, and for any object that is an 
 * instance of a built-in type like String, Number, Boolean, 
 * Array, Function, or Error.
 */
dojo.lang.isBuiltIn = function(wh){
	return (dojo.lang.isArray(wh)		|| 
			dojo.lang.isFunction(wh)	|| 
			dojo.lang.isString(wh)		|| 
			dojo.lang.isNumber(wh)		|| 
			dojo.lang.isBoolean(wh)		|| 
			(wh == null)				|| 
			(wh instanceof Error)		|| 
			(typeof wh == "error") );
}

/**
 * Returns true for any object where the value of the 
 * property 'constructor' is 'Object'.  
 * 
 * Examples:
 * <pre>
 *   dojo.lang.isPureObject(new Object()); // returns true
 *   dojo.lang.isPureObject({a: 1, b: 2}); // returns true
 * 
 *   dojo.lang.isPureObject(new Date());   // returns false
 *   dojo.lang.isPureObject([11, 2, 3]);   // returns false
 * </pre>
 */
dojo.lang.isPureObject = function(wh){
	return ((wh != null) && dojo.lang.isObject(wh) && wh.constructor == Object);
}

/**
 * Given a value and a datatype, this method returns true if the
 * type of the value matches the datatype. The datatype parameter
 * can be an array of datatypes, in which case the method returns
 * true if the type of the value matches any of the datatypes.
 *
 * Examples:
 * <pre>
 *   dojo.lang.isOfType("foo", String);                // returns true
 *   dojo.lang.isOfType(12345, Number);                // returns true
 *   dojo.lang.isOfType(false, Boolean);               // returns true
 *   dojo.lang.isOfType([6, 8], Array);                // returns true
 *   dojo.lang.isOfType(dojo.lang.isOfType, Function); // returns true
 *   dojo.lang.isOfType({foo: "bar"}, Object);         // returns true
 *   dojo.lang.isOfType(new Date(), Date);             // returns true
 *   dojo.lang.isOfType(xxxxx, Date);                  // returns true
 *
 *   dojo.lang.isOfType("foo", "string");                // returns true
 *   dojo.lang.isOfType(12345, "number");                // returns true
 *   dojo.lang.isOfType(false, "boolean");               // returns true
 *   dojo.lang.isOfType([6, 8], "array");                // returns true
 *   dojo.lang.isOfType(dojo.lang.isOfType, "function"); // returns true
 *   dojo.lang.isOfType({foo: "bar"}, "object");         // returns true
 *   dojo.lang.isOfType(xxxxx, "undefined");             // returns true
 *   dojo.lang.isOfType(null, "null");                   // returns true

 *   dojo.lang.isOfType("foo", [Number, String, Boolean]); // returns true
 *   dojo.lang.isOfType(12345, [Number, String, Boolean]); // returns true
 *   dojo.lang.isOfType(false, [Number, String, Boolean]); // returns true
 *   dojo.lang.isOfType(xxxxx, "undefined");               // returns true
 * </pre>
 *
 * @param	value	Any literal value or object instance.
 * @param	type	A class of object, or a literal type, or the string name of a type, or an array with a list of types.
 * @return	Returns a boolean
 */
dojo.lang.isOfType = function(value, type) {
	if(dojo.lang.isArray(type)){
		var arrayOfTypes = type;
		for(var i in arrayOfTypes){
			var aType = arrayOfTypes[i];
			if(dojo.lang.isOfType(value, aType)) {
				return true;
			}
		}
		return false;
	}else{
		if(dojo.lang.isString(type)){
			type = type.toLowerCase();
		}
		switch (type) {
			case Array:
			case "array":
				return dojo.lang.isArray(value);
				break;
			case Function:
			case "function":
				return dojo.lang.isFunction(value);
				break;
			case String:
			case "string":
				return dojo.lang.isString(value);
				break;
			case Number:
			case "number":
				return dojo.lang.isNumber(value);
				break;
			case "numeric":
				return dojo.lang.isNumeric(value);
				break;
			case Boolean:
			case "boolean":
				return dojo.lang.isBoolean(value);
				break;
			case Object:
			case "object":
				return dojo.lang.isObject(value);
				break;
			case "pureobject":
				return dojo.lang.isPureObject(value);
				break;
			case "builtin":
				return dojo.lang.isBuiltIn(value);
				break;
			case "alien":
				return dojo.lang.isAlien(value);
				break;
			case "undefined":
				return dojo.lang.isUndefined(value);
				break;
			case null:
			case "null":
				return (value === null);
				break;
			case "optional":
				return ((value === null) || dojo.lang.isUndefined(value));
				break;
			default:
				if (dojo.lang.isFunction(type)) {
					return (value instanceof type);
				} else {
					dojo.raise("dojo.lang.isOfType() was passed an invalid type");
				}
				break;
		}
	}
	dojo.raise("If we get here, it means a bug was introduced above.");
}

/*
 * 	From reflection code, part of merge.
 *	TRT 2006-02-01
 */
dojo.lang.getObject=function(/* String */ str){
	//	summary
	//	Will return an object, if it exists, based on the name in the passed string.
	var parts=str.split("."), i=0, obj=dj_global; 
	do{ 
		obj=obj[parts[i++]]; 
	}while(i<parts.length&&obj); 
	return (obj!=dj_global)?obj:null;	//	Object
}

dojo.lang.doesObjectExist=function(/* String */ str){
	//	summary
	//	Check to see if object [str] exists, based on the passed string.
	var parts=str.split("."), i=0, obj=dj_global; 
	do{ 
		obj=obj[parts[i++]]; 
	}while(i<parts.length&&obj); 
	return (obj&&obj!=dj_global);	//	boolean
}

__CPAN_FILE__ src/lang/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		"dojo.lang",
		"dojo.lang.common",
		"dojo.lang.assert",
		"dojo.lang.array",
		"dojo.lang.type",
		"dojo.lang.func",
		"dojo.lang.extras",
		"dojo.lang.repr",
		"dojo.lang.declare"
	]
});
dojo.provide("dojo.lang.*");

__CPAN_DIR__ src/lfx
__CPAN_FILE__ src/lfx/Animation.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lfx.Animation");
dojo.provide("dojo.lfx.Line");

dojo.require("dojo.lang.func");

/*
	Animation package based on Dan Pupius' work: http://pupius.co.uk/js/Toolkit.Drawing.js
*/
dojo.lfx.Line = function(start, end){
	this.start = start;
	this.end = end;
	if(dojo.lang.isArray(start)){
		var diff = [];
		dojo.lang.forEach(this.start, function(s,i){
			diff[i] = this.end[i] - s;
		}, this);
		
		this.getValue = function(/*float*/ n){
			var res = [];
			dojo.lang.forEach(this.start, function(s, i){
				res[i] = (diff[i] * n) + s;
			}, this);
			return res;
		}
	}else{
		var diff = end - start;
			
		this.getValue = function(/*float*/ n){
			//	summary: returns the point on the line
			//	n: a floating point number greater than 0 and less than 1
			return (diff * n) + this.start;
		}
	}
}

dojo.lfx.easeIn = function(n){
	//	summary: returns the point on an easing curve
	//	n: a floating point number greater than 0 and less than 1
	return Math.pow(n, 3);
}

dojo.lfx.easeOut = function(n){
	//	summary: returns the point on the line
	//	n: a floating point number greater than 0 and less than 1
	return ( 1 - Math.pow(1 - n, 3) );
}

dojo.lfx.easeInOut = function(n){
	//	summary: returns the point on the line
	//	n: a floating point number greater than 0 and less than 1
	return ( (3 * Math.pow(n, 2)) - (2 * Math.pow(n, 3)) );
}

dojo.lfx.IAnimation = function(){}
dojo.lang.extend(dojo.lfx.IAnimation, {
	// public properties
	curve: null,
	duration: 1000,
	easing: null,
	repeatCount: 0,
	rate: 25,
	
	// events
	handler: null,
	beforeBegin: null,
	onBegin: null,
	onAnimate: null,
	onEnd: null,
	onPlay: null,
	onPause: null,
	onStop: null,
	
	// public methods
	play: null,
	pause: null,
	stop: null,
	
	fire: function(evt, args){
		if(this[evt]){
			if(args){
				this[evt].apply(this, args);
			}else{
				this[evt].apply(this);
			}
		}
	},
	
	// private properties
	_active: false,
	_paused: false
});

dojo.lfx.Animation = function(/*Object*/ handlers, /*int*/ duration, /*Array*/ curve, /*function*/ easing, /*int*/ repeatCount, /*int*/ rate){
	//	summary
	//		a generic animation object that fires callbacks into it's handlers
	//		object at various states
	//	handlers
	//		object { 
	//			handler: function(){}, 
	//			onstart: function(){}, 
	//			onstop: function(){}, 
	//			onanimate: function(){}
	//		}
	dojo.lfx.IAnimation.call(this);
	if(dojo.lang.isNumber(handlers)||(!handlers && duration.getValue)){
		// no handlers argument:
		rate = repeatCount;
		repeatCount = easing;
		easing = curve;
		curve = duration;
		duration = handlers;
		handlers = null;
	}else if(handlers.getValue||dojo.lang.isArray(handlers)){
		// no handlers or duration:
		rate = easing;
		repeatCount = curve;
		easing = duration;
		curve = handlers;
		duration = null;
		handlers = null;
	}
	if(dojo.lang.isArray(curve)){
		this.curve = new dojo.lfx.Line(curve[0], curve[1]);
	}else{
		this.curve = curve;
	}
	if(duration != null && duration > 0){ this.duration = duration; }
	if(repeatCount){ this.repeatCount = repeatCount; }
	if(rate){ this.rate = rate; }
	if(handlers){
		this.handler = handlers.handler;
		this.beforeBegin = handlers.beforeBegin;
		this.onBegin = handlers.onBegin;
		this.onEnd = handlers.onEnd;
		this.onPlay = handlers.onPlay;
		this.onPause = handlers.onPause;
		this.onStop = handlers.onStop;
		this.onAnimate = handlers.onAnimate;
	}
	if(easing && dojo.lang.isFunction(easing)){
		this.easing=easing;
	}
}
dojo.inherits(dojo.lfx.Animation, dojo.lfx.IAnimation);
dojo.lang.extend(dojo.lfx.Animation, {
	// "private" properties
	_startTime: null,
	_endTime: null,
	_timer: null,
	_percent: 0,
	_startRepeatCount: 0,

	// public methods
	play: function(delay, gotoStart) {
		if( gotoStart ) {
			clearTimeout(this._timer);
			this._active = false;
			this._paused = false;
			this._percent = 0;
		} else if( this._active && !this._paused ) {
			return;
		}
		
		this.fire("beforeBegin");

		if(delay > 0){
			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
			return;
		}
		
		this._startTime = new Date().valueOf();
		if( this._paused ) {
			this._startTime -= (this.duration * this._percent / 100);
		}
		this._endTime = this._startTime + this.duration;

		this._active = true;
		this._paused = false;
		
		var step = this._percent / 100;
		var value = this.curve.getValue(step);
		if( this._percent == 0 ) {
			if(!this._startRepeatCount) {
				this._startRepeatCount = this.repeatCount;
			}
			this.fire("handler", ["begin", value]);
			this.fire("onBegin", [value]);
		}

		this.fire("handler", ["play", value]);
		this.fire("onPlay", [value]);

		this._cycle();
	},

	pause: function() {
		clearTimeout(this._timer);
		if( !this._active ) { return; }
		this._paused = true;
		var value = this.curve.getValue(this._percent / 100);
		this.fire("handler", ["pause", value]);
		this.fire("onPause", [value]);
	},

	gotoPercent: function(pct, andPlay) {
		clearTimeout(this._timer);
		this._active = true;
		this._paused = true;
		this._percent = pct;
		if( andPlay ) { this.play(); }
	},

	stop: function(gotoEnd) {
		clearTimeout(this._timer);
		var step = this._percent / 100;
		if( gotoEnd ) {
			step = 1;
		}
		var value = this.curve.getValue(step);
		this.fire("handler", ["stop", value]);
		this.fire("onStop", [value]);
		this._active = false;
		this._paused = false;
	},

	status: function() {
		if( this._active ) {
			return this._paused ? "paused" : "playing";
		} else {
			return "stopped";
		}
	},

	// "private" methods
	_cycle: function() {
		clearTimeout(this._timer);
		if( this._active ) {
			var curr = new Date().valueOf();
			var step = (curr - this._startTime) / (this._endTime - this._startTime);

			if( step >= 1 ) {
				step = 1;
				this._percent = 100;
			} else {
				this._percent = step * 100;
			}
			
			// Perform easing
			if(this.easing && dojo.lang.isFunction(this.easing)) {
				step = this.easing(step);
			}

			var value = this.curve.getValue(step);
			this.fire("handler", ["animate", value]);
			this.fire("onAnimate", [value]);

			if( step < 1 ) {
				this._timer = setTimeout(dojo.lang.hitch(this, "_cycle"), this.rate);
			} else {
				this._active = false;
				this.fire("handler", ["end"]);
				this.fire("onEnd");

				if( this.repeatCount > 0 ) {
					this.repeatCount--;
					this.play(null, true);
				} else if( this.repeatCount == -1 ) {
					this.play(null, true);
				} else {
					if(this._startRepeatCount) {
						this.repeatCount = this._startRepeatCount;
						this._startRepeatCount = 0;
					}
				}
			}
		}
	}
});

dojo.lfx.Combine = function(){
	dojo.lfx.IAnimation.call(this);
	this._anims = [];
	this._animsEnded = 0;
	
	var anims = arguments;
	if(anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
		anims = anims[0];
	}
	
	var _this = this;
	dojo.lang.forEach(anims, function(anim){
		_this._anims.push(anim);
		dojo.event.connect(anim, "onEnd", function(){ _this._onAnimsEnded(); });
	});
}
dojo.inherits(dojo.lfx.Combine, dojo.lfx.IAnimation);
dojo.lang.extend(dojo.lfx.Combine, {
	// private members
	_animsEnded: 0,
	
	// public methods
	play: function(delay, gotoStart){
		if( !this._anims.length ){ return; }

		this.fire("beforeBegin");

		if(delay > 0){
			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
			return;
		}
		
		if(gotoStart || this._anims[0].percent == 0){
			this.fire("onBegin");
		}
		this.fire("onPlay");
		this._animsCall("play", null, gotoStart);
	},
	
	pause: function(){
		this.fire("onPause");
		this._animsCall("pause"); 
	},
	
	stop: function(gotoEnd){
		this.fire("onStop");
		this._animsCall("stop", gotoEnd);
	},
	
	// private methods
	_onAnimsEnded: function(){
		this._animsEnded++;
		if(this._animsEnded >= this._anims.length){
			this.fire("onEnd");
		}
	},
	
	_animsCall: function(funcName){
		var args = [];
		if(arguments.length > 1){
			for(var i = 1 ; i < arguments.length ; i++){
				args.push(arguments[i]);
			}
		}
		var _this = this;
		dojo.lang.forEach(this._anims, function(anim){
			anim[funcName](args);
		}, _this);
	}
});

dojo.lfx.Chain = function() {
	dojo.lfx.IAnimation.call(this);
	this._anims = [];
	this._currAnim = -1;
	
	var anims = arguments;
	if(anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
		anims = anims[0];
	}
	
	var _this = this;
	dojo.lang.forEach(anims, function(anim, i, anims_arr){
		_this._anims.push(anim);
		if(i < anims_arr.length - 1){
			dojo.event.connect(anim, "onEnd", function(){ _this._playNext(); });
		}else{
			dojo.event.connect(anim, "onEnd", function(){ _this.fire("onEnd"); });
		}
	}, _this);
}
dojo.inherits(dojo.lfx.Chain, dojo.lfx.IAnimation);
dojo.lang.extend(dojo.lfx.Chain, {
	// private members
	_currAnim: -1,
	
	// public methods
	play: function(delay, gotoStart){
		if( !this._anims.length ) { return; }
		if( gotoStart || !this._anims[this._currAnim] ) {
			this._currAnim = 0;
		}

		this.fire("beforeBegin");
		if(delay > 0){
			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
			return;
		}
		
		if( this._anims[this._currAnim] ){
			if( this._currAnim == 0 ){
				this.fire("handler", ["begin", this._currAnim]);
				this.fire("onBegin", [this._currAnim]);
			}
			this.fire("onPlay", [this._currAnim]);
			this._anims[this._currAnim].play(null, gotoStart);
		}
	},
	
	pause: function(){
		if( this._anims[this._currAnim] ) {
			this._anims[this._currAnim].pause();
			this.fire("onPause", [this._currAnim]);
		}
	},
	
	playPause: function(){
		if( this._anims.length == 0 ) { return; }
		if( this._currAnim == -1 ) { this._currAnim = 0; }
		var currAnim = this._anims[this._currAnim];
		if( currAnim ) {
			if( !currAnim._active || currAnim._paused ) {
				this.play();
			} else {
				this.pause();
			}
		}
	},
	
	stop: function(){
		if( this._anims[this._currAnim] ){
			this._anims[this._currAnim].stop();
			this.fire("onStop", [this._currAnim]);
		}
	},
	
	// private methods
	_playNext: function(){
		if( this._currAnim == -1 || this._anims.length == 0 ) { return; }
		this._currAnim++;
		if( this._anims[this._currAnim] ){
			this._anims[this._currAnim].play(null, true);
		}
	}
});

dojo.lfx.combine = function(){
	var anims = arguments;
	if(dojo.lang.isArray(arguments[0])){
		anims = arguments[0];
	}
	return new dojo.lfx.Combine(anims);
}

dojo.lfx.chain = function(){
	var anims = arguments;
	if(dojo.lang.isArray(arguments[0])){
		anims = arguments[0];
	}
	return new dojo.lfx.Chain(anims);
}

__CPAN_FILE__ src/lfx/extras.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lfx.extras");

dojo.require("dojo.lfx.html");
dojo.require("dojo.lfx.Animation");

dojo.lfx.html.fadeWipeIn = function(nodes, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anim = dojo.lfx.combine(
		dojo.lfx.wipeIn(nodes, duration, easing),
		dojo.lfx.fadeIn(nodes, duration, easing));
	
	if(callback){
		dojo.event.connect(anim, "onEnd", function(){
			callback(nodes, anim);
		});
	}
	
	return anim;
}

dojo.lfx.html.fadeWipeOut = function(nodes, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anim = dojo.lfx.combine(
		dojo.lfx.wipeOut(nodes, duration, easing),
		dojo.lfx.fadeOut(nodes, duration, easing));
	
	if(callback){
		dojo.event.connect(anim, "onEnd", function(){
			callback(nodes, anim);
		});
	}

	return anim;
}

dojo.lfx.html.scale = function(nodes, percentage, scaleContent, fromCenter, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	dojo.lang.forEach(nodes, function(node){
		var origWidth = dojo.style.getOuterWidth(node);
		var origHeight = dojo.style.getOuterHeight(node);

		var actualPct = percentage/100.0;
		var props = [
			{	property: "width",
				start: origWidth,
				end: origWidth * actualPct
			},
			{	property: "height",
				start: origHeight,
				end: origHeight * actualPct
			}];
		
		if(scaleContent){
			var fontSize = dojo.style.getStyle(node, 'font-size');
			var fontSizeType = null;
			if(!fontSize){
				fontSize = parseFloat('100%');
				fontSizeType = '%';
			}else{
				dojo.lang.some(['em','px','%'], function(item, index, arr){
					if(fontSize.indexOf(item)>0){
						fontSize = parseFloat(fontSize);
						fontSizeType = item;
						return true;
					}
				});
			}
			props.push({
				property: "font-size",
				start: fontSize,
				end: fontSize * actualPct,
				units: fontSizeType });
		}
		
		if(fromCenter){
			var positioning = dojo.style.getStyle(node, "position");
			var originalTop = node.offsetTop;
			var originalLeft = node.offsetLeft;
			var endTop = ((origHeight * actualPct) - origHeight)/2;
			var endLeft = ((origWidth * actualPct) - origWidth)/2;
			props.push({
				property: "top",
				start: originalTop,
				end: (positioning == "absolute" ? originalTop - endTop : (-1*endTop))
			});
			props.push({
				property: "left",
				start: originalLeft,
				end: (positioning == "absolute" ? originalLeft - endLeft : (-1*endLeft))
			});
		}
		
		var anim = dojo.lfx.propertyAnimation(node, props, duration, easing);
		if(callback){
			dojo.event.connect(anim, "onEnd", function(){
				callback(node, anim);
			});
		}

		anims.push(anim);
	});
	
	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
	else{ return anims[0]; }
}

dojo.lang.mixin(dojo.lfx, dojo.lfx.html);

__CPAN_FILE__ src/lfx/html.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lfx.html");
dojo.require("dojo.lfx.Animation");

dojo.require("dojo.html");
dojo.require("dojo.event");
dojo.require("dojo.lang.func");

dojo.lfx.html._byId = function(nodes){
	if(dojo.lang.isArrayLike(nodes)){
		if(!nodes.alreadyChecked){
			var n = [];
			dojo.lang.forEach(nodes, function(node){
				n.push(dojo.byId(node));
			});
			n.alreadyChecked = true;
			return n;
		}else{
			return nodes;
		}
	}else{
		return [dojo.byId(nodes)];
	}
}

dojo.lfx.html.propertyAnimation = function(	/*DOMNode*/ nodes, 
											/*Array*/ propertyMap, 
											/*int*/ duration,
											/*function*/ easing){
	nodes = dojo.lfx.html._byId(nodes);

	if(nodes.length==1){
		// FIXME: we're only supporting start-value filling when one node is
		// passed

		dojo.lang.forEach(propertyMap, function(prop){
			if(typeof prop["start"] == "undefined"){
				prop.start = parseInt(dojo.style.getComputedStyle(nodes[0], prop.property));
				if(isNaN(prop.start) && (prop.property == "opacity")){
					prop.start = 1;
				}
			}
		});
	}

	var coordsAsInts = function(coords){
		var cints = new Array(coords.length);
		for(var i = 0; i < coords.length; i++){
			cints[i] = Math.round(coords[i]);
		}
		return cints;
	}
	var setStyle = function(n, style){
		n = dojo.byId(n);
		if(!n || !n.style){ return; }
		for(s in style){
			if(s == "opacity"){
				dojo.style.setOpacity(n, style[s]);
			}else{
				n.style[dojo.style.toCamelCase(s)] = style[s];
			}
		}
	}
	var propLine = function(properties){
		this._properties = properties;
		this.diffs = new Array(properties.length);
		dojo.lang.forEach(properties, function(prop, i){
			// calculate the end - start to optimize a bit
			if(dojo.lang.isArray(prop.start)){
				// don't loop through the arrays
				this.diffs[i] = null;
			}else{
				this.diffs[i] = prop.end - prop.start;
			}
		}, this);
		this.getValue = function(n){
			var ret = {};
			dojo.lang.forEach(this._properties, function(prop, i){
				var value = null;
				if(dojo.lang.isArray(prop.start)){
					value = (prop.units||"rgb") + "(";
					for(var j = 0 ; j < prop.start.length ; j++){
						value += Math.round(((prop.end[j] - prop.start[j]) * n) + prop.start[j]) + (j < prop.start.length - 1 ? "," : "");
					}
					value += ")";
				}else{
					value = ((this.diffs[i]) * n) + prop.start + (prop.property != "opacity" ? prop.units||"px" : "");
				}
				ret[prop.property] = value;
			}, this);
			return ret;
		}
	}
	
	var anim = new dojo.lfx.Animation(duration, new propLine(propertyMap), easing);
	
	dojo.event.connect(anim, "onAnimate", function(propValues){
		dojo.lang.forEach(nodes, function(node){
			setStyle(node, propValues); 
		});
	});
	
	return anim;
}

dojo.lfx.html._makeFadeable = function(nodes){
	var makeFade = function(node){
		if(dojo.render.html.ie){
			// only set the zoom if the "tickle" value would be the same as the
			// default
			if( (node.style.zoom.length == 0) &&
				(dojo.style.getStyle(node, "zoom") == "normal") ){
				// make sure the node "hasLayout"
				// NOTE: this has been tested with larger and smaller user-set text
				// sizes and works fine
				node.style.zoom = "1";
				// node.style.zoom = "normal";
			}
			// don't set the width to auto if it didn't already cascade that way.
			// We don't want to f anyones designs
			if(	(node.style.width.length == 0) &&
				(dojo.style.getStyle(node, "width") == "auto") ){
				node.style.width = "auto";
			}
		}
	}
	if(dojo.lang.isArrayLike(nodes)){
		dojo.lang.forEach(nodes, makeFade);
	}else{
		makeFade(nodes);
	}
}

dojo.lfx.html.fadeIn = function(nodes, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	dojo.lfx.html._makeFadeable(nodes);
	var anim = dojo.lfx.propertyAnimation(nodes, [
		{	property: "opacity",
			start: dojo.style.getOpacity(nodes[0]),
			end: 1 } ], duration, easing);
	if(callback){
		dojo.event.connect(anim, "onEnd", function(){
			callback(nodes, anim);
		});
	}

	return anim;
}

dojo.lfx.html.fadeOut = function(nodes, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	dojo.lfx.html._makeFadeable(nodes);
	var anim = dojo.lfx.propertyAnimation(nodes, [
		{	property: "opacity",
			start: dojo.style.getOpacity(nodes[0]),
			end: 0 } ], duration, easing);
	if(callback){
		dojo.event.connect(anim, "onEnd", function(){
			callback(nodes, anim);
		});
	}

	return anim;
}

dojo.lfx.html.fadeShow = function(nodes, duration, easing, callback){
	var anim = dojo.lfx.html.fadeIn(nodes, duration, easing, callback);
	dojo.event.connect(anim, "beforeBegin", function(){
		if(dojo.lang.isArrayLike(nodes)){
			dojo.lang.forEach(nodes, dojo.style.show);
		}else{
			dojo.style.show(nodes);
		}
	});
	
	return anim;
}

dojo.lfx.html.fadeHide = function(nodes, duration, easing, callback){
	var anim = dojo.lfx.html.fadeOut(nodes, duration, easing, function(){
		if(dojo.lang.isArrayLike(nodes)){
			dojo.lang.forEach(nodes, dojo.style.hide);
		}else{
			dojo.style.hide(nodes);
		}
		if(callback){ callback(nodes, anim); }
	});
	
	return anim;
}

dojo.lfx.html.wipeIn = function(nodes, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	var init = function(node, overflow){
		if(overflow == "visible") {
			node.style.overflow = "hidden";
		}
		dojo.style.show(node);
		node.style.height = 0;
	}

	dojo.lang.forEach(nodes, function(node){
		var overflow = dojo.style.getStyle(node, "overflow");
		var initialize = function(){
			init(node, overflow);
		}
		initialize();
		
		var anim = dojo.lfx.propertyAnimation(node,
			[{	property: "height",
				start: 0,
				end: node.scrollHeight }], duration, easing);
		
		dojo.event.connect(anim, "beforeBegin", initialize);
		dojo.event.connect(anim, "onEnd", function(){
			node.style.overflow = overflow;
			node.style.height = "auto";
			if(callback){ callback(node, anim); }
		});
		anims.push(anim);
	});
	
	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
	else{ return anims[0]; }
}

dojo.lfx.html.wipeOut = function(nodes, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];
	
	var init = function(node, overflow){
		dojo.style.show(node);
		if(overflow == "visible") {
			node.style.overflow = "hidden";
		}
	}
	dojo.lang.forEach(nodes, function(node){
		var overflow = dojo.style.getStyle(node, "overflow");
		var initialize = function(){
			init(node, overflow);
		}
		initialize();

		var anim = dojo.lfx.propertyAnimation(node,
			[{	property: "height",
				start: node.offsetHeight,
				end: 0 } ], duration, easing);
		
		dojo.event.connect(anim, "beforeBegin", initialize);
		dojo.event.connect(anim, "onEnd", function(){
			dojo.style.hide(node);
			node.style.overflow = overflow;
			if(callback){ callback(node, anim); }
		});
		anims.push(anim);
	});

	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
	else { return anims[0]; }
}

dojo.lfx.html.slideTo = function(nodes, coords, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	dojo.lang.forEach(nodes, function(node){
		var top = null;
		var left = null;
		var pos = null;
		
		var init = (function(){
			var innerNode = node;
			return function(){
				top = node.offsetTop;
				left = node.offsetLeft;
				pos = dojo.style.getComputedStyle(node, 'position');

				if (pos == 'relative' || pos == 'static') {
					top = parseInt(dojo.style.getComputedStyle(node, 'top')) || 0;
					left = parseInt(dojo.style.getComputedStyle(node, 'left')) || 0;
				}
			}
		})();
		init();
		
		var anim = dojo.lfx.propertyAnimation(node,
			[{	property: "top",
				start: top,
				end: coords[0] },
			{	property: "left",
				start: left,
				end: coords[1] }], duration, easing);
		
		dojo.event.connect(anim, "beforeBegin", init);
		if(callback){
			dojo.event.connect(anim, "onEnd", function(){
				callback(node, anim);
			});
		}

		anims.push(anim);
	});
	
	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
	else{ return anims[0]; }
}

dojo.lfx.html.explode = function(start, endNode, duration, easing, callback){
	var startCoords = dojo.style.toCoordinateArray(start);
	var outline = document.createElement("div");
	with(outline.style){
		position = "absolute";
		border = "1px solid black";
		display = "none";
	}
	document.body.appendChild(outline);

	endNode = dojo.byId(endNode);
	with(endNode.style){
		visibility = "hidden";
		display = "block";
	}
	var endCoords = dojo.style.toCoordinateArray(endNode);
	with(endNode.style){
		display = "none";
		visibility = "visible";
	}

	var anim = new dojo.lfx.Animation({
		beforeBegin: function(){
			dojo.style.show(outline);
		},
		onAnimate: function(value){
			with(outline.style){
				left = value[0] + "px";
				top = value[1] + "px";
				width = value[2] + "px";
				height = value[3] + "px";
			}
		},
		onEnd: function(){
			dojo.style.show(endNode);
			outline.parentNode.removeChild(outline);
		}
	}, duration, new dojo.lfx.Line(startCoords, endCoords), easing);
	if(callback){
		dojo.event.connect(anim, "onEnd", function(){
			callback(endNode, anim);
		});
	}
	return anim;
}

dojo.lfx.html.implode = function(startNode, end, duration, easing, callback){
	var startCoords = dojo.style.toCoordinateArray(startNode);
	var endCoords = dojo.style.toCoordinateArray(end);

	startNode = dojo.byId(startNode);
	var outline = document.createElement("div");
	with(outline.style){
		position = "absolute";
		border = "1px solid black";
		display = "none";
	}
	document.body.appendChild(outline);

	var anim = new dojo.lfx.Animation({
		beforeBegin: function(){
			dojo.style.hide(startNode);
			dojo.style.show(outline);
		},
		onAnimate: function(value){
			with(outline.style){
				left = value[0] + "px";
				top = value[1] + "px";
				width = value[2] + "px";
				height = value[3] + "px";
			}
		},
		onEnd: function(){
			outline.parentNode.removeChild(outline);
		}
	}, duration, new dojo.lfx.Line(startCoords, endCoords), easing);
	if(callback){
		dojo.event.connect(anim, "onEnd", function(){
			callback(startNode, anim);
		});
	}
	return anim;
}

dojo.lfx.html.highlight = function(nodes, startColor, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	dojo.lang.forEach(nodes, function(node){
		var color = dojo.style.getBackgroundColor(node);
		var bg = dojo.style.getStyle(node, "background-color").toLowerCase();
		var wasTransparent = (bg == "transparent" || bg == "rgba(0, 0, 0, 0)");
		while(color.length > 3) { color.pop(); }

		var rgb = new dojo.graphics.color.Color(startColor).toRgb();
		var endRgb = new dojo.graphics.color.Color(color).toRgb();

		var anim = dojo.lfx.propertyAnimation(node, [{
			property: "background-color",
			start: rgb,
			end: endRgb
		}], duration, easing);

		dojo.event.connect(anim, "beforeBegin", function(){
			node.style.backgroundColor = "rgb(" + rgb.join(",") + ")";
		});

		dojo.event.connect(anim, "onEnd", function(){
			if(wasTransparent){
				node.style.backgroundColor = "transparent";
			}
			if(callback){
				callback(node, anim);
			}
		});

		anims.push(anim);
	});

	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
	else{ return anims[0]; }
}

dojo.lfx.html.unhighlight = function(nodes, endColor, duration, easing, callback){
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	dojo.lang.forEach(nodes, function(node){
		var color = new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node)).toRgb();
		var rgb = new dojo.graphics.color.Color(endColor).toRgb();
		
		var anim = dojo.lfx.propertyAnimation(node, [{
			property: "background-color",
			start: color,
			end: rgb
		}], duration, easing);

		dojo.event.connect(anim, "beforeBegin", function(){
			node.style.backgroundColor = "rgb(" + color.join(",") + ")";
		});
		if(callback){
			dojo.event.connect(anim, "onEnd", function(){
				callback(node, anim);
			});
		}

		anims.push(anim);
	});

	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
	else{ return anims[0]; }
}

dojo.lang.mixin(dojo.lfx, dojo.lfx.html);

__CPAN_FILE__ src/lfx/toggle.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.lfx.toggle");
dojo.require("dojo.lfx.*");

dojo.lfx.toggle.plain = {
	show: function(node, duration, easing, callback){
		dojo.style.show(node);
		if(dojo.lang.isFunction(callback)){ callback(); }
	},
	
	hide: function(node, duration, easing, callback){
		dojo.style.hide(node);
		if(dojo.lang.isFunction(callback)){ callback(); }
	}
}

dojo.lfx.toggle.fade = {
	show: function(node, duration, easing, callback){
		dojo.lfx.fadeShow(node, duration, easing, callback).play();
	},

	hide: function(node, duration, easing, callback){
		dojo.lfx.fadeHide(node, duration, easing, callback).play();
	}
}

dojo.lfx.toggle.wipe = {
	show: function(node, duration, easing, callback){
		dojo.lfx.wipeIn(node, duration, easing, callback).play();
	},

	hide: function(node, duration, easing, callback){
		dojo.lfx.wipeOut(node, duration, easing, callback).play();
	}
}

dojo.lfx.toggle.explode = {
	show: function(node, duration, easing, callback, explodeSrc){
		dojo.lfx.explode(explodeSrc||[0,0,0,0], node, duration, easing, callback).play();
	},

	hide: function(node, duration, easing, callback, explodeSrc){
		dojo.lfx.implode(node, explodeSrc||[0,0,0,0], duration, easing, callback).play();
	}
}

__CPAN_FILE__ src/lfx/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	browser: ["dojo.lfx.html"],
	dashboard: ["dojo.lfx.html"]
});
dojo.provide("dojo.lfx.*");
__CPAN_DIR__ src/logging
__CPAN_FILE__ src/logging/Logger.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/*		This is the dojo logging facility, which is imported from nWidgets
		(written by Alex Russell, CLA on file), which is patterned on the
		Python logging module, which in turn has been heavily influenced by
		log4j (execpt with some more pythonic choices, which we adopt as well).

		While the dojo logging facilities do provide a set of familiar
		interfaces, many of the details are changed to reflect the constraints
		of the browser environment. Mainly, file and syslog-style logging
		facilites are not provided, with HTTP POST and GET requests being the
		only ways of getting data from the browser back to a server. Minimal
		support for this (and XML serialization of logs) is provided, but may
		not be of practical use in a deployment environment.

		The Dojo logging classes are agnostic of any environment, and while
		default loggers are provided for browser-based interpreter
		environments, this file and the classes it define are explicitly
		designed to be portable to command-line interpreters and other
		ECMA-262v3 envrionments.

	the logger needs to accomidate:
		log "levels"
		type identifiers
		file?
		message
		tic/toc?

	The logger should ALWAYS record:
		time/date logged
		message
		type
		level
*/
// TODO: conver documentation to javadoc style once we confirm that is our choice
// TODO: define DTD for XML-formatted log messages
// TODO: write XML Formatter class
// TODO: write HTTP Handler which uses POST to send log lines/sections

// Filename:	LogCore.js
// Purpose:		a common logging infrastructure for dojo
// Classes:		dojo.logging, dojo.logging.Logger, dojo.logging.Record, dojo.logging.LogFilter
// Global Objects:	dojo.logging
// Dependencies:	none

dojo.provide("dojo.logging.Logger");
dojo.provide("dojo.log");
dojo.require("dojo.lang");

/*
	A simple data structure class that stores information for and about
	a logged event. Objects of this type are created automatically when
	an event is logged and are the internal format in which information
	about log events is kept.
*/

dojo.logging.Record = function(lvl, msg){
	this.level = lvl;
	this.message = msg;
	this.time = new Date();
	// FIXME: what other information can we receive/discover here?
}

// an empty parent (abstract) class which concrete filters should inherit from.
dojo.logging.LogFilter = function(loggerChain){
	this.passChain = loggerChain || "";
	this.filter = function(record){
		// FIXME: need to figure out a way to enforce the loggerChain
		// restriction
		return true; // pass all records
	}
}

dojo.logging.Logger = function(){
	this.cutOffLevel = 0;
	this.propagate = true;
	this.parent = null;
	// storage for dojo.logging.Record objects seen and accepted by this logger
	this.data = [];
	this.filters = [];
	this.handlers = [];
}

dojo.lang.extend(dojo.logging.Logger, {
	argsToArr: function(args){
		// utility function, reproduced from __util__ here to remove dependency
		var ret = [];
		for(var x=0; x<args.length; x++){
			ret.push(args[x]);
		}
		return ret;
	},

	setLevel: function(lvl){
		this.cutOffLevel = parseInt(lvl);
	},

	isEnabledFor: function(lvl){
		return parseInt(lvl) >= this.cutOffLevel;
	},

	getEffectiveLevel: function(){
		if((this.cutOffLevel==0)&&(this.parent)){
			return this.parent.getEffectiveLevel();
		}
		return this.cutOffLevel;
	},

	addFilter: function(flt){
		this.filters.push(flt);
		return this.filters.length-1;
	},

	removeFilterByIndex: function(fltIndex){
		if(this.filters[fltIndex]){
			delete this.filters[fltIndex];
			return true;
		}
		return false;
	},

	removeFilter: function(fltRef){
		for(var x=0; x<this.filters.length; x++){
			if(this.filters[x]===fltRef){
				delete this.filters[x];
				return true;
			}
		}
		return false;
	},

	removeAllFilters: function(){
		this.filters = []; // clobber all of them
	},

	filter: function(rec){
		for(var x=0; x<this.filters.length; x++){
			if((this.filters[x]["filter"])&&
			   (!this.filters[x].filter(rec))||
			   (rec.level<this.cutOffLevel)){
				return false;
			}
		}
		return true;
	},

	addHandler: function(hdlr){
		this.handlers.push(hdlr);
		return this.handlers.length-1;
	},

	handle: function(rec){
		if((!this.filter(rec))||(rec.level<this.cutOffLevel)){ return false; }
		for(var x=0; x<this.handlers.length; x++){
			if(this.handlers[x]["handle"]){
			   this.handlers[x].handle(rec);
			}
		}
		// FIXME: not sure what to do about records to be propagated that may have
		// been modified by the handlers or the filters at this logger. Should
		// parents always have pristine copies? or is passing the modified record
		// OK?
		// if((this.propagate)&&(this.parent)){ this.parent.handle(rec); }
		return true;
	},

	// the heart and soul of the logging system
	log: function(lvl, msg){
		if(	(this.propagate)&&(this.parent)&&
			(this.parent.rec.level>=this.cutOffLevel)){
			this.parent.log(lvl, msg);
			return false;
		}
		// FIXME: need to call logging providers here!
		this.handle(new dojo.logging.Record(lvl, msg));
		return true;
	},

	// logger helpers
	debug:function(msg){
		return this.logType("DEBUG", this.argsToArr(arguments));
	},

	info: function(msg){
		return this.logType("INFO", this.argsToArr(arguments));
	},

	warning: function(msg){
		return this.logType("WARNING", this.argsToArr(arguments));
	},

	error: function(msg){
		return this.logType("ERROR", this.argsToArr(arguments));
	},

	critical: function(msg){
		return this.logType("CRITICAL", this.argsToArr(arguments));
	},

	exception: function(msg, e, squelch){
		// FIXME: this needs to be modified to put the exception in the msg
		// if we're on Moz, we can get the following from the exception object:
		//		lineNumber
		//		message
		//		fileName
		//		stack
		//		name
		// on IE, we get:
		//		name
		//		message (from MDA?)
		//		number
		//		description (same as message!)
		if(e){
			var eparts = [e.name, (e.description||e.message)];
			if(e.fileName){
				eparts.push(e.fileName);
				eparts.push("line "+e.lineNumber);
				// eparts.push(e.stack);
			}
			msg += " "+eparts.join(" : ");
		}

		this.logType("ERROR", msg);
		if(!squelch){
			throw e;
		}
	},

	logType: function(type, args){
		var na = [dojo.logging.log.getLevel(type)];
		if(typeof args == "array"){
			na = na.concat(args);
		}else if((typeof args == "object")&&(args["length"])){
			na = na.concat(this.argsToArr(args));
			/* for(var x=0; x<args.length; x++){
				na.push(args[x]);
			} */
		}else{
			na = na.concat(this.argsToArr(arguments).slice(1));
			/* for(var x=1; x<arguments.length; x++){
				na.push(arguments[x]);
			} */
		}
		return this.log.apply(this, na);
	}
});

void(function(){
	var ptype = dojo.logging.Logger.prototype;
	ptype.warn = ptype.warning;
	ptype.err = ptype.error;
	ptype.crit = ptype.critical;
})();

// the Handler class
dojo.logging.LogHandler = function(level){
	this.cutOffLevel = (level) ? level : 0;
	this.formatter = null; // FIXME: default formatter?
	this.data = [];
	this.filters = [];
}

dojo.logging.LogHandler.prototype.setFormatter = function(fmtr){
	// FIXME: need to vet that it is indeed a formatter object
	dojo.unimplemented("setFormatter");
}

dojo.logging.LogHandler.prototype.flush = function(){
	dojo.unimplemented("flush");
}

dojo.logging.LogHandler.prototype.close = function(){
	dojo.unimplemented("close");
}

dojo.logging.LogHandler.prototype.handleError = function(){
	dojo.unimplemented("handleError");
}

dojo.logging.LogHandler.prototype.handle = function(record){
	// emits the passed record if it passes this object's filters
	if((this.filter(record))&&(record.level>=this.cutOffLevel)){
		this.emit(record);
	}
}

dojo.logging.LogHandler.prototype.emit = function(record){
	// do whatever is necessaray to actually log the record
	dojo.unimplemented("emit");
}

// set aliases since we don't want to inherit from dojo.logging.Logger
void(function(){ // begin globals protection closure
	var names = [
		"setLevel", "addFilter", "removeFilterByIndex", "removeFilter",
		"removeAllFilters", "filter"
	];
	var tgt = dojo.logging.LogHandler.prototype;
	var src = dojo.logging.Logger.prototype;
	for(var x=0; x<names.length; x++){
		tgt[names[x]] = src[names[x]];
	}
})(); // end globals protection closure

dojo.logging.log = new dojo.logging.Logger();

// an associative array of logger objects. This object inherits from
// a list of level names with their associated numeric levels
dojo.logging.log.levels = [ {"name": "DEBUG", "level": 1},
						   {"name": "INFO", "level": 2},
						   {"name": "WARNING", "level": 3},
						   {"name": "ERROR", "level": 4},
						   {"name": "CRITICAL", "level": 5} ];

dojo.logging.log.loggers = {};

dojo.logging.log.getLogger = function(name){
	if(!this.loggers[name]){
		this.loggers[name] = new dojo.logging.Logger();
		this.loggers[name].parent = this;
	}
	return this.loggers[name];
}

dojo.logging.log.getLevelName = function(lvl){
	for(var x=0; x<this.levels.length; x++){
		if(this.levels[x].level == lvl){
			return this.levels[x].name;
		}
	}
	return null;
}

dojo.logging.log.addLevelName = function(name, lvl){
	if(this.getLevelName(name)){
		this.err("could not add log level "+name+" because a level with that name already exists");
		return false;
	}
	this.levels.append({"name": name, "level": parseInt(lvl)});
	return true;
}

dojo.logging.log.getLevel = function(name){
	for(var x=0; x<this.levels.length; x++){
		if(this.levels[x].name.toUpperCase() == name.toUpperCase()){
			return this.levels[x].level;
		}
	}
	return null;
}

// a default handler class, it simply saves all of the handle()'d records in
// memory. Useful for attaching to with dojo.event.connect()
dojo.logging.MemoryLogHandler = function(level, recordsToKeep, postType, postInterval){
	// mixin style inheritance
	dojo.logging.LogHandler.call(this, level);
	// default is unlimited
	this.numRecords = (typeof djConfig['loggingNumRecords'] != 'undefined') ? djConfig['loggingNumRecords'] : ((recordsToKeep) ? recordsToKeep : -1);
	// 0=count, 1=time, -1=don't post TODO: move this to a better location for prefs
	this.postType = (typeof djConfig['loggingPostType'] != 'undefined') ? djConfig['loggingPostType'] : ( postType || -1);
	// milliseconds for time, interger for number of records, -1 for non-posting,
	this.postInterval = (typeof djConfig['loggingPostInterval'] != 'undefined') ? djConfig['loggingPostInterval'] : ( postType || -1);
	
}
// prototype inheritance
dojo.logging.MemoryLogHandler.prototype = new dojo.logging.LogHandler();

// FIXME
// dojo.inherits(dojo.logging.MemoryLogHandler, 

// over-ride base-class
dojo.logging.MemoryLogHandler.prototype.emit = function(record){
	this.data.push(record);
	if(this.numRecords != -1){
		while(this.data.length>this.numRecords){
			this.data.shift();
		}
	}
}

dojo.logging.logQueueHandler = new dojo.logging.MemoryLogHandler(0,50,0,10000);
// actual logging event handler
dojo.logging.logQueueHandler.emit = function(record){
	// we should probably abstract this in the future
	var logStr = String(dojo.log.getLevelName(record.level)+": "+record.time.toLocaleTimeString())+": "+record.message;
	if(!dj_undef("debug", dj_global)){
		dojo.debug(logStr);
	}else if((typeof dj_global["print"] == "function")&&(!dojo.render.html.capable)){
		print(logStr);
	}
	this.data.push(record);
	if(this.numRecords != -1){
		while(this.data.length>this.numRecords){
			this.data.shift();
		}
	}
}

dojo.logging.log.addHandler(dojo.logging.logQueueHandler);
dojo.log = dojo.logging.log;

__CPAN_FILE__ src/logging/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.logging.Logger", false, false],
	rhino: ["dojo.logging.RhinoLogger"]
});
dojo.provide("dojo.logging.*");

__CPAN_DIR__ src/math
__CPAN_FILE__ src/math/curves.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.math.curves");

dojo.require("dojo.math");

/* Curves from Dan's 13th lib stuff.
 * See: http://pupius.co.uk/js/Toolkit.Drawing.js
 *      http://pupius.co.uk/dump/dojo/Dojo.Math.js
 */

dojo.math.curves = {
	//Creates a straight line object
	Line: function(start, end) {
		this.start = start;
		this.end = end;
		this.dimensions = start.length;

		for(var i = 0; i < start.length; i++) {
			start[i] = Number(start[i]);
		}

		for(var i = 0; i < end.length; i++) {
			end[i] = Number(end[i]);
		}

		//simple function to find point on an n-dimensional, straight line
		this.getValue = function(n) {
			var retVal = new Array(this.dimensions);
			for(var i=0;i<this.dimensions;i++)
				retVal[i] = ((this.end[i] - this.start[i]) * n) + this.start[i];
			return retVal;
		}

		return this;
	},


	//Takes an array of points, the first is the start point, the last is end point and the ones in
	//between are the Bezier control points.
	Bezier: function(pnts) {
		this.getValue = function(step) {
			if(step >= 1) return this.p[this.p.length-1];	// if step>=1 we must be at the end of the curve
			if(step <= 0) return this.p[0];					// if step<=0 we must be at the start of the curve
			var retVal = new Array(this.p[0].length);
			for(var k=0;j<this.p[0].length;k++) { retVal[k]=0; }
			for(var j=0;j<this.p[0].length;j++) {
				var C=0; var D=0;
				for(var i=0;i<this.p.length;i++) {
					C += this.p[i][j] * this.p[this.p.length-1][0]
						* dojo.math.bernstein(step,this.p.length,i);
				}
				for(var l=0;l<this.p.length;l++) {
					D += this.p[this.p.length-1][0] * dojo.math.bernstein(step,this.p.length,l);
				}
				retVal[j] = C/D;
			}
			return retVal;
		}
		this.p = pnts;
		return this;
	},


	//Catmull-Rom Spline - allows you to interpolate a smooth curve through a set of points in n-dimensional space
	CatmullRom : function(pnts,c) {
		this.getValue = function(step) {
			var percent = step * (this.p.length-1);
			var node = Math.floor(percent);
			var progress = percent - node;

			var i0 = node-1; if(i0 < 0) i0 = 0;
			var i = node;
			var i1 = node+1; if(i1 >= this.p.length) i1 = this.p.length-1;
			var i2 = node+2; if(i2 >= this.p.length) i2 = this.p.length-1;

			var u = progress;
			var u2 = progress*progress;
			var u3 = progress*progress*progress;

			var retVal = new Array(this.p[0].length);
			for(var k=0;k<this.p[0].length;k++) {
				var x1 = ( -this.c * this.p[i0][k] ) + ( (2 - this.c) * this.p[i][k] ) + ( (this.c-2) * this.p[i1][k] ) + ( this.c * this.p[i2][k] );
				var x2 = ( 2 * this.c * this.p[i0][k] ) + ( (this.c-3) * this.p[i][k] ) + ( (3 - 2 * this.c) * this.p[i1][k] ) + ( -this.c * this.p[i2][k] );
				var x3 = ( -this.c * this.p[i0][k] ) + ( this.c * this.p[i1][k] );
				var x4 = this.p[i][k];

				retVal[k] = x1*u3 + x2*u2 + x3*u + x4;
			}
			return retVal;

		}


		if(!c) this.c = 0.7;
		else this.c = c;
		this.p = pnts;

		return this;
	},

	// FIXME: This is the bad way to do a partial-arc with 2 points. We need to have the user
	// supply the radius, otherwise we always get a half-circle between the two points.
	Arc : function(start, end, ccw) {
		var center = dojo.math.points.midpoint(start, end);
		var sides = dojo.math.points.translate(dojo.math.points.invert(center), start);
		var rad = Math.sqrt(Math.pow(sides[0], 2) + Math.pow(sides[1], 2));
		var theta = dojo.math.radToDeg(Math.atan(sides[1]/sides[0]));
		if( sides[0] < 0 ) {
			theta -= 90;
		} else {
			theta += 90;
		}
		dojo.math.curves.CenteredArc.call(this, center, rad, theta, theta+(ccw?-180:180));
	},

	// Creates an arc object, with center and radius (Top of arc = 0 degrees, increments clockwise)
	//  center => 2D point for center of arc
	//  radius => scalar quantity for radius of arc
	//  start  => to define an arc specify start angle (default: 0)
	//  end    => to define an arc specify start angle
	CenteredArc : function(center, radius, start, end) {
		this.center = center;
		this.radius = radius;
		this.start = start || 0;
		this.end = end;

		this.getValue = function(n) {
			var retVal = new Array(2);
			var theta = dojo.math.degToRad(this.start+((this.end-this.start)*n));

			retVal[0] = this.center[0] + this.radius*Math.sin(theta);
			retVal[1] = this.center[1] - this.radius*Math.cos(theta);

			return retVal;
		}

		return this;
	},

	// Special case of Arc (start = 0, end = 360)
	Circle : function(center, radius) {
		dojo.math.curves.CenteredArc.call(this, center, radius, 0, 360);
		return this;
	},

	Path : function() {
		var curves = [];
		var weights = [];
		var ranges = [];
		var totalWeight = 0;

		this.add = function(curve, weight) {
			if( weight < 0 ) { dojo.raise("dojo.math.curves.Path.add: weight cannot be less than 0"); }
			curves.push(curve);
			weights.push(weight);
			totalWeight += weight;
			computeRanges();
		}

		this.remove = function(curve) {
			for(var i = 0; i < curves.length; i++) {
				if( curves[i] == curve ) {
					curves.splice(i, 1);
					totalWeight -= weights.splice(i, 1)[0];
					break;
				}
			}
			computeRanges();
		}

		this.removeAll = function() {
			curves = [];
			weights = [];
			totalWeight = 0;
		}

		this.getValue = function(n) {
			var found = false, value = 0;
			for(var i = 0; i < ranges.length; i++) {
				var r = ranges[i];
				//w(r.join(" ... "));
				if( n >= r[0] && n < r[1] ) {
					var subN = (n - r[0]) / r[2];
					value = curves[i].getValue(subN);
					found = true;
					break;
				}
			}

			// FIXME: Do we want to assume we're at the end?
			if( !found ) {
				value = curves[curves.length-1].getValue(1);
			}

			for(j = 0; j < i; j++) {
				value = dojo.math.points.translate(value, curves[j].getValue(1));
			}
			return value;
		}

		function computeRanges() {
			var start = 0;
			for(var i = 0; i < weights.length; i++) {
				var end = start + weights[i] / totalWeight;
				var len = end - start;
				ranges[i] = [start, end, len];
				start = end;
			}
		}

		return this;
	}
};

__CPAN_FILE__ src/math/Math.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.deprecated("dojo.math.Math does not exist, include dojo.math");
dojo.require("dojo.math");

__CPAN_FILE__ src/math/matrix.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.math.matrix");

//
// some of this code is based on
// http://www.mkaz.com/math/MatrixCalculator.java
// (published under a BSD Open Source License)
//
// the rest is from my vague memory of matricies in school [cal]
//
// the copying of arguments is a little excessive, and could be trimmed back in
// the case where a function doesn't modify them at all (but some do!)
//

dojo.math.matrix.iDF = 0;

dojo.math.matrix.multiply = function(a, b){

	a = dojo.math.matrix.copy(a);
	b = dojo.math.matrix.copy(b);

	var ax = a[0].length;
	var ay = a.length;
	var bx = b[0].length;
	var by = b.length;

	if (ax != by){
		dojo.debug("Can't multiply matricies of sizes "+ax+','+ay+' and '+bx+','+by);
		return [[0]];
	}

	var c = [];

	for(var k=0; k<ay; k++){
		c[k] = [];
		for(var i=0; i<bx; i++){

			c[k][i] = 0;

			for(var m=0; m<ax; m++){

				c[k][i] += a[k][m]*b[m][i];
			}
		}
	}

	return c;
}

dojo.math.matrix.inverse = function(a){

	a = dojo.math.matrix.copy(a);

	// Formula used to Calculate Inverse:
	// inv(A) = 1/det(A) * adj(A)

	var tms = a.length;

	var m = dojo.math.matrix.create(tms, tms);
	var mm = dojo.math.matrix.adjoint(a);

	var det = dojo.math.matrix.determinant(a);
	var dd = 0;

	if (det == 0){
		dojo.debug("Determinant Equals 0, Not Invertible.");
		return [[0]];
	}else{
		dd = 1 / det;
	}

	for (var i = 0; i < tms; i++)
		for (var j = 0; j < tms; j++) {
			m[i][j] = dd * mm[i][j];
		}

	return m;
}

dojo.math.matrix.determinant = function(a){

	a = dojo.math.matrix.copy(a);

	if (a.length != a[0].length){
		dojo.debug("Can't calculate the determiant of a non-squre matrix!");
		return 0;
	}

	var tms = a.length;
	var det = 1;

	var b = dojo.math.matrix.upperTriangle(a);

	for (var i=0; i < tms; i++){
		det *= b[i][i];
	}

	det = det * dojo.math.matrix.iDF;

	return det;
}

dojo.math.matrix.upperTriangle = function(m){

	m = dojo.math.matrix.copy(m);

	var f1 = 0;
	var temp = 0;
	var tms = m.length;
	var v = 1;

	dojo.math.matrix.iDF = 1;

	for (var col = 0; col < tms - 1; col++) {
		for (var row = col + 1; row < tms; row++) {
			v = 1;

			var stop_loop = 0;

			// check if 0 in diagonal
 			while ((m[col][col] == 0) && !stop_loop){

				// if so switch until not
				if (col + v >= tms){

					// check if switched all rows
					dojo.math.matrix.iDF = 0;
					stop_loop = 1;
				}else{
					for (var c = 0; c < tms; c++) {
						temp = m[col][c];
						m[col][c] = m[col + v][c]; // switch rows
						m[col + v][c] = temp;
					}
					v++; // count row switchs
					dojo.math.matrix.iDF *= -1; // each switch changes determinant factor
				}
			}

			if (m[col][col] != 0) {
				f1 = (-1) * m[row][col] / m[col][col];
				for (var i = col; i < tms; i++) {
					m[row][i] = f1 * m[col][i] + m[row][i];
				}
			}
		}
	}

	return m;
}

dojo.math.matrix.create = function(a, b){
	var m = [];
	for(var i=0; i<b; i++){
		m[i] = [];
		for(var j=0; j<a; j++){
			m[i][j] = 0;
		}
	}
	return m;
}

dojo.math.matrix.adjoint = function(a){

	a = dojo.math.matrix.copy(a);

	var tms = a.length;

	if (a.length != a[0].length){
		dojo.debug("Can't find the adjoint of a non-square matrix");
		return [[0]];
	}

	if (tms == 1){
		dojo.debug("Can't find the adjoint of a 1x1 matrix");
		return [[0]];
	}

	var m = dojo.math.matrix.create(tms, tms);

	var ii = 0;
	var jj = 0;
	var ia = 0;
	var ja = 0;
	var det = 0;

	for (var i = 0; i < tms; i++){
		for (var j = 0; j < tms; j++){

			ia = 0;
			ja = 0;

			var ap = dojo.math.matrix.create(tms-1, tms-1);

			for (ii = 0; ii < tms; ii++) {
				for (jj = 0; jj < tms; jj++) {

					if ((ii != i) && (jj != j)) {
						ap[ia][ja] = a[ii][jj];
						ja++;
					}

				}

				if ((ii != i) && (jj != j)) {
					ia++;
				}
				ja = 0;
			}

			det = dojo.math.matrix.determinant(ap);
			m[i][j] = Math.pow(-1 , (i + j)) * det;
		}
	}

	m = dojo.math.matrix.transpose(m);

	return m;
}

dojo.math.matrix.transpose = function(a){

	a = dojo.math.matrix.copy(a);

	var m = dojo.math.matrix.create(a.length, a[0].length);

	for (var i = 0; i < a.length; i++)
		for (var j = 0; j < a[i].length; j++)
			m[j][i] = a[i][j];
	return m;
}

dojo.math.matrix.format = function(a){

	function format_int(x){
		var dp = 5;
		var fac = Math.pow(10 , dp);
		var a = Math.round(x*fac)/fac;
		var b = a.toString();
		if (b.charAt(0) != '-'){ b = ' ' + b;}
		var has_dp = 0;
		for(var i=1; i<b.length; i++){
			if (b.charAt(i) == '.'){ has_dp = 1; }
		}
		if (!has_dp){ b += '.'; }
		while(b.length < dp+3){ b += '0'; }
		return b;
	}

	var ya = a.length;
	var xa = a[0].length;

	var buffer = '';

	for (var y=0; y<ya; y++){
		buffer += '| ';
		for (var x=0; x<xa; x++){
			buffer += format_int(a[y][x]) + ' ';
		}
		buffer += '|\n';
	}

	return buffer;
}

dojo.math.matrix.copy = function(a){

	var ya = a.length;
	var xa = a[0].length;

	var m = dojo.math.matrix.create(xa, ya);

	for (var y=0; y<ya; y++){
		for (var x=0; x<xa; x++){
			m[y][x] = a[y][x];
		}
	}

	return m;
}

dojo.math.matrix.scale = function(k, a){

	a = dojo.math.matrix.copy(a);

	var ya = a.length;
	var xa = a[0].length;

	for (var y=0; y<ya; y++){
		for (var x=0; x<xa; x++){
			a[y][x] *= k;
		}
	}

	return a;
}

__CPAN_FILE__ src/math/points.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.math.points");
dojo.require("dojo.math");

// TODO: add a Point class?
dojo.math.points = {
	translate: function(a, b) {
		if( a.length != b.length ) {
			dojo.raise("dojo.math.translate: points not same size (a:[" + a + "], b:[" + b + "])");
		}
		var c = new Array(a.length);
		for(var i = 0; i < a.length; i++) {
			c[i] = a[i] + b[i];
		}
		return c;
	},

	midpoint: function(a, b) {
		if( a.length != b.length ) {
			dojo.raise("dojo.math.midpoint: points not same size (a:[" + a + "], b:[" + b + "])");
		}
		var c = new Array(a.length);
		for(var i = 0; i < a.length; i++) {
			c[i] = (a[i] + b[i]) / 2;
		}
		return c;
	},

	invert: function(a) {
		var b = new Array(a.length);
		for(var i = 0; i < a.length; i++) { b[i] = -a[i]; }
		return b;
	},

	distance: function(a, b) {
		return Math.sqrt(Math.pow(b[0]-a[0], 2) + Math.pow(b[1]-a[1], 2));
	}
};

__CPAN_FILE__ src/math/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		["dojo.math", false, false],
		["dojo.math.curves", false, false],
		["dojo.math.points", false, false]
	]
});
dojo.provide("dojo.math.*");

__CPAN_DIR__ src/reflect
__CPAN_FILE__ src/reflect/reflection.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.deprecated("dojo.reflect is merged into dojo.lang (dojo.lang[type]).  Will be removed by 0.4");
dojo.provide("dojo.reflect");

/*****************************************************************
	reflect.js
	v.1.5.0
	(c) 2003-2004 Thomas R. Trenka, Ph.D.

	Derived from the reflection functions of f(m).
	http://dojotoolkit.org
	http://fm.dept-z.com

	There is a dependency on the variable dJ_global, which
	should always refer to the global object.
******************************************************************/
if(!dj_global){ var dj_global = this; }

dojo.reflect = {} ;
dojo.reflect.$unknownType = function(){ } ;
dojo.reflect.ParameterInfo = function(name, type){ 
	this.name = name ;
	this.type = (type) ? type : dojo.reflect.$unknownType ;
} ;
dojo.reflect.PropertyInfo = function(name, type) { 
	this.name = name ;
	this.type = (type) ? type : dojo.reflect.$unknownType ;
} ;
dojo.reflect.MethodInfo = function(name, fn){
	var parse = function(f) {
		var o = {} ; 
		var s = f.toString() ;
		var param = ((s.substring(s.indexOf('(')+1, s.indexOf(')'))).replace(/\s+/g, "")).split(",") ;
		o.parameters = [] ;
		for (var i = 0; i < param.length; i++) {
			o.parameters.push(new dojo.reflect.ParameterInfo(param[i])) ;
		}
		o.body = (s.substring(s.indexOf('{')+1, s.lastIndexOf('}'))).replace(/(^\s*)|(\s*$)/g, "") ;
		return o ;
	} ;

	var tmp = parse(fn) ;
	var p = tmp.parameters ;
	var body = tmp.body ;
	
	this.name = (name) ? name : "anonymous" ;
	this.getParameters = function(){ return p ; } ;
	this.getNullArgumentsObject = function() {
		var a = [] ;
		for (var i = 0; i < p.length; i++){
			a.push(null);
		}
		return a ;
	} ;
	this.getBody = function() { return body ; } ;
	this.type = Function ;
	this.invoke = function(src, args){ return fn.apply(src, args) ; } ;
} ;

//	Static object that can activate instances of the passed type.
dojo.reflect.Activator = new (function(){
	this.createInstance = function(type, args) {
		switch (typeof(type)) {
			case "function" : { 
				var o = {} ;
				type.apply(o, args) ;
				return o ;
			} ;
			case "string" : {
				var o = {} ;
				(dojo.reflect.Reflector.getTypeFromString(type)).apply(o, args) ;
				return o ;
			} ;
		}
		throw new Error("dojo.reflect.Activator.createInstance(): no such type exists.");
	}
})() ;

dojo.reflect.Reflector = new (function(){
	this.getTypeFromString = function(s) {
		var parts = s.split("."), i = 0, obj = dj_global ; 
		do { obj = obj[parts[i++]] ; } while (i < parts.length && obj) ; 
		return (obj != dj_global) ? obj : null ;
	}; 

	this.typeExists = function(s) {
		var parts = s.split("."), i = 0, obj = dj_global ; 
		do { obj = obj[parts[i++]] ; } while (i < parts.length && obj) ; 
		return (obj && obj != dj_global) ;
	}; 

	this.getFieldsFromType = function(s) { 
		var type = s ;
		if (typeof(s) == "string") {
			type = this.getTypeFromString(s) ;
		}
		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
		return this.getFields(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
	};

	this.getPropertiesFromType = function(s) { 
		var type = s ;
		if (typeof(s) == "string") {
			type = this.getTypeFromString(s);
		}
		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
		return this.getProperties(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
	};

	this.getMethodsFromType = function(s) { 
		var type = s ;
		if (typeof(s) == "string") {
			type = this.getTypeFromString(s) ;
		}
		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
		return this.getMethods(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
	};

	this.getType = function(o) { return o.constructor ; } ;

	this.getFields = function(obj) {
		var arr = [] ;
		for (var p in obj) { 
			if(this.getType(obj[p]) != Function){
				arr.push(new dojo.reflect.PropertyInfo(p, this.getType(obj[p]))) ;
			}else{
				arr.push(new dojo.reflect.MethodInfo(p, obj[p]));
			}
		}
		return arr ;
	};

	this.getProperties = function(obj) {
		var arr = [] ;
		var fi = this.getFields(obj) ;
		for (var i = 0; i < fi.length; i++){
			if (this.isInstanceOf(fi[i], dojo.reflect.PropertyInfo)){
				arr.push(fi[i]) ;
			}
		}
		return arr ;
	};

	this.getMethods = function(obj) {
		var arr = [] ;
		var fi = this.getFields(obj) ;
		for (var i = 0; i < fi.length; i++){
			if (this.isInstanceOf(fi[i], dojo.reflect.MethodInfo)){
				arr.push(fi[i]) ;
			}
		}
		return arr ;
	};

	/*
	this.implements = function(o, type) {
		if (this.isSubTypeOf(o, type)) return false ;
		var f = this.getFieldsFromType(type) ;
		for (var i = 0; i < f.length; i++) {
			if (typeof(o[(f[i].name)]) == "undefined"){
				return false;
			}
		}
		return true ;
	};
	*/

	this.getBaseClass = function(o) {
		if (o.getType().prototype.prototype.constructor){
			return (o.getType()).prototype.prototype.constructor ;
		}
		return Object ;
	} ;

	this.isInstanceOf = function(o, type) { 
		return (this.getType(o) == type) ; 
	};

	this.isSubTypeOf = function(o, type) { 
		return (o instanceof type) ; 
	};

	this.isBaseTypeOf = function(o, type) { 
		return (type instanceof o); 
	};
})();

// back-compat
dojo.provide("dojo.reflect.reflection");

__CPAN_FILE__ src/reflect/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.deprecated("dojo.reflect is merged into dojo.lang (dojo.lang[type]).  Will be removed by 0.4");
dojo.kwCompoundRequire({
	common: ["dojo.reflect.reflection"]
});
dojo.provide("dojo.reflect.*");

__CPAN_DIR__ src/rpc
__CPAN_FILE__ src/rpc/Deferred.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.rpc.Deferred");
dojo.require("dojo.Deferred");

dojo.rpc.Deferred = dojo.Deferred;
dojo.rpc.Deferred.prototype = dojo.Deferred.prototype;

__CPAN_FILE__ src/rpc/JotService.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.rpc.JotService");
dojo.require("dojo.rpc.RpcService");
dojo.require("dojo.rpc.JsonService");
dojo.require("dojo.json");

dojo.rpc.JotService = function(){
	this.serviceUrl = "/_/jsonrpc";
}

dojo.inherits(dojo.rpc.JotService, dojo.rpc.JsonService);

dojo.lang.extend(dojo.rpc.JotService, {
	bind: function(method, parameters, deferredRequestHandler, url){
		dojo.io.bind({
			url: url||this.serviceUrl,
			content: {
				json: this.createRequest(method, parameters)
			},
			method: "POST",
			mimetype: "text/json",
			load: this.resultCallback(deferredRequestHandler),
			error: this.errorCallback(deferredRequestHandler),
			preventCache: true
		});
	},

	createRequest: function(method, params){
		var req = { "params": params, "method": method, "id": this.lastSubmissionId++ };
		return dojo.json.serialize(req);
	}
});

__CPAN_FILE__ src/rpc/JsonService.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.rpc.JsonService");
dojo.require("dojo.rpc.RpcService");
dojo.require("dojo.io.*");
dojo.require("dojo.json");
dojo.require("dojo.lang");

dojo.rpc.JsonService = function(args){
	// passing just the URL isn't terribly useful. It's expected that at
	// various times folks will want to specify:
	//	- just the serviceUrl (for use w/ remoteCall())
	//	- the text of the SMD to evaluate
	// 	- a raw SMD object
	//	- the SMD URL
	if(args){
		if(dojo.lang.isString(args)){
			// we assume it's an SMD file to be processed, since this was the
			// earlier function signature

			// FIXME: also accept dojo.uri.Uri objects?
			this.connect(args);
		}else{
			// otherwise we assume it's an arguments object with the following
			// (optional) properties:
			//	- serviceUrl
			//	- strictArgChecks
			//	- smdUrl
			//	- smdStr
			//	- smdObj
			if(args["smdUrl"]){
				this.connect(args.smdUrl);
			}
			if(args["smdStr"]){
				this.processSmd(dj_eval("("+args.smdStr+")"));
			}
			if(args["smdObj"]){
				this.processSmd(args.smdObj);
			}
			if(args["serviceUrl"]){
				this.serviceUrl = args.serviceUrl;
			}
			if(typeof args["strictArgChecks"] != "undefined"){
				this.strictArgChecks = args.strictArgChecks;
			}
		}
	}
}

dojo.inherits(dojo.rpc.JsonService, dojo.rpc.RpcService);

dojo.lang.extend(dojo.rpc.JsonService, {

	bustCache: false,
	
	contentType: "application/json-rpc",

	lastSubmissionId: 0,

	callRemote: function(method, params){
		var deferred = new dojo.rpc.Deferred();
		this.bind(method, params, deferred);
		return deferred;
	},

	bind: function(method, parameters, deferredRequestHandler, url){
		dojo.io.bind({
			url: url||this.serviceUrl,
			postContent: this.createRequest(method, parameters),
			method: "POST",
			contentType: this.contentType,
			mimetype: "text/json",
			load: this.resultCallback(deferredRequestHandler),
			preventCache:this.bustCache 
		});
	},

	createRequest: function(method, params){
		var req = { "params": params, "method": method, "id": ++this.lastSubmissionId };
		var data = dojo.json.serialize(req);
		dojo.debug("JsonService: JSON-RPC Request: " + data);
		return data;
	},

	parseResults: function(obj){
		if(!obj){ return; }
		if(obj["Result"]||obj["result"]){
			return obj["result"]||obj["Result"];
		}else if(obj["ResultSet"]){
			return obj["ResultSet"];
		}else{
			return obj;
		}
	}
});

__CPAN_FILE__ src/rpc/RpcService.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.rpc.RpcService");
dojo.require("dojo.io.*");
dojo.require("dojo.json");
dojo.require("dojo.lang.func");
dojo.require("dojo.rpc.Deferred");

dojo.rpc.RpcService = function(url){
	// summary
	// constructor for rpc base class
	if(url){
		this.connect(url);
	}
}

dojo.lang.extend(dojo.rpc.RpcService, {

	strictArgChecks: true,
	serviceUrl: "",

	parseResults: function(obj){
		// summary
		// parse the results coming back from an rpc request.  
   		// this base implementation, just returns the full object
		// subclasses should parse and only return the actual results
		return obj;
	},

	errorCallback: function(/* dojo.rpc.Deferred */ deferredRequestHandler){
		// summary
		// create callback that calls the Deferres errback method
		return function(type, obj, e){
			deferredRequestHandler.errback(e);
		}
	},

	resultCallback: function(/* dojo.rpc.Deferred */ deferredRequestHandler){
		// summary
		// create callback that calls the Deferred's callback method
		var tf = dojo.lang.hitch(this, 
			function(type, obj, e){
				var results = this.parseResults(obj||e);
				deferredRequestHandler.callback(results); 
			}
		);
		return tf;
	},


	generateMethod: function(/*string*/ method, /*array*/ parameters, /*string*/ url){
		// summary
		// generate the local bind methods for the remote object
		return dojo.lang.hitch(this, function(){
			var deferredRequestHandler = new dojo.rpc.Deferred();

			// if params weren't specified, then we can assume it's varargs
			if( (this.strictArgChecks) &&
				(parameters != null) &&
				(arguments.length != parameters.length)
			){
				// put error stuff here, no enough params
				dojo.raise("Invalid number of parameters for remote method.");
			} else {
				this.bind(method, arguments, deferredRequestHandler, url);
			}

			return deferredRequestHandler;
		});
	},

	processSmd: function(/*json*/ object){
		// summary
		// callback method for reciept of a smd object.  Parse the smd and
		// generate functions based on the description
		dojo.debug("RpcService: Processing returned SMD.");
		if(object.methods){
			dojo.lang.forEach(object.methods, function(m){
				if(m && m["name"]){
					dojo.debug("RpcService: Creating Method: this.", m.name, "()");
					this[m.name] = this.generateMethod(	m.name,
														m.parameters, 
														m["url"]||m["serviceUrl"]||m["serviceURL"]);
					if(dojo.lang.isFunction(this[m.name])){
						dojo.debug("RpcService: Successfully created", m.name, "()");
					}else{
						dojo.debug("RpcService: Failed to create", m.name, "()");
					}
				}
			}, this);
		}

		this.serviceUrl = object.serviceUrl||object.serviceURL;
		dojo.debug("RpcService: Dojo RpcService is ready for use.");
	},

	connect: function(/*String*/ smdUrl){
		// summary
		// connect to a remote url and retrieve a smd object
		dojo.debug("RpcService: Attempting to load SMD document from:", smdUrl);
		dojo.io.bind({
			url: smdUrl,
			mimetype: "text/json",
			load: dojo.lang.hitch(this, function(type, object, e){ return this.processSmd(object); }),
			sync: true
		});		
	}
});

__CPAN_FILE__ src/rpc/yahoo.smd
{
	"SMDVersion":".1",
	"objectName":"yahoo",
	"serviceType":"JSON-P",
	"methods":[
		//
		// MAPS 
		//
		{
			// http://developer.yahoo.com/maps/rest/V1/mapImage.html
			"name":"mapImage",
			"serviceURL": "http://api.local.yahoo.com/MapsService/V1/mapImage",
			"parameters":[
				{ "name":"street", "type":"STRING" },
				{ "name":"city", "type":"STRING" },
				{ "name":"zip", "type":"INTEGER" },
				{ "name":"location", "type":"STRING" },
				{ "name":"longitude", "type":"FLOAT" },
				{ "name":"latitude", "type":"FLOAT" },
				{ "name":"image_type", "type":"STRING" },
				{ "name":"image_width", "type":"INTEGER" },
				{ "name":"image_height", "type":"INTEGER" },
				{ "name":"zoom", "type":"INTEGER" },
				{ "name":"radius", "type":"INTEGER" }
			]
		},
		{
			// http://developer.yahoo.com/traffic/rest/V1/index.html
			"name":"trafficData",
			"serviceURL": "http://api.local.yahoo.com/MapsService/V1/trafficData",
			"parameters":[
				{ "name":"street", "type":"STRING" },
				{ "name":"city", "type":"STRING" },
				{ "name":"zip", "type":"INTEGER" },
				{ "name":"location", "type":"STRING" },
				{ "name":"longitude", "type":"FLOAT" },
				{ "name":"latitude", "type":"FLOAT" },
				{ "name":"severity", "type":"INTEGER" },
				{ "name":"include_map", "type":"INTEGER" },
				{ "name":"image_type", "type":"STRING" },
				{ "name":"image_width", "type":"INTEGER" },
				{ "name":"image_height", "type":"INTEGER" },
				{ "name":"zoom", "type":"INTEGER" },
				{ "name":"radius", "type":"INTEGER" }
			]
		},
		/*
			// Yahoo's geocoding service is f'd for JSON and Y! advises that it
			// may not be returning
		{
			// http://developer.yahoo.com/maps/rest/V1/geocode.html
			"name":"geocode",
			"serviceURL": "http://api.local.yahoo.com/MapsService/V1/geocode",
			"parameters":[
				{ "name":"street", "type":"STRING" },
				{ "name":"city", "type":"STRING" },
				{ "name":"zip", "type":"INTEGER" },
				{ "name":"location", "type":"STRING" }
			]
		},
		*/
		//
		// LOCAL SEARCH
		//
		{
			// http://developer.yahoo.com/search/local/V3/localSearch.html
			"name":"localSearch",
			"serviceURL": "http://api.local.yahoo.com/LocalSearchService/V3/localSearch",
			"parameters":[
				{ "name":"street", "type":"STRING" },
				{ "name":"city", "type":"STRING" },
				{ "name":"zip", "type":"INTEGER" },
				{ "name":"location", "type":"STRING" },
				{ "name":"listing_id", "type":"STRING" },
				{ "name":"sort", "type":"STRING" }, // "relevence", "title", "distance", or "rating"
				{ "name":"start", "type":"INTEGER" },
				{ "name":"radius", "type":"FLOAT" },
				{ "name":"results", "type":"INTEGER" }, // 1-50, defaults to 10
				{ "name":"longitude", "type":"FLOAT" },
				{ "name":"latitude", "type":"FLOAT" },
				{ "name":"category", "type":"INTEGER" },
				{ "name":"omit_category", "type":"INTEGER" },
				{ "name":"minimum_rating", "type":"INTEGER" }
			]
		},
		//
		// WEB SEARCH
		//

		// NOTE: contextual search and term extraction are not stubbed out
		// becaues I'm not sure if we can POST via script src inclusion method
		{
			// http://developer.yahoo.com/search/web/V1/webSearch.html 
			"name":"webSearch",
			"serviceURL": "http://api.search.yahoo.com/WebSearchService/V1/webSearch",
			"parameters":[
				{ "name":"query", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // defaults to "all"
				{ "name":"region", "type":"STRING" }, // defaults to "us"
				{ "name":"results", "type":"INTEGER" }, // defaults to 10
				{ "name":"start", "type":"INTEGER" }, // defaults to 1
				{ "name":"format", "type":"STRING" }, // defaults to "any", can be "html", "msword", "pdf", "ppt", "rst", "txt", or "xls"
				{ "name":"adult_ok", "type":"INTEGER" }, // defaults to null
				{ "name":"similar_ok", "type":"INTEGER" }, // defaults to null
				{ "name":"language", "type":"STRING" }, // defaults to null
				{ "name":"country", "type":"STRING" }, // defaults to null
				{ "name":"site", "type":"STRING" }, // defaults to null
				{ "name":"subscription", "type":"STRING" }, // defaults to null
				{ "name":"license", "type":"STRING" } // defaults to "any"
			]
		},
		{
			// http://developer.yahoo.com/search/web/V1/spellingSuggestion.html
			"name":"spellingSuggestion",
			"serviceURL": "http://api.search.yahoo.com/WebSearchService/V1/spellingSuggestion",
			"parameters":[ { "name":"query", "type":"STRING" } ]
		},
		{
			// http://developer.yahoo.com/search/web/V1/relatedSuggestion.html
			"name":"spellingSuggestion",
			"serviceURL": "http://api.search.yahoo.com/WebSearchService/V1/relatedSuggestion",
			"parameters":[
				{ "name":"query", "type":"STRING" },
				{ "name":"results", "type":"INTEGER" } // 1-50, defaults to 10
			]
		},
		//
		// IMAGE SEARCH
		//
		{
			// http://developer.yahoo.com/search/image/V1/imageSearch.html
			"name":"imageSearch",
			"serviceURL": "http://api.search.yahoo.com/ImageSearchService/V1/imageSearch",
			"parameters":[
				{ "name":"query", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // defaults to "all", can by "any" or "phrase"
				{ "name":"results", "type":"INTEGER" }, // defaults to 10
				{ "name":"start", "type":"INTEGER" }, // defaults to 1
				{ "name":"format", "type":"STRING" }, // defaults to "any", can be "bmp", "gif", "jpeg", or "png"
				{ "name":"adult_ok", "type":"INTEGER" }, // defaults to null
				{ "name":"coloration", "type":"STRING" }, // "any", "color", or "bw"
				{ "name":"site", "type":"STRING" } // defaults to null
			]
		},
		//
		// SITE EXPLORER
		//
		{
			// http://developer.yahoo.com/search/siteexplorer/V1/inlinkData.html 
			"name":"inlinkData",
			"serviceURL": "http://api.search.yahoo.com/SiteExplorerService/V1/inlinkData",
			"parameters":[
				{ "name":"query", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // defaults to "all", can by "any" or "phrase"
				{ "name":"entire_site", "type":"INTEGER" }, // defaults to null
				{ "name":"omit_inlinks", "type":"STRING" }, // "domain" or "subdomain", defaults to null
				{ "name":"results", "type":"INTEGER" }, // defaults to 50
				{ "name":"start", "type":"INTEGER" }, // defaults to 1
				{ "name":"site", "type":"STRING" } // defaults to null
			]
		},
		{
			// http://developer.yahoo.com/search/siteexplorer/V1/pageData.html
			"name":"pageData",
			"serviceURL": "http://api.search.yahoo.com/SiteExplorerService/V1/pageData",
			"parameters":[
				{ "name":"query", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // defaults to "all", can by "any" or "phrase"
				{ "name":"domain_only", "type":"INTEGER" }, // defaults to null
				{ "name":"results", "type":"INTEGER" }, // defaults to 50
				{ "name":"start", "type":"INTEGER" }, // defaults to 1
				{ "name":"site", "type":"STRING" } // defaults to null
			]
		},
		//
		// MUSIC SEARCH
		//
		{
			// http://developer.yahoo.com/search/audio/V1/artistSearch.html
			"name":"artistSearch",
			"serviceURL": "http://api.search.yahoo.com/AudioSearchService/V1/artistSearch",
			"parameters":[
				{ "name":"artist", "type":"STRING" },
				{ "name":"artistid", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // "all", "any", or "phrase"
				{ "name":"results", "type":"INTEGER" }, // 1-50, defaults to 10
				{ "name":"start", "type":"INTEGER" } // defaults to 1
			]
		},
		{
			// http://developer.yahoo.com/search/audio/V1/albumSearch.html
			"name":"albumSearch",
			"serviceURL": "http://api.search.yahoo.com/AudioSearchService/V1/albumSearch",
			"parameters":[
				{ "name":"artist", "type":"STRING" },
				{ "name":"artistid", "type":"STRING" },
				{ "name":"album", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // "all", "any", or "phrase"
				{ "name":"results", "type":"INTEGER" }, // 1-50, defaults to 10
				{ "name":"start", "type":"INTEGER" } // defaults to 1
			]
		},
		{
			// http://developer.yahoo.com/search/audio/V1/songSearch.html
			"name":"songSearch",
			"serviceURL": "http://api.search.yahoo.com/AudioSearchService/V1/songSearch",
			"parameters":[
				{ "name":"artist", "type":"STRING" },
				{ "name":"artistid", "type":"STRING" },
				{ "name":"album", "type":"STRING" },
				{ "name":"albumid", "type":"STRING" },
				{ "name":"song", "type":"STRING" },
				{ "name":"songid", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // "all", "any", or "phrase"
				{ "name":"results", "type":"INTEGER" }, // 1-50, defaults to 10
				{ "name":"start", "type":"INTEGER" } // defaults to 1
			]
		},
		{
			// http://developer.yahoo.com/search/audio/V1/songDownloadLocation.html
			"name":"songDownloadLocation",
			"serviceURL": "http://api.search.yahoo.com/AudioSearchService/V1/songDownloadLocation",
			"parameters":[
				{ "name":"songid", "type":"STRING" },
				// "source" can contain:
				//	audiolunchbox artistdirect buymusic dmusic
				//	emusic epitonic garageband itunes yahoo
				//	livedownloads mp34u msn musicmatch mapster passalong
				//	rhapsody soundclick theweb
				{ "name":"source", "type":"STRING" },
				{ "name":"results", "type":"INTEGER" }, // 1-50, defaults to 10
				{ "name":"start", "type":"INTEGER" } // defaults to 1
			]
		},
		//
		// NEWS SEARCH
		//
		{
			// http://developer.yahoo.com/search/news/V1/newsSearch.html
			"name":"newsSearch",
			"serviceURL": "http://api.search.yahoo.com/NewsSearchService/V1/newsSearch",
			"parameters":[
				{ "name":"query", "type":"STRING" },
				{ "name":"type", "type":"STRING" }, // defaults to "all"
				{ "name":"results", "type":"INTEGER" }, // defaults to 10
				{ "name":"start", "type":"INTEGER" }, // defaults to 1
				{ "name":"sort", "type":"STRING" }, // "rank" or "date"
				{ "name":"language", "type":"STRING" }, // defaults to null
				{ "name":"site", "type":"STRING" } // defaults to null
			]
		}
		/*
		{
			// 
			"name":"",
			"serviceURL": "",
			"parameters":[
				{ "name":"street", "type":"STRING" },
			]
		}
		*/
	]
}

__CPAN_FILE__ src/rpc/YahooService.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.rpc.YahooService");
dojo.require("dojo.rpc.RpcService");
dojo.require("dojo.rpc.JsonService");
dojo.require("dojo.json");
dojo.require("dojo.uri.*");
dojo.require("dojo.io.ScriptSrcIO");

dojo.rpc.YahooService = function(appId){
	this.appId = appId;
	if(!appId){
		this.appId = "dojotoolkit";
		dojo.debug(	"please initializae the YahooService class with your own",
					"application ID. Using the default may cause problems during",
					"deployment of your application");
	}
	this.connect(dojo.uri.dojoUri("src/rpc/yahoo.smd"));
	this.scrictArgChecks = false;
}

dojo.inherits(dojo.rpc.YahooService, dojo.rpc.JsonService);

dojo.lang.extend(dojo.rpc.YahooService, {
	strictArgChecks: false,

	bind: function(method, parameters, deferredRequestHandler, url){
		var params = parameters;
		if(	(dojo.lang.isArrayLike(parameters))&&
			(parameters.length == 1)){
			params = parameters[0];
		}
		params.output = "json";
		params.appid= this.appId;
		dojo.io.bind({
			url: url||this.serviceUrl,
			transport: "ScriptSrcTransport",
			// FIXME: need to get content interpolation fixed
			content: params,
			jsonParamName: "callback",
			mimetype: "text/json",
			load: this.resultCallback(deferredRequestHandler),
			error: this.errorCallback(deferredRequestHandler),
			preventCache: true
		});
	}
});

__CPAN_FILE__ src/rpc/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.rpc.JsonService", false, false]
});
dojo.provide("dojo.rpc.*");

__CPAN_DIR__ src/selection
__CPAN_FILE__ src/selection/Selection.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.selection.Selection");
dojo.require("dojo.lang.array");
dojo.require("dojo.lang.func");
dojo.require("dojo.math");

dojo.selection.Selection = function(items, isCollection) {
	this.items = [];
	this.selection = [];
	this._pivotItems = [];
	this.clearItems();

	if(items) {
		if(isCollection) {
			this.setItemsCollection(items);
		} else {
			this.setItems(items);
		}
	}
}
dojo.lang.extend(dojo.selection.Selection, {
	items: null, // items to select from, order matters for growable selections

	selection: null, // items selected, aren't stored in order (see sorted())
	lastSelected: null, // last item selected

	allowImplicit: true, // if true, grow selection will start from 0th item when nothing is selected
	length: 0, // number of *selected* items

	// if true, the selection is treated as an in-order and can grow by ranges, not just by single item
	isGrowable: true,

	_pivotItems: null, // stack of pivot items
	_pivotItem: null, // item we grow selections from, top of stack

	// event handlers
	onSelect: function(item) {},
	onDeselect: function(item) {},
	onSelectChange: function(item, selected) {},

	_find: function(item, inSelection) {
		if(inSelection) {
			return dojo.lang.find(item, this.selection);
		} else {
			return dojo.lang.find(item, this.items);
		}
	},

	isSelectable: function(item) {
		// user-customizable, will filter items through this
		return true;
	},

	setItems: function(/* ... */) {
		this.clearItems();
		this.addItems.call(this, arguments);
	},

	// this is in case you have an active collection array-like object
	// (i.e. getElementsByTagName collection) that manages its own order
	// and item list
	setItemsCollection: function(collection) {
		this.items = collection;
	},

	addItems: function(/* ... */) {
		var args = dojo.lang.unnest(arguments);
		for(var i = 0; i < args.length; i++) {
			this.items.push(args[i]);
		}
	},

	addItemsAt: function(item, before /* ... */) {
		if(this.items.length == 0) { // work for empy case
			return this.addItems(dojo.lang.toArray(arguments, 2));
		}

		if(!this.isItem(item)) {
			item = this.items[item];
		}
		if(!item) { throw new Error("addItemsAt: item doesn't exist"); }
		var idx = this._find(item);
		if(idx > 0 && before) { idx--; }
		for(var i = 2; i < arguments.length; i++) {
			if(!this.isItem(arguments[i])) {
				this.items.splice(idx++, 0, arguments[i]);
			}
		}
	},

	removeItem: function(item) {
		// remove item
		var idx = this._find(item);
		if(idx > -1) {
			this.items.splice(i, 1);
		}
		// remove from selection
		// FIXME: do we call deselect? I don't think so because this isn't how
		// you usually want to deselect an item. For example, if you deleted an
		// item, you don't really want to deselect it -- you want it gone. -DS
		id = this._find(item, true);
		if(idx > -1) {
			this.selection.splice(i, 1);
		}
	},

	clearItems: function() {
		this.items = [];
		this.deselectAll();
	},

	isItem: function(item) {
		return this._find(item) > -1;
	},

	isSelected: function(item) {
		return this._find(item, true) > -1;
	},

	/**
	 * allows you to filter item in or out of the selection
	 * depending on the current selection and action to be taken
	**/
	selectFilter: function(item, selection, add, grow) {
		return true;
	},

	/**
	 * update -- manages selections, most selecting should be done here
	 *  item => item which may be added/grown to/only selected/deselected
	 *  add => behaves like ctrl in windows selection world
	 *  grow => behaves like shift
	 *  noToggle => if true, don't toggle selection on item
	**/
	update: function(item, add, grow, noToggle) {
		if(!this.isItem(item)) { return false; }

		if(this.isGrowable && grow) {
			if(!this.isSelected(item)
				&& this.selectFilter(item, this.selection, false, true)) {
				this.grow(item);
				this.lastSelected = item;
			}
		} else if(add) {
			if(this.selectFilter(item, this.selection, true, false)) {
				if(noToggle) {
					if(this.select(item)) {
						this.lastSelected = item;
					}
				} else if(this.toggleSelected(item)) {
					this.lastSelected = item;
				}
			}
		} else {
			this.deselectAll();
			this.select(item);
		}

		this.length = this.selection.length;
	},

	/**
	 * Grow a selection.
	 *  toItem => which item to grow selection to
	 *  fromItem => which item to start the growth from (it won't be selected)
	 *
	 * Any items in (fromItem, lastSelected] that aren't part of
	 * (fromItem, toItem] will be deselected
	**/
	grow: function(toItem, fromItem) {
		if(!this.isGrowable) { return; }

		if(arguments.length == 1) {
			fromItem = this._pivotItem;
			if(!fromItem && this.allowImplicit) {
				fromItem = this.items[0];
			}
		}
		if(!toItem || !fromItem) { return false; }

		var fromIdx = this._find(fromItem);

		// get items to deselect (fromItem, lastSelected]
		var toDeselect = {};
		var lastIdx = -1;
		if(this.lastSelected) {
			lastIdx = this._find(this.lastSelected);
			var step = fromIdx < lastIdx ? -1 : 1;
			var range = dojo.math.range(lastIdx, fromIdx, step);
			for(var i = 0; i < range.length; i++) {
				toDeselect[range[i]] = true;
			}
		}

		// add selection (fromItem, toItem]
		var toIdx = this._find(toItem);
		var step = fromIdx < toIdx ? -1 : 1;
		var shrink = lastIdx >= 0 && step == 1 ? lastIdx < toIdx : lastIdx > toIdx;
		var range = dojo.math.range(toIdx, fromIdx, step);
		if(range.length) {
			for(var i = range.length-1; i >= 0; i--) {
				var item = this.items[range[i]];
				if(this.selectFilter(item, this.selection, false, true)) {
					if(this.select(item, true) || shrink) {
						this.lastSelected = item;
					}
					if(range[i] in toDeselect) {
						delete toDeselect[range[i]];
					}
				}
			}
		} else {
			this.lastSelected = fromItem;
		}

		// now deselect...
		for(var i in toDeselect) {
			if(this.items[i] == this.lastSelected) {
				dbg("oops!");
			}
			this.deselect(this.items[i]);
		}

		// make sure everything is all kosher after selections+deselections
		this._updatePivot();
	},

	/**
	 * Grow selection upwards one item from lastSelected
	**/
	growUp: function() {
		if(!this.isGrowable) { return; }

		var idx = this._find(this.lastSelected) - 1;
		while(idx >= 0) {
			if(this.selectFilter(this.items[idx], this.selection, false, true)) {
				this.grow(this.items[idx]);
				break;
			}
			idx--;
		}
	},

	/**
	 * Grow selection downwards one item from lastSelected
	**/
	growDown: function() {
		if(!this.isGrowable) { return; }

		var idx = this._find(this.lastSelected);
		if(idx < 0 && this.allowImplicit) {
			this.select(this.items[0]);
			idx = 0;
		}
		idx++;
		while(idx > 0 && idx < this.items.length) {
			if(this.selectFilter(this.items[idx], this.selection, false, true)) {
				this.grow(this.items[idx]);
				break;
			}
			idx++;
		}
	},

	toggleSelected: function(item, noPivot) {
		if(this.isItem(item)) {
			if(this.select(item, noPivot)) { return 1; }
			if(this.deselect(item)) { return -1; }
		}
		return 0;
	},

	select: function(item, noPivot) {
		if(this.isItem(item) && !this.isSelected(item)
			&& this.isSelectable(item)) {
			this.selection.push(item);
			this.lastSelected = item;
			this.onSelect(item);
			this.onSelectChange(item, true);
			if(!noPivot) {
				this._addPivot(item);
			}
			return true;
		}
		return false;
	},

	deselect: function(item) {
		var idx = this._find(item, true);
		if(idx > -1) {
			this.selection.splice(idx, 1);
			this.onDeselect(item);
			this.onSelectChange(item, false);
			if(item == this.lastSelected) {
				this.lastSelected = null;
			}

			this._removePivot(item);

			return true;
		}
		return false;
	},

	selectAll: function() {
		for(var i = 0; i < this.items.length; i++) {
			this.select(this.items[i]);
		}
	},

	deselectAll: function() {
		while(this.selection && this.selection.length) {
			this.deselect(this.selection[0]);
		}
	},

	selectNext: function() {
		var idx = this._find(this.lastSelected);
		while(idx > -1 && ++idx < this.items.length) {
			if(this.isSelectable(this.items[idx])) {
				this.deselectAll();
				this.select(this.items[idx]);
				return true;
			}
		}
		return false;
	},

	selectPrevious: function() {
		//debugger;
		var idx = this._find(this.lastSelected);
		while(idx-- > 0) {
			if(this.isSelectable(this.items[idx])) {
				this.deselectAll();
				this.select(this.items[idx]);
				return true;
			}
		}
		return false;
	},

	// select first selectable item
	selectFirst: function() {
		this.deselectAll();
		var idx = 0;
		while(this.items[idx] && !this.select(this.items[idx])) {
			idx++;
		}
		return this.items[idx] ? true : false;
	},

	// select last selectable item
	selectLast: function() {
		this.deselectAll();
		var idx = this.items.length-1;
		while(this.items[idx] && !this.select(this.items[idx])) {
			idx--;
		}
		return this.items[idx] ? true : false;
	},

	_addPivot: function(item, andClear) {
		this._pivotItem = item;
		if(andClear) {
			this._pivotItems = [item];
		} else {
			this._pivotItems.push(item);
		}
	},

	_removePivot: function(item) {
		var i = dojo.lang.find(item, this._pivotItems);
		if(i > -1) {
			this._pivotItems.splice(i, 1);
			this._pivotItem = this._pivotItems[this._pivotItems.length-1];
		}

		this._updatePivot();
	},

	_updatePivot: function() {
		if(this._pivotItems.length == 0) {
			if(this.lastSelected) {
				this._addPivot(this.lastSelected);
			}
		}
	},

	sorted: function() {
		return dojo.lang.toArray(this.selection).sort(
			dojo.lang.hitch(this, function(a, b) {
				var A = this._find(a), B = this._find(b);
				if(A > B) {
					return 1;
				} else if(A < B) {
					return -1;
				} else {
					return 0;
				}
			})
		);
	},

	// remove any items from the selection that are no longer in this.items
	updateSelected: function() {
		for(var i = 0; i < this.selection.length; i++) {
			if(this._find(this.selection[i]) < 0) {
				var removed = this.selection.splice(i, 1);

				this._removePivot(removed[0]);
			}
		}

		this.length = this.selection.length;
	}
});

__CPAN_DIR__ src/storage
__CPAN_FILE__ src/storage/browser.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.storage.browser");
dojo.provide("dojo.storage.browser.FlashStorageProvider");

dojo.require("dojo.storage");
dojo.require("dojo.flash");
dojo.require("dojo.json");
dojo.require("dojo.uri.*");

/** 
		Storage provider that uses features in Flash to achieve permanent storage.
		
		@author Alex Russel, alex@dojotoolkit.org
		@author Brad Neuberg, bkn3@columbia.edu 
*/
dojo.storage.browser.FlashStorageProvider = function(){
}

dojo.inherits(dojo.storage.browser.FlashStorageProvider, dojo.storage);

// instance methods and properties
dojo.lang.extend(dojo.storage.browser.FlashStorageProvider, {
	namespace: "default",
	initialized: false,
	_available: null,
	_statusHandler: null,
	
	initialize: function(){
		// initialize our Flash
		var loadedListener = function(){
			dojo.storage._flashLoaded();
		}
		dojo.flash.addLoadedListener(loadedListener);
		var swfloc6 = dojo.uri.dojoUri("Storage_version6.swf").toString();
		var swfloc8 = dojo.uri.dojoUri("Storage_version8.swf").toString();
		dojo.flash.setSwf({flash6: swfloc6, flash8: swfloc8, visible: false});
	},
	
	isAvailable: function(){
		if(djConfig["disableFlashStorage"] == true){
			this._available = false;
		}
		
		return this._available;
	},
	
	setNamespace: function(namespace){
		this.namespace = namespace;
	},

	put: function(key, value, resultsHandler){
		if(this.isValidKey(key) == false){
			dojo.raise("Invalid key given: " + key);
		}
			
		this._statusHandler = resultsHandler;
		
		// serialize the value
		// Handle strings differently so they have better performance
		if(dojo.lang.isString(value)){
			value = "string:" + value;
		}else{
			value = dojo.json.serialize(value);
		}
		
		dojo.flash.comm.put(key, value, this.namespace);
	},

	get: function(key){
		if(this.isValidKey(key) == false){
			dojo.raise("Invalid key given: " + key);
		}
		
		var results = dojo.flash.comm.get(key, this.namespace);

		if(results == ""){
			return null;
		}
    
		// destringify the content back into a 
		// real JavaScript object
		// Handle strings differently so they have better performance
		if(!dojo.lang.isUndefined(results) && results != null 
			 && /^string:/.test(results)){
			results = results.substring("string:".length);
		}else{
			results = dojo.json.evalJson(results);
		}
    
		return results;
	},

	getKeys: function(){
		var results = dojo.flash.comm.getKeys(this.namespace);
		
		if(results == ""){
			return new Array();
		}

		// the results are returned comma seperated; split them
		results = results.split(",");
		
		return results;
	},

	clear: function(){
		dojo.flash.comm.clear(this.namespace);
	},
	
	remove: function(key){
	},
	
	isPermanent: function(){
		return true;
	},

	getMaximumSize: function(){
		return dojo.storage.SIZE_NO_LIMIT;
	},

	hasSettingsUI: function(){
		return true;
	},

	showSettingsUI: function(){
		dojo.flash.comm.showSettings();
		dojo.flash.obj.setVisible(true);
		dojo.flash.obj.center();
	},

	hideSettingsUI: function(){
		// hide the dialog
		dojo.flash.obj.setVisible(false);
		
		// call anyone who wants to know the dialog is
		// now hidden
		if(dojo.storage.onHideSettingsUI != null &&
			!dojo.lang.isUndefined(dojo.storage.onHideSettingsUI)){
			dojo.storage.onHideSettingsUI.call(null);	
		}
	},
	
	/** 
			The provider name as a string, such as 
			"dojo.storage.FlashStorageProvider". 
	*/
	getType: function(){
		return "dojo.storage.FlashStorageProvider";
	},
	
	/** Called when the Flash is finished loading. */
	_flashLoaded: function(){
		this.initialized = true;

		// indicate that this storage provider is now loaded
		dojo.storage.manager.loaded();
	},
	
	/** 
			Called if the storage system needs to tell us about the status
			of a put() request. 
	*/
	_onStatus: function(statusResult, key){
		//dojo.debug("_onStatus, statusResult="+statusResult+", key="+key);
		if(statusResult == dojo.storage.PENDING){
			dojo.flash.obj.center();
			dojo.flash.obj.setVisible(true);
		}else{
			dojo.flash.obj.setVisible(false);
		}
		
		if(!dojo.lang.isUndefined(dojo.storage._statusHandler) 
				&& dojo.storage._statusHandler != null){
			dojo.storage._statusHandler.call(null, statusResult, key);		
		}
	}
});

// register the existence of our storage providers
dojo.storage.manager.register("dojo.storage.browser.FlashStorageProvider",
                              new dojo.storage.browser.FlashStorageProvider());

// now that we are loaded and registered tell the storage manager to initialize
// itself
dojo.storage.manager.initialize();
															

__CPAN_FILE__ src/storage/dashboard.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.storage");
dojo.require("dojo.json");
dojo.provide("dojo.storage.dashboard");

dojo.storage.dashboard.StorageProvider = function(){
	this.initialized = false;
}

dojo.inherits(dojo.storage.dashboard.StorageProvider, dojo.storage.StorageProvider);

dojo.lang.extend(dojo.storage.dashboard.StorageProvider, {
	storageOnLoad: function(){
		this.initialized = true;
	},

	set: function(key, value, ns){
		if (ns && widget.system){
			widget.system("/bin/mkdir " + ns);
			var system = widget.system("/bin/echo " + value + " >" + ns + "/" + key);
			if(system.errorString){
				return false;
			}
			return true;
		}

		return widget.setPreferenceForKey(dojo.json.serialize(value), key);
	},

	get: function(key, ns){
		if (ns && widget.system) {
			var system = widget.system("/bin/cat " + ns + "/" + key);
			if(system.errorString){
				return "";
			}
			return system.outputString;
		}

		return dojo.json.evalJson(widget.preferenceForKey(key));
	}
});

dojo.storage.setProvider(new dojo.storage.dashboard.StorageProvider());

__CPAN_FILE__ src/storage/Storage.as
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

import DojoExternalInterface;

class Storage {
	public static var SUCCESS = "success";
	public static var FAILED = "failed";
	public static var PENDING = "pending";
	
	public var so;
	
	public function Storage(){
		DojoExternalInterface.initialize();
		DojoExternalInterface.addCallback("put", this, put);
		DojoExternalInterface.addCallback("get", this, get);
		DojoExternalInterface.addCallback("showSettings", this, showSettings);
		DojoExternalInterface.addCallback("clear", this, clear);
		DojoExternalInterface.addCallback("getKeys", this, getKeys);
		DojoExternalInterface.addCallback("remove", this, remove);
		DojoExternalInterface.loaded();
		
		// preload the System Settings finished button movie for offline
		// access so it is in the cache
		_root.createEmptyMovieClip("_settingsBackground", 1);
		_root._settingsBackground.loadMovie("../../storage_dialog.swf");
	}

	public function put(keyName, keyValue, namespace){
		// Get the SharedObject for these values and save it
		so = SharedObject.getLocal(namespace);
		
		// prepare a storage status handler
		var self = this;
		so.onStatus = function(infoObject:Object){
			//getURL("javascript:dojo.debug('FLASH: onStatus, infoObject="+infoObject.code+"')");
			
			// delete the data value if the request was denied
			if (infoObject.code == "SharedObject.Flush.Failed"){
				delete self.so.data[keyName];
			}
			
			var statusResults;
			if(infoObject.code == "SharedObject.Flush.Failed"){
				statusResults = Storage.FAILED;
			}else if(infoObject.code == "SharedObject.Flush.Pending"){
				statusResults = Storage.PENDING;
			}else if(infoObject.code == "SharedObject.Flush.Success"){
				statusResults = Storage.SUCCESS;
			}
			//getURL("javascript:dojo.debug('FLASH: onStatus, statusResults="+statusResults+"')");
			
			// give the status results to JavaScript
			DojoExternalInterface.call("dojo.storage._onStatus", null, statusResults, 
																 keyName);
		}
		
		// save the key and value
		so.data[keyName] = keyValue;
		var flushResults = so.flush();
		
		// return results of this command to JavaScript
		var statusResults;
		if(flushResults == true){
			statusResults = Storage.SUCCESS;
		}else if(flushResults == "pending"){
			statusResults = Storage.PENDING;
		}else{
			statusResults = Storage.FAILED;
		}
		
		DojoExternalInterface.call("dojo.storage._onStatus", null, statusResults, 
															 keyName);
	}

	public function get(keyName, namespace){
		// Get the SharedObject for these values and save it
		so = SharedObject.getLocal(namespace);
		var results = so.data[keyName];
		
		return results;
	}
	
	public function showSettings(){
		// Show the configuration options for the Flash player, opened to the
		// section for local storage controls (pane 1)
		System.showSettings(1);
		
		// there is no way we can intercept when the Close button is pressed, allowing us
		// to hide the Flash dialog. Instead, we need to load a movie in the
		// background that we can show a close button on.
		_root.createEmptyMovieClip("_settingsBackground", 1);
		_root._settingsBackground.loadMovie("../../storage_dialog.swf");
	}
	
	public function clear(namespace){
		so = SharedObject.getLocal(namespace);
		so.clear();
		so.flush();
	}
	
	public function getKeys(namespace){
		// Returns a list of the available keys in this namespace
		
		// get the storage object
		so = SharedObject.getLocal(namespace);
		
		// get all of the keys
		var results = new Array();
		for(var i in so.data)
			results.push(i);	
		
		// join the keys together in a comma seperate string
		results = results.join(",");
		
		return results;
	}
	
	public function remove(keyName, namespace){
		// Removes a key

		// get the storage object
		so = SharedObject.getLocal(namespace);
		
		// delete this value
		delete so.data[keyName];
		
		// save the changes
		so.flush();
	}

	static function main(mc){
		//getURL("javascript:dojo.debug('FLASH: storage loaded')");
		_root.app = new Storage(); 
	}
}


__CPAN_FILE__ src/storage/storage_dialog.fla
                >  	                                       	   
          R o o t   E n t r y                                                  p|YrRASH               !e         C o n t e n t s                                                                                          {j     P a g e   1                                                                                                     M e d i a   1                                                                                                                  B                       R o o t   E n t r y                                                  p|YrRASH              :73d         C o n t e n t s                                                                                          {j     P a g e   1                                                                                                     M e d i a   1                                                                                                                                                 !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~                         	  
                                               !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @  A                                                      	   
                                                                      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~      8                   CDocumentPageP a g e   1 S c e n e   1                           8">D                                    GD                                                                                                                     CSwfPageM e d i a   1 B u t t o n   	W?                 C          B u t t o n                              B u t t o n            m x . c o n t r o l s . B u t t o n C : \ D o c u m e n t s   a n d   S e t t i n g s \ b r a d n e u b e r g \ L o c a l   S e t t i n g s \ A p p l i c a t i o n   D a t a \ M a c r o m e d i a \ F l a s h   M X   2 0 0 4 \ e n \ C o n f i g u r a t i o n \ T M P 3 y j b t s 6 p 0 8 . . s w f ]o  CWS x;	l\q].)")RE,,DY!_O&i#a";NU Ip&5hH44{+(oy3f{o_W=#ZV
{ '"`^|"X{_n~l)<?N=`^.ObG}s9R~8g`a :?~9N~rt?q.oyokW?;WCqkC5RrJ
-Ba- v
^ Frsp`E8rY\t	!c9H9tq&iUL{;G}s?4qgR&M4,M^(j3;97_}gd>1e0Z0Z-OV6~o,}`,#y+{!a	9\&FaC=way@rq*/YPu+8h> 7+G]wUqvulfuv
ywqI2wV(jvGd	!:oe]xHV* )ylZ0m:HY}b	!k/Zg*E;mV/@b5V(Kq2/:f8P(]Ach]p}2Y B}g@nYb1yrqQj,[P*[!qzqm0{gOb9H gA4IG\
dfEiJJ.,v"TQ=cdCrtIxdv}k'o#2 - qa2v[zxqg:C_l
	l7;e`<ZKi]#!?:a'4-<yE!yEh[cP!D]$9{5bIM3C2t&"'o:pr	nZOw0 2_x i jH,g@j	5tLS]qa\^6 }xD/4&4WBd1bP	>7`G#BG)tf(v~$;_-|Mx,'ciAK>>:;D0=HToe,n;;Gb=7*d)
R4AGx\}$Yy^
)x@~rsl4A^$w"(k]hXm1FcM(~g&LKDp^n`MT-eb0!WES4QWNV0a[E(2rVa0d"eVboGRaw^IT'!<ZYoCR
IQm5@us0=B77(NA$k]t#O@hA[cy]u$HHsv'v_G=i  CPicPage  	 CPicLayer  	 CPicFrame   CPicSwf     %	                I            }v       c l o s e B u t t o n 	   i c o n              i c o n  FLs     l a b e l             F i n i s h e d l a b e l  Eb[cFE\G     l a b e l P l a c e m e n t            l e f t r i g h t t o p b o t t o m l a b e l P l a c e m e n t  TI^D     s e l e c t e d             f a l s e s e l e c t e d  /?ZJ|g     t o g g l e             f a l s e t o g g l e  gYD     e n a b l e d             t r u e e n a b l e d  !RG5S8bmO t h e r    v i s i b l e             t r u e v i s i b l e  D*LcXTC$vO t h e r    	m i n H e i g h t             0 	m i n H e i g h t  PKu@&jS i z e    m i n W i d t h             0 m i n W i d t h  !7C2I l/S i z e               < c o m p o n e n t   m e t a D a t a F e t c h e d = ' t r u e '   s c h e m a U r l = ' '   s c h e m a O p e r a t i o n = ' '   s c e n e R o o t L a b e l = ' S c e n e   1 '   o l d C o p i e d C o m p o n e n t P a t h = ' 1 ' > 
 	 < e v e n t M a p > 
 	 	 < p r o p e r t y   n a m e = " s e l e c t e d "   v a l u e = " c l i c k "   / > 
 	 < / e v e n t M a p > 
 	 < p r o p e r t y   n a m e = " s e l e c t e d " > 
 < s c h e m a   n a m e = " B o o l e a n "   b a s e = " B o o l e a n "   c l a s s = " m x . d a t a . t y p e s . B o o l "   r e q u i r e d = " t r u e "   r e a d o n l y = " f a l s e "   w r i t e o n l y = " f a l s e "   c a t e g o r y = " s i m p l e "   o r i g i n a l = " t r u e " > 
 	 	 	 < p r o p e r t i e s > 
 	 	 	 	 < p r o p e r t y   n a m e = " d e f a u l t L a b e l "   v a l u e = " "   / > 
 	 	 	 	 < p r o p e r t y   n a m e = " d e f a u l t U I C o n t r o l "   v a l u e = " "   / > 
 	 	 	 < / p r o p e r t i e s > 
 	 	 < / s c h e m a > 
 	 < / p r o p e r t y > 
 < / c o m p o n e n t > 
   CPicText                             /          X       
 _ s a n s           (               P r e s s   F i n i s h e d   w h e n   d o n e                                                            _!l  0  0_!  0  l                   ?       Zz      V/ /   k n o w   w h e n   t h e   c l o s e   b u t t o n   i s   p r e s s e d ;   t h i s   i s   n e e d e d   a s   a   w o r k a r o u n d   w h e n  
 / /   s h o w i n g   t h e   s t o r a g e   c o n f i g u r a t i o n   d i a l o g ,   s i n c e   t h e r e   i s   n o   w a y   w e   c a n  
 / /   k n o w   w h e n   t h a t   p a n e l ' s   c l o s e   b u t t o n   i s   p r e s s e d  
 c l o s e B u t t o n . o n M o u s e D o w n   =   f u n c t i o n ( ) {  
 	 / /   s o m e   v e r s i o n s   o f   F l a s h   d o n ' t   h a v e   a c c e s s   t o   c o n t a i n i n g   p a r e n t s    
 	 / /   o b j e c t s ,   l i k e   D o j o E x t e r n a l I n t e r f a c e ;   o n l y   F l a s h   8   s e e m s   t o   h a v e   a c c e s s  
 	 i f ( t y p e o f   D o j o E x t e r n a l I n t e r f a c e   ! =   " u n d e f i n e d " ) {   / /   f l a s h   8  
 	 	 D o j o E x t e r n a l I n t e r f a c e . c a l l ( " d o j o . s t o r a g e . h i d e S e t t i n g s U I " ,   n u l l ) ;  
 	 } e l s e {   / /   f l a s h   6  
 	 	 f s c o m m a n d ( " c a l l " ,   " d o j o . s t o r a g e . h i d e S e t t i n g s U I " ) ;  
 	 }  
 } ;                                         L a y e r   1   OO                        " ,   " d o j o . s t o r a g e . h i d e S e t t i n g s U I " ) ;  
 } ;                                         L a y e r   1   OO                         r i g h t t o p b o t t o m l a b e l P l a c e m e n t  TI^D     s e l e c t e d             8                   CDocumentPageP a g e   1 S c e n e   1                           8">D                                    GD                                                                                                                     CSwfPageM e d i a   1 B u t t o n   	W?                 C          B u t t o n                              B u t t o n            m x . c o n t r o l s . B u t t o n C : \ D o c u m e n t s   a n d   S e t t i n g s \ b r a d n e u b e r g \ L o c a l   S e t t i n g s \ A p p l i c a t i o n   D a t a \ M a c r o m e d i a \ F l a s h   M X   2 0 0 4 \ e n \ C o n f i g u r a t i o n \ T M P 3 y j b t s 6 p 0 8 . . s w f ]o  CWS x;	l\q].)")RE,,DY!_O&i#a";NU Ip&5hH44{+(oy3f{o_W=#ZV
{ '"`^|"X{_n~l)<?N=`^.ObG}s9R~8g`a :?~9N~rt?q.oyokW?;WCqkC5RrJ
-Ba- v
^ Frsp`E8rY\t	!c9H9tq&iUL{;G}s?4qgR&M4,M^(j3;97_}gd>1e0Z0Z-OV6~o,}`,#y+{!a	9\&FaC=way@rq*/YPu+8h> 7+G]wUqvulfuv
ywqI2wV(jvGd	!:oe]xHV* )ylZ0m:HY}b	!k/Zg*E;mV/@b5V(Kq2/:f8P(]Ach]p}2Y B}g@nYb1yrqQj,[P*[!qzqm0{gOb9H gA4IG\
dfEiJJ.,v"TQ=cdCrtIxdv}k'o#2 - qa2v[zxqg:C_l
	l7;e`<ZKi]#!?:a'4-<yE!yEh[cP!D]$9{5bIM3C2t&"'o:pr	nZOw0 2_x i jH,g@j	5tLS]qa\^6 }xD/4&4WBd1bP	>7`G#BG)tf(v~$;_-|Mx,'ciAK>>:;D0=HToe,n;;Gb=7*d)
R4AGx\}$Yy^
)x@~rsl4A^$w"(k]hXm1FcM(~g&LKDp^n`MT-eb0!WES4QWNV0a[E(2rVa0d"eVboGRaw^IT'!<ZYoCR
IQm5@us0=B77(NA$k]t#O@hA[cy]u$HHsv'v_G=iZ|o4aIm>db)#2O$M,R0QH)\4>~MaMXtVoK~[<@hV`O,NFnasP|M:H5KbxN]O{1d
'kJlEY--:C2)!HR0Q0^;4ZVn{Cqo&!9=9bt#Bn-dztb?T!SR9on#0@6,B_fa!za&pQ12f/k!jAK% S~H(1J38
*c<n|^`8y8d'&ZwJe!_ tLOOw]#xIe^+sQ+_zO D'Wz};>a;baZZP/fCIvJ2IFKF >oDv_v1tn^uV\E`:xUXcL0AM\hu](;-=R|5yz+*9G`9/t=s}w?]~_:n1w%@;tG4_;C}	&6tu2+k?-V) \]E0(~jQBk_KSXSDpT&.WJ-M) 5(9JlUa=m6kQrK/
+w`61JBVRclUT$44?2J".4Zl8+x7"h-ds{B/w/T}G;h}[xp5~NZB4m7Pw9u,B<ZO,i;#SJ);y:/egiqOtGF;[0kv"5\E)S6"ski0R*KEzsVRgkhER+wAHM!)(~FOO+!qr[+H+c"6!h0$Bs26@@#@PHePd
@Z-F"_")#IQU:&j)p]EShw+QL2J33rU4pS=KP`#H Q]pTh5joZz}1FP[Po=L/S,2}dB]xK&sBY%q0@a.MtfM1;;ydu&t2zibo2\)%wlyf1U9d4c"(x,+Ed&:ICNNZJ<3U8R <iD,^;JqGq'N<_	8b0hlq0];7} tu@.vr}%;;qx$:" nWidJr CZ_9<6xW,]g0q]z]3J(s
X/j$](1d(gm`,zNk|yF<-Gne6S+m&rGW@kw`>Re,S6+!S%F^ 2"ePWB=]uzV!sT<gW]$$I\PC!)h J0U`R,~LEA(![GEx(RYPY&p:]j4=pLxZ=@?%}E<#P;~%$ZD)?Yk-'6yB6T$iCRkfc1U/-J9:X3TPa`eJK:jQYX2L\;z
Y*EJn?UV2edUb\<R
GGQvV~0U]f*Ze4b Te4
$,n*f.*)!653(dSZ,^#f)blU3*E5~[XNYdKaY)Sg9zivE}fvC7>$jj"T*U!b 
_[)+7^O;6NC1(H8+Su3:QdjLUg(so!D/1=R$_*TXV[Zf.-p.#6.,m2=N!<x^gh:!rzG3}Ze}m}}x}e
7fSG<}|w+jmYmH!^j
Sc&JA"JvW7,:"_u>9oCH[qQ8F$rG@Ul/wK6GQJAM<x]k#V6yZhQIlli/PdLIrxv<r4u'O2PSs.tbBv=T0QNgeUmlhBCYooC$EKU.)k=|Z%T@KKOBX u{dj{wy@@&QwJ:U2uA-wy&|V3BcLu*|	JOqx0'1}S#'CoxoZ'W0kOku(:8sTme!>-[
y[WD6E^t1&U!Q7s$~~]F| 9HF%D8#:		t4^gkM+#MhL*z>nca<(#USb4u-^\K:1`iw#cvRRM.k"-1 7<4XRuaPCKPP04'
N'#+p(Z[]F$5 E:-NL,mOwkERjQ F9ZA4
pMr9B@(.hnM[-C({iJ?jT}<}X
_F''~4:6P^%Q(8FJAhzr)\T{M?X?;mv[s[^@WSET1/,p+de{9THS:b7> )6@J*)sGG#J`~\pU!Jp7Jx3>u5Auq{Ih:\1)9?U}S%H!>$WV5jchv%9:/&YP@t9RdS)#t@u]~U @NNw $@dIP  (%^X^fly88N39v%Lwr<>>8#[DuT^ zz|tUOIL%	w|x"*7[`
n+>'M1G1O+ >o/Zp+gP<2fQb` ac|d4Of5o:o$Cd`n.FYZ6aSIzRBB:krjSEZuj7{I2A;nnq9SXSFeF:N1uouPh?uS1>>h8?jSc1=~{QvN?@(>>uap)Vs(zVN\A4ZV3
	5*hMy&b_"Y/
J8&Gq#c*'1q*2L$0z3&BlxY^<`s'.!# ]Y8UcG	@u#xK	O/W"1N)e@3:d4#'FgYiN'H0BY,|V7c7JmPW^M5\6'WWa_9U!yxIf@WKg`7'Q#	=$C29LtV;%(wG26`&:%OXW!Sk_H|2a;r@2Kp|M+>hg`:5MM_pWqv7f1[{Pfo17F|\ 071[FD}2ZflhH'D,JrjB,WrEqNA?(`Y1kYTEfZM/)DdJSH)<HSw p%L(j>t,VYlu|L89mi(ju+Tf,\D[[xom(\s CB=UQ;Juf/ na'&&JSESxFX"$8!Rb cmIvteiU	imK&/ 0=H;iFUFJtHvxAh_xcn*m$[%^p8oIx{jP#A1B;]K|w-]\6N[-mQ\r'4,K	,we-:dwuRwwiEZpNee<XVXVU{w}+_z{*7R C.PM}CUI`x@0`l']8]8j-N'dM.d{<d[_)noI`A7$Q4'$< ;\d,(&M0MblI*b4!EQk- H3-IDt- 
LhrZ0hV6>6a-0>dRVkHj#Wk-wlBTI)F'f<'b34uM [XPy,MN<R,I
9ZQQ R !@LGEPN)v+HgKkn`4c0mNF@s&EYXQL8%RvkoZa/LN@1.|K{x"B~Js`JgTCiyW2i>4vC}$^dTSYJJ8jtfgun1qPDf7+Q&%0hd`':n)n0r0x4F5@r&q5__-Nd=9pkJDjur]BV_F:[/~om,~[ome[}Co`{veD;f=y+Dg()dlxl-5?+:'q8GwBNyjY5[PS'~+UGPv=Z9\ndRSuy}+U[#5Z%Uij]MVB:9(HC{hmRGsx$*2fF^kiAqRKkhPWY-yL6)307#S:' "v;X_Q8(dJ"zpS3&r"4cPP)JUP o6U B8m"s3Eh '[7-`T@C7=4iSl~33s4L%Z;m![\Z%YwspH
T
C!)j!CLzL!5fBYBECtxLJG.bmRiiS%ht`??VM	e@ PQYu$}q)`8XRX*J%OdVDe/V(|ZVg )&4`DG	Wk*A)L7i|3nLY7(tFeoTV#h~~<N'})z'\F?1$')9[IR[U:dsRNb8ax;mA
"Kt)a#@G-?=<mH5yWWff#%+gI1'Zr`p'fo*@EC f.xp$*G?2Tn8>'xIG#:J\~K6)Li26pycs[5Umi:p#]qn>ls3e@lLqR\BL 	L .dz8NYC04TE,"hAaaicGL3l0"&/">*^/ ;@{B^Vv :J
#&S}1^b7;1'6m6X2E*11*$h)DX39on@kTxz(uUP(gv]1BcjX;[Y:O6B.Ie\V$!he/9W~*,>-NeJoCFG?v]Z>>"cv[P~D/vnZ8eU["Dep-#c	 19b .#D7UMx~{FPbGH4RiUE(YOUE;:K:eFQT%F1X>'N;7:G7[7w.zi
ZR(B7Iz/1Q$4t%Aww!-45DJJ/'	I^d,7[f*sGWr!5H  Y[JYR =}1 iE!O[pM:I~^@t_skM]:~<oCX_aPo N'y@\]Q34UP\7d 7v*XZJ\WV'x{xc)z\ycWXg8<GlNM8dUl QI,'nV=0Pns&+XXlXjJ-oOR1J:<t'X|5tTBixfJE7]x57o"r+m=9^${7$R_`/WD-+ ngr=<Er@8CI{
Kqm:D|wd%GDw2N..]%Vg='HxISoDF~#897(?,P(hu|3Po$HX_^=rY|YVpeQ"@|+`c:[$5L~yZ>}V}H9-O~0=(#g!S+2j^b5-3Sz:)=fNM{Z^ws<,g	u<-}) C3C-u|]<Xcob=;:x1~
v?%B^n*?j/?u?jPP=8toATLrK2E`;^
:bmyehuyI9q7.bMC)y
kY}:x,16>{X~egH*;; -jxm@r .b(9j5=iO
9lai|p-1>q*Fp//xw>^'R@N%	P{Qp6*f<"R'\_R^LUH3i~_	8Q^6FgQM
<	&/Yh_/x6yB>eVR42
o-^tpsky9!cJY5J>d<BR0DRN}4T\QX4_VKK(,h#S5\68l@|#y;|R#F0|GphC|C@@!***
}Q~I}YU+*U
R:/qhiY=|CsA+zS=*r7<_@Z8C94|CKbe"e"Keb<"-,-QPcEi	i>u8/ +VXH;1pO3O^>|<e<Dn369.=/Rg5.+,&GJH|:]_/"FWWW)u#?)o>?hT&]am=S=Ctg:]un4QI$$ob	!\!)y@PJV(^Z7%krCRZkE2!:P"pzbRfv-`H2HgKv)P(sBmhKCI {Z@v.(^j8\0k^9Cd19(	hA%GdB<N,?NkbQa/?(K/NLS`%ha ;32$F*z~9>d+y	 h1"Ww?CJ@ )oI7E66a#of('2/( Y/FTO`,PN'_8'ZS'c)Po50;SAeI|hVW0B\|!]y/ ,&U]Xvg)!|4Rf9q9wq.!qh%5`PWM%!.`h\0[	sXotf$1R=fRk V]QrO41BE2EUpVszCDMH)DYZL]b=Pr6q,@Za}y@}i m#>S5b;mYS>h\0 "Y7!&MH	C3VS'# 6;_Z:=D4t+^6}lUDi`K]p #	y:~#hU
 w C&7pf(+5I4kZj"Qa4f{(PuPM	0i"ddpf3z4XtjqPU?\lVC&.$5U,3r$;c@5&yL=wu^/Yf2qkej'% SDNaaSI@d,99bX}L)m6WY&{.uy?o.L)1_LE[HTs=98xp[?{@xP!3ySo0'0< 6KPk(^92kt*r\6QLW&xHJk0-I:&t-Y+SLWiYxbl58#;gPd7xZM$I`>9rUgMQD*D$kiM.-z*t]
VU
EWVK*4BUhJJ*4zk0CT23RXV{wgy` 	AnfeA96&>8o"{ZvE\'DA+sz.AZ[eBz)j2yp[
Yjvs@{)B2("+CMOO^f3}3fCA5/}ntKACy7<z,_M^O~FRptf,&.+HMJizgTh83I
Ec"Ehk.ep@; lMHNK%VQ_4H&}bDz,0
R*hAHs<gP^ 4Wr+&.|'TEyEUkQL~	[;'I l]'B&dOU.).> ]	pc<c7S,%
lAS&Lh}9<TvTo@ `+UAejWZvG_-/ToN\q]<Xv?UT&O2HJSeG=Zq(U6-F94#S b|iVLKg
B]CCI`(CJYjhR[(LL@8c 2(iK@NCt&KW5iM]	_aRnc?=F
f)>}8$9^}'U#k"Z*\*"XV`ZhR5naDgnKZ[cf`*ZMTHgdevdBMMG;2Cl%[KY[d,2JCE5|?;|wU>yz.RR]5DJs{U&XN{ul`aVlDskols8R2[$C?x\-D]*T1^!I>[r]-6$v
TYOc1bGn7u-lbQU}$XN(m).iKl-T14skjrb>i;I E43cr]a*xsMa(`*-`2v`==x<o]l/Q=hhZE<j<y \6E>-^.H+''8 QhW,].W."*5Sl?p-L|Fy)1..{'mpTkLlJ+Ge<	!jlZF\.\"I-+9RhKXw*R.'eE,_b$?ZOBB4>4sD6dY5;20B^XP-H!36A%8H"#T,x`!ylmQ8!;YEd6[dI& Wi/KO9IebF]8>oyr)A [I3chef"GF>^uaC[dLqE+Adl(*Dtf@s lzRv055w`uy) cW[h 	R!t#C`l-"EFV&"ddl;dd]"KFvaeJCC%]i?  8@=DT#AgC*~|})#Glk'@s2tJir\H${evrIzQ5Jz\!qN: ?`7dtWc<jP08 JA=~pP	hOi	-ufL\,j9yuX}*=lU7L^K9iVIe$PPh8dX~>Y1a0PoG LP6A'<a?K".l
7\oa 5ryNx3' ]RlT%uTM+ |K58/8'ni%={qH_h{/)%P~!4TT MPYOlri ~#C s
(/)Rj<5<kEVY6,'XsesI%Kgx~pR#5%M3Y=731zfbJ<FuP.'j"QvB6)`QLxJ%qR5mt>%J3*/XQlnhuk%zo4=7^1
s|;.Li'KK'JWD.NOglB94LgBC^IY
cb!KWxW0q6l0['3PkVOf#bxvCK'y(o(|4D-}vb0WxI,X17=V,^-\c
	l 
zaO:wx"'0;3q<U.w 4A>@=pfJb	?#s3J~T(_&n?aj	8oNT'Q Ej/5%A2gd"XM6#:%.,L/t(pyVrrw=!Ua"#kxX{,>;66&#~*l`+9C$]n'{Kh/+7~;9.smf_y>Fm7}_p}dQs:(69^Rc|dYdr>^PEF9nFNQs/N~/THNj'0RjyaJ	 _mVULU;j,rg/YU;o~IGB-	ylz0r0_F.k	>Ix[n(m<E-
vFE$[#8
r0^pf{Y
M}tSMy5y+^zKx/(LNV\dDkF,p[bX?!"`.-L$g=RLhd4Djl$z|@-6j" QO\US-0
fuyZ=jAfVP8OZX)!(1J4 ~ktrT?yN[1
YV
ls~6AleQXfeP ?2	8e)^\g#?'3>{z|;6&t.Z-zgL.\]^Q1WgUQ3Y*Zkj9b>}v93$_,gybRq}=P61'Cyq{j" ZNhm\e9{>u(^,>Yx>1Z`4b%[D^=>+I~>rNngG6lv/v7t7@V&:U:3b=(R}z<[0a2dfXiR#I1p,>SD^,i7'D[hB3L>^oqzv\z3$Y6}7QZax!e4DkUCIC)c&(Okk1ae+GgldJ2$*|{f'Q}UjMMu#]6\yiTEjf
^\x0MLM:~5<w
?ieQ\] mKHKBBK#AT!`i5g.#$y

R7(YlwAP/+*k/XyI =5@E)c@} E0{]k^	
':j@R>2Du~}_mu6/&b!{S{J90.(I(F_XEV7m(CBVLOUO4EIG{-UR	TAZkT#>.X(0RB->ldlN7&gvo(abmFD}BIp[O+.695nu;,GE:!HQ=zumXT;I"aNg:o2R}?+7 ef]<,*\|<RGo4ytXJ>:]6g\dR~]R8|gcP"%ax<*M%OKSJN'KW<Hd<S'HY=N\C95v.SsS(@p,43Gaj9K]<KbR\rkO/!K,17BKaz|y 
#&C
q3kt4YnAS- %A>-f|IC)Ei	PohTTw~57p}_XOl9-%Q[20,frb@K'O\'~Bqfr<2l	m4/(xaXlo<x1&{.;8<qxY 9|rEe	I	n&4 Kis>6{n0R1=m)a=dTRaF)O>5a|%Lh)0V7jzKY'yF`kf3# uVZ%t]VX
"5F/jP- 	,d$akXef *i`58\f\s|Oqr7[#A:lq)50}|>Ag)$*Wp:?	^M/`KLN	S8ZV[GuOs>v%g
OB4w_W}>@mjdwQz-b6@
{]
doTz2j31.H11Mr5r)!'Wk\+'N[CGEs6,H:D+,=1uh3Ef{$5e+C[3.CI*'}DP2j4D tp'B%*L'<G88u8aU '3]G}`sSf*nml26e7e.)s)eUGA"|)a!l!njXsun_de _3z2c)P=dvnlSZ5znLMQY"e>lu):+ )hmR30X~E8SO?=	4}r55/
f!8mcgkm WO^Fi0SC^G]^lDN9'00hj}kk*yeR#Tw9'/yjl#>s	rF!LnMvCG'ry
MO,+M*q+/{UX'*1pJ=2f^G.OKD|10s_	yzg4]#|(<exDZQ~hOC<C|4Xx	%og_NF6fK(KEOEft#:"g~c!hX+>Z}`YcUdm"S 6#ZZ( ZW/2*,W:8{ZN+ep:,x
W?5Z=2A`g*<V,9ef'K#l,-Ek 9ytF)P)>Sa"ef$zUV.TM+i{9'Yp7Q~4G2O5+V2j1_2r T:&es3Ea cd/gU/hzV	h6MSN/{%K`@;s`-zg
ELAYqX!yMgV9"Cc3Yo=N/F0fcSyE	Sb >B@6~0@ 8#FLPM{2|/bB8pMfaJ3mw}B<5nCg!|@55*G&'F.9&oaTo'f+q7Q88cC)il0wCW+q\s4P	{,BWan{`"h $AF0Z.x,BGBVr..daeDXkC T|&z4Kw]AE"8maS%e~6 NH_Ol4p:Yl4w6A~P#&wLI7;%yMlY5Zr~4J(ftWeFVo2%);ECHc9&.[ms*H*['xSc lailmR"`"XNN)=K6|d;Iv3hmQ0xs `(YMNPw[34_p6g`4N;aVf;5=^5}4&_cq 0=LU4wn:vFzPcbTH[o!n3%]TsJ^j
luNB;!MtGdp@+UMOH eCx?[HuY,$ccvr.^p"On:;Fs3~DY1Sr6xU|9n,R%R,<~GN*=Y36U`*wgl'#f*wyj=jgeEbWp D!hkd%_1"?ps?Hlx@W7Y*]jADsLX87k$NC4A`*YS;y2YhDYed3QE%F%>l$09>@5#9LyFd7&#Fkcu6?]Q	BYrBFsLI<'#y&Fqj~r0]<yA=PN $DMz<IlX/qF6GGEFn"!P^[9-ysE/VW`|.gwDO+h 9H'/k/b*FN_Y#+ZKcqC4Kl4gNTZDmpza]XtAw.TE.41t>4I+a6QLp4L+d2L	0V0 Z'6 LFa2R&#a2a&fdDMxm"3Ql@o&"0JL		_>6de0;@5ZqC^R~,cy~^pv/Rbp8G6^3;7 q.?x!|A1,nCK~ k3z7#r=_8~ZYQ*y$JPd_J}oEVC{YwUPg{TiI=z;=h2$1M^4_'<C
q/xD$q'my%&?\ jT9=e~S79zgS
A,jcPZ'a!"`5$UA>!s{b|i<RxL2Ye`D
2p!Mp0:UJ%QRH,?	:i[*(X'om:P.*/._rOTh8&O7+5'B~L:Txb7N/IrxBr\4)PgmQiIk-LKtA;m*:z@'@se8@yr%D<T.*mEFPVs1}@gU903=PEjQbY>5o1`0QwR%ZTbij$c@Bv?joW2w-uzC^!bJd.o=kRX_l{F0I|(yM>%^,%NVu~?#~C%`{&_$.Zj33kpIAty sKy~9NV	5?+QM6E^~$<0si{1/gQ"X>@vV3^5^{=$b^zda& ww&|)>(/pQ6B% B_@%9JM>?Q%!zvAF "7TkiQ2n$4e2k](P8`y(CCQX&ZRHUd@tmx(jw#Wr{^ gAy{<)TdXl!jY:S&Xf'\NeBMi#P~:}e2h53 	t/br]25D1(S9pK\HAeD IdK`)fjVo|5A!Nrji*97Z.T	+Lie^iw$nv:i9?[+|+Xg|C%	*xA;2?k@1sP/^>{qD5o`8W(+3aWY]l=z7hd]RkFlDK(*w
+ u[Q0
v-wKIcnB,oD:`cnsdOKgUItm'@0=|&V5~q/;qU^E=LHSFE#>2WC4MHHSS*R^+BD
b7U\mEjk^$.0~ns:3FP\Y;j*>YIn#VIY}Y:1C$RlAK<3z}N*"_u3px#A-*Nh_F;-j|{#/)5G	 u4/J_4/|o2q6%ml/%tq)$*<vL;CX8 MFNBXC<H&t9Rv`["dITbP(m$i.cZ`uYm'>H%dE[e}Buml56j:
ZkZm}J-D;nS!MI@$]d;[Oz-M:Q3e4qso1_c;+NQ`7r5St,	! VQ_gJ&^1+Fidb^rdF=}uK7:{[LAmo}@e9u&A.Fw0gF1RL	u
7UG$!^QxM\W^Qxm\uid=t#9Wgv ]ih"hAjg8Ql'xuKSNLqE|LtqEEO\.F}+1#94zb!Dfq=_^ 0VW|v`P
u7[$W4v;N):6.$xkI4Etl|Qon-Rac+%Ke`lA1Es\^)5r.gW:XnuPz<u&I<821|vlP0-Nw7QdCDQluhLqr7lT)e]cQl|9 %i!B3&GSaC,i8$65CJc1*v1R&)Lat|H`ALL]>:4 /LZ1WR*v2wE>tW&~&Lz=^
fcwP(jQx,[2s*"5PsU~ j/8,A/nR*FgI}1/&c*Q en,DEUwR@1w?6do_H-<FivQ?*22dWHJSy\F+rA[Bf,jf
HNeOIN 
MF,m(:!V#`|F nc8a[ _Np[Y*XV41:dvL.2rbquhQbIlF-{k]	s%Z*THwI`b%&k\^SIyj3aVkto?c7gKr>#e_	{ F#d\=m?K ?R,y'^Ufs6luJo_:pmH.c)a@2ww2&v)CSLFa}Ko}K@@4HN4@%D0R`j8JJAV}84.MGk{@4Cf0}X3x!d}f3~m}YQQYQQYQQ5^G>jA0vO_z7o}Xo,>lJgs\++Y/w#-.]e}a7q#T$k,PPKs3!bd-m/,6FS j!Mx;}_$VGuv`en/J#"W9,NZ^yFv7>AKhtoJIkZE7H7\*o?QEi5IpC^s z\6d'Dx)Im8rp0F.d7#ItFrThX9}gZ(VLh<VjR0oGnA%L*qb{2	,(-3 B {(%fW3#e46V.Ba+y86
d[&7])
kJj"q<^-]yFNtUewalPZ^zap6d5ksn^]5LhhAQA^JiL
M"~'I@y((+oqNQXRCjHi/
Uel:[3XlR [PwC5Z`6lu0efG[,[I>jl#|#g;	s"A7~{C%Oy'nx7n 8Oul*X{8
:{crqnE>B	SD3sPPE1U^8A8Bq3	ro0Cv r|\[<?hn;;;KcK#}SDZ+c[D];hX$%?ns^Z>|}=HFdl$tHIk"YMY,wsi?2LS"MVqCVwVy(}%4krN],EVB`*}{={z 1Hbvip*GGh|{PC1cH!1V;<9.Ia)$&M*TnoFu1N\W`n?wTZi\V[pRcZRgJSu+;q6D'?Owu0x73t6ha;t~= ?ZwF]k~Vy{ETwCT\t_3?gww?J,9-sL/&"L08ef3V
CUyPb=4yIshSJRcK 6Uqrbs4cy+.`eNN$7A[wg,+Na8S-nfeh;iTiGCt0I4"PgI1=,<Ksk0"LoX?)
ts85.GaMIjZ+NbkcZBiab%'l:9&(&'"Ta~Fy`4y`i[ZP^LC-*VdosZ-M[7*=QCA0
SwfzHkLn&QER3_|	^.aKFMSE,V 9r'dMXy f|jVj,#Z+$+Znc<PzSYW vN SVYtuDZw}6JO"XN],];u@~kZd(itX+~~xw%;knY/U b	FDDYbo `F&T/rLY=V|&.MpSl]R6m8Ml\!8]8|Z%qk`(J
@>u/*V;o?z'd}QX/Q:JV"ueu{{_^WzW^y%z4L1atSWg	/MJ		 Xb5'""7hl j;b\5;RuecT2vb{|]hOeFVjo	}lWT{~@"10aN`YRU:}|g/7Fv{=^fd#/{sM12>Z.yYXV*<JC[6q4V>1]}&U;>?j[:WB (!I:Hpo}M];kGk^p48q%g}bZoxuA L$_A.GutodoE]nt@-!0n GyqpA;[<6"tZEpp"% FRqH'RVJ>l%Z(<OGj(3|[5g1Qd'oai]y1+/'.P5dHfgJ&.OOIR cTZVLj)pEr]ex[wwbieT6_Qdw	>&'i
,d%&ItN~^,'W1c                       	   i c o n              i c o n  FLs     l a b e l             B u t t o n l a b e l  Eb[cFE\G     l a b e l P l a c e m e n t            l e f t r i g h t t o p b o t t o m l a b e l P l a c e m e n t  TI^D     s e l e c t e d             f a l s e s e l e c t e d  /?ZJ|g     t o g g l e             f a l s e t o g g l e  gYD     e n a b l e d             t r u e e n a b l e d  !RG5S8bmO t h e r    v i s i b l e             t r u e v i s i b l e  D*LcXTC$vO t h e r    	m i n H e i g h t             0 	m i n H e i g h t  PKu@&jS i z e    m i n W i d t h             0 m i n W i d t h  !7C2I l/S i z e        )< ? x m l   v e r s i o n = " 1 . 0 "   e n c o d i n g   = " u t f - 8 " ? >  
 < c o m p o n e n t P a c k a g e   x m l n s = " h t t p : / / w w w . m a c r o m e d i a . c o m / f l a s h / s w c c a t a l o g / 7 " >  
 < c o m p o n e n t   i d = " B u t t o n "   c l a s s = " m x . c o n t r o l s . B u t t o n "   i m p l e m e n t a t i o n = " B u t t o n . s w f "   i c o n F i l e = " B u t t o n . p n g "   t o o l t i p = " B u t t o n "   s r c = " m x . c o n t r o l s . B u t t o n . a s i "   m o d i f i e d = " 1 0 5 9 0 7 3 8 8 9 " >  
 < m o v i e B o u n d s   x m i n = " 0 "   x m a x = " 2 0 0 0 "   y m i n = " 0 "   y m a x = " 4 4 0 "   / >  
         < i n c l u d e   i d = " B o u n d i n g B o x " / >  
         < i n c l u d e   i d = " S i m p l e B u t t o n " / >  
         < i n c l u d e   i d = " B o r d e r " / >  
         < i n c l u d e   i d = " R e c t B o r d e r " / >  
         < i n c l u d e   i d = " B u t t o n S k i n " / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n " / >  
 < c l a s s   i d = " m x . c o n t r o l s . B u t t o n "   >  
             < E v e n t   p a r a m 1 = " c l i c k "   / >  
             < T a g N a m e   p a r a m 1 = " B u t t o n "   / >  
             < I c o n F i l e   p a r a m 1 = " B u t t o n . p n g "   / >  
       < p r o p e r t y   i d = " _ i n h e r i t e d _ s e l e c t e d "   t y p e = " B o o l e a n "   >  
             < B i n d a b l e   / >  
             < C h a n g e E v e n t   p a r a m 1 = " c l i c k "   / >  
       < / p r o p e r t y >  
       < m e t h o d   i d = " i c o n "   >  
             < p a r a m   i d = " l i n k a g e "     / >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " l a b e l "   >  
             < p a r a m   i d = " l b l "   t y p e = " S t r i n g "   / >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " B u t t o n "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " l a b e l P l a c e m e n t "   >  
             < p a r a m   i d = " v a l "   t y p e = " S t r i n g "   / >  
             < I n s p e c t a b l e   e n u m e r a t i o n = " l e f t , r i g h t , t o p , b o t t o m "   d e f a u l t V a l u e = " r i g h t "   / >  
       < / m e t h o d >  
 < / c l a s s >  
 < c l a s s   i d = " m x . c o n t r o l s . S i m p l e B u t t o n "   >  
             < E v e n t   p a r a m 1 = " c l i c k "   / >  
             < T a g N a m e   p a r a m 1 = " S i m p l e B u t t o n "   / >  
       < m e t h o d   i d = " s e l e c t e d "   r e t u r n T y p e = " B o o l e a n " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " f a l s e "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " t o g g l e "   r e t u r n T y p e = " B o o l e a n " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " f a l s e "   / >  
       < / m e t h o d >  
 < / c l a s s >  
 < c l a s s   i d = " m x . c o r e . U I C o m p o n e n t "   >  
             < E v e n t   p a r a m 1 = " f o c u s I n "   / >  
             < E v e n t   p a r a m 1 = " f o c u s O u t "   / >  
             < E v e n t   p a r a m 1 = " k e y D o w n "   / >  
             < E v e n t   p a r a m 1 = " k e y U p "   / >  
       < p r o p e r t y   i d = " e n a b l e d "   t y p e = " B o o l e a n "   >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " t r u e "   v e r b o s e = " 1 "   c a t e g o r y = " O t h e r "   / >  
       < / p r o p e r t y >  
 < / c l a s s >  
 < c l a s s   i d = " m x . c o r e . U I O b j e c t "   >  
             < E v e n t   p a r a m 1 = " r e s i z e "   / >  
             < E v e n t   p a r a m 1 = " m o v e "   / >  
             < E v e n t   p a r a m 1 = " d r a w "   / >  
             < E v e n t   p a r a m 1 = " l o a d "   / >  
             < E v e n t   p a r a m 1 = " u n l o a d "   / >  
       < m e t h o d   i d = " m i n H e i g h t "   r e t u r n T y p e = " N u m b e r " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " 0 "   v e r b o s e = " 1 "   c a t e g o r y = " S i z e "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " m i n W i d t h "   r e t u r n T y p e = " N u m b e r " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " 0 "   v e r b o s e = " 1 "   c a t e g o r y = " S i z e "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " v i s i b l e "   r e t u r n T y p e = " B o o l e a n " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " t r u e "   v e r b o s e = " 1 "   c a t e g o r y = " O t h e r "   / >  
       < / m e t h o d >  
 < / c l a s s >  
 < a s s e t   i d = " B o u n d i n g B o x "   m o d i f i e d = " 1 0 5 4 5 9 3 6 5 5 " >  
 < / a s s e t >  
 < a s s e t   i d = " U I C o m p o n e n t E x t e n s i o n s "   m o d i f i e d = " 1 0 5 8 8 1 4 6 6 6 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s " / >  
 < / a s s e t >  
 < a s s e t   i d = " F o c u s R e c t "   m o d i f i e d = " 1 0 5 5 7 4 4 8 1 9 " >  
             < i n c l u d e   i d = " B o u n d i n g B o x " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t " / >  
 < / a s s e t >  
 < a s s e t   i d = " F o c u s M a n a g e r "   m o d i f i e d = " 1 0 5 5 7 4 4 7 8 1 " >  
             < i n c l u d e   i d = " F o c u s R e c t " / >  
             < i n c l u d e   i d = " U I O b j e c t " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r " / >  
 < / a s s e t >  
 < a s s e t   i d = " U I O b j e c t E x t e n s i o n s "   m o d i f i e d = " 1 0 5 8 8 1 4 7 0 2 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s " / >  
 < / a s s e t >  
 < a s s e t   i d = " D e f a u l t s "   m o d i f i e d = " 1 0 5 5 7 3 7 2 7 9 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s " / >  
 < / a s s e t >  
 < a s s e t   i d = " U I O b j e c t "   m o d i f i e d = " 1 0 5 8 8 1 4 7 3 1 " >  
             < i n c l u d e   i d = " D e f a u l t s " / >  
             < i n c l u d e   i d = " U I O b j e c t E x t e n s i o n s " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t " / >  
 < / a s s e t >  
 < a s s e t   i d = " U I C o m p o n e n t "   m o d i f i e d = " 1 0 5 8 8 1 4 7 0 0 " >  
             < i n c l u d e   i d = " U I O b j e c t " / >  
             < i n c l u d e   i d = " F o c u s M a n a g e r " / >  
             < i n c l u d e   i d = " U I C o m p o n e n t E x t e n s i o n s " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t " / >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n U p "   m o d i f i e d = " 1 0 6 2 2 2 5 0 2 6 " >  
             < i n c l u d e   i d = " B r d r B l k " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
             < i n c l u d e   i d = " B r d r S h d w " / >  
             < i n c l u d e   i d = " B r d r H i l g h t " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r H i l g h t "   m o d i f i e d = " 1 0 5 2 7 7 0 9 0 8 " >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r B l k "   m o d i f i e d = " 1 0 5 2 7 7 0 9 1 3 " >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n I n "   m o d i f i e d = " 1 0 6 2 2 2 5 0 2 0 " >  
             < i n c l u d e   i d = " B r d r B l k " / >  
             < i n c l u d e   i d = " B r d r H i l g h t " / >  
             < i n c l u d e   i d = " B r d r S h d w " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r F a c e "   m o d i f i e d = " 1 0 5 1 7 6 7 5 4 1 " >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r S h d w "   m o d i f i e d = " 1 0 5 8 9 3 1 5 2 1 " >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n D o w n "   m o d i f i e d = " 1 0 6 2 2 2 5 0 1 9 " >  
             < i n c l u d e   i d = " B r d r S h d w " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n "   m o d i f i e d = " 1 0 5 5 7 4 4 7 8 1 " >  
             < i n c l u d e   i d = " B o u n d i n g B o x " / >  
             < i n c l u d e   i d = " S i m p l e B u t t o n D o w n " / >  
             < i n c l u d e   i d = " S i m p l e B u t t o n I n " / >  
             < i n c l u d e   i d = " S i m p l e B u t t o n U p " / >  
             < i n c l u d e   i d = " U I C o m p o n e n t " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n " / >  
 < / a s s e t >  
 < a s s e t   i d = " B o r d e r "   m o d i f i e d = " 1 0 6 2 2 2 4 8 7 2 " >  
             < i n c l u d e   i d = " U I O b j e c t " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . B o r d e r " / >  
 < / a s s e t >  
 < a s s e t   i d = " R e c t B o r d e r "   m o d i f i e d = " 1 0 6 2 2 2 4 8 8 7 " >  
             < i n c l u d e   i d = " B o r d e r " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r " / >  
 < / a s s e t >  
 < a s s e t   i d = " B u t t o n S k i n "   m o d i f i e d = " 1 0 6 2 2 2 4 8 9 3 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n " / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t "   s r c = " m x . s k i n s . C o l o r e d S k i n E l e m e n t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   s r c = " m x . c o r e . U I O b j e c t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   s r c = " m x . s k i n s . S k i n E l e m e n t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "   s r c = " m x . s t y l e s . C S S T e x t S t y l e s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   s r c = " m x . s t y l e s . C S S S t y l e D e c l a r a t i o n . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   s r c = " m x . s t y l e s . S t y l e M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   s r c = " m x . c o r e . U I C o m p o n e n t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n "   s r c = " m x . c o n t r o l s . S i m p l e B u t t o n . a s i "   m o d i f i e d = " 1 0 6 1 5 0 3 6 9 1 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n "   s r c = " m x . c o n t r o l s . B u t t o n . a s i "   m o d i f i e d = " 1 0 6 1 5 0 3 6 9 0 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r "   s r c = " m x . e v e n t s . E v e n t D i s p a t c h e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r "   s r c = " m x . e v e n t s . U I E v e n t D i s p a t c h e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   s r c = " m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s "   s r c = " m x . s k i n s . h a l o . D e f a u l t s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t "   s r c = " m x . s k i n s . h a l o . F o c u s R e c t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r "   s r c = " m x . m a n a g e r s . D e p t h M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r "   s r c = " m x . m a n a g e r s . F o c u s M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 7 2 6 4 0 9 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r "   s r c = " m x . m a n a g e r s . S y s t e m M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s "   s r c = " m x . m a n a g e r s . O v e r l a p p e d W i n d o w s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s "   s r c = " m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e "   s r c = " m x . s t y l e s . C S S S e t S t y l e . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . B o r d e r "   s r c = " m x . s k i n s . B o r d e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r "   s r c = " m x . s k i n s . R e c t B o r d e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . B o r d e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n "   s r c = " m x . s k i n s . h a l o . B u t t o n S k i n . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r "   s r c = " m x . s k i n s . h a l o . R e c t B o r d e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r "   / >  
 < / a s s e t >  
 < / c o m p o n e n t >  
 < / c o m p o n e n t P a c k a g e >  
        M e d i a   1 B i t m a p   1  
B u t t o n . p n g C                 C                                       2    H                xi 	@!ENw'w* Qa}$K=EFsW<_,)CQj>QYZquDSyK0z_Y?A7Is Q$  B u t t o n             B u t t o n 
B u t t o n . s w f 	W?   +   B o r d e r B o r d e r 
B u t t o n . s w f CP?          U I O b j e c t 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . s k i n s . B o r d e r 
B u t t o n . s w f                         B o u n d i n g B o x B o u n d i n g B o x 
B u t t o n . s w f w>                 B r d r B l k B r d r B l k 
B u t t o n . s w f a>                 B r d r F a c e B r d r F a c e 
B u t t o n . s w f >                 
B r d r H i l g h t 
B r d r H i l g h t 
B u t t o n . s w f \>                 B r d r S h d w B r d r S h d w 
B u t t o n . s w f A?                 
B u t t o n S k i n 
B u t t o n S k i n 
B u t t o n . s w f CP?              #_ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n 
B u t t o n . s w f                         D e f a u l t s D e f a u l t s 
B u t t o n . s w f E>                                                                                                                                                                                                                                                                                                                                                                                                           !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s 
B u t t o n . s w f                         F o c u s M a n a g e r F o c u s M a n a g e r 
B u t t o n . s w f c>          	F o c u s R e c t 
B u t t o n . s w f                       U I O b j e c t 
B u t t o n . s w f                          #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r 
B u t t o n . s w f                         	F o c u s R e c t 	F o c u s R e c t 
B u t t o n . s w f 3c>          B o u n d i n g B o x 
B u t t o n . s w f                          "_ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t 
B u t t o n . s w f                         
R e c t B o r d e r 
R e c t B o r d e r 
B u t t o n . s w f CP?          B o r d e r 
B u t t o n . s w f                          #_ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r 
B u t t o n . s w f                         S i m p l e B u t t o n S i m p l e B u t t o n 
B u t t o n . s w f c>          B o u n d i n g B o x 
B u t t o n . s w f                       S i m p l e B u t t o n D o w n 
B u t t o n . s w f                       S i m p l e B u t t o n I n 
B u t t o n . s w f                       S i m p l e B u t t o n U p 
B u t t o n . s w f                       U I C o m p o n e n t 
B u t t o n . s w f                          #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f                         S i m p l e B u t t o n D o w n S i m p l e B u t t o n D o w n 
B u t t o n . s w f {DP?          B r d r S h d w 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                             S i m p l e B u t t o n I n S i m p l e B u t t o n I n 
B u t t o n . s w f |DP?          B r d r B l k 
B u t t o n . s w f                       
B r d r H i l g h t 
B u t t o n . s w f                       B r d r S h d w 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                             S i m p l e B u t t o n U p S i m p l e B u t t o n U p 
B u t t o n . s w f DP?          B r d r B l k 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                       B r d r S h d w 
B u t t o n . s w f                       
B r d r H i l g h t 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                             U I C o m p o n e n t U I C o m p o n e n t 
B u t t o n . s w f :?          U I O b j e c t 
B u t t o n . s w f                       F o c u s M a n a g e r 
B u t t o n . s w f                       U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                         U I C o m p o n e n t E x t e n s i o n s U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f :?              ,_ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f                         U I O b j e c t U I O b j e c t 
B u t t o n . s w f ;?          D e f a u l t s 
B u t t o n . s w f                       U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                         U I O b j e c t E x t e n s i o n s U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f :?              )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                         _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n 
B u t t o n . s w f BE?              #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       m x . c o n t r o l s . B u t t o n qi m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . c o n t r o l s . S i m p l e B u t t o n ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " c l i c k " ) ]    
 [ T a g N a m e ( " B u t t o n " ) ]    
 [ I c o n F i l e ( " B u t t o n . p n g " ) ]    
 i n t r i n s i c   c l a s s   m x . c o n t r o l s . B u t t o n   e x t e n d s   m x . c o n t r o l s . S i m p l e B u t t o n  
 {  
       p u b l i c   f u n c t i o n   B u t t o n ( ) ;  
       p u b l i c   v a r   _ _ g e t _ _ i c o n : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l P l a c e m e n t : F u n c t i o n ;  
       p u b l i c   v a r   _ _ l a b e l : S t r i n g ;  
       p u b l i c   v a r   _ _ l a b e l P l a c e m e n t : S t r i n g ;  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   _ g e t I c o n ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   _ i c o n L i n k a g e N a m e : S t r i n g ;  
       [ B i n d a b l e ]   [ C h a n g e E v e n t ( " c l i c k " ) ]   p u b l i c   v a r   _ i n h e r i t e d _ s e l e c t e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   _ s e t I c o n ( l i n k a g e ) : V o i d ;  
       p u b l i c   v a r   b o r d e r W : N u m b e r ;  
       p u b l i c   v a r   b t n O f f s e t : N u m b e r ;  
       p u b l i c   f u n c t i o n   c a l c S i z e ( t a g : N u m b e r ,   r e f : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   c e n t e r C o n t e n t : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w ( ) ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t B t n O f f s e t ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t L a b e l ( V o i d ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t L a b e l P l a c e m e n t ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   h i t A r e a _ m c : M o v i e C l i p ;  
       f u n c t i o n   g e t   i c o n ( ) : S t r i n g ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " " ) ]   f u n c t i o n   s e t   i c o n ( l i n k a g e ) ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t I c o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( c : S t r i n g ) : V o i d ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " B u t t o n " ) ]   f u n c t i o n   s e t   l a b e l ( l b l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l ( ) : S t r i n g ;  
       p u b l i c   v a r   l a b e l P a t h : O b j e c t ;  
       [ I n s p e c t a b l e ( e n u m e r a t i o n = " l e f t , r i g h t , t o p , b o t t o m " d e f a u l t V a l u e = " r i g h t " ) ]   f u n c t i o n   s e t   l a b e l P l a c e m e n t ( v a l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l P l a c e m e n t ( ) : S t r i n g ;  
       s t a t i c   v a r   m e r g e d C l i p P a r a m e t e r s : B o o l e a n ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( e n a b l e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t H i t A r e a ( w : N u m b e r ,   h : N u m b e r ) ;  
       p u b l i c   f u n c t i o n   s e t L a b e l ( l a b e l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t L a b e l P l a c e m e n t ( v a l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   s e t V i e w ( o f f s e t : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n : S t r i n g ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   v i e w S k i n ( v a r N a m e : S t r i n g ) : V o i d ;  
 } ;  
 #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f BE?              _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       m x . c o n t r o l s . S i m p l e B u t t o n i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " c l i c k " ) ]    
 [ T a g N a m e ( " S i m p l e B u t t o n " ) ]    
 i n t r i n s i c   c l a s s   m x . c o n t r o l s . S i m p l e B u t t o n   e x t e n d s   m x . c o r e . U I C o m p o n e n t  
 {  
       p u b l i c   f u n c t i o n   S i m p l e B u t t o n ( ) ;  
       p u b l i c   v a r   _ _ e m p h a s i z e d : B o o l e a n ;  
       p u b l i c   v a r   _ _ e m p h a t i c : B o o l e a n ;  
       p u b l i c   v a r   _ _ e m p h a t i c S t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   _ _ g e t _ _ e m p h a s i z e d : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ s e l e c t e d : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ t o g g l e : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ v a l u e : F u n c t i o n ;  
       p u b l i c   v a r   _ _ s t a t e : B o o l e a n ;  
       p u b l i c   v a r   _ _ t o g g l e : B o o l e a n ;  
       p u b l i c   v a r   a u t o R e p e a t : B o o l e a n ;  
       p u b l i c   v a r   b o u n d i n g B o x _ m c : M o v i e C l i p ;  
       p u b l i c   v a r   b t n O f f s e t : N u m b e r ;  
       p u b l i c   v a r   b u t t o n D o w n H a n d l e r : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c a l c S i z e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e I c o n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ) : V o i d ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i c k H a n d l e r : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d e t a i l : N u m b e r ;  
       p u b l i c   v a r   d f i ;  
       p u b l i c   v a r   d f s ;  
       p u b l i c   v a r   d i s a b l e d I c o n : O b j e c t ;  
       p u b l i c   v a r   d i s a b l e d S k i n : O b j e c t ;  
       p u b l i c   v a r   d o w n I c o n : O b j e c t ;  
       p u b l i c   v a r   d o w n S k i n : O b j e c t ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d t i ;  
       p u b l i c   v a r   d t s ;  
       f u n c t i o n   g e t   e m p h a s i z e d ( ) : B o o l e a n ;  
       f u n c t i o n   s e t   e m p h a s i z e d ( v a l : B o o l e a n ) ;  
       s t a t i c   v a r   e m p h a s i z e d S t y l e D e c l a r a t i o n ;  
       s t a t i c   v a r   f a l s e D i s a b l e d : N u m b e r ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   f a l s e D o w n : N u m b e r ;  
       p u b l i c   v a r   f a l s e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   f a l s e O v e r : N u m b e r ;  
       p u b l i c   v a r   f a l s e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   f a l s e U p : N u m b e r ;  
       p u b l i c   v a r   f a l s e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f d i ;  
       p u b l i c   v a r   f d s ;  
       p u b l i c   v a r   f r i ;  
       p u b l i c   v a r   f r s ;  
       p u b l i c   v a r   f u i ;  
       p u b l i c   v a r   f u s ;  
       p u b l i c   f u n c t i o n   g e t L a b e l ( V o i d ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t S e l e c t e d ( ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   g e t S t a t e ( V o i d ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   g e t T o g g l e ( V o i d ) : B o o l e a n ;  
       p u b l i c   v a r   i c o n N a m e : O b j e c t ;  
       p u b l i c   v a r   i d N a m e s ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t i a l i z i n g : B o o l e a n ;  
       p u b l i c   v a r   i n t e r v a l ;  
       p u b l i c   f u n c t i o n   k e y D o w n ( e : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   k e y U p ( e : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   l i n k L e n g t h : N u m b e r ;  
       p u b l i c   f u n c t i o n   o n D r a g O u t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n D r a g O v e r ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n K i l l F o c u s ( n e w F o c u s : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n P r e s s ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n P r e s s D e l a y ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n P r e s s R e p e a t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e O u t s i d e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R o l l O u t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R o l l O v e r ( V o i d ) : V o i d ;  
       p u b l i c   v a r   p h a s e : S t r i n g ;  
       p u b l i c   v a r   p r e s e t : B o o l e a n ;  
       p u b l i c   v a r   r e f N a m e s ;  
       p u b l i c   f u n c t i o n   r e f r e s h ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e m o v e I c o n s ( ) ;  
       p u b l i c   v a r   r o l l o v e r I c o n : O b j e c t ;  
       p u b l i c   v a r   r o l l o v e r S k i n : O b j e c t ;  
       f u n c t i o n   s e t   s e l e c t e d ( v a l : B o o l e a n ) ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = f a l s e ) ]   f u n c t i o n   g e t   s e l e c t e d ( ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( v a l : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t I c o n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   s e t L a b e l ( v a l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S e l e c t e d ( v a l : B o o l e a n ) ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   s e t S t a t e ( s t a t e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S t a t e V a r ( s t a t e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t T o g g l e ( v a l : B o o l e a n ) ;  
       p u b l i c   f u n c t i o n   s e t V i e w ( o f f s e t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s h o w E m p h a s i z e d ( e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s k i n N a m e : O b j e c t ;  
       p u b l i c   v a r   s t a t e N a m e s ;  
       p u b l i c   v a r   s t y l e 3 d I n s e t : N u m b e r ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a g M a p ;  
       p u b l i c   v a r   t d i ;  
       p u b l i c   v a r   t d s ;  
       f u n c t i o n   s e t   t o g g l e ( v a l : B o o l e a n ) ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = f a l s e ) ]   f u n c t i o n   g e t   t o g g l e ( ) : B o o l e a n ;  
       p u b l i c   v a r   t r i ;  
       p u b l i c   v a r   t r s ;  
       s t a t i c   v a r   t r u e D i s a b l e d : N u m b e r ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   t r u e D o w n : N u m b e r ;  
       p u b l i c   v a r   t r u e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   t r u e O v e r : N u m b e r ;  
       p u b l i c   v a r   t r u e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   t r u e U p : N u m b e r ;  
       p u b l i c   v a r   t r u e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t u i ;  
       p u b l i c   v a r   t u s ;  
       p u b l i c   v a r   u p I c o n : O b j e c t ;  
       p u b l i c   v a r   u p S k i n : O b j e c t ;  
       f u n c t i o n   s e t   v a l u e ( v a l : B o o l e a n ) ;  
       f u n c t i o n   g e t   v a l u e ( ) : B o o l e a n ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   v i e w I c o n ( v a r N a m e : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   v i e w S k i n ( v a r N a m e : S t r i n g ,   i n i t O b j : O b j e c t ) : V o i d ;  
 } ;  
 _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f #U?              _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       m x . c o r e . U I C o m p o n e n t i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
  
 [ E v e n t ( " f o c u s I n " ) ]    
 [ E v e n t ( " f o c u s O u t " ) ]    
 [ E v e n t ( " k e y D o w n " ) ]    
 [ E v e n t ( " k e y U p " ) ]    
 i n t r i n s i c   c l a s s   m x . c o r e . U I C o m p o n e n t   e x t e n d s   m x . c o r e . U I O b j e c t  
 {  
       p u b l i c   f u n c t i o n   U I C o m p o n e n t ( ) ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   f u n c t i o n   d i s p a t c h V a l u e C h a n g e d E v e n t ( v a l u e ) : V o i d ;  
       p u b l i c   v a r   d r a w F o c u s : F u n c t i o n ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = t r u e ,   v e r b o s e = 1 ,   c a t e g o r y = " O t h e r " ) ]   p u b l i c   v a r   e n a b l e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   e n a b l e d C h a n g e d ( i d : S t r i n g ,   o l d V a l u e : B o o l e a n ,   n e w V a l u e : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   f i n d F o c u s F r o m O b j e c t ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   f i n d F o c u s I n C h i l d r e n ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   v a r   f o c u s E n a b l e d : B o o l e a n ;  
       p u b l i c   v a r   f o c u s M a n a g e r : M o v i e C l i p ;  
       p u b l i c   v a r   f o c u s T e x t F i e l d : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s ( ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s M a n a g e r ( ) : O b j e c t ;  
       p u b l i c   v a r   g r o u p N a m e : S t r i n g ;  
       f u n c t i o n   g e t   h e i g h t ( ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   i n i t ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   i s P a r e n t ( o : O b j e c t ) : B o o l e a n ;  
       s t a t i c   v a r   k S t r e t c h : N u m b e r ;  
       s t a t i c   v a r   m e r g e d C l i p P a r a m e t e r s : B o o l e a n ;  
       p u b l i c   f u n c t i o n   o n K i l l F o c u s ( n e w F o c u s : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n S e t F o c u s ( o l d F o c u s : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   o r i g B o r d e r S t y l e s : O b j e c t ;  
       p u b l i c   v a r   o r i g B o r d e r V a l u e s : O b j e c t ;  
       p u b l i c   v a r   p o p U p : B o o l e a n ;  
       p u b l i c   f u n c t i o n   p r e s s F o c u s ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e l e a s e F o c u s ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( e n a b l e d : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t F o c u s ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t V i s i b l e ( x : B o o l e a n ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a b E n a b l e d : B o o l e a n ;  
       p u b l i c   v a r   t a b I n d e x : N u m b e r ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       f u n c t i o n   g e t   w i d t h ( ) : N u m b e r ;  
 } ;  
 _ _ P a c k a g e s . m x . c o r e . U I O b j e c t _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                       !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f                           m x . c o r e . U I O b j e c t i m p o r t   m x . s t y l e s . S t y l e M a n a g e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
  
 [ E v e n t ( " r e s i z e " ) ]    
 [ E v e n t ( " m o v e " ) ]    
 [ E v e n t ( " d r a w " ) ]    
 [ E v e n t ( " l o a d " ) ]    
 [ E v e n t ( " u n l o a d " ) ]    
 i n t r i n s i c   c l a s s   m x . c o r e . U I O b j e c t   e x t e n d s   M o v i e C l i p  
 {  
       p u b l i c   f u n c t i o n   U I O b j e c t ( ) ;  
       p u b l i c   f u n c t i o n   _ _ g e t T e x t F o r m a t ( t f : T e x t F o r m a t ,   b A l l : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   v a r   _ _ g e t _ _ m i n H e i g h t : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ m i n W i d t h : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ s c a l e X : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ s c a l e Y : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ v i s i b l e : F u n c t i o n ;  
       p u b l i c   v a r   _ _ h e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ _ o n U n l o a d : F u n c t i o n ;  
       p u b l i c   v a r   _ _ w i d t h : N u m b e r ;  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   _ c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   _ e n d I n i t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   _ g e t T e x t F o r m a t ( V o i d ) : T e x t F o r m a t ;  
       p r i v a t e   v a r   _ i d : S t r i n g ;  
       p r i v a t e   v a r   _ m a x H e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ m a x W i d t h : N u m b e r ;  
       p r i v a t e   v a r   _ m i n H e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ m i n W i d t h : N u m b e r ;  
       p r i v a t e   v a r   _ p r e f e r r e d H e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ p r e f e r r e d W i d t h : N u m b e r ;  
       p r i v a t e   v a r   _ t f : T e x t F o r m a t ;  
       p u b l i c   v a r   _ t o p m o s t : B o o l e a n ;  
       p u b l i c   v a r   a d d E v e n t L i s t e n e r : F u n c t i o n ;  
       f u n c t i o n   g e t   b o t t o m ( ) : N u m b e r ;  
       p u b l i c   v a r   b u i l d D e p t h T a b l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c a n c e l A l l D o L a t e r s ( V o i d ) : V o i d ;  
       p u b l i c   v a r   c h a n g e C o l o r S t y l e I n C h i l d r e n : F u n c t i o n ;  
       p u b l i c   v a r   c h a n g e T e x t S t y l e I n C h i l d r e n : F u n c t i o n ;  
       p u b l i c   v a r   c h i l d r e n C r e a t e d : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   v a r   c o l o r : N u m b e r ;  
       p u b l i c   f u n c t i o n   c o n s t r u c t O b j e c t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   c r e a t e A c c e s s i b i l i t y I m p l e m e n t a t i o n : F u n c t i o n ;  
       p u b l i c   v a r   c r e a t e C h i l d A t D e p t h : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   v a r   c r e a t e C l a s s C h i l d A t D e p t h : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e C l a s s O b j e c t ( c l a s s N a m e : F u n c t i o n ,   i d : S t r i n g ,   d e p t h : N u m b e r ,   i n i t o b j : O b j e c t ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   f u n c t i o n   c r e a t e E m p t y O b j e c t ( i d : S t r i n g ,   d e p t h : N u m b e r ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   v a r   c r e a t e E v e n t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e L a b e l ( n a m e : S t r i n g ,   d e p t h : N u m b e r ,   t e x t ) : T e x t F i e l d ;  
       p u b l i c   f u n c t i o n   c r e a t e O b j e c t ( l i n k a g e N a m e : S t r i n g ,   i d : S t r i n g ,   d e p t h : N u m b e r ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   c r e a t e S k i n ( t a g : N u m b e r ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   f u n c t i o n   d e s t r o y O b j e c t ( i d : S t r i n g ) : V o i d ;  
       p u b l i c   v a r   d i s p a t c h E v e n t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   d o L a t e r ( o b j : O b j e c t ,   f n : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   d o L a t e r D i s p a t c h e r ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w R e c t ( x 1 : N u m b e r ,   y 1 : N u m b e r ,   x 2 : N u m b e r ,   y 2 : N u m b e r ) : V o i d ;  
       p u b l i c   v a r   e m b e d F o n t s : B o o l e a n ;  
       p u b l i c   v a r   f i n d N e x t A v a i l a b l e D e p t h : F u n c t i o n ;  
       p u b l i c   v a r   f o n t F a m i l y : S t r i n g ;  
       p u b l i c   v a r   f o n t S i z e : N u m b e r ;  
       p u b l i c   v a r   f o n t S t y l e : S t r i n g ;  
       p u b l i c   v a r   f o n t W e i g h t : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t C l a s s S t y l e D e c l a r a t i o n ( V o i d ) : m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
       p u b l i c   f u n c t i o n   g e t M i n H e i g h t ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t M i n W i d t h ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t S k i n I D N a m e ( t a g : N u m b e r ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t S t y l e ( s t y l e P r o p : S t r i n g ) ;  
       p u b l i c   f u n c t i o n   g e t S t y l e N a m e ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   h a n d l e E v e n t : F u n c t i o n ;  
       f u n c t i o n   g e t   h e i g h t ( ) : N u m b e r ;  
       p u b l i c   v a r   i d N a m e s : A r r a y ;  
       p u b l i c   v a r   i g n o r e C l a s s S t y l e D e c l a r a t i o n : O b j e c t ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   i n i t F r o m C l i p P a r a m e t e r s ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t P r o p e r t i e s : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   i n v a l i d a t e F l a g : B o o l e a n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( V o i d ) : V o i d ;  
       f u n c t i o n   g e t   l e f t ( ) : N u m b e r ;  
       p r i v a t e   v a r   l i n e C o l o r : N u m b e r ;  
       p r i v a t e   v a r   l i n e W i d t h : N u m b e r ;  
       p u b l i c   v a r   m a r g i n L e f t : N u m b e r ;  
       p u b l i c   v a r   m a r g i n R i g h t : N u m b e r ;  
       s t a t i c   f u n c t i o n   m e r g e C l i p P a r a m e t e r s ( o ,   p ) : B o o l e a n ;  
       p u b l i c   v a r   m e t h o d T a b l e : A r r a y ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = 0 ,   v e r b o s e = 1 ,   c a t e g o r y = " S i z e " ) ]   f u n c t i o n   g e t   m i n H e i g h t ( ) : N u m b e r ;  
       f u n c t i o n   s e t   m i n H e i g h t ( h : N u m b e r ) : V o i d ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = 0 ,   v e r b o s e = 1 ,   c a t e g o r y = " S i z e " ) ]   f u n c t i o n   g e t   m i n W i d t h ( ) : N u m b e r ;  
       f u n c t i o n   s e t   m i n W i d t h ( w : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   m o v e ( x : N u m b e r ,   y : N u m b e r ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   v a r   n o t i f y S t y l e C h a n g e I n C h i l d r e n : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   r e d r a w ( b A l w a y s : B o o l e a n ) : V o i d ;  
       p u b l i c   v a r   r e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       f u n c t i o n   g e t   r i g h t ( ) : N u m b e r ;  
       f u n c t i o n   g e t   s c a l e X ( ) : N u m b e r ;  
       f u n c t i o n   s e t   s c a l e X ( x : N u m b e r ) : V o i d ;  
       f u n c t i o n   g e t   s c a l e Y ( ) : N u m b e r ;  
       f u n c t i o n   s e t   s c a l e Y ( y : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c o l o r : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t M i n H e i g h t ( h : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t M i n W i d t h ( w : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S i z e ( w : N u m b e r ,   h : N u m b e r ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t O b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   v a r   s e t S t y l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   s e t V i s i b l e ( x : B o o l e a n ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   s t y l e c a c h e : O b j e c t ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a b E n a b l e d : B o o l e a n ;  
       p u b l i c   v a r   t e x t A l i g n : S t r i n g ;  
       s t a t i c   v a r   t e x t C o l o r L i s t ;  
       p u b l i c   v a r   t e x t D e c o r a t i o n : S t r i n g ;  
       p u b l i c   v a r   t e x t I n d e n t : N u m b e r ;  
       p r i v a t e   v a r   t f L i s t : O b j e c t ;  
       f u n c t i o n   g e t   t o p ( ) : N u m b e r ;  
       p u b l i c   v a r   v a l i d a t e N o w : B o o l e a n ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = t r u e ,   v e r b o s e = 1 ,   c a t e g o r y = " O t h e r " ) ]   f u n c t i o n   g e t   v i s i b l e ( ) : B o o l e a n ;  
       f u n c t i o n   s e t   v i s i b l e ( x : B o o l e a n ) : V o i d ;  
       f u n c t i o n   g e t   w i d t h ( ) : N u m b e r ;  
       f u n c t i o n   g e t   x ( ) : N u m b e r ;  
       f u n c t i o n   g e t   y ( ) : N u m b e r ;  
 } ;  
 ,_ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s ,_ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f #U?           _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s 
B u t t o n . s w f                       !m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s :i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s  
 {  
       s t a t i c   f u n c t i o n   E x t e n s i o n s ( ) : B o o l e a n ;  
       s t a t i c   v a r   F o c u s M a n a g e r D e p e n d e n c y ;  
       s t a t i c   v a r   O v e r l a p p e d W i n d o w s D e p e n d e n c y ;  
       s t a t i c   v a r   U I C o m p o n e n t D e p e n d e n c y ;  
       s t a t i c   v a r   U I C o m p o n e n t E x t e n d e d ;  
       s t a t i c   v a r   b E x t e n d e d ;  
 } ;  
 )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f #U?          &_ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f                       "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s 
B u t t o n . s w f                       &_ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r 
B u t t o n . s w f                       m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
 i m p o r t   m x . e v e n t s . U I E v e n t D i s p a t c h e r ;  
  
 i n t r i n s i c   c l a s s   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s  
 {  
       s t a t i c   v a r   C S S T e x t S t y l e s D e p e n d e n c y ;  
       s t a t i c   f u n c t i o n   E x t e n s i o n s ( ) : B o o l e a n ;  
       s t a t i c   v a r   S k i n E l e m e n t D e p e n d e n c y ;  
       s t a t i c   v a r   U I E v e n t D i s p a t c h e r D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t E x t e n d e d ;  
       s t a t i c   f u n c t i o n   a d d G e o m e t r y ( t f : O b j e c t ,   u i : O b j e c t ) : V o i d ;  
       s t a t i c   v a r   b E x t e n d e d ;  
 } ;  
 $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r 
B u t t o n . s w f #U?               m x . e v e n t s . E v e n t D i s p a t c h e r  
 i n t r i n s i c   c l a s s   m x . e v e n t s . E v e n t D i s p a t c h e r  
 {  
       s t a t i c   v a r   _ f E v e n t D i s p a t c h e r : m x . e v e n t s . E v e n t D i s p a t c h e r ;  
       s t a t i c   f u n c t i o n   _ r e m o v e E v e n t L i s t e n e r ( q u e u e : O b j e c t ,   e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   a d d E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   d i s p a t c h E v e n t ( e v e n t O b j : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   d i s p a t c h Q u e u e ( q u e u e O b j : O b j e c t ,   e v e n t O b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   i n i t i a l i z e ( o b j e c t : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e m o v e E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
 } ;  
 &_ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r &_ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r 
B u t t o n . s w f #U?              $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r 
B u t t o n . s w f                       m x . e v e n t s . U I E v e n t D i s p a t c h e r i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . e v e n t s . E v e n t D i s p a t c h e r ;  
  
 i n t r i n s i c   c l a s s   m x . e v e n t s . U I E v e n t D i s p a t c h e r   e x t e n d s   m x . e v e n t s . E v e n t D i s p a t c h e r  
 {  
       p u b l i c   f u n c t i o n   _ _ a d d E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       p u b l i c   v a r   _ _ o r i g A d d E v e n t L i s t e n e r : F u n c t i o n ;  
       p u b l i c   v a r   _ _ s e n t L o a d E v e n t ;  
       s t a t i c   v a r   _ f E v e n t D i s p a t c h e r : m x . e v e n t s . U I E v e n t D i s p a t c h e r ;  
       s t a t i c   f u n c t i o n   a d d K e y E v e n t s ( o b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   a d d L o a d E v e n t s ( o b j : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   d i s p a t c h E v e n t ( e v e n t O b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   i n i t i a l i z e ( o b j : O b j e c t ) : V o i d ;  
       s t a t i c   v a r   k e y E v e n t s : O b j e c t ;  
       s t a t i c   v a r   l o a d E v e n t s : O b j e c t ;  
       s t a t i c   v a r   l o w L e v e l E v e n t s : O b j e c t ;  
       p u b l i c   f u n c t i o n   o n K e y D o w n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n K e y U p ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n L o a d ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n U n l o a d ( V o i d ) : V o i d ;  
       p u b l i c   v a r   o w n e r : O b j e c t ;  
       p u b l i c   f u n c t i o n   r e m o v e E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e m o v e K e y E v e n t s ( o b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e m o v e L o a d E v e n t s ( o b j : O b j e c t ) : V o i d ;  
 } ;  
 #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                           m x . m a n a g e r s . D e p t h M a n a g e r oi m p o r t   m x . c o r e . U I O b j e c t ;  
  
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . D e p t h M a n a g e r  
 {  
       p u b l i c   f u n c t i o n   D e p t h M a n a g e r ( ) ;  
       s t a t i c   v a r   _ _ d e p t h M a n a g e r : m x . m a n a g e r s . D e p t h M a n a g e r ;  
       p u b l i c   v a r   _ c h i l d C o u n t e r : N u m b e r ;  
       p u b l i c   v a r   _ p a r e n t : M o v i e C l i p ;  
       p u b l i c   v a r   _ t o p m o s t : B o o l e a n ;  
       p u b l i c   f u n c t i o n   b u i l d D e p t h T a b l e ( V o i d ) : A r r a y ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d A t D e p t h ( l i n k a g e N a m e : S t r i n g ,   d e p t h F l a g : N u m b e r ,   i n i t O b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   c r e a t e C l a s s C h i l d A t D e p t h ( c l a s s N a m e : F u n c t i o n ,   d e p t h F l a g : N u m b e r ,   i n i t O b j : O b j e c t ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   v a r   c r e a t e C l a s s O b j e c t : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   c r e a t e C l a s s O b j e c t A t D e p t h ( c l a s s N a m e : O b j e c t ,   d e p t h S p a c e : N u m b e r ,   i n i t O b j : O b j e c t ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   v a r   c r e a t e O b j e c t : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   c r e a t e O b j e c t A t D e p t h ( l i n k a g e N a m e : S t r i n g ,   d e p t h S p a c e : N u m b e r ,   i n i t O b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   f i n d N e x t A v a i l a b l e D e p t h ( t a r g e t D e p t h : N u m b e r ,   d e p t h T a b l e : A r r a y ,   d i r e c t i o n : S t r i n g ) : N u m b e r ;  
       p u b l i c   v a r   g e t D e p t h : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   g e t D e p t h B y F l a g ( d e p t h F l a g : N u m b e r ,   d e p t h T a b l e : A r r a y ) : N u m b e r ;  
       s t a t i c   v a r   h i g h e s t D e p t h : N u m b e r ;  
       s t a t i c   p r i v a t e   v a r   h o l d e r : M o v i e C l i p ;  
       s t a t i c   v a r   k B o t t o m : N u m b e r ;  
       s t a t i c   v a r   k C u r s o r : N u m b e r ;  
       s t a t i c   v a r   k N o t o p m o s t : N u m b e r ;  
       s t a t i c   v a r   k T o o l t i p : N u m b e r ;  
       s t a t i c   v a r   k T o p : N u m b e r ;  
       s t a t i c   v a r   k T o p m o s t : N u m b e r ;  
       s t a t i c   v a r   l o w e s t D e p t h : N u m b e r ;  
       s t a t i c   v a r   n u m b e r O f A u t h o r t i m e L a y e r s : N u m b e r ;  
       s t a t i c   v a r   r e s e r v e d D e p t h : N u m b e r ;  
       p u b l i c   f u n c t i o n   s e t D e p t h A b o v e ( t a r g e t I n s t a n c e : M o v i e C l i p ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t D e p t h B e l o w ( t a r g e t I n s t a n c e : M o v i e C l i p ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t D e p t h T o ( d e p t h F l a g : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s h u f f l e D e p t h s ( s u b j e c t : M o v i e C l i p ,   t a r g e t D e p t h : N u m b e r ,   d e p t h T a b l e : A r r a y ,   d i r e c t i o n : S t r i n g ) : V o i d ;  
       s t a t i c   f u n c t i o n   s o r t F u n c t i o n ( a : M o v i e C l i p ,   b : M o v i e C l i p ) : N u m b e r ;  
       p u b l i c   v a r   s w a p D e p t h s : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   t e s t ( d e p t h : N u m b e r ) : B o o l e a n ;  
 } ;  
 #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r 
B u t t o n . s w f 	W?          #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f                       #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r 
B u t t o n . s w f                       $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       m x . m a n a g e r s . F o c u s M a n a g e r i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . m a n a g e r s . S y s t e m M a n a g e r ;  
 i m p o r t   m x . c o n t r o l s . S i m p l e B u t t o n ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . F o c u s M a n a g e r   e x t e n d s   m x . c o r e . U I C o m p o n e n t  
 {  
       p u b l i c   f u n c t i o n   F o c u s M a n a g e r ( ) ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   _ _ d e f a u l t P u s h B u t t o n : m x . c o n t r o l s . S i m p l e B u t t o n ;  
       p u b l i c   v a r   _ _ g e t _ _ d e f a u l t P u s h B u t t o n : F u n c t i o n ;  
       p r i v a t e   v a r   _ f i r s t N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ f i r s t O b j : O b j e c t ;  
       p r i v a t e   v a r   _ f o u n d L i s t : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t O b j : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t T a r g e t : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t x : O b j e c t ;  
       p r i v a t e   v a r   _ n e e d P r e v : B o o l e a n ;  
       p r i v a t e   v a r   _ n e x t I s N e x t : B o o l e a n ;  
       p r i v a t e   v a r   _ n e x t N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ n e x t O b j : O b j e c t ;  
       p u b l i c   f u n c t i o n   _ o n M o u s e D o w n ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   _ p r e v N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ p r e v O b j : O b j e c t ;  
       p r i v a t e   v a r   _ s e a r c h K e y : N u m b e r ;  
       p u b l i c   f u n c t i o n   a c t i v a t e ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   a c t i v a t e d : B o o l e a n ;  
       p u b l i c   v a r   b D r a w F o c u s : B o o l e a n ;  
       p u b l i c   v a r   b N e e d F o c u s : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   d e a c t i v a t e ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d e f P u s h B u t t o n : m x . c o n t r o l s . S i m p l e B u t t o n ;  
       f u n c t i o n   g e t   d e f a u l t P u s h B u t t o n ( ) : m x . c o n t r o l s . S i m p l e B u t t o n ;  
       f u n c t i o n   s e t   d e f a u l t P u s h B u t t o n ( x : m x . c o n t r o l s . S i m p l e B u t t o n ) ;  
       p u b l i c   v a r   d e f a u l t P u s h B u t t o n E n a b l e d : B o o l e a n ;  
       s t a t i c   f u n c t i o n   e n a b l e F o c u s M a n a g e m e n t ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   e n a b l e d C h a n g e d ( i d : S t r i n g ,   o l d V a l u e : B o o l e a n ,   n e w V a l u e : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   v a r   f o r m ;  
       p u b l i c   f u n c t i o n   g e t A c t u a l F o c u s ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s ( V o i d ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s M a n a g e r F r o m O b j e c t ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t M a x T a b I n d e x ( o : m x . c o r e . U I C o m p o n e n t ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t M o u s e d C o m p o n e n t F r o m C h i l d r e n ( x : N u m b e r ,   y : N u m b e r ,   o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t N e x t T a b I n d e x ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t S e l e c t i o n F o c u s ( ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t T a b C a n d i d a t e ( o : M o v i e C l i p ,   i n d e x : N u m b e r ,   g r o u p N a m e : S t r i n g ,   d i r : B o o l e a n ,   f i r s t C h i l d : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   g e t T a b C a n d i d a t e F r o m C h i l d r e n ( o : M o v i e C l i p ,   i n d e x : N u m b e r ,   g r o u p N a m e : S t r i n g ,   d i r : B o o l e a n ,   f i r s t C h i l d : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   h a n d l e E v e n t ( e : O b j e c t ) ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       s t a t i c   v a r   i n i t i a l i z e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   i s O u r F o c u s ( o : O b j e c t ) : B o o l e a n ;  
       p u b l i c   v a r   l a s t F o c u s : O b j e c t ;  
       p u b l i c   v a r   l a s t S e l F o c u s : O b j e c t ;  
       p u b l i c   v a r   l a s t T a b F o c u s : O b j e c t ;  
       p u b l i c   v a r   l a s t X M o u s e : N u m b e r ;  
       p u b l i c   v a r   l a s t Y M o u s e : N u m b e r ;  
       p u b l i c   f u n c t i o n   m o u s e A c t i v a t e ( V o i d ) : V o i d ;  
       f u n c t i o n   g e t   n e x t T a b I n d e x ( ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   o n K e y D o w n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n M o u s e U p ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n S e t F o c u s ( o : O b j e c t ,   n : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n U n l o a d ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e l o c a t e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e s t o r e F o c u s ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e n d D e f a u l t P u s h B u t t o n E v e n t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t F o c u s ( o : O b j e c t ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p r i v a t e   v a r   t a b C a p t u r e : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   t a b H a n d l e r ( V o i d ) : V o i d ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   w a l k T r e e ( p : M o v i e C l i p ,   i n d e x : N u m b e r ,   g r o u p N a m e : S t r i n g ,   d i r : B o o l e a n ,   l o o k u p : B o o l e a n ,   f i r s t C h i l d : B o o l e a n ) : V o i d ;  
 } ;  
 (_ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s (_ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                          $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r 
B u t t o n . s w f                       m x . m a n a g e r s . O v e r l a p p e d W i n d o w s (i m p o r t   m x . m a n a g e r s . S y s t e m M a n a g e r ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . O v e r l a p p e d W i n d o w s  
 {  
       s t a t i c   v a r   S y s t e m M a n a g e r D e p e n d e n c y ;  
       s t a t i c   f u n c t i o n   _ _ a d d E v e n t L i s t e n e r ( e : S t r i n g ,   o : O b j e c t ,   l : F u n c t i o n ) : V o i d ;  
       s t a t i c   f u n c t i o n   _ _ r e m o v e E v e n t L i s t e n e r ( e : S t r i n g ,   o : O b j e c t ,   l : F u n c t i o n ) : V o i d ;  
       s t a t i c   f u n c t i o n   a c t i v a t e ( f : M o v i e C l i p ) : V o i d ;  
       s t a t i c   f u n c t i o n   a d d F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
       s t a t i c   f u n c t i o n   c h e c k I d l e ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   d e a c t i v a t e ( f : M o v i e C l i p ) : V o i d ;  
       s t a t i c   f u n c t i o n   e n a b l e O v e r l a p p e d W i n d o w s ( ) : V o i d ;  
       s t a t i c   v a r   i n i t i a l i z e d : B o o l e a n ;  
       s t a t i c   f u n c t i o n   o n M o u s e D o w n ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   o n M o u s e M o v e ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   o n M o u s e U p ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e m o v e F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
 } ;  
 $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r 
B u t t o n . s w f                           m x . m a n a g e r s . S y s t e m M a n a g e r i m p o r t   m x . e v e n t s . E v e n t D i s p a t c h e r ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " i d l e " ) ]    
 [ E v e n t ( " r e s i z e " ) ]    
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . S y s t e m M a n a g e r  
 {  
       s t a t i c   v a r   _ _ a d d E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   _ _ r e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   _ _ s c r e e n : O b j e c t ;  
       s t a t i c   p r i v a t e   v a r   _ i n i t i a l i z e d : B o o l e a n ;  
       s t a t i c   v a r   _ x A d d E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   _ x R e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   a c t i v a t e : F u n c t i o n ;  
       s t a t i c   v a r   a d d E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   a d d F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
       s t a t i c   v a r   c h e c k I d l e : F u n c t i o n ;  
       s t a t i c   v a r   d e a c t i v a t e : F u n c t i o n ;  
       s t a t i c   v a r   d i s p a t c h E v e n t : F u n c t i o n ;  
       s t a t i c   v a r   f o r m : M o v i e C l i p ;  
       s t a t i c   v a r   f o r m s : A r r a y ;  
       s t a t i c   v a r   i d l e F r a m e s : N u m b e r ;  
       s t a t i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       s t a t i c   v a r   i n t e r v a l : N u m b e r ;  
       s t a t i c   v a r   i s M o u s e D o w n ;  
       s t a t i c   f u n c t i o n   o n M o u s e D o w n ( V o i d ) : V o i d ;  
       s t a t i c   v a r   o n M o u s e M o v e : F u n c t i o n ;  
       s t a t i c   v a r   o n M o u s e U p : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   o n R e s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   r e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   r e m o v e F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
       s t a t i c   f u n c t i o n   g e t   s c r e e n ( ) : O b j e c t ;  
 } ;  
 _ _ P a c k a g e s . m x . s k i n s . B o r d e r _ _ P a c k a g e s . m x . s k i n s . B o r d e r 
B u t t o n . s w f #U?              _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       m x . s k i n s . B o r d e r hi m p o r t   m x . c o r e . U I O b j e c t ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . B o r d e r   e x t e n d s   m x . c o r e . U I O b j e c t  
 {  
       p u b l i c   f u n c t i o n   B o r d e r ( ) ;  
       p u b l i c   v a r   b o r d e r S t y l e : S t r i n g ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   i d N a m e s : A r r a y ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a g B o r d e r : N u m b e r ;  
 } ;  
 &_ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t &_ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t 
B u t t o n . s w f #U?               m x . s k i n s . C o l o r e d S k i n E l e m e n t  
 i n t r i n s i c   c l a s s   m x . s k i n s . C o l o r e d S k i n E l e m e n t  
 {  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   v a r   g e t S t y l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   m i x i n s : m x . s k i n s . C o l o r e d S k i n E l e m e n t ;  
       p u b l i c   v a r   o n E n t e r F r a m e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c : N u m b e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   s e t C o l o r S t y l e ( p : O b j e c t ,   c o l o r S t y l e : S t r i n g ) : V o i d ;  
 } ;  
 _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r 
B u t t o n . s w f $U?              _ _ P a c k a g e s . m x . s k i n s . B o r d e r 
B u t t o n . s w f                       m x . s k i n s . R e c t B o r d e r i m p o r t   m x . s k i n s . B o r d e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . R e c t B o r d e r   e x t e n d s   m x . s k i n s . B o r d e r  
 {  
       p u b l i c   f u n c t i o n   R e c t B o r d e r ( ) ;  
       p u b l i c   v a r   _ _ b o r d e r M e t r i c s : O b j e c t ;  
       p u b l i c   v a r   b a c k g r o u n d C o l o r N a m e : S t r i n g ;  
       p u b l i c   v a r   b o r d e r C o l o r N a m e : S t r i n g ;  
       f u n c t i o n   g e t   b o r d e r M e t r i c s ( ) : O b j e c t ;  
       p u b l i c   v a r   b o r d e r S t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   b u t t o n C o l o r N a m e : S t r i n g ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w B o r d e r ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   g e t B o r d e r M e t r i c s ( V o i d ) : O b j e c t ;  
       f u n c t i o n   g e t   h e i g h t ( ) : N u m b e r ;  
       p u b l i c   v a r   h i g h l i g h t C o l o r N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   o f f s e t : N u m b e r ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s h a d o w C o l o r N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       f u n c t i o n   g e t   w i d t h ( ) : N u m b e r ;  
 } ;  
 _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f $U?               m x . s k i n s . S k i n E l e m e n t  
 i n t r i n s i c   c l a s s   m x . s k i n s . S k i n E l e m e n t   e x t e n d s   M o v i e C l i p  
 {  
       p u b l i c   f u n c t i o n   _ _ s e t _ _ v i s i b l e ( v i s i b l e : B o o l e a n ) : V o i d ;  
       p u b l i c   v a r   h e i g h t : N u m b e r ;  
       p u b l i c   f u n c t i o n   m o v e ( x : N u m b e r ,   y : N u m b e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e g i s t e r E l e m e n t ( n a m e : S t r i n g ,   c l a s s N a m e : F u n c t i o n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S i z e ( w : N u m b e r ,   h : N u m b e r ) : V o i d ;  
       p u b l i c   v a r   t o p : N u m b e r ;  
       p u b l i c   v a r   v i s i b l e : B o o l e a n ;  
       p u b l i c   v a r   w i d t h : N u m b e r ;  
 } ;  
 #_ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n #_ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n 
B u t t o n . s w f #U?              )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r 
B u t t o n . s w f                       m x . s k i n s . h a l o . B u t t o n S k i n i m p o r t   m x . s k i n s . R e c t B o r d e r ;  
 i m p o r t   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . B u t t o n S k i n   e x t e n d s   m x . s k i n s . R e c t B o r d e r  
 {  
       p u b l i c   f u n c t i o n   B u t t o n S k i n ( ) ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   b a c k g r o u n d C o l o r N a m e ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e ;  
       p u b l i c   f u n c t i o n   d r a w H a l o R e c t ( w : N u m b e r ,   h : N u m b e r ) : V o i d ;  
       p u b l i c   v a r   d r a w R o u n d R e c t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   i n i t ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
 } ;  
 !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s 
B u t t o n . s w f $U?          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                       )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       m x . s k i n s . h a l o . D e f a u l t s i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . D e f a u l t s  
 {  
       s t a t i c   v a r   C S S S t y l e D e c l a r a t i o n D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   b e g i n F i l l : F u n c t i o n ;  
       p u b l i c   v a r   b e g i n G r a d i e n t F i l l : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d ;  
       p u b l i c   v a r   c u r v e T o : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   d r a w R o u n d R e c t ( x ,   y ,   w ,   h ,   r ,   c ,   a l p h a ,   r o t ,   g r a d i e n t ,   r a t i o s ) ;  
       p u b l i c   v a r   e n d F i l l : F u n c t i o n ;  
       p u b l i c   v a r   l i n e T o : F u n c t i o n ;  
       p u b l i c   v a r   m o v e T o : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   s e t T h e m e D e f a u l t s ( ) : V o i d ;  
 } ;  
 "_ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t "_ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t 
B u t t o n . s w f $U?          #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f                       !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s 
B u t t o n . s w f                       m x . s k i n s . h a l o . F o c u s R e c t i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . s k i n s . h a l o . D e f a u l t s ;  
 i m p o r t   m x . m a n a g e r s . D e p t h M a n a g e r ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . F o c u s R e c t   e x t e n d s   m x . s k i n s . S k i n E l e m e n t  
 {  
       s t a t i c   v a r   D e f a u l t s D e p e n d e n c y : m x . s k i n s . h a l o . D e f a u l t s ;  
       p u b l i c   f u n c t i o n   F o c u s R e c t ( ) ;  
       s t a t i c   v a r   U I C o m p o n e n t D e p e n d e n c y : m x . c o r e . U I C o m p o n e n t ;  
       p u b l i c   v a r   b o u n d i n g B o x _ m c : M o v i e C l i p ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   d r a w ( o : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   d r a w R o u n d R e c t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   h a n d l e E v e n t ( e : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S i z e ( w : N u m b e r ,   h : N u m b e r ,   r ,   a : N u m b e r ,   r e c t C o l : N u m b e r ) : V o i d ;  
 } ;  
 #_ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r #_ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r 
B u t t o n . s w f $U?          (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                          )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r 
B u t t o n . s w f                       m x . s k i n s . h a l o . R e c t B o r d e r oi m p o r t   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s ;  
 i m p o r t   m x . s k i n s . B o r d e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . R e c t B o r d e r   e x t e n d s   m x . s k i n s . R e c t B o r d e r  
 {  
       p u b l i c   f u n c t i o n   R e c t B o r d e r ( ) ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   b o r d e r C a p C o l o r N a m e : S t r i n g ;  
       p r i v a t e   v a r   b o r d e r W i d t h s : O b j e c t ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p r i v a t e   v a r   c o l o r L i s t : O b j e c t ;  
       p u b l i c   f u n c t i o n   d r a w 3 d B o r d e r ( c 1 : N u m b e r ,   c 2 : N u m b e r ,   c 3 : N u m b e r ,   c 4 : N u m b e r ,   c 5 : N u m b e r ,   c 6 : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w B o r d e r ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d r a w R o u n d R e c t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   g e t B o r d e r M e t r i c s ( V o i d ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s h a d o w C a p C o l o r N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
 } ;  
  _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e  _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e 
B u t t o n . s w f $U?          !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f                          (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                       m x . s t y l e s . C S S S e t S t y l e bi m p o r t   m x . s t y l e s . S t y l e M a n a g e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s t y l e s . C S S S e t S t y l e  
 {  
       s t a t i c   v a r   C S S S t y l e D e c l a r a t i o n D e p e n d e n c y ;  
       p u b l i c   v a r   _ c o l o r : N u m b e r ;  
       p u b l i c   f u n c t i o n   _ s e t S t y l e ( s t y l e P r o p : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e C o l o r S t y l e I n C h i l d r e n ( s h e e t N a m e : S t r i n g ,   c o l o r S t y l e : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e T e x t S t y l e I n C h i l d r e n ( s t y l e P r o p : S t r i n g ) : V o i d ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       s t a t i c   f u n c t i o n   e n a b l e R u n T i m e C S S ( ) : V o i d ;  
       p u b l i c   v a r   i n v a l i d a t e S t y l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   n o t i f y S t y l e C h a n g e I n C h i l d r e n ( s h e e t N a m e : S t r i n g ,   s t y l e P r o p : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   v a r   s e t C o l o r : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   s e t S t y l e ( s t y l e P r o p : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   v a r   s t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   s t y l e c a c h e : O b j e c t ;  
 } ;  
 (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f $U?          !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f                          "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s 
B u t t o n . s w f                       m x . s t y l e s . C S S S t y l e D e c l a r a t i o n %i m p o r t   m x . s t y l e s . S t y l e M a n a g e r ;  
 i m p o r t   m x . s t y l e s . C S S T e x t S t y l e s ;  
  
 i n t r i n s i c   c l a s s   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n  
 {  
       s t a t i c   v a r   C S S T e x t S t y l e s D e p e n d e n c y ;  
       p u b l i c   f u n c t i o n   _ _ g e t T e x t F o r m a t ( t f : T e x t F o r m a t ,   b A l l : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   v a r   _ t f : T e x t F o r m a t ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p u b l i c   v a r   c o l o r : N u m b e r ;  
       p u b l i c   v a r   e m b e d F o n t s : B o o l e a n ;  
       p u b l i c   v a r   f o n t F a m i l y : S t r i n g ;  
       p u b l i c   v a r   f o n t S i z e : N u m b e r ;  
       p u b l i c   v a r   f o n t S t y l e : S t r i n g ;  
       p u b l i c   v a r   f o n t W e i g h t : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t S t y l e ( s t y l e P r o p : S t r i n g ) ;  
       p u b l i c   v a r   m a r g i n L e f t : N u m b e r ;  
       p u b l i c   v a r   m a r g i n R i g h t : N u m b e r ;  
       p u b l i c   v a r   s t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   t e x t A l i g n : S t r i n g ;  
       p u b l i c   v a r   t e x t D e c o r a t i o n : S t r i n g ;  
       p u b l i c   v a r   t e x t I n d e n t : N u m b e r ;  
 } ;  
 "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s 
B u t t o n . s w f $U?               m x . s t y l e s . C S S T e x t S t y l e s t 
 i n t r i n s i c   c l a s s   m x . s t y l e s . C S S T e x t S t y l e s  
 {  
       s t a t i c   f u n c t i o n   a d d T e x t S t y l e s ( o : O b j e c t ,   b C o l o r : B o o l e a n ) : V o i d ;  
 } ;  
 !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f $U?               m x . s t y l e s . S t y l e M a n a g e r  
 i n t r i n s i c   c l a s s   m x . s t y l e s . S t y l e M a n a g e r  
 {  
       s t a t i c   v a r   T e x t F o r m a t S t y l e P r o p s : O b j e c t ;  
       s t a t i c   v a r   T e x t S t y l e M a p : O b j e c t ;  
       s t a t i c   v a r   c o l o r N a m e s : O b j e c t ;  
       s t a t i c   v a r   c o l o r S t y l e s : O b j e c t ;  
       s t a t i c   f u n c t i o n   g e t C o l o r N a m e ( c o l o r N a m e : S t r i n g ) : N u m b e r ;  
       s t a t i c   v a r   i n h e r i t i n g S t y l e s : O b j e c t ;  
       s t a t i c   f u n c t i o n   i s C o l o r N a m e ( c o l o r N a m e : S t r i n g ) : B o o l e a n ;  
       s t a t i c   f u n c t i o n   i s C o l o r S t y l e ( s t y l e N a m e : S t r i n g ) : B o o l e a n ;  
       s t a t i c   f u n c t i o n   i s I n h e r i t i n g S t y l e ( s t y l e N a m e : S t r i n g ) : B o o l e a n ;  
       s t a t i c   f u n c t i o n   r e g i s t e r C o l o r N a m e ( c o l o r N a m e : S t r i n g ,   c o l o r V a l u e : N u m b e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e g i s t e r C o l o r S t y l e ( s t y l e N a m e : S t r i n g ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e g i s t e r I n h e r i t i n g S t y l e ( s t y l e N a m e : S t r i n g ) : V o i d ;  
 } ;  
    B o u n d i n g B o x 
B u t t o n . s w f                       S i m p l e B u t t o n 
B u t t o n . s w f                       B o r d e r 
B u t t o n . s w f                       
R e c t B o r d e r 
B u t t o n . s w f                       
B u t t o n S k i n 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n 
B u t t o n . s w f                       m x . c o n t r o l s . B u t t o n qi m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . c o n t r o l s . S i m p l e B u t t o n ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " c l i c k " ) ]    
 [ T a g N a m e ( " B u t t o n " ) ]    
 [ I c o n F i l e ( " B u t t o n . p n g " ) ]    
 i n t r i n s i c   c l a s s   m x . c o n t r o l s . B u t t o n   e x t e n d s   m x . c o n t r o l s . S i m p l e B u t t o n  
 {  
       p u b l i c   f u n c t i o n   B u t t o n ( ) ;  
       p u b l i c   v a r   _ _ g e t _ _ i c o n : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l P l a c e m e n t : F u n c t i o n ;  
       p u b l i c   v a r   _ _ l a b e l : S t r i n g ;  
       p u b l i c   v a r   _ _ l a b e l P l a c e m e n t : S t r i n g ;  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   _ g e t I c o n ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   _ i c o n L i n k a g e N a m e : S t r i n g ;  
       [ B i n d a b l e ]   [ C h a n g e E v e n t ( " c l i c k " ) ]   p u b l i c   v a r   _ i n h e r i t e d _ s e l e c t e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   _ s e t I c o n ( l i n k a g e ) : V o i d ;  
       p u b l i c   v a r   b o r d e r W : N u m b e r ;  
       p u b l i c   v a r   b t n O f f s e t : N u m b e r ;  
       p u b l i c   f u n c t i o n   c a l c S i z e ( t a g : N u m b e r ,   r e f : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   c e n t e r C o n t e n t : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w ( ) ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t B t n O f f s e t ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t L a b e l ( V o i d ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t L a b e l P l a c e m e n t ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   h i t A r e a _ m c : M o v i e C l i p ;  
       f u n c t i o n   g e t   i c o n ( ) : S t r i n g ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " " ) ]   f u n c t i o n   s e t   i c o n ( l i n k a g e ) ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t I c o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( c : S t r i n g ) : V o i d ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " B u t t o n " ) ]   f u n c t i o n   s e t   l a b e l ( l b l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l ( ) : S t r i n g ;  
       p u b l i c   v a r   l a b e l P a t h : O b j e c t ;  
       [ I n s p e c t a b l e ( e n u m e r a t i o n = " l e f t , r i g h t , t o p , b o t t o m " d e f a u l t V a l u e = " r i g h t " ) ]   f u n c t i o n   s e t   l a b e l P l a c e m e n t ( v a l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l P l a c e m e n t ( ) : S t r i n g ;  
       s t a t i c   v a r   m e r g e d C l i p P a r a m e t e r s : B o o l e a n ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( e n a b l e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t H i t A r e a ( w : N u m b e r ,   h : N u m b e r ) ;  
       p u b l i c   f u n c t i o n   s e t L a b e l ( l a b e l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t L a b e l P l a c e m e n t ( v a l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   s e t V i e w ( o f f s e t : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n : S t r i n g ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   v i e w S k i n ( v a r N a m e : S t r i n g ) : V o i d ;  
 } ;  
               
    h   h  h  h  h                    P r o p S h e e t : : A c t i v e T a b 7 6 4 1     !P u b l i s h G i f P r o p e r t i e s : : P a l e t t e N a m e   P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 5 6 K 0 "P u b l i s h H t m l P r o p e r t i e s : : S t a r t P a u s e d 0 %P u b l i s h F o r m a t P r o p e r t i e s : : h t m l F i l e N a m e s t o r a g e _ d i a l o g . h t m l  P u b l i s h Q T P r o p e r t i e s : : L a y e r O p t i o n   P u b l i s h Q T P r o p e r t i e s : : A l p h a O p t i o n  "P u b l i s h Q T P r o p e r t i e s : : M a t c h M o v i e D i m 1 V e c t o r : : D e b u g g i n g   P e r m i t t e d 0 P u b l i s h P r o f i l e P r o p e r t i e s : : n a m e D e f a u l t P u b l i s h H t m l P r o p e r t i e s : : L o o p 1 P u b l i s h F o r m a t P r o p e r t i e s : : j p e g 0 P u b l i s h Q T P r o p e r t i e s : : W i d t h 2 1 5 $P u b l i s h P N G P r o p e r t i e s : : O p t i m i z e C o l o r s 1 &P u b l i s h R N W K P r o p e r t i e s : : s p e e d S i n g l e I S D N 0 &P u b l i s h R N W K P r o p e r t i e s : : s i n g l e R a t e A u d i o 0 V e c t o r : : E x t e r n a l   P l a y e r  %P u b l i s h H t m l P r o p e r t i e s : : s h o w T a g W a r n M s g 1 P u b l i s h H t m l P r o p e r t i e s : : U n i t s 0 4P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t A l t e r n a t e F i l e n a m e 1 P u b l i s h G i f P r o p e r t i e s : : S m o o t h 1 %P u b l i s h R N W K P r o p e r t i e s : : m e d i a C o p y r i g h t ( c )   2 0 0 0 #P u b l i s h R N W K P r o p e r t i e s : : f l a s h B i t R a t e 1 2 0 0 V e c t o r : : C o m p r e s s   M o v i e 1 V e c t o r : : P a c k a g e   P a t h s  &P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h F i l e N a m e . . \ . . \ s t o r a g e _ d i a l o g . s w f 'P u b l i s h F o r m a t P r o p e r t i e s : : g i f D e f a u l t N a m e 1 %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c 0 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r O p t i o n  !P u b l i s h R N W K P r o p e r t i e s : : e x p o r t S M I L 1  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 3 8 4 K 0 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t A u d i o 1 V e c t o r : : F i r e F o x 0 P u b l i s h H t m l P r o p e r t i e s : : Q u a l i t y 4 (P u b l i s h H t m l P r o p e r t i e s : : V e r t i c a l A l i g n m e n t 1 $P u b l i s h F o r m a t P r o p e r t i e s : : p n g F i l e N a m e s t o r a g e _ d i a l o g . p n g P u b l i s h F o r m a t P r o p e r t i e s : : h t m l 0 "P u b l i s h P N G P r o p e r t i e s : : F i l t e r O p t i o n  'P u b l i s h R N W K P r o p e r t i e s : : m e d i a D e s c r i p t i o n  V e c t o r : : O v e r r i d e   S o u n d s 0 !P u b l i s h H t m l P r o p e r t i e s : : D e v i c e F o n t 0 -P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r D e f a u l t N a m e 1 P u b l i s h Q T P r o p e r t i e s : : F l a t t e n 1 P u b l i s h P N G P r o p e r t i e s : : B i t D e p t h 2 4 - b i t   w i t h   A l p h a P u b l i s h P N G P r o p e r t i e s : : S m o o t h 1 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r S o l i d s 0 P u b l i s h G i f P r o p e r t i e s : : I n t e r l a c e 0 P u b l i s h J p e g P r o p e r t i e s : : D P I 4 7 1 8 5 9 2 V e c t o r : : Q u a l i t y 8 0 V e c t o r : : P r o t e c t 0 "P u b l i s h H t m l P r o p e r t i e s : : D i s p l a y M e n u 1 *P u b l i s h H t m l P r o p e r t i e s : : H o r i z o n t a l A l i g n m e n t 1 2P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n D e t e c t i o n I f A v a i l a b l e 0 V e c t o r : : T e m p l a t e 0 *P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r F i l e N a m e s t o r a g e _ d i a l o g . s w t (P u b l i s h F o r m a t P r o p e r t i e s : : r n w k D e f a u l t N a m e 1 (P u b l i s h F o r m a t P r o p e r t i e s : : j p e g D e f a u l t N a m e 1 P u b l i s h F o r m a t P r o p e r t i e s : : g i f 0 P u b l i s h G i f P r o p e r t i e s : : L o o p 1 P u b l i s h G i f P r o p e r t i e s : : W i d t h 2 1 5 $P u b l i s h R N W K P r o p e r t i e s : : m e d i a K e y w o r d s  !P u b l i s h R N W K P r o p e r t i e s : : m e d i a T i t l e  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 8 K 1 #P u b l i s h F o r m a t P r o p e r t i e s : : q t F i l e N a m e s t o r a g e _ d i a l o g . m o v "P u b l i s h P N G P r o p e r t i e s : : D i t h e r O p t i o n  #P u b l i s h G i f P r o p e r t i e s : : P a l e t t e O p t i o n  #P u b l i s h G i f P r o p e r t i e s : : M a t c h M o v i e D i m 1 $P u b l i s h R N W K P r o p e r t i e s : : s p e e d D u a l I S D N 0 $P u b l i s h R N W K P r o p e r t i e s : : r e a l V i d e o R a t e 1 0 0 0 0 0 P u b l i s h J p e g P r o p e r t i e s : : Q u a l i t y 8 0 P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h 1 #P u b l i s h P N G P r o p e r t i e s : : P a l e t t e O p t i o n  #P u b l i s h P N G P r o p e r t i e s : : M a t c h M o v i e D i m 1 $P u b l i s h J p e g P r o p e r t i e s : : M a t c h M o v i e D i m 1 V e c t o r : : P a c k a g e   E x p o r t   F r a m e 1 !P u b l i s h P r o f i l e P r o p e r t i e s : : v e r s i o n 1 P u b l i s h H t m l P r o p e r t i e s : : A l i g n 0 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n F i l e N a m e s t o r a g e _ d i a l o g . e x e 'P u b l i s h F o r m a t P r o p e r t i e s : : p n g D e f a u l t N a m e 1 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c D e f a u l t N a m e 1 #P u b l i s h Q T P r o p e r t i e s : : P l a y E v e r y F r a m e 0 "P u b l i s h P N G P r o p e r t i e s : : D i t h e r S o l i d s 0 "P u b l i s h J p e g P r o p e r t i e s : : P r o g r e s s i v e 0 V e c t o r : : D e b u g g i n g   P a s s w o r d  V e c t o r : : O m i t   T r a c e   A c t i o n s 0 P u b l i s h H t m l P r o p e r t i e s : : H e i g h t 1 3 8 P u b l i s h H t m l P r o p e r t i e s : : W i d t h 2 1 5 %P u b l i s h F o r m a t P r o p e r t i e s : : j p e g F i l e N a m e s t o r a g e _ d i a l o g . j p g )P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h D e f a u l t N a m e 0 P u b l i s h P N G P r o p e r t i e s : : I n t e r l a c e 0 P u b l i s h G i f P r o p e r t i e s : : H e i g h t 1 3 8 P u b l i s h J p e g P r o p e r t i e s : : S i z e 0 V e c t o r : : D e v i c e S o u n d 0 V e c t o r : : T o p D o w n 0 'P u b l i s h H t m l P r o p e r t i e s : : T e m p l a t e F i l e N a m e C : \ D o c u m e n t s   a n d   S e t t i n g s \ b r a d n e u b e r g \ L o c a l   S e t t i n g s \ A p p l i c a t i o n   D a t a \ M a c r o m e d i a \ F l a s h   M X   2 0 0 4 \ e n \ C o n f i g u r a t i o n \ H t m l \ D e f a u l t . h t m l !P u b l i s h H t m l P r o p e r t i e s : : W i n d o w M o d e 0 2P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t C o n t e n t F i l e n a m e 1 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c F i l e N a m e s t o r a g e _ d i a l o g . h q x (P u b l i s h F o r m a t P r o p e r t i e s : : h t m l D e f a u l t N a m e 1 P u b l i s h F o r m a t P r o p e r t i e s : : r n w k 0 P u b l i s h F o r m a t P r o p e r t i e s : : p n g 0 P u b l i s h Q T P r o p e r t i e s : : H e i g h t 1 3 8 %P u b l i s h P N G P r o p e r t i e s : : R e m o v e G r a d i e n t s 0 P u b l i s h G i f P r o p e r t i e s : : M a x C o l o r s 2 5 5 'P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t O p t i o n  P u b l i s h G i f P r o p e r t i e s : : L o o p C o u n t  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 6 K 1 V e c t o r : : R e p o r t 0 +P u b l i s h H t m l P r o p e r t i e s : : O w n A l t e r n a t e F i l e n a m e  (P u b l i s h H t m l P r o p e r t i e s : : A l t e r n a t e F i l e n a m e  &P u b l i s h H t m l P r o p e r t i e s : : C o n t e n t F i l e n a m e  "P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r 0 $P u b l i s h G i f P r o p e r t i e s : : O p t i m i z e C o l o r s 1 "P u b l i s h R N W K P r o p e r t i e s : : a u d i o F o r m a t 0 V e c t o r : : V e r s i o n 7 V e c t o r : : E v e n t   F o r m a t 0 V e c t o r : : S t r e a m   C o m p r e s s 7 P u b l i s h F o r m a t P r o p e r t i e s : : q t 0 P u b l i s h P N G P r o p e r t i e s : : H e i g h t 1 3 8 P u b l i s h P N G P r o p e r t i e s : : W i d t h 2 1 5 %P u b l i s h G i f P r o p e r t i e s : : Z|o4aIm>db)#2O$M,R0QH)\4>~MaMXtVoK~[<@hV`O,NFnasP|M:H5KbxN]O{1d
'kJlEY--:C2)!HR0Q0^;4ZVn{Cqo&!9=9bt#Bn-dztb?T!SR9on#0@6,B_fa!za&pQ12f/k!jAK% S~H(1J38
*c<n|^`8y8d'&ZwJe!_ tLOOw]#xIe^+sQ+_zO D'Wz};>a;baZZP/fCIvJ2IFKF >oDv_v1tn^uV\E`:xUXcL0AM\hu](;-=R|5yz+*9G`9/t=s}w?]~_:n1w%@;tG4_;C}	&6tu2+k?-V) \]E0(~jQBk_KSXSDpT&.WJ-M) 5(9JlUa=m6kQrK/
+w`61JBVRclUT$44?2J".4Zl8+x7"h-ds{B/w/T}G;h}[xp5~NZB4m7Pw9u,B<ZO,i;#SJ);y:/egiqOtGF;[0kv"5\E)S6"ski0R*KEzsVRgkhER+wAHM!)(~FOO+!qr[+H+c"6!h0$Bs26@@#@PHePd
@Z-F"_")#IQU:&j)p]EShw+QL2J33rU4pS=KP`#H Q]pTh5joZz}1FP[Po=L/S,2}dB]xK&sBY%q0@a.MtfM1;;ydu&t2zibo2\)%wlyf1U9d4c"(x,+Ed&:ICNNZJ<3U8R <iD,^;JqGq'N<_	8b0hlq0];7} tu@.vr}%;;qx$:" nWidJr CZ_9<6xW,]g0q]z]3J(s
X/j$](1d(gm`,zNk|yF<-Gne6S+m&rGW@kw`>Re,S6+!S%F^ 2"ePWB=]uzV!sT<gW]$$I\PC!)h J0U`R,~LEA(![GEx(RYPY&p:]j4=pLxZ=@?%}E<#P;~%$ZD)?Yk-'6yB6T$iCRkfc1U/-J9:X3TPa`eJK:jQYX2L\;z
Y*EJn?UV2edUb\<R
GGQvV~0U]f*Ze4b Te4
$,n*f.*)!653(dSZ,^#f)blU3*E5~[XNYdKaY)Sg9zivE}fvC7>$jj"T*U!b 
_[)+7^O;6NC1(H8+Su3:QdjLUg(so!D/1=R$_*TXV[Zf.-p.#6.,m2=N!<x^gh:!rzG3}Ze}m}}x}e
7fSG<}|w+jmYmH!^j
Sc&JA"JvW7,:"_u>9oCH[qQ8F$rG@Ul/wK6GQJAM<x]k#V6yZhQIlli/PdLIrxv<r4u'O2PSs.tbBv=T0QNgeUmlhBCYooC$EKU.)k=|Z%T@KKOBX u{dj{wy@@&QwJ:U2uA-wy&|V3BcLu*|	JOqx0'1}S#'CoxoZ'W0kOku(:8sTme!>-[
y[WD6E^t1&U!Q7s$~~]F| 9HF%D8#:		t4^gkM+#MhL*z>nca<(#USb4u-^\K:1`iw#cvRRM.k"-1 7<4XRuaPCKPP04'
N'#+p(Z[]F$5 E:-NL,mOwkERjQ F9ZA4
pMr9B@(.hnM[-C({iJ?jT}<}X
_F''~4:6P^%Q(8FJAhzr)\T{M?X?;mv[s[^@WSET1/,p+de{9THS:b7> )6@J*)sGG#J`~\pU!Jp7Jx3>u5Auq{Ih:\1)9?U}S%H!>$WV5jchv%9:/&YP@t9RdS)#t@u]~U @NNw $@dIP  (%^X^fly88N39v%Lwr<>>8#[DuT^ zz|tUOIL%	w|x"*7[`
n+>'M1G1O+ >o/Zp+gP<2fQb` ac|d4Of5o:o$Cd`n.FYZ6aSIzRBB:krjSEZuj7{I2A;nnq9SXSFeF:N1uouPh?uS1>>h8?jSc1=~{QvN?@(>>uap)Vs(zVN\A4ZV3
	5*hMy&b_"Y/
J8&Gq#c*'1q*2L$0z3&BlxY^<`s'.!# ]Y8UcG	@u#xK	O/W"1N)e@3:d4#'FgYiN'H0BY,|V7c7JmPW^M5\6'WWa_9U!yxIf@WKg`7'Q#	=$C29LtV;%(wG26`&:%OXW!Sk_H|2a;r@2Kp|M+>hg`:5MM_pWqv7f1[{Pfo17F|\ 071[FD}2ZflhH'D,JrjB,WrEqNA?(`Y1kYTEfZM/)DdJSH)<HSw p%L(j>t,VYlu|L89mi(ju+Tf,\D[[xom(\s CB=UQ;Juf/ na'&&JSESxFX"$8!Rb cmIvteiU	imK&/ 0=H;iFUFJtHvxAh_xcn*m$[%^p8oIx{jP#A1B;]K|w-]\6N[-mQ\r'4,K	,we-:dwuRwwiEZpNee<XVXVU{w}+_z{*7R C.PM}CUI`x@0`l']8]8j-N'dM.d{<d[_)noI`A7$Q4'$< ;\d,(&M0MblI*b4!EQk- H3-IDt- 
LhrZ0hV6>6a-0>dRVkHj#Wk-wlBTI)F'f<'b34uM [XPy,MN<R,I
9ZQQ R !@LGEPN)v+HgKkn`4c0mNF@s&EYXQL8%RvkoZa/LN@1.|K{x"B~Js`JgTCiyW2i>4vC}$^dTSYJJ8jtfgun1qPDf7+Q&%0hd`':n)n0r0x4F5@r&q5__-Nd=9pkJDjur]BV_F:[/~om,~[ome[}Co`{veD;f=y+Dg()dlxl-5?+:'q8GwBNyjY5[PS'~+UGPv=Z9\ndRSuy}+U[#5Z%Uij]MVB:9(HC{hmRGsx$*2fF^kiAqRKkhPWY-yL6)307#S:' "v;X_Q8(dJ"zpS3&r"4cPP)JUP o6U B8m"s3Eh '[7-`T@C7=4iSl~33s4L%Z;m![\Z%YwspH
T
C!)j!CLzL!5fBYBECtxLJG.bmRiiS%ht`??VM	e@ PQYu$}q)`8XRX*J%OdVDe/V(|ZVg )&4`DG	Wk*A)L7i|3nLY7(tFeoTV#h~~<N'})z'\F?1$')9[IR[U:dsRNb8ax;mA
"Kt)a#@G-?=<mH5yWWff#%+gI1'Zr`p'fo*@EC f.xp$*G?2Tn8>'xIG#:J\~K6)Li26pycs[5Umi:p#]qn>ls3e@lLqR\BL 	L .dz8NYC04TE,"hAaaicGL3l0"&/">*^/ ;@{B^Vv :J
#&S}1^b7;1'6m6X2E*11*$h)DX39on@kTxz(uUP(gv]1BcjX;[Y:O6B.Ie\V$!he/9W~*,>-NeJoCFG?v]Z>>"cv[P~D/vnZ8eU["Dep-#c	 19b .#D7UMx~{FPbGH4RiUE(YOUE;:K:eFQT%F1X>'N;7:G7[7w.zi
ZR(B7Iz/1Q$4t%Aww!-45DJJ/'	I^d,7[f*sGWr!5H  Y[JYR =}1 iE!O[pM:I~^@t_skM]:~<oCX_aPo N'y@\]Q34UP\7d 7v*XZJ\WV'x{xc)z\ycWXg8<GlNM8dUl QI,'nV=0Pns&+XXlXjJ-oOR1J:<t'X|5tTBixfJE7]x57o"r+m=9^${7$R_`/WD-+ ngr=<Er@8CI{
Kqm:D|wd%GDw2N..]%Vg='HxISoDF~#897(?,P(hu|3Po$HX_^=rY|YVpeQ"@|+`c:[$5L~yZ>}V}H9-O~0=(#g!S+2j^b5-3Sz:)=fNM{Z^ws<,g	u<-}) C3C-u|]<Xcob=;:x1~
v?%B^n*?j/?u?jPP=8toATLrK2E`;^
:bmyehuyI9q7.bMC)y
kY}:x,16>{X~egH*;; -jxm@r .b(9j5=iO
9lai|p-1>q*Fp//xw>^'R@N%	P{Qp6*f<"R'\_R^LUH3i~_	8Q^6FgQM
<	&/Yh_/x6yB>eVR42
o-^tpsky9!cJY5J>d<BR0DRN}4T\QX4_VKK(,h#S5\68l@|#y;|R#F0|GphC|C@@!***
}Q~I}YU+*U
R:/qhiY=|CsA+zS=*r7<_@Z8C94|CKbe"e"Keb<"-,-QPcEi	i>u8/ +VXH;1pO3O^>|<e<Dn369.=/Rg5.+,&GJH|:]_/"FWWW)u#?)o>?hT&]am=S=Ctg:]un4QI$$ob	!\!)y@PJV(^Z7%krCRZkE2!:P"pzbRfv-`H2HgKv)P(sBmhKCI {Z@v.(^j8\0k^9Cd19(	hA%GdB<N,?NkbQa/?(K/NLS`%ha ;32$F*z~9>d+y	 h1"Ww?CJ@ )oI7E66a#of('2/( Y/FTO`,PN'_8'ZS'c)Po50;SAeI|hVW0B\|!]y/ ,&U]Xvg)!|4Rf9q9wq.!qh%5`PWM%!.`h\0[	sXotf$1R=fRk V]QrO41BE2EUpVszCDMH)DYZL]b=Pr6q,@Za}y@}i m#>S5b;mYS>h\0 "Y7!&MH	C3VS'# 6;_Z:=D4t+^6}lUDi`K]p #	y:~#hU
 w C&7pf(+5I4kZj"Qa4f{(PuPM	0i"ddpf3z4XtjqPU?\lVC&.$5U,3r$;c@5&yL=wu^/Yf2qkej'% SDNaaSI@d,99bX}L)m6WY&{.uy?o.L)1_LE[HTs=98xp[?{@xP!3ySo0'0< 6KPk(^92kt*r\6QLW&xHJk0-I:&t-Y+SLWiYxbl58#;gPd7xZM$I`>9rUgMQD*D$kiM.-z*t]
VU
EWVK*4BUhJJ*4zk0CT23RXV{wgy` 	AnfeA96&>8o"{ZvE\'DA+sz.AZ[eBz)j2yp[
Yjvs@{)B2("+CMOO^f3}3fCA5/}ntKACy7<z,_M^O~FRptf,&.+HMJizgTh83I
Ec"Ehk.ep@; lMHNK%VQ_4H&}bDz,0
R*hAHs<gP^ 4Wr+&.|'TEyEUkQL~	[;'I l]'B&dOU.).> ]	pc<c7S,%
lAS&Lh}9<TvTo@ `+UAejWZvG_-/ToN\q]<Xv?UT&O2HJSeG=Zq(U6-F94#S b|iVLKg
B]CCI`(CJYjhR[(LL@8c 2(iK@NCt&KW5iM]	_aRnc?=F
f)>}8$9^}'U#k"Z*\*"XV`ZhR5naDgnKZ[cf`*ZMTHgdevdBMMG;2Cl%[KY[d,2JCE5|?;|wU>yz.RR]5DJs{U&XN{ul`aVlDskols8R2[$C?x\-D]*T1^!I>[r]-6$v
TYOc1bGn7u-lbQU}$XN(m).iKl-T14skjrb>i;I E43cr]a*xsMa(`*-`2v`==x<o]l/Q=hhZE<j<y \6E>-^.H+''8 QhW,].W."*5Sl?p-L|Fy)1..{'mpTkLlJ+Ge<	!jlZF\.\"I-+9RhKXw*R.'eE,_b$?ZOBB4>4sD6dY5;20B^XP-H!36A%8H"#T,x`!ylmQ8!;YEd6[dI& Wi/KO9IebF]8>oyr)A [I3chef"GF>^uaC[dLqE+Adl(*Dtf@s lzRv055w`uy) cW[h 	R!t#C`l-"EFV&"ddl;dd]"KFvaeJCC%]i?  8@=DT#AgC*~|})#Glk'@s2tJir\H${evrIzQ5Jz\!qN: ?`7dtWc<jP08 JA=~pP	hOi	-ufL\,j9yuX}*=lU7L^K9iVIe$PPh8dX~>Y1a0PoG LP6A'<a?K".l
7\oa 5ryNx3' ]RlT%uTM+ |K58/8'ni%={qH_h{/)%P~!4TT MPYOlri ~#C s
(/)Rj<5<kEVY6,'XsesI%Kgx~pR#5%M3Y=731zfbJ<FuP.'j"QvB6)`QLxJ%qR5mt>%J3*/XQlnhuk%zo4=7^1
s|;.Li'KK'JWD.NOglB94LgBC^IY
cb!KWxW0q6l0['3PkVOf#bxvCK'y(o(|4D-}vb0WxI,X17=V,^-\c
	l 
zaO:wx"'0;3q<U.w 4A>@=pfJb	?#s3J~T(_&n?aj	8oNT'Q Ej/5%A2gd"XM6#:%.,L/t(pyVrrw=!Ua"#kxX{,>;66&#~*l`+9C$]n'{Kh/+7~;9.smf_y>Fm7}_p}dQs:(69^Rc|dYdr>^PEF9nFNQs/N~/THNj'0RjyaJ	 _mVULU;j,rg/YU;o~IGB-	ylz0r0_F.k	>Ix[n(m<E-
vFE$[#8
r0^pf{Y
M}tSMy5y+^zKx/(LNV\dDkF,p[bX?!"`.-L$g=RLhd4Djl$z|@-6j" QO\US-0
fuyZ=jAfVP8OZX)!(1J4 ~ktrT?yN[1
YV
ls~6AleQXfeP ?2	8e)^\g#?'3>{z|;6&t.Z-zgL.\]^Q1WgUQ3Y*Zkj9b>}v93$_,gybRq}=P61'Cyq{j" ZNhm\e9{>u(^,>Yx>1Z`4b%[D^=>+I~>rNngG6lv/v7t7@V&:U:3b=(R}z<[0a2dfXiR#I1p,>SD^,i7'D[hB3L>^oqzv\z3$Y6}7QZax!e4DkUCIC)c&(Okk1ae+GgldJ2$*|{f'Q}UjMMu#]6\yiTEjf
^\x0MLM:~5<w
?ieQ\] mKHKBBK#AT!`i5g.#$y

R7(YlwAP/+*k/XyI =5@E)c@} E0{]k^	
':j@R>2Du~}_mu6/&b!{S{J90.(I(F_XEV7m(CBVLOUO4EIG{-UR	TAZkT#>.X(0RB->ldlN7&gvo(abmFD}BIp[O+.695nu;,GE:!HQ=zumXT;I"aNg:o2R}?+7 ef]<,*\|<RGo4ytXJ>:]6g\dR~]R8|gcP"%ax<*M%OKSJN'KW<Hd<S'HY=N\C95v.SsS(@p,43Gaj9K]<KbR\rkO/!K,17BKaz|y 
#&C
q3kt4YnAS- %A>-f|IC)Ei	PohTTw~57p}_XOl9-%Q[20,frb@K'O\'~Bqfr<2l	m4/(xaXlo<x1&{.;8<qxY 9|rEe	I	n&4 Kis>6{n0R1=m)a=dTRaF)O>5a|%Lh)0V7jzKY'yF`kf3# uVZ%t]VX
"5F/jP- 	,d$akXef *i`58\f\s|Oqr7[#A:lq)50}|>Ag)$*Wp:?	^M/`KLN	S8ZV[GuOs>v%g
OB4w_W}>@mjdwQz-b6@
{]
doTz2j31.H11Mr5r)!'Wk\+'N[CGEs6,H:D+,=1uh3Ef{$5e+C[3.CI*'}DP2j4D tp'B%*L'<G88u8aU '3]G}`sSf*nml26e7e.)s)eUGA"|)a!l!njXsun_de _3z2c)P=dvnlSZ5znLMQY"e>lu):+ )hmR30X~E8SO?=	4}r55/
f!8mcgkm WO^Fi0SC^G]^lDN9'00hj}kk*yeR#Tw9'/yjl#>s	rF!LnMvCG'ry
MO,+M*q+/{UX'*1pJ=2f^G.OKD|10s_	yzg4]#|(<exDZQ~hOC<C|4Xx	%og_NF6fK(KEOEft#:"g~c!hX+>Z}`YcUdm"S 6#ZZ( ZW/2*,W:8{ZN+ep:,x
W?5Z=2A`g*<V,9ef'K#l,-Ek 9ytF)P)>Sa"ef$zUV.TM+i{9'Yp7Q~4G2O5+V2j1_2r T:&es3Ea cd/gU/hzV	h6MSN/{%K`@;s`-zg
ELAYqX!yMgV9"Cc3Yo=N/F0fcSyE	Sb >B@6~0@ 8#FLPM{2|/bB8pMfaJ3mw}B<5nCg!|@55*G&'F.9&oaTo'f+q7Q88cC)il0wCW+q\s4P	{,BWan{`"h $AF0Z.x,BGBVr..daeDXkC T|&z4Kw]AE"8maS%e~6 NH_Ol4p:Yl4w6A~P#&wLI7;%yMlY5Zr~4J(ftWeFVo2%);ECHc9&.[ms*H*['xSc lailmR"`"XNN)=K6|d;Iv3hmQ0xs `(YMNPw[34_p6g`4N;aVf;5=^5}4&_cq 0=LU4wn:vFzPcbTH[o!n3%]TsJ^j
luNB;!MtGdp@+UMOH eCx?[HuY,$ccvr.^p"On:;Fs3~DY1Sr6xU|9n,R%R,<~GN*=Y36U`*wgl'#f*wyj=jgeEbWp D!hkd%_1"?ps?Hlx@W7Y*]jADsLX87k$NC4A`*YS;y2YhDYed3QE%F%>l$09>@5#9LyFd7&#Fkcu6?]Q	BYrBFsLI<'#y&Fqj~r0]<yA=PN $DMz<IlX/qF6GGEFn"!P^[9-ysE/VW`|.gwDO+h 9H'/k/b*FN_Y#+ZKcqC4Kl4gNTZDmpza]XtAw.TE.41t>4I+a6QLp4L+d2L	0V0 Z'6 LFa2R&#a2a&fdDMxm"3Ql@o&"0JL		_>6de0;@5ZqC^R~,cy~^pv/Rbp8G6^3;7 q.?x!|A1,nCK~ k3z7#r=_8~ZYQ*y$JPd_J}oEVC{YwUPg{TiI=z;=h2$1M^4_'<C
q/xD$q'my%&?\ jT9=e~S79zgS
A,jcPZ'a!"`5$UA>!s{b|i<RxL2Ye`D
2p!Mp0:UJ%QRH,?	:i[*(X'om:P.*/._rOTh8&O7+5'B~L:Txb7N/IrxBr\4)PgmQiIk-LKtA;m*:z@'@se8@yr%D<T.*mEFPVs1}@gU903=PEjQbY>5o1`0QwR%ZTbij$c@Bv?joW2w-uzC^!bJd.o=kRX_l{F0I|(yM>%^,%NVu~?#~C%`{&_$.Zj33kpIAty sKy~9NV	5?+QM6E^~$<0si{1/gQ"X>@vV3^5^{=$b^zda& ww&|)>(/pQ6B% B_@%9JM>?Q%!zvAF "7TkiQ2n$4e2k](P8`y(CCQX&ZRHUd@tmx(jw#Wr{^ gAy{<)TdXl!jY:S&Xf'\NeBMi#P~:}e2h53 	t/br]25D1(S9pK\HAeD IdK`)fjVo|5A!Nrji*97Z.T	+Lie^iw$nv:i9?[+|+Xg|C%	*xA;2?k@1sP/^>{qD5o`8W(+3aWY]l=z7hd]RkFlDK(*w
+ u[Q0
v-wKIcnB,oD:`cnsdOKgUItm'@0=|&V5~q/;qU^E=LHSFE#>2WC4MHHSS*R^+BD
b7U\mEjk^$.0~ns:3FP\Y;j*>YIn#VIY}Y:1C$RlAK<3z}N*"_u3px#A-*Nh_F;-j|{#/)5G	 u4/J_4/|o2q6%ml/%tq)$*<vL;CX8 MFNBXC<H&t9Rv`["dITbP(m$i.cZ`uYm'>H%dE[e}Buml56j:
ZkZm}J-D;nS!MI@$]d;[Oz-M:Q3e4qso1_c;+NQ`7r5St,	! VQ_gJ&^1+Fidb^rdF=}uK7:{[LAmo}@e9u&A.Fw0gF1RL	u
7UG$!^QxM\W^Qxm\uid=t#9Wgv ]ih"hAjg8Ql'xuKSNLqE|LtqEEO\.F}+1#94zb!Dfq=_^ 0VW|v`P
u7[$W4v;N):6.$xkI4Etl|Qon-Rac+%Ke`lA1Es\^)5r.gW:XnuPz<u&I<821|vlP0-Nw7QdCDQluhLqr7lT)e]cQl|9 %i!B3&GSaC,i8$65CJc1*v1R&)Lat|H`ALL]>:4 /LZ1WR*v2wE>tW&~&Lz=^
fcwP(jQx,[2s*"5PsU~ j/8,A/nR*FgI}1/&c*Q en,DEUwR@1w?6do_H-<FivQ?*22dWHJSy\F+rA[Bf,jf
HNeOIN 
MF,m(:!V#`|F nc8a[ _Np[Y*XV41:dvL.2rbquhQbIlF-{k]	s%Z*THwI`b%&k\^SIyj3aVkto?c7gKr>#e_	{ F#d\=m?K ?R,y'^Ufs6luJo_:pmH.c)a@2ww2&v)CSLFa}Ko}K@@4HN4@%D0R`j8JJAV}84.MGk{@4Cf0}X3x!d}f3~m}YQQYQQYQQ5^G>jA0vO_z7o}Xo,>lJgs\++Y/w#-.]e}a7q#T$k,PPKs3!bd-m/,6FS j!Mx;}_$VGuv`en/J#"W9,NZ^yFv7>AKhtoJIkZE7H7\*o?QEi5IpC^s z\6d'Dx)Im8rp0F.d7#ItFrThX9}gZ(VLh<VjR0oGnA%L*qb{2	,(-3 B {(%fW3#e46V.Ba+y86
d[&7])
kJj"q<^-]yFNtUewalPZ^zap6d5ksn^]5LhhAQA^JiL
M"~'I@y((+oqNQXRCjHi/
Uel:[3XlR [PwC5Z`6lu0efG[,[I>jl#|#g;	s"A7~{C%Oy'nx7n 8Oul*X{8
:{crqnE>B	SD3sPPE1U^8A8Bq3	ro0Cv r|\[<?hn;;;KcK#}SDZ+c[D];hX$%?ns^Z>|}=HFdl$tHIk"YMY,wsi?2LS"MVqCVwVy(}%4krN],EVB`*}{={z 1Hbvip*GGh|{PC1cH!1V;<9.Ia)$&M*TnoFu1N\W`n?wTZi\V[pRcZRgJSu+;q6D'?Owu0x73t6ha;t~= ?ZwF]k~Vy{ETwCT\t_3?gww?J,9-sL/&"L08ef3V
CUyPb=4yIshSJRcK 6Uqrbs4cy+.`eNN$7A[wg,+Na8S-nfeh;iTiGCt0I4"PgI1=,<Ksk0"LoX?)
ts85.GaMIjZ+NbkcZBiab%'l:9&(&'"Ta~Fy`4y`i[ZP^LC-*VdosZ-M[7*=QCA0
SwfzHkLn&QER3_|	^.aKFMSE,V 9r'dMXy f|jVj,#Z+$+Znc<PzSYW vN SVYtuDZw}6JO"XN],];u@~kZd(itX+~~xw%;knY/U b	FDDYbo `F&T/rLY=V|&.MpSl]R6m8Ml\!8]8|Z%qk`(J
@>u/*V;o?z'd}QX/Q:JV"ueu{{_^WzW^y%z4L1atSWg	/MJ		 Xb5'""7hl j;b\5;RuecT2vb{|]hOeFVjo	}lWT{~@"10aN`YRU:}|g/7Fv{=^fd#/{sM12>Z.yYXV*<JC[6q4V>1]}&U;>?j[:WB (!I:Hpo}M];kGk^p48q%g}bZoxuA L$_A.GutodoE]nt@-!0n GyqpA;[<6"tZEpp"% FRqH'RVJ>l%Z(<OGj(3|[5g1Qd'oai]y1+/'.P5dHfgJ&.OOIR cTZVLj)pEr]ex[wwbieT6_Qdw	>&'i
,d%&ItN~^,'W1c                       	   i c o n              i c o n  FLs     l a b e l             B u t t o n l a b e l  Eb[cFE\G     l a b e l P l a c e m e n t            l e f t r i g h t t o p b o t t o m l a b e l P l a c e m e n t  TI^D     s e l e c t e d             f a l s e s e l e c t e d  /?ZJ|g     t o g g l e             f a l s e t o g g l e  gYD     e n a b l e d             t r u e e n a b l e d  !RG5S8bmO t h e r    v i s i b l e             t r u e v i s i b l e  D*LcXTC$vO t h e r    	m i n H e i g h t             0 	m i n H e i g h t  PKu@&jS i z e    m i n W i d t h             0 m i n W i d t h  !7C2I l/S i z e        )< ? x m l   v e r s i o n = " 1 . 0 "   e n c o d i n g   = " u t f - 8 " ? >  
 < c o m p o n e n t P a c k a g e   x m l n s = " h t t p : / / w w w . m a c r o m e d i a . c o m / f l a s h / s w c c a t a l o g / 7 " >  
 < c o m p o n e n t   i d = " B u t t o n "   c l a s s = " m x . c o n t r o l s . B u t t o n "   i m p l e m e n t a t i o n = " B u t t o n . s w f "   i c o n F i l e = " B u t t o n . p n g "   t o o l t i p = " B u t t o n "   s r c = " m x . c o n t r o l s . B u t t o n . a s i "   m o d i f i e d = " 1 0 5 9 0 7 3 8 8 9 " >  
 < m o v i e B o u n d s   x m i n = " 0 "   x m a x = " 2 0 0 0 "   y m i n = " 0 "   y m a x = " 4 4 0 "   / >  
         < i n c l u d e   i d = " B o u n d i n g B o x " / >  
         < i n c l u d e   i d = " S i m p l e B u t t o n " / >  
         < i n c l u d e   i d = " B o r d e r " / >  
         < i n c l u d e   i d = " R e c t B o r d e r " / >  
         < i n c l u d e   i d = " B u t t o n S k i n " / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n " / >  
 < c l a s s   i d = " m x . c o n t r o l s . B u t t o n "   >  
             < E v e n t   p a r a m 1 = " c l i c k "   / >  
             < T a g N a m e   p a r a m 1 = " B u t t o n "   / >  
             < I c o n F i l e   p a r a m 1 = " B u t t o n . p n g "   / >  
       < p r o p e r t y   i d = " _ i n h e r i t e d _ s e l e c t e d "   t y p e = " B o o l e a n "   >  
             < B i n d a b l e   / >  
             < C h a n g e E v e n t   p a r a m 1 = " c l i c k "   / >  
       < / p r o p e r t y >  
       < m e t h o d   i d = " i c o n "   >  
             < p a r a m   i d = " l i n k a g e "     / >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " l a b e l "   >  
             < p a r a m   i d = " l b l "   t y p e = " S t r i n g "   / >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " B u t t o n "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " l a b e l P l a c e m e n t "   >  
             < p a r a m   i d = " v a l "   t y p e = " S t r i n g "   / >  
             < I n s p e c t a b l e   e n u m e r a t i o n = " l e f t , r i g h t , t o p , b o t t o m "   d e f a u l t V a l u e = " r i g h t "   / >  
       < / m e t h o d >  
 < / c l a s s >  
 < c l a s s   i d = " m x . c o n t r o l s . S i m p l e B u t t o n "   >  
             < E v e n t   p a r a m 1 = " c l i c k "   / >  
             < T a g N a m e   p a r a m 1 = " S i m p l e B u t t o n "   / >  
       < m e t h o d   i d = " s e l e c t e d "   r e t u r n T y p e = " B o o l e a n " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " f a l s e "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " t o g g l e "   r e t u r n T y p e = " B o o l e a n " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " f a l s e "   / >  
       < / m e t h o d >  
 < / c l a s s >  
 < c l a s s   i d = " m x . c o r e . U I C o m p o n e n t "   >  
             < E v e n t   p a r a m 1 = " f o c u s I n "   / >  
             < E v e n t   p a r a m 1 = " f o c u s O u t "   / >  
             < E v e n t   p a r a m 1 = " k e y D o w n "   / >  
             < E v e n t   p a r a m 1 = " k e y U p "   / >  
       < p r o p e r t y   i d = " e n a b l e d "   t y p e = " B o o l e a n "   >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " t r u e "   v e r b o s e = " 1 "   c a t e g o r y = " O t h e r "   / >  
       < / p r o p e r t y >  
 < / c l a s s >  
 < c l a s s   i d = " m x . c o r e . U I O b j e c t "   >  
             < E v e n t   p a r a m 1 = " r e s i z e "   / >  
             < E v e n t   p a r a m 1 = " m o v e "   / >  
             < E v e n t   p a r a m 1 = " d r a w "   / >  
             < E v e n t   p a r a m 1 = " l o a d "   / >  
             < E v e n t   p a r a m 1 = " u n l o a d "   / >  
       < m e t h o d   i d = " m i n H e i g h t "   r e t u r n T y p e = " N u m b e r " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " 0 "   v e r b o s e = " 1 "   c a t e g o r y = " S i z e "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " m i n W i d t h "   r e t u r n T y p e = " N u m b e r " >  
             < I n                                                                                                                                                                                                                                                                s p e c t a b l e   d e f a u l t V a l u e = " 0 "   v e r b o s e = " 1 "   c a t e g o r y = " S i z e "   / >  
       < / m e t h o d >  
       < m e t h o d   i d = " v i s i b l e "   r e t u r n T y p e = " B o o l e a n " >  
             < I n s p e c t a b l e   d e f a u l t V a l u e = " t r u e "   v e r b o s e = " 1 "   c a t e g o r y = " O t h e r "   / >  
       < / m e t h o d >  
 < / c l a s s >  
 < a s s e t   i d = " B o u n d i n g B o x "   m o d i f i e d = " 1 0 5 4 5 9 3 6 5 5 " >  
 < / a s s e t >  
 < a s s e t   i d = " U I C o m p o n e n t E x t e n s i o n s "   m o d i f i e d = " 1 0 5 8 8 1 4 6 6 6 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s " / >  
 < / a s s e t >  
 < a s s e t   i d = " F o c u s R e c t "   m o d i f i e d = " 1 0 5 5 7 4 4 8 1 9 " >  
             < i n c l u d e   i d = " B o u n d i n g B o x " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t " / >  
 < / a s s e t >  
 < a s s e t   i d = " F o c u s M a n a g e r "   m o d i f i e d = " 1 0 5 5 7 4 4 7 8 1 " >  
             < i n c l u d e   i d = " F o c u s R e c t " / >  
             < i n c l u d e   i d = " U I O b j e c t " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r " / >  
 < / a s s e t >  
 < a s s e t   i d = " U I O b j e c t E x t e n s i o n s "   m o d i f i e d = " 1 0 5 8 8 1 4 7 0 2 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s " / >  
 < / a s s e t >  
 < a s s e t   i d = " D e f a u l t s "   m o d i f i e d = " 1 0 5 5 7 3 7 2 7 9 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s " / >  
 < / a s s e t >  
 < a s s e t   i d = " U I O b j e c t "   m o d i f i e d = " 1 0 5 8 8 1 4 7 3 1 " >  
             < i n c l u d e   i d = " D e f a u l t s " / >  
             < i n c l u d e   i d = " U I O b j e c t E x t e n s i o n s " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t " / >  
 < / a s s e t >  
 < a s s e t   i d = " U I C o m p o n e n t "   m o d i f i e d = " 1 0 5 8 8 1 4 7 0 0 " >  
             < i n c l u d e   i d = " U I O b j e c t " / >  
             < i n c l u d e   i d = " F o c u s M a n a g e r " / >  
             < i n c l u d e   i d = " U I C o m p o n e n t E x t e n s i o n s " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t " / >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n U p "   m o d i f i e d = " 1 0 6 2 2 2 5 0 2 6 " >  
             < i n c l u d e   i d = " B r d r B l k " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
             < i n c l u d e   i d = " B r d r S h d w " / >  
             < i n c l u d e   i d = " B r d r H i l g h t " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r H i l g h t "   m o d i f i e d = " 1 0 5 2 7 7 0 9 0 8 " >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r B l k "   m o d i f i e d = " 1 0 5 2 7 7 0 9 1 3 " >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n I n "   m o d i f i e d = " 1 0 6 2 2 2 5 0 2 0 " >  
             < i n c l u d e   i d = " B r d r B l k " / >  
             < i n c l u d e   i d = " B r d r H i l g h t " / >  
             < i n c l u d e   i d = " B r d r S h d w " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r F a c e "   m o d i f i e d = " 1 0 5 1 7 6 7 5 4 1 " >  
 < / a s s e t >  
 < a s s e t   i d = " B r d r S h d w "   m o d i f i e d = " 1 0 5 8 9 3 1 5 2 1 " >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n D o w n "   m o d i f i e d = " 1 0 6 2 2 2 5 0 1 9 " >  
             < i n c l u d e   i d = " B r d r S h d w " / >  
             < i n c l u d e   i d = " B r d r F a c e " / >  
 < / a s s e t >  
 < a s s e t   i d = " S i m p l e B u t t o n "   m o d i f i e d = " 1 0 5 5 7 4 4 7 8 1 " >  
             < i n c l u d e   i d = " B o u n d i n g B o x " / >  
             < i n c l u d e   i d = " S i m p l e B u t t o n D o w n " / >  
             < i n c l u d e   i d = " S i m p l e B u t t o n I n " / >  
             < i n c l u d e   i d = " S i m p l e B u t t o n U p " / >  
             < i n c l u d e   i d = " U I C o m p o n e n t " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n " / >  
 < / a s s e t >  
 < a s s e t   i d = " B o r d e r "   m o d i f i e d = " 1 0 6 2 2 2 4 8 7 2 " >  
             < i n c l u d e   i d = " U I O b j e c t " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . B o r d e r " / >  
 < / a s s e t >  
 < a s s e t   i d = " R e c t B o r d e r "   m o d i f i e d = " 1 0 6 2 2 2 4 8 8 7 " >  
             < i n c l u d e   i d = " B o r d e r " / >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r " / >  
 < / a s s e t >  
 < a s s e t   i d = " B u t t o n S k i n "   m o d i f i e d = " 1 0 6 2 2 2 4 8 9 3 " >  
             < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n " / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t "   s r c = " m x . s k i n s . C o l o r e d S k i n E l e m e n t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   s r c = " m x . c o r e . U I O b j e c t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   s r c = " m x . s k i n s . S k i n E l e m e n t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "   s r c = " m x . s t y l e s . C S S T e x t S t y l e s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   s r c = " m x . s t y l e s . C S S S t y l e D e c l a r a t i o n . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   s r c = " m x . s t y l e s . S t y l e M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   s r c = " m x . c o r e . U I C o m p o n e n t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n "   s r c = " m x . c o n t r o l s . S i m p l e B u t t o n . a s i "   m o d i f i e d = " 1 0 6 1 5 0 3 6 9 1 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n "   s r c = " m x . c o n t r o l s . B u t t o n . a s i "   m o d i f i e d = " 1 0 6 1 5 0 3 6 9 0 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r "   s r c = " m x . e v e n t s . E v e n t D i s p a t c h e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r "   s r c = " m x . e v e n t s . U I E v e n t D i s p a t c h e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   s r c = " m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s "   s r c = " m x . s k i n s . h a l o . D e f a u l t s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t "   s r c = " m x . s k i n s . h a l o . F o c u s R e c t . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r "   s r c = " m x . m a n a g e r s . D e p t h M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r "   s r c = " m x . m a n a g e r s . F o c u s M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 7 2 6 4 0 9 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r "   s r c = " m x . m a n a g e r s . S y s t e m M a n a g e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s "   s r c = " m x . m a n a g e r s . O v e r l a p p e d W i n d o w s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s "   s r c = " m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e "   s r c = " m x . s t y l e s . C S S S e t S t y l e . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . B o r d e r "   s r c = " m x . s k i n s . B o r d e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . U I O b j e c t "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r "   s r c = " m x . s k i n s . R e c t B o r d e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . B o r d e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n "   s r c = " m x . s k i n s . h a l o . B u t t o n S k i n . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 3 " >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r "   / >  
 < / a s s e t >  
 < a s s e t   i d = " _ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r "   s r c = " m x . s k i n s . h a l o . R e c t B o r d e r . a s i "   m o d i f i e d = " 1 0 6 2 5 8 2 5 6 4 " >  
         < i n c l u d e   i d = " _ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s "   / >  
         < e x p o r t A f t e r   i d = " _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r "   / >  
 < / a s s e t >  
 < / c o m p o n e n t >  
 < / c o m p o n e n t P a c k a g e >  
        M e d i a   1 B i t m a p   1  
B u t t o n . p n g C                 C                                       2    H                xi 	@!ENw'w* Qa}$K=EFsW<_,)CQj>QYZquDSyK0z_Y?A7Is Q$  B u t t o n             B u t t o n 
B u t t o n . s w f 	W?   +   B o r d e r B o r d e r 
B u t t o n . s w f CP?          U I O b j e c t 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . s k i n s . B o r d e r 
B u t t o n . s w f                         B o u n d i n g B o x B o u n d i n g B o x 
B u t t o n . s w f w>                 B r d r B l k B r d r B l k 
B u t t o n . s w f a>                 B r d r F a c e B r d r F a c e 
B u t t o n . s w f >                 
B r d r H i l g h t 
B r d r H i l g h t 
B u t t o n . s w f \>                 B r d r S h d w B r d r S h d w 
B u t t o n . s w f A?                 
B u t t o n S k i n 
B u t t o n S k i n 
B u t t o n . s w f CP?              #_ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n 
B u t t o n . s w f                         D e f a u l t s D e f a u l t s 
B u t t o n . s w f E>              !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s 
B u t t o n . s w f                         F o c u s M a n a g e r F o c u s M a n a g e r 
B u t t o n . s w f c>          	F o c u s R e c t 
B u t t o n . s w f                       U I O b j e c t 
B u t t o n . s w f                          #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r 
B u t t o n . s w f                         	F o c u s R e c t 	F o c u s R e c t 
B u t t o n . s w f 3c>          B o u n d i n g B o x 
B u t t o n . s w f                          "_ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t 
B u t t o n . s w f                         
R e c t B o r d e r 
R e c t B o r d e r 
B u t t o n . s w f CP?          B o r d e r 
B u t t o n . s w f                          #_ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r 
B u t t o n . s w f                         S i m p l e B u t t o n S i m p l e B u t t o n 
B u t t o n . s w f c>          B o u n d i n g B o x 
B u t t o n . s w f                       S i m p l e B u t t o n D o w n 
B u t t o n . s w f                       S i m p l e B u t t o n I n 
B u t t o n . s w f                       S i m p l e B u t t o n U p 
B u t t o n . s w f                       U I C o m p o n e n t 
B u t t o n . s w f                          #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f                         S i m p l e B u t t o n D o w n S i m p l e B u t t o n D o w n 
B u t t o n . s w f {DP?          B r d r S h d w 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                             S i m p l e B u t t o n I n S i m p l e B u t t o n I n 
B u t t o n . s w f |DP?          B r d r B l k 
B u t t o n . s w f                       
B r d r H i l g h t 
B u t t o n . s w f                       B r d r S h d w 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                             S i m p l e B u t t o n U p S i m p l e B u t t o n U p 
B u t t o n . s w f DP?          B r d r B l k 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                       B r d r S h d w 
B u t t o n . s w f                       
B r d r H i l g h t 
B u t t o n . s w f                       B r d r F a c e 
B u t t o n . s w f                             U I C o m p o n e n t U I C o m p o n e n t 
B u t t o n . s w f :?          U I O b j e c t 
B u t t o n . s w f                       F o c u s M a n a g e r 
B u t t o n . s w f                       U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                         U I C o m p o n e n t E x t e n s i o n s U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f :?              ,_ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f                         U I O b j e c t U I O b j e c t 
B u t t o n . s w f ;?          D e f a u l t s 
B u t t o n . s w f                       U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                         U I O b j e c t E x t e n s i o n s U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f :?              )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                         _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n 
B u t t o n . s w f BE?              #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       m x . c o n t r o l s . B u t t o n qi m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . c o n t r o l s . S i m p l e B u t t o n ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " c l i c k " ) ]    
 [ T a g N a m e ( " B u t t o n " ) ]    
 [ I c o n F i l e ( " B u t t o n . p n g " ) ]    
 i n t r i n s i c   c l a s s   m x . c o n t r o l s . B u t t o n   e x t e n d s   m x . c o n t r o l s . S i m p l e B u t t o n  
 {  
       p u b l i c   f u n c t i o n   B u t t o n ( ) ;  
       p u b l i c   v a r   _ _ g e t _ _ i c o n : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l P l a c e m e n t : F u n c t i o n ;  
       p u b l i c   v a r   _ _ l a b e l : S t r i n g ;  
       p u b l i c   v a r   _ _ l a b e l P l a c e m e n t : S t r i n g ;  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   _ g e t I c o n ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   _ i c o n L i n k a g e N a m e : S t r i n g ;  
       [ B i n d a b l e ]   [ C h a n g e E v e n t ( " c l i c k " ) ]   p u b l i c   v a r   _ i n h e r i t e d _ s e l e c t e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   _ s e t I c o n ( l i n k a g e ) : V o i d ;  
       p u b l i c   v a r   b o r d e r W : N u m b e r ;  
       p u b l i c   v a r   b t n O f f s e t : N u m b e r ;  
       p u b l i c   f u n c t i o n   c a l c S i z e ( t a g : N u m b e r ,   r e f : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   c e n t e r C o n t e n t : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w ( ) ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t B t n O f f s e t ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t L a b e l ( V o i d ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t L a b e l P l a c e m e n t ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   h i t A r e a _ m c : M o v i e C l i p ;  
       f u n c t i o n   g e t   i c o n ( ) : S t r i n g ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " " ) ]   f u n c t i o n   s e t   i c o n ( l i n k a g e ) ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t I c o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( c : S t r i n g ) : V o i d ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " B u t t o n " ) ]   f u n c t i o n   s e t   l a b e l ( l b l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l ( ) : S t r i n g ;  
       p u b l i c   v a r   l a b e l P a t h : O b j e c t ;  
       [ I n s p e c t a b l e ( e n u m e r a t i o n = " l e f t , r i g h t , t o p , b o t t o m " d e f a u l t V a l u e = " r i g h t " ) ]   f u n c t i o n   s e t   l a b e l P l a c e m e n t ( v a l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l P l a c e m e n t ( ) : S t r i n g ;  
       s t a t i c   v a r   m e r g e d C l i p P a r a m e t e r s : B o o l e a n ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( e n a b l e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t H i t A r e a ( w : N u m b e r ,   h : N u m b e r ) ;  
       p u b l i c   f u n c t i o n   s e t L a b e l ( l a b e l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t L a b e l P l a c e m e n t ( v a l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   s e t V i e w ( o f f s e t : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n : S t r i n g ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   v i e w S k i n ( v a r N a m e : S t r i n g ) : V o i d ;  
 } ;  
 #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f BE?              _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       m x . c o n t r o l s . S i m p l e B u t t o n i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " c l i c k " ) ]    
 [ T a g N a m e ( " S i m p l e B u t t o n " ) ]    
 i n t r i n s i c   c l a s s   m x . c o n t r o l s . S i m p l e B u t t o n   e x t e n d s   m x . c o r e . U I C o m p o n e n t  
 {  
       p u b l i c   f u n c t i o n   S i m p l e B u t t o n ( ) ;  
       p u b l i c   v a r   _ _ e m p h a s i z e d : B o o l e a n ;  
       p u b l i c   v a r   _ _ e m p h a t i c : B o o l e a n ;  
       p u b l i c   v a r   _ _ e m p h a t i c S t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   _ _ g e t _ _ e m p h a s i z e d : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ s e l e c t e d : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ t o g g l e : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ v a l u e : F u n c t i o n ;  
       p u b l i c   v a r   _ _ s t a t e : B o o l e a n ;  
       p u b l i c   v a r   _ _ t o g g l e : B o o l e a n ;  
       p u b l i c   v a r   a u t o R e p e a t : B o o l e a n ;  
       p u b l i c   v a r   b o u n d i n g B o x _ m c : M o v i e C l i p ;  
       p u b l i c   v a r   b t n O f f s e t : N u m b e r ;  
       p u b l i c   v a r   b u t t o n D o w n H a n d l e r : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c a l c S i z e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e I c o n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ) : V o i d ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i c k H a n d l e r : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d e t a i l : N u m b e r ;  
       p u b l i c   v a r   d f i ;  
       p u b l i c   v a r   d f s ;  
       p u b l i c   v a r   d i s a b l e d I c o n : O b j e c t ;  
       p u b l i c   v a r   d i s a b l e d S k i n : O b j e c t ;  
       p u b l i c   v a r   d o w n I c o n : O b j e c t ;  
       p u b l i c   v a r   d o w n S k i n : O b j e c t ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d t i ;  
       p u b l i c   v a r   d t s ;  
       f u n c t i o n   g e t   e m p h a s i z e d ( ) : B o o l e a n ;  
       f u n c t i o n   s e t   e m p h a s i z e d ( v a l : B o o l e a n ) ;  
       s t a t i c   v a r   e m p h a s i z e d S t y l e D e c l a r a t i o n ;  
       s t a t i c   v a r   f a l s e D i s a b l e d : N u m b e r ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   f a l s e D o w n : N u m b e r ;  
       p u b l i c   v a r   f a l s e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   f a l s e O v e r : N u m b e r ;  
       p u b l i c   v a r   f a l s e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   f a l s e U p : N u m b e r ;  
       p u b l i c   v a r   f a l s e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   f d i ;  
       p u b l i c   v a r   f d s ;  
       p u b l i c   v a r   f r i ;  
       p u b l i c   v a r   f r s ;  
       p u b l i c   v a r   f u i ;  
       p u b l i c   v a r   f u s ;  
       p u b l i c   f u n c t i o n   g e t L a b e l ( V o i d ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t S e l e c t e d ( ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   g e t S t a t e ( V o i d ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   g e t T o g g l e ( V o i d ) : B o o l e a n ;  
       p u b l i c   v a r   i c o n N a m e : O b j e c t ;  
       p u b l i c   v a r   i d N a m e s ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t i a l i z i n g : B o o l e a n ;  
       p u b l i c   v a r   i n t e r v a l ;  
       p u b l i c   f u n c t i o n   k e y D o w n ( e : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   k e y U p ( e : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   l i n k L e n g t h : N u m b e r ;  
       p u b l i c   f u n c t i o n   o n D r a g O u t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n D r a g O v e r ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n K i l l F o c u s ( n e w F o c u s : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n P r e s s ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n P r e s s D e l a y ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n P r e s s R e p e a t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e O u t s i d e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R o l l O u t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n R o l l O v e r ( V o i d ) : V o i d ;  
       p u b l i c   v a r   p h a s e : S t r i n g ;  
       p u b l i c   v a r   p r e s e t : B o o l e a n ;  
       p u b l i c   v a r   r e f N a m e s ;  
       p u b l i c   f u n c t i o n   r e f r e s h ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e m o v e I c o n s ( ) ;  
       p u b l i c   v a r   r o l l o v e r I c o n : O b j e c t ;  
       p u b l i c   v a r   r o l l o v e r S k i n : O b j e c t ;  
       f u n c t i o n   s e t   s e l e c t e d ( v a l : B o o l e a n ) ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = f a l s e ) ]   f u n c t i o n   g e t   s e l e c t e d ( ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( v a l : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t I c o n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   s e t L a b e l ( v a l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S e l e c t e d ( v a l : B o o l e a n ) ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   s e t S t a t e ( s t a t e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S t a t e V a r ( s t a t e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t T o g g l e ( v a l : B o o l e a n ) ;  
       p u b l i c   f u n c t i o n   s e t V i e w ( o f f s e t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s h o w E m p h a s i z e d ( e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s k i n N a m e : O b j e c t ;  
       p u b l i c   v a r   s t a t e N a m e s ;  
       p u b l i c   v a r   s t y l e 3 d I n s e t : N u m b e r ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a g M a p ;  
       p u b l i c   v a r   t d i ;  
       p u b l i c   v a r   t d s ;  
       f u n c t i o n   s e t   t o g g l e ( v a l : B o o l e a n ) ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = f a l s e ) ]   f u n c t i o n   g e t   t o g g l e ( ) : B o o l e a n ;  
       p u b l i c   v a r   t r i ;  
       p u b l i c   v a r   t r s ;  
       s t a t i c   v a r   t r u e D i s a b l e d : N u m b e r ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   t r u e D o w n : N u m b e r ;  
       p u b l i c   v a r   t r u e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   t r u e O v e r : N u m b e r ;  
       p u b l i c   v a r   t r u e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n E m p h a s i z e d : S t r i n g ;  
       s t a t i c   v a r   t r u e U p : N u m b e r ;  
       p u b l i c   v a r   t r u e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p I c o n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n E m p h a s i z e d : S t r i n g ;  
       p u b l i c   v a r   t u i ;  
       p u b l i c   v a r   t u s ;  
       p u b l i c   v a r   u p I c o n : O b j e c t ;  
       p u b l i c   v a r   u p S k i n : O b j e c t ;  
       f u n c t i o n   s e t   v a l u e ( v a l : B o o l e a n ) ;  
       f u n c t i o n   g e t   v a l u e ( ) : B o o l e a n ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   v i e w I c o n ( v a r N a m e : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   v i e w S k i n ( v a r N a m e : S t r i n g ,   i n i t O b j : O b j e c t ) : V o i d ;  
 } ;  
 _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f #U?              _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       m x . c o r e . U I C o m p o n e n t i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
  
 [ E v e n t ( " f o c u s I n " ) ]    
 [ E v e n t ( " f o c u s O u t " ) ]    
 [ E v e n t ( " k e y D o w n " ) ]    
 [ E v e n t ( " k e y U p " ) ]    
 i n t r i n s i c   c l a s s   m x . c o r e . U I C o m p o n e n t   e x t e n d s   m x . c o r e . U I O b j e c t  
 {  
       p u b l i c   f u n c t i o n   U I C o m p o n e n t ( ) ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   f u n c t i o n   d i s p a t c h V a l u e C h a n g e d E v e n t ( v a l u e ) : V o i d ;  
       p u b l i c   v a r   d r a w F o c u s : F u n c t i o n ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = t r u e ,   v e r b o s e = 1 ,   c a t e g o r y = " O t h e r " ) ]   p u b l i c   v a r   e n a b l e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   e n a b l e d C h a n g e d ( i d : S t r i n g ,   o l d V a l u e : B o o l e a n ,   n e w V a l u e : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   f u n c t i o n   f i n d F o c u s F r o m O b j e c t ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   f i n d F o c u s I n C h i l d r e n ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   v a r   f o c u s E n a b l e d : B o o l e a n ;  
       p u b l i c   v a r   f o c u s M a n a g e r : M o v i e C l i p ;  
       p u b l i c   v a r   f o c u s T e x t F i e l d : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s ( ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s M a n a g e r ( ) : O b j e c t ;  
       p u b l i c   v a r   g r o u p N a m e : S t r i n g ;  
       f u n c t i o n   g e t   h e i g h t ( ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   i n i t ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   i s P a r e n t ( o : O b j e c t ) : B o o l e a n ;  
       s t a t i c   v a r   k S t r e t c h : N u m b e r ;  
       s t a t i c   v a r   m e r g e d C l i p P a r a m e t e r s : B o o l e a n ;  
       p u b l i c   f u n c t i o n   o n K i l l F o c u s ( n e w F o c u s : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n S e t F o c u s ( o l d F o c u s : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   o r i g B o r d e r S t y l e s : O b j e c t ;  
       p u b l i c   v a r   o r i g B o r d e r V a l u e s : O b j e c t ;  
       p u b l i c   v a r   p o p U p : B o o l e a n ;  
       p u b l i c   f u n c t i o n   p r e s s F o c u s ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e l e a s e F o c u s ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( e n a b l e d : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t F o c u s ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t V i s i b l e ( x : B o o l e a n ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a b E n a b l e d : B o o l e a n ;  
       p u b l i c   v a r   t a b I n d e x : N u m b e r ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       f u n c t i o n   g e t   w i d t h ( ) : N u m b e r ;  
 } ;  
 _ _ P a c k a g e s . m x . c o r e . U I O b j e c t _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                       !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f                           m x . c o r e . U I O b j e c t i m p o r t   m x . s t y l e s . S t y l e M a n a g e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
  
 [ E v e n t ( " r e s i z e " ) ]    
 [ E v e n t ( " m o v e " ) ]    
 [ E v e n t ( " d r a w " ) ]    
 [ E v e n t ( " l o a d " ) ]    
 [ E v e n t ( " u n l o a d " ) ]    
 i n t r i n s i c   c l a s s   m x . c o r e . U I O b j e c t   e x t e n d s   M o v i e C l i p  
 {  
       p u b l i c   f u n c t i o n   U I O b j e c t ( ) ;  
       p u b l i c   f u n c t i o n   _ _ g e t T e x t F o r m a t ( t f : T e x t F o r m a t ,   b A l l : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   v a r   _ _ g e t _ _ m i n H e i g h t : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ m i n W i d t h : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ s c a l e X : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ s c a l e Y : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ v i s i b l e : F u n c t i o n ;  
       p u b l i c   v a r   _ _ h e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ _ o n U n l o a d : F u n c t i o n ;  
       p u b l i c   v a r   _ _ w i d t h : N u m b e r ;  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   _ c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   _ e n d I n i t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   _ g e t T e x t F o r m a t ( V o i d ) : T e x t F o r m a t ;  
       p r i v a t e   v a r   _ i d : S t r i n g ;  
       p r i v a t e   v a r   _ m a x H e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ m a x W i d t h : N u m b e r ;  
       p r i v a t e   v a r   _ m i n H e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ m i n W i d t h : N u m b e r ;  
       p r i v a t e   v a r   _ p r e f e r r e d H e i g h t : N u m b e r ;  
       p r i v a t e   v a r   _ p r e f e r r e d W i d t h : N u m b e r ;  
       p r i v a t e   v a r   _ t f : T e x t F o r m a t ;  
       p u b l i c   v a r   _ t o p m o s t : B o o l e a n ;  
       p u b l i c   v a r   a d d E v e n t L i s t e n e r : F u n c t i o n ;  
       f u n c t i o n   g e t   b o t t o m ( ) : N u m b e r ;  
       p u b l i c   v a r   b u i l d D e p t h T a b l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c a n c e l A l l D o L a t e r s ( V o i d ) : V o i d ;  
       p u b l i c   v a r   c h a n g e C o l o r S t y l e I n C h i l d r e n : F u n c t i o n ;  
       p u b l i c   v a r   c h a n g e T e x t S t y l e I n C h i l d r e n : F u n c t i o n ;  
       p u b l i c   v a r   c h i l d r e n C r e a t e d : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   v a r   c o l o r : N u m b e r ;  
       p u b l i c   f u n c t i o n   c o n s t r u c t O b j e c t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   c r e a t e A c c e s s i b i l i t y I m p l e m e n t a t i o n : F u n c t i o n ;  
       p u b l i c   v a r   c r e a t e C h i l d A t D e p t h : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   v a r   c r e a t e C l a s s C h i l d A t D e p t h : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e C l a s s O b j e c t ( c l a s s N a m e : F u n c t i o n ,   i d : S t r i n g ,   d e p t h : N u m b e r ,   i n i t o b j : O b j e c t ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   f u n c t i o n   c r e a t e E m p t y O b j e c t ( i d : S t r i n g ,   d e p t h : N u m b e r ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   v a r   c r e a t e E v e n t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   c r e a t e L a b e l ( n a m e : S t r i n g ,   d e p t h : N u m b e r ,   t e x t ) : T e x t F i e l d ;  
       p u b l i c   f u n c t i o n   c r e a t e O b j e c t ( l i n k a g e N a m e : S t r i n g ,   i d : S t r i n g ,   d e p t h : N u m b e r ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   c r e a t e S k i n ( t a g : N u m b e r ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   f u n c t i o n   d e s t r o y O b j e c t ( i d : S t r i n g ) : V o i d ;  
       p u b l i c   v a r   d i s p a t c h E v e n t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   d o L a t e r ( o b j : O b j e c t ,   f n : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   d o L a t e r D i s p a t c h e r ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w R e c t ( x 1 : N u m b e r ,   y 1 : N u m b e r ,   x 2 : N u m b e r ,   y 2 : N u m b e r ) : V o i d ;  
       p u b l i c   v a r   e m b e d F o n t s : B o o l e a n ;  
       p u b l i c   v a r   f i n d N e x t A v a i l a b l e D e p t h : F u n c t i o n ;  
       p u b l i c   v a r   f o n t F a m i l y : S t r i n g ;  
       p u b l i c   v a r   f o n t S i z e : N u m b e r ;  
       p u b l i c   v a r   f o n t S t y l e : S t r i n g ;  
       p u b l i c   v a r   f o n t W e i g h t : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t C l a s s S t y l e D e c l a r a t i o n ( V o i d ) : m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
       p u b l i c   f u n c t i o n   g e t M i n H e i g h t ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t M i n W i d t h ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t S k i n I D N a m e ( t a g : N u m b e r ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t S t y l e ( s t y l e P r o p : S t r i n g ) ;  
       p u b l i c   f u n c t i o n   g e t S t y l e N a m e ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   h a n d l e E v e n t : F u n c t i o n ;  
       f u n c t i o n   g e t   h e i g h t ( ) : N u m b e r ;  
       p u b l i c   v a r   i d N a m e s : A r r a y ;  
       p u b l i c   v a r   i g n o r e C l a s s S t y l e D e c l a r a t i o n : O b j e c t ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   i n i t F r o m C l i p P a r a m e t e r s ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t P r o p e r t i e s : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   i n v a l i d a t e F l a g : B o o l e a n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( V o i d ) : V o i d ;  
       f u n c t i o n   g e t   l e f t ( ) : N u m b e r ;  
       p r i v a t e   v a r   l i n e C o l o r : N u m b e r ;  
       p r i v a t e   v a r   l i n e W i d t h : N u m b e r ;  
       p u b l i c   v a r   m a r g i n L e f t : N u m b e r ;  
       p u b l i c   v a r   m a r g i n R i g h t : N u m b e r ;  
       s t a t i c   f u n c t i o n   m e r g e C l i p P a r a m e t e r s ( o ,   p ) : B o o l e a n ;  
       p u b l i c   v a r   m e t h o d T a b l e : A r r a y ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = 0 ,   v e r b o s e = 1 ,   c a t e g o r y = " S i z e " ) ]   f u n c t i o n   g e t   m i n H e i g h t ( ) : N u m b e r ;  
       f u n c t i o n   s e t   m i n H e i g h t ( h : N u m b e r ) : V o i d ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = 0 ,   v e r b o s e = 1 ,   c a t e g o r y = " S i z e " ) ]   f u n c t i o n   g e t   m i n W i d t h ( ) : N u m b e r ;  
       f u n c t i o n   s e t   m i n W i d t h ( w : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   m o v e ( x : N u m b e r ,   y : N u m b e r ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   v a r   n o t i f y S t y l e C h a n g e I n C h i l d r e n : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   r e d r a w ( b A l w a y s : B o o l e a n ) : V o i d ;  
       p u b l i c   v a r   r e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       f u n c t i o n   g e t   r i g h t ( ) : N u m b e r ;  
       f u n c t i o n   g e t   s c a l e X ( ) : N u m b e r ;  
       f u n c t i o n   s e t   s c a l e X ( x : N u m b e r ) : V o i d ;  
       f u n c t i o n   g e t   s c a l e Y ( ) : N u m b e r ;  
       f u n c t i o n   s e t   s c a l e Y ( y : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c o l o r : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t M i n H e i g h t ( h : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t M i n W i d t h ( w : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S i z e ( w : N u m b e r ,   h : N u m b e r ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t O b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   v a r   s e t S t y l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   s e t V i s i b l e ( x : B o o l e a n ,   n o E v e n t : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   s t y l e c a c h e : O b j e c t ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a b E n a b l e d : B o o l e a n ;  
       p u b l i c   v a r   t e x t A l i g n : S t r i n g ;  
       s t a t i c   v a r   t e x t C o l o r L i s t ;  
       p u b l i c   v a r   t e x t D e c o r a t i o n : S t r i n g ;  
       p u b l i c   v a r   t e x t I n d e n t : N u m b e r ;  
       p r i v a t e   v a r   t f L i s t : O b j e c t ;  
       f u n c t i o n   g e t   t o p ( ) : N u m b e r ;  
       p u b l i c   v a r   v a l i d a t e N o w : B o o l e a n ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = t r u e ,   v e r b o s e = 1 ,   c a t e g o r y = " O t h e r " ) ]   f u n c t i o n   g e t   v i s i b l e ( ) : B o o l e a n ;  
       f u n c t i o n   s e t   v i s i b l e ( x : B o o l e a n ) : V o i d ;  
       f u n c t i o n   g e t   w i d t h ( ) : N u m b e r ;  
       f u n c t i o n   g e t   x ( ) : N u m b e r ;  
       f u n c t i o n   g e t   y ( ) : N u m b e r ;  
 } ;  
 ,_ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s ,_ _ P a c k a g e s . m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s 
B u t t o n . s w f #U?           _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s 
B u t t o n . s w f                       !m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s :i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . c o r e . e x t . U I C o m p o n e n t E x t e n s i o n s  
 {  
       s t a t i c   f u n c t i o n   E x t e n s i o n s ( ) : B o o l e a n ;  
       s t a t i c   v a r   F o c u s M a n a g e r D e p e n d e n c y ;  
       s t a t i c   v a r   O v e r l a p p e d W i n d o w s D e p e n d e n c y ;  
       s t a t i c   v a r   U I C o m p o n e n t D e p e n d e n c y ;  
       s t a t i c   v a r   U I C o m p o n e n t E x t e n d e d ;  
       s t a t i c   v a r   b E x t e n d e d ;  
 } ;  
 )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f #U?          &_ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f                       "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s 
B u t t o n . s w f                       &_ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r 
B u t t o n . s w f                       m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
 i m p o r t   m x . e v e n t s . U I E v e n t D i s p a t c h e r ;  
  
 i n t r i n s i c   c l a s s   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s  
 {  
       s t a t i c   v a r   C S S T e x t S t y l e s D e p e n d e n c y ;  
       s t a t i c   f u n c t i o n   E x t e n s i o n s ( ) : B o o l e a n ;  
       s t a t i c   v a r   S k i n E l e m e n t D e p e n d e n c y ;  
       s t a t i c   v a r   U I E v e n t D i s p a t c h e r D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t E x t e n d e d ;  
       s t a t i c   f u n c t i o n   a d d G e o m e t r y ( t f : O b j e c t ,   u i : O b j e c t ) : V o i d ;  
       s t a t i c   v a r   b E x t e n d e d ;  
 } ;  
 $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r 
B u t t o n . s w f #U?               m x . e v e n t s . E v e n t D i s p a t c h e r  
 i n t r i n s i c   c l a s s   m x . e v e n t s . E v e n t D i s p a t c h e r  
 {  
       s t a t i c   v a r   _ f E v e n t D i s p a t c h e r : m x . e v e n t s . E v e n t D i s p a t c h e r ;  
       s t a t i c   f u n c t i o n   _ r e m o v e E v e n t L i s t e n e r ( q u e u e : O b j e c t ,   e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   a d d E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   d i s p a t c h E v e n t ( e v e n t O b j : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   d i s p a t c h Q u e u e ( q u e u e O b j : O b j e c t ,   e v e n t O b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   i n i t i a l i z e ( o b j e c t : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e m o v e E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
 } ;  
 &_ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r &_ _ P a c k a g e s . m x . e v e n t s . U I E v e n t D i s p a t c h e r 
B u t t o n . s w f #U?              $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r 
B u t t o n . s w f                       m x . e v e n t s . U I E v e n t D i s p a t c h e r i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . e v e n t s . E v e n t D i s p a t c h e r ;  
  
 i n t r i n s i c   c l a s s   m x . e v e n t s . U I E v e n t D i s p a t c h e r   e x t e n d s   m x . e v e n t s . E v e n t D i s p a t c h e r  
 {  
       p u b l i c   f u n c t i o n   _ _ a d d E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       p u b l i c   v a r   _ _ o r i g A d d E v e n t L i s t e n e r : F u n c t i o n ;  
       p u b l i c   v a r   _ _ s e n t L o a d E v e n t ;  
       s t a t i c   v a r   _ f E v e n t D i s p a t c h e r : m x . e v e n t s . U I E v e n t D i s p a t c h e r ;  
       s t a t i c   f u n c t i o n   a d d K e y E v e n t s ( o b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   a d d L o a d E v e n t s ( o b j : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   d i s p a t c h E v e n t ( e v e n t O b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   i n i t i a l i z e ( o b j : O b j e c t ) : V o i d ;  
       s t a t i c   v a r   k e y E v e n t s : O b j e c t ;  
       s t a t i c   v a r   l o a d E v e n t s : O b j e c t ;  
       s t a t i c   v a r   l o w L e v e l E v e n t s : O b j e c t ;  
       p u b l i c   f u n c t i o n   o n K e y D o w n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n K e y U p ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n L o a d ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n U n l o a d ( V o i d ) : V o i d ;  
       p u b l i c   v a r   o w n e r : O b j e c t ;  
       p u b l i c   f u n c t i o n   r e m o v e E v e n t L i s t e n e r ( e v e n t : S t r i n g ,   h a n d l e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e m o v e K e y E v e n t s ( o b j : O b j e c t ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e m o v e L o a d E v e n t s ( o b j : O b j e c t ) : V o i d ;  
 } ;  
 #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                           m x . m a n a g e r s . D e p t h M a n a g e r oi m p o r t   m x . c o r e . U I O b j e c t ;  
  
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . D e p t h M a n a g e r  
 {  
       p u b l i c   f u n c t i o n   D e p t h M a n a g e r ( ) ;  
       s t a t i c   v a r   _ _ d e p t h M a n a g e r : m x . m a n a g e r s . D e p t h M a n a g e r ;  
       p u b l i c   v a r   _ c h i l d C o u n t e r : N u m b e r ;  
       p u b l i c   v a r   _ p a r e n t : M o v i e C l i p ;  
       p u b l i c   v a r   _ t o p m o s t : B o o l e a n ;  
       p u b l i c   f u n c t i o n   b u i l d D e p t h T a b l e ( V o i d ) : A r r a y ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d A t D e p t h ( l i n k a g e N a m e : S t r i n g ,   d e p t h F l a g : N u m b e r ,   i n i t O b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   c r e a t e C l a s s C h i l d A t D e p t h ( c l a s s N a m e : F u n c t i o n ,   d e p t h F l a g : N u m b e r ,   i n i t O b j : O b j e c t ) : m x .               	  
                                               !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  c o r e . U I O b j e c t ;  
       p u b l i c   v a r   c r e a t e C l a s s O b j e c t : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   c r e a t e C l a s s O b j e c t A t D e p t h ( c l a s s N a m e : O b j e c t ,   d e p t h S p a c e : N u m b e r ,   i n i t O b j : O b j e c t ) : m x . c o r e . U I O b j e c t ;  
       p u b l i c   v a r   c r e a t e O b j e c t : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   c r e a t e O b j e c t A t D e p t h ( l i n k a g e N a m e : S t r i n g ,   d e p t h S p a c e : N u m b e r ,   i n i t O b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   f i n d N e x t A v a i l a b l e D e p t h ( t a r g e t D e p t h : N u m b e r ,   d e p t h T a b l e : A r r a y ,   d i r e c t i o n : S t r i n g ) : N u m b e r ;  
       p u b l i c   v a r   g e t D e p t h : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   g e t D e p t h B y F l a g ( d e p t h F l a g : N u m b e r ,   d e p t h T a b l e : A r r a y ) : N u m b e r ;  
       s t a t i c   v a r   h i g h e s t D e p t h : N u m b e r ;  
       s t a t i c   p r i v a t e   v a r   h o l d e r : M o v i e C l i p ;  
       s t a t i c   v a r   k B o t t o m : N u m b e r ;  
       s t a t i c   v a r   k C u r s o r : N u m b e r ;  
       s t a t i c   v a r   k N o t o p m o s t : N u m b e r ;  
       s t a t i c   v a r   k T o o l t i p : N u m b e r ;  
       s t a t i c   v a r   k T o p : N u m b e r ;  
       s t a t i c   v a r   k T o p m o s t : N u m b e r ;  
       s t a t i c   v a r   l o w e s t D e p t h : N u m b e r ;  
       s t a t i c   v a r   n u m b e r O f A u t h o r t i m e L a y e r s : N u m b e r ;  
       s t a t i c   v a r   r e s e r v e d D e p t h : N u m b e r ;  
       p u b l i c   f u n c t i o n   s e t D e p t h A b o v e ( t a r g e t I n s t a n c e : M o v i e C l i p ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t D e p t h B e l o w ( t a r g e t I n s t a n c e : M o v i e C l i p ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t D e p t h T o ( d e p t h F l a g : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s h u f f l e D e p t h s ( s u b j e c t : M o v i e C l i p ,   t a r g e t D e p t h : N u m b e r ,   d e p t h T a b l e : A r r a y ,   d i r e c t i o n : S t r i n g ) : V o i d ;  
       s t a t i c   f u n c t i o n   s o r t F u n c t i o n ( a : M o v i e C l i p ,   b : M o v i e C l i p ) : N u m b e r ;  
       p u b l i c   v a r   s w a p D e p t h s : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   t e s t ( d e p t h : N u m b e r ) : B o o l e a n ;  
 } ;  
 #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r #_ _ P a c k a g e s . m x . m a n a g e r s . F o c u s M a n a g e r 
B u t t o n . s w f 	W?          #_ _ P a c k a g e s . m x . c o n t r o l s . S i m p l e B u t t o n 
B u t t o n . s w f                       #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r 
B u t t o n . s w f                       $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       m x . m a n a g e r s . F o c u s M a n a g e r i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . m a n a g e r s . S y s t e m M a n a g e r ;  
 i m p o r t   m x . c o n t r o l s . S i m p l e B u t t o n ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . F o c u s M a n a g e r   e x t e n d s   m x . c o r e . U I C o m p o n e n t  
 {  
       p u b l i c   f u n c t i o n   F o c u s M a n a g e r ( ) ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   _ _ d e f a u l t P u s h B u t t o n : m x . c o n t r o l s . S i m p l e B u t t o n ;  
       p u b l i c   v a r   _ _ g e t _ _ d e f a u l t P u s h B u t t o n : F u n c t i o n ;  
       p r i v a t e   v a r   _ f i r s t N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ f i r s t O b j : O b j e c t ;  
       p r i v a t e   v a r   _ f o u n d L i s t : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t O b j : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t T a r g e t : O b j e c t ;  
       p r i v a t e   v a r   _ l a s t x : O b j e c t ;  
       p r i v a t e   v a r   _ n e e d P r e v : B o o l e a n ;  
       p r i v a t e   v a r   _ n e x t I s N e x t : B o o l e a n ;  
       p r i v a t e   v a r   _ n e x t N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ n e x t O b j : O b j e c t ;  
       p u b l i c   f u n c t i o n   _ o n M o u s e D o w n ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   _ p r e v N o d e : O b j e c t ;  
       p r i v a t e   v a r   _ p r e v O b j : O b j e c t ;  
       p r i v a t e   v a r   _ s e a r c h K e y : N u m b e r ;  
       p u b l i c   f u n c t i o n   a c t i v a t e ( V o i d ) : V o i d ;  
       p r i v a t e   v a r   a c t i v a t e d : B o o l e a n ;  
       p u b l i c   v a r   b D r a w F o c u s : B o o l e a n ;  
       p u b l i c   v a r   b N e e d F o c u s : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   d e a c t i v a t e ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d e f P u s h B u t t o n : m x . c o n t r o l s . S i m p l e B u t t o n ;  
       f u n c t i o n   g e t   d e f a u l t P u s h B u t t o n ( ) : m x . c o n t r o l s . S i m p l e B u t t o n ;  
       f u n c t i o n   s e t   d e f a u l t P u s h B u t t o n ( x : m x . c o n t r o l s . S i m p l e B u t t o n ) ;  
       p u b l i c   v a r   d e f a u l t P u s h B u t t o n E n a b l e d : B o o l e a n ;  
       s t a t i c   f u n c t i o n   e n a b l e F o c u s M a n a g e m e n t ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   e n a b l e d C h a n g e d ( i d : S t r i n g ,   o l d V a l u e : B o o l e a n ,   n e w V a l u e : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   v a r   f o r m ;  
       p u b l i c   f u n c t i o n   g e t A c t u a l F o c u s ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s ( V o i d ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t F o c u s M a n a g e r F r o m O b j e c t ( o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t M a x T a b I n d e x ( o : m x . c o r e . U I C o m p o n e n t ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t M o u s e d C o m p o n e n t F r o m C h i l d r e n ( x : N u m b e r ,   y : N u m b e r ,   o : O b j e c t ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t N e x t T a b I n d e x ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t S e l e c t i o n F o c u s ( ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   g e t T a b C a n d i d a t e ( o : M o v i e C l i p ,   i n d e x : N u m b e r ,   g r o u p N a m e : S t r i n g ,   d i r : B o o l e a n ,   f i r s t C h i l d : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   g e t T a b C a n d i d a t e F r o m C h i l d r e n ( o : M o v i e C l i p ,   i n d e x : N u m b e r ,   g r o u p N a m e : S t r i n g ,   d i r : B o o l e a n ,   f i r s t C h i l d : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   h a n d l e E v e n t ( e : O b j e c t ) ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       s t a t i c   v a r   i n i t i a l i z e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   i s O u r F o c u s ( o : O b j e c t ) : B o o l e a n ;  
       p u b l i c   v a r   l a s t F o c u s : O b j e c t ;  
       p u b l i c   v a r   l a s t S e l F o c u s : O b j e c t ;  
       p u b l i c   v a r   l a s t T a b F o c u s : O b j e c t ;  
       p u b l i c   v a r   l a s t X M o u s e : N u m b e r ;  
       p u b l i c   v a r   l a s t Y M o u s e : N u m b e r ;  
       p u b l i c   f u n c t i o n   m o u s e A c t i v a t e ( V o i d ) : V o i d ;  
       f u n c t i o n   g e t   n e x t T a b I n d e x ( ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   o n K e y D o w n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n M o u s e U p ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n S e t F o c u s ( o : O b j e c t ,   n : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   o n U n l o a d ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e l o c a t e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   r e s t o r e F o c u s ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e n d D e f a u l t P u s h B u t t o n E v e n t ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t F o c u s ( o : O b j e c t ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p r i v a t e   v a r   t a b C a p t u r e : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   t a b H a n d l e r ( V o i d ) : V o i d ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   w a l k T r e e ( p : M o v i e C l i p ,   i n d e x : N u m b e r ,   g r o u p N a m e : S t r i n g ,   d i r : B o o l e a n ,   l o o k u p : B o o l e a n ,   f i r s t C h i l d : B o o l e a n ) : V o i d ;  
 } ;  
 (_ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s (_ _ P a c k a g e s . m x . m a n a g e r s . O v e r l a p p e d W i n d o w s 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                          $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r 
B u t t o n . s w f                       m x . m a n a g e r s . O v e r l a p p e d W i n d o w s (i m p o r t   m x . m a n a g e r s . S y s t e m M a n a g e r ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . O v e r l a p p e d W i n d o w s  
 {  
       s t a t i c   v a r   S y s t e m M a n a g e r D e p e n d e n c y ;  
       s t a t i c   f u n c t i o n   _ _ a d d E v e n t L i s t e n e r ( e : S t r i n g ,   o : O b j e c t ,   l : F u n c t i o n ) : V o i d ;  
       s t a t i c   f u n c t i o n   _ _ r e m o v e E v e n t L i s t e n e r ( e : S t r i n g ,   o : O b j e c t ,   l : F u n c t i o n ) : V o i d ;  
       s t a t i c   f u n c t i o n   a c t i v a t e ( f : M o v i e C l i p ) : V o i d ;  
       s t a t i c   f u n c t i o n   a d d F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
       s t a t i c   f u n c t i o n   c h e c k I d l e ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   d e a c t i v a t e ( f : M o v i e C l i p ) : V o i d ;  
       s t a t i c   f u n c t i o n   e n a b l e O v e r l a p p e d W i n d o w s ( ) : V o i d ;  
       s t a t i c   v a r   i n i t i a l i z e d : B o o l e a n ;  
       s t a t i c   f u n c t i o n   o n M o u s e D o w n ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   o n M o u s e M o v e ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   o n M o u s e U p ( V o i d ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e m o v e F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
 } ;  
 $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r $_ _ P a c k a g e s . m x . m a n a g e r s . S y s t e m M a n a g e r 
B u t t o n . s w f #U?          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       $_ _ P a c k a g e s . m x . e v e n t s . E v e n t D i s p a t c h e r 
B u t t o n . s w f                           m x . m a n a g e r s . S y s t e m M a n a g e r i m p o r t   m x . e v e n t s . E v e n t D i s p a t c h e r ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " i d l e " ) ]    
 [ E v e n t ( " r e s i z e " ) ]    
 i n t r i n s i c   c l a s s   m x . m a n a g e r s . S y s t e m M a n a g e r  
 {  
       s t a t i c   v a r   _ _ a d d E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   _ _ r e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   _ _ s c r e e n : O b j e c t ;  
       s t a t i c   p r i v a t e   v a r   _ i n i t i a l i z e d : B o o l e a n ;  
       s t a t i c   v a r   _ x A d d E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   _ x R e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   v a r   a c t i v a t e : F u n c t i o n ;  
       s t a t i c   v a r   a d d E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   a d d F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
       s t a t i c   v a r   c h e c k I d l e : F u n c t i o n ;  
       s t a t i c   v a r   d e a c t i v a t e : F u n c t i o n ;  
       s t a t i c   v a r   d i s p a t c h E v e n t : F u n c t i o n ;  
       s t a t i c   v a r   f o r m : M o v i e C l i p ;  
       s t a t i c   v a r   f o r m s : A r r a y ;  
       s t a t i c   v a r   i d l e F r a m e s : N u m b e r ;  
       s t a t i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       s t a t i c   v a r   i n t e r v a l : N u m b e r ;  
       s t a t i c   v a r   i s M o u s e D o w n ;  
       s t a t i c   f u n c t i o n   o n M o u s e D o w n ( V o i d ) : V o i d ;  
       s t a t i c   v a r   o n M o u s e M o v e : F u n c t i o n ;  
       s t a t i c   v a r   o n M o u s e U p : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   o n R e s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   r e m o v e E v e n t L i s t e n e r : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   r e m o v e F o c u s M a n a g e r ( f : m x . c o r e . U I C o m p o n e n t ) : V o i d ;  
       s t a t i c   f u n c t i o n   g e t   s c r e e n ( ) : O b j e c t ;  
 } ;  
 _ _ P a c k a g e s . m x . s k i n s . B o r d e r _ _ P a c k a g e s . m x . s k i n s . B o r d e r 
B u t t o n . s w f #U?              _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       m x . s k i n s . B o r d e r hi m p o r t   m x . c o r e . U I O b j e c t ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . B o r d e r   e x t e n d s   m x . c o r e . U I O b j e c t  
 {  
       p u b l i c   f u n c t i o n   B o r d e r ( ) ;  
       p u b l i c   v a r   b o r d e r S t y l e : S t r i n g ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   i d N a m e s : A r r a y ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       p u b l i c   v a r   t a g B o r d e r : N u m b e r ;  
 } ;  
 &_ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t &_ _ P a c k a g e s . m x . s k i n s . C o l o r e d S k i n E l e m e n t 
B u t t o n . s w f #U?               m x . s k i n s . C o l o r e d S k i n E l e m e n t  
 i n t r i n s i c   c l a s s   m x . s k i n s . C o l o r e d S k i n E l e m e n t  
 {  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   v a r   g e t S t y l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   m i x i n s : m x . s k i n s . C o l o r e d S k i n E l e m e n t ;  
       p u b l i c   v a r   o n E n t e r F r a m e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c : N u m b e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   s e t C o l o r S t y l e ( p : O b j e c t ,   c o l o r S t y l e : S t r i n g ) : V o i d ;  
 } ;  
 _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r 
B u t t o n . s w f $U?              _ _ P a c k a g e s . m x . s k i n s . B o r d e r 
B u t t o n . s w f                       m x . s k i n s . R e c t B o r d e r i m p o r t   m x . s k i n s . B o r d e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . R e c t B o r d e r   e x t e n d s   m x . s k i n s . B o r d e r  
 {  
       p u b l i c   f u n c t i o n   R e c t B o r d e r ( ) ;  
       p u b l i c   v a r   _ _ b o r d e r M e t r i c s : O b j e c t ;  
       p u b l i c   v a r   b a c k g r o u n d C o l o r N a m e : S t r i n g ;  
       p u b l i c   v a r   b o r d e r C o l o r N a m e : S t r i n g ;  
       f u n c t i o n   g e t   b o r d e r M e t r i c s ( ) : O b j e c t ;  
       p u b l i c   v a r   b o r d e r S t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   b u t t o n C o l o r N a m e : S t r i n g ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   d r a w ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w B o r d e r ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   g e t B o r d e r M e t r i c s ( V o i d ) : O b j e c t ;  
       f u n c t i o n   g e t   h e i g h t ( ) : N u m b e r ;  
       p u b l i c   v a r   h i g h l i g h t C o l o r N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   o f f s e t : N u m b e r ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s h a d o w C o l o r N a m e : S t r i n g ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       f u n c t i o n   g e t   w i d t h ( ) : N u m b e r ;  
 } ;  
 _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f $U?               m x . s k i n s . S k i n E l e m e n t  
 i n t r i n s i c   c l a s s   m x . s k i n s . S k i n E l e m e n t   e x t e n d s   M o v i e C l i p  
 {  
       p u b l i c   f u n c t i o n   _ _ s e t _ _ v i s i b l e ( v i s i b l e : B o o l e a n ) : V o i d ;  
       p u b l i c   v a r   h e i g h t : N u m b e r ;  
       p u b l i c   f u n c t i o n   m o v e ( x : N u m b e r ,   y : N u m b e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e g i s t e r E l e m e n t ( n a m e : S t r i n g ,   c l a s s N a m e : F u n c t i o n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S i z e ( w : N u m b e r ,   h : N u m b e r ) : V o i d ;  
       p u b l i c   v a r   t o p : N u m b e r ;  
       p u b l i c   v a r   v i s i b l e : B o o l e a n ;  
       p u b l i c   v a r   w i d t h : N u m b e r ;  
 } ;  
 #_ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n #_ _ P a c k a g e s . m x . s k i n s . h a l o . B u t t o n S k i n 
B u t t o n . s w f #U?              )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r 
B u t t o n . s w f                       m x . s k i n s . h a l o . B u t t o n S k i n i m p o r t   m x . s k i n s . R e c t B o r d e r ;  
 i m p o r t   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . B u t t o n S k i n   e x t e n d s   m x . s k i n s . R e c t B o r d e r  
 {  
       p u b l i c   f u n c t i o n   B u t t o n S k i n ( ) ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   b a c k g r o u n d C o l o r N a m e ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e ;  
       p u b l i c   f u n c t i o n   d r a w H a l o R e c t ( w : N u m b e r ,   h : N u m b e r ) : V o i d ;  
       p u b l i c   v a r   d r a w R o u n d R e c t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   i n i t ( ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
 } ;  
 !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s 
B u t t o n . s w f $U?          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I O b j e c t 
B u t t o n . s w f                       (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                       )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       m x . s k i n s . h a l o . D e f a u l t s i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . D e f a u l t s  
 {  
       s t a t i c   v a r   C S S S t y l e D e c l a r a t i o n D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t D e p e n d e n c y ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   b e g i n F i l l : F u n c t i o n ;  
       p u b l i c   v a r   b e g i n G r a d i e n t F i l l : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d ;  
       p u b l i c   v a r   c u r v e T o : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   d r a w R o u n d R e c t ( x ,   y ,   w ,   h ,   r ,   c ,   a l p h a ,   r o t ,   g r a d i e n t ,   r a t i o s ) ;  
       p u b l i c   v a r   e n d F i l l : F u n c t i o n ;  
       p u b l i c   v a r   l i n e T o : F u n c t i o n ;  
       p u b l i c   v a r   m o v e T o : F u n c t i o n ;  
       s t a t i c   f u n c t i o n   s e t T h e m e D e f a u l t s ( ) : V o i d ;  
 } ;  
 "_ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t "_ _ P a c k a g e s . m x . s k i n s . h a l o . F o c u s R e c t 
B u t t o n . s w f $U?          #_ _ P a c k a g e s . m x . m a n a g e r s . D e p t h M a n a g e r 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o r e . U I C o m p o n e n t 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . S k i n E l e m e n t 
B u t t o n . s w f                       !_ _ P a c k a g e s . m x . s k i n s . h a l o . D e f a u l t s 
B u t t o n . s w f                       m x . s k i n s . h a l o . F o c u s R e c t i m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . s k i n s . h a l o . D e f a u l t s ;  
 i m p o r t   m x . m a n a g e r s . D e p t h M a n a g e r ;  
 i m p o r t   m x . s k i n s . S k i n E l e m e n t ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . F o c u s R e c t   e x t e n d s   m x . s k i n s . S k i n E l e m e n t  
 {  
       s t a t i c   v a r   D e f a u l t s D e p e n d e n c y : m x . s k i n s . h a l o . D e f a u l t s ;  
       p u b l i c   f u n c t i o n   F o c u s R e c t ( ) ;  
       s t a t i c   v a r   U I C o m p o n e n t D e p e n d e n c y : m x . c o r e . U I C o m p o n e n t ;  
       p u b l i c   v a r   b o u n d i n g B o x _ m c : M o v i e C l i p ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   d r a w ( o : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   d r a w R o u n d R e c t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   h a n d l e E v e n t ( e : O b j e c t ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S i z e ( w : N u m b e r ,   h : N u m b e r ,   r ,   a : N u m b e r ,   r e c t C o l : N u m b e r ) : V o i d ;  
 } ;  
 #_ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r #_ _ P a c k a g e s . m x . s k i n s . h a l o . R e c t B o r d e r 
B u t t o n . s w f $U?          (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                          )_ _ P a c k a g e s . m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s 
B u t t o n . s w f                       _ _ P a c k a g e s . m x . s k i n s . R e c t B o r d e r 
B u t t o n . s w f                       m x . s k i n s . h a l o . R e c t B o r d e r oi m p o r t   m x . c o r e . e x t . U I O b j e c t E x t e n s i o n s ;  
 i m p o r t   m x . s k i n s . B o r d e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s k i n s . h a l o . R e c t B o r d e r   e x t e n d s   m x . s k i n s . R e c t B o r d e r  
 {  
       p u b l i c   f u n c t i o n   R e c t B o r d e r ( ) ;  
       s t a t i c   v a r   U I O b j e c t E x t e n s i o n s D e p e n d e n c y ;  
       p u b l i c   v a r   b o r d e r C a p C o l o r N a m e : S t r i n g ;  
       p r i v a t e   v a r   b o r d e r W i d t h s : O b j e c t ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p r i v a t e   v a r   c o l o r L i s t : O b j e c t ;  
       p u b l i c   f u n c t i o n   d r a w 3 d B o r d e r ( c 1 : N u m b e r ,   c 2 : N u m b e r ,   c 3 : N u m b e r ,   c 4 : N u m b e r ,   c 5 : N u m b e r ,   c 6 : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w B o r d e r ( V o i d ) : V o i d ;  
       p u b l i c   v a r   d r a w R o u n d R e c t : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   g e t B o r d e r M e t r i c s ( V o i d ) : O b j e c t ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   s h a d o w C a p C o l o r N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r : O b j e c t ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
 } ;  
  _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e  _ _ P a c k a g e s . m x . s t y l e s . C S S S e t S t y l e 
B u t t o n . s w f $U?          !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f                          (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f                       m x . s t y l e s . C S S S e t S t y l e bi m p o r t   m x . s t y l e s . S t y l e M a n a g e r ;  
 i m p o r t   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n ;  
  
 i n t r i n s i c   c l a s s   m x . s t y l e s . C S S S e t S t y l e  
 {  
       s t a t i c   v a r   C S S S t y l e D e c l a r a t i o n D e p e n d e n c y ;  
       p u b l i c   v a r   _ c o l o r : N u m b e r ;  
       p u b l i c   f u n c t i o n   _ s e t S t y l e ( s t y l e P r o p : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e C o l o r S t y l e I n C h i l d r e n ( s h e e t N a m e : S t r i n g ,   c o l o r S t y l e : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   f u n c t i o n   c h a n g e T e x t S t y l e I n C h i l d r e n ( s t y l e P r o p : S t r i n g ) : V o i d ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       s t a t i c   f u n c t i o n   e n a b l e R u n T i m e C S S ( ) : V o i d ;  
       p u b l i c   v a r   i n v a l i d a t e S t y l e : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   n o t i f y S t y l e C h a n g e I n C h i l d r e n ( s h e e t N a m e : S t r i n g ,   s t y l e P r o p : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   v a r   s e t C o l o r : F u n c t i o n ;  
       p u b l i c   f u n c t i o n   s e t S t y l e ( s t y l e P r o p : S t r i n g ,   n e w V a l u e ) : V o i d ;  
       p u b l i c   v a r   s t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   s t y l e c a c h e : O b j e c t ;  
 } ;  
 (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n (_ _ P a c k a g e s . m x . s t y l e s . C S S S t y l e D e c l a r a t i o n 
B u t t o n . s w f $U?          !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f                          "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s 
B u t t o n . s w f                       m x . s t y l e s . C S S S t y l e D e c l a r a t i o n %i m p o r t   m x . s t y l e s . S t y l e M a n a g e r ;  
 i m p o r t   m x . s t y l e s . C S S T e x t S t y l e s ;  
  
 i n t r i n s i c   c l a s s   m x . s t y l e s . C S S S t y l e D e c l a r a t i o n  
 {  
       s t a t i c   v a r   C S S T e x t S t y l e s D e p e n d e n c y ;  
       p u b l i c   f u n c t i o n   _ _ g e t T e x t F o r m a t ( t f : T e x t F o r m a t ,   b A l l : B o o l e a n ) : B o o l e a n ;  
       p u b l i c   v a r   _ t f : T e x t F o r m a t ;  
       s t a t i c   f u n c t i o n   c l a s s C o n s t r u c t ( ) : B o o l e a n ;  
       s t a t i c   v a r   c l a s s C o n s t r u c t e d : B o o l e a n ;  
       p u b l i c   v a r   c o l o r : N u m b e r ;  
       p u b l i c   v a r   e m b e d F o n t s : B o o l e a n ;  
       p u b l i c   v a r   f o n t F a m i l y : S t r i n g ;  
       p u b l i c   v a r   f o n t S i z e : N u m b e r ;  
       p u b l i c   v a r   f o n t S t y l e : S t r i n g ;  
       p u b l i c   v a r   f o n t W e i g h t : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t S t y l e ( s t y l e P r o p : S t r i n g ) ;  
       p u b l i c   v a r   m a r g i n L e f t : N u m b e r ;  
       p u b l i c   v a r   m a r g i n R i g h t : N u m b e r ;  
       p u b l i c   v a r   s t y l e N a m e : S t r i n g ;  
       p u b l i c   v a r   t e x t A l i g n : S t r i n g ;  
       p u b l i c   v a r   t e x t D e c o r a t i o n : S t r i n g ;  
       p u b l i c   v a r   t e x t I n d e n t : N u m b e r ;  
 } ;  
 "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s "_ _ P a c k a g e s . m x . s t y l e s . C S S T e x t S t y l e s 
B u t t o n . s w f $U?               m x . s t y l e s . C S S T e x t S t y l e s t 
 i n t r i n s i c   c l a s s   m x . s t y l e s . C S S T e x t S t y l e s  
 {  
       s t a t i c   f u n c t i o n   a d d T e x t S t y l e s ( o : O b j e c t ,   b C o l o r : B o o l e a n ) : V o i d ;  
 } ;  
 !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r !_ _ P a c k a g e s . m x . s t y l e s . S t y l e M a n a g e r 
B u t t o n . s w f $U?               m x . s t y l e s . S t y l e M a n a g e r  
 i n t r i n s i c   c l a s s   m x . s t y l e s . S t y l e M a n a g e r  
 {  
       s t a t i c   v a r   T e x t F o r m a t S t y l e P r o p s : O b j e c t ;  
       s t a t i c   v a r   T e x t S t y l e M a p : O b j e c t ;  
       s t a t i c   v a r   c o l o r N a m e s : O b j e c t ;  
       s t a t i c   v a r   c o l o r S t y l e s : O b j e c t ;  
       s t a t i c   f u n c t i o n   g e t C o l o r N a m e ( c o l o r N a m e : S t r i n g ) : N u m b e r ;  
       s t a t i c   v a r   i n h e r i t i n g S t y l e s : O b j e c t ;  
       s t a t i c   f u n c t i o n   i s C o l o r N a m e ( c o l o r N a m e : S t r i n g ) : B o o l e a n ;  
       s t a t i c   f u n c t i o n   i s C o l o r S t y l e ( s t y l e N a m e : S t r i n g ) : B o o l e a n ;  
       s t a t i c   f u n c t i o n   i s I n h e r i t i n g S t y l e ( s t y l e N a m e : S t r i n g ) : B o o l e a n ;  
       s t a t i c   f u n c t i o n   r e g i s t e r C o l o r N a m e ( c o l o r N a m e : S t r i n g ,   c o l o r V a l u e : N u m b e r ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e g i s t e r C o l o r S t y l e ( s t y l e N a m e : S t r i n g ) : V o i d ;  
       s t a t i c   f u n c t i o n   r e g i s t e r I n h e r i t i n g S t y l e ( s t y l e N a m e : S t r i n g ) : V o i d ;  
 } ;  
    B o u n d i n g B o x 
B u t t o n . s w f                       S i m p l e B u t t o n 
B u t t o n . s w f                       B o r d e r 
B u t t o n . s w f                       
R e c t B o r d e r 
B u t t o n . s w f                       
B u t t o n S k i n 
B u t t o n . s w f                          _ _ P a c k a g e s . m x . c o n t r o l s . B u t t o n 
B u t t o n . s w f                       m x . c o n t r o l s . B u t t o n qi m p o r t   m x . c o r e . U I O b j e c t ;  
 i m p o r t   m x . c o n t r o l s . S i m p l e B u t t o n ;  
 i m p o r t   m x . c o r e . U I C o m p o n e n t ;  
  
 [ E v e n t ( " c l i c k " ) ]    
 [ T a g N a m e ( " B u t t o n " ) ]    
 [ I c o n F i l e ( " B u t t o n . p n g " ) ]    
 i n t r i n s i c   c l a s s   m x . c o n t r o l s . B u t t o n   e x t e n d s   m x . c o n t r o l s . S i m p l e B u t t o n  
 {  
       p u b l i c   f u n c t i o n   B u t t o n ( ) ;  
       p u b l i c   v a r   _ _ g e t _ _ i c o n : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l : F u n c t i o n ;  
       p u b l i c   v a r   _ _ g e t _ _ l a b e l P l a c e m e n t : F u n c t i o n ;  
       p u b l i c   v a r   _ _ l a b e l : S t r i n g ;  
       p u b l i c   v a r   _ _ l a b e l P l a c e m e n t : S t r i n g ;  
       p u b l i c   v a r   _ c o l o r ;  
       p u b l i c   f u n c t i o n   _ g e t I c o n ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   _ i c o n L i n k a g e N a m e : S t r i n g ;  
       [ B i n d a b l e ]   [ C h a n g e E v e n t ( " c l i c k " ) ]   p u b l i c   v a r   _ i n h e r i t e d _ s e l e c t e d : B o o l e a n ;  
       p u b l i c   f u n c t i o n   _ s e t I c o n ( l i n k a g e ) : V o i d ;  
       p u b l i c   v a r   b o r d e r W : N u m b e r ;  
       p u b l i c   v a r   b t n O f f s e t : N u m b e r ;  
       p u b l i c   f u n c t i o n   c a l c S i z e ( t a g : N u m b e r ,   r e f : O b j e c t ) : V o i d ;  
       p u b l i c   v a r   c e n t e r C o n t e n t : B o o l e a n ;  
       p u b l i c   v a r   c l a s s N a m e : S t r i n g ;  
       p u b l i c   v a r   c l i p P a r a m e t e r s : O b j e c t ;  
       p u b l i c   f u n c t i o n   c r e a t e C h i l d r e n ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   d r a w ( ) ;  
       p u b l i c   v a r   f a l s e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   f a l s e U p S k i n : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t B t n O f f s e t ( V o i d ) : N u m b e r ;  
       p u b l i c   f u n c t i o n   g e t L a b e l ( V o i d ) : S t r i n g ;  
       p u b l i c   f u n c t i o n   g e t L a b e l P l a c e m e n t ( V o i d ) : S t r i n g ;  
       p u b l i c   v a r   h i t A r e a _ m c : M o v i e C l i p ;  
       f u n c t i o n   g e t   i c o n ( ) : S t r i n g ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " " ) ]   f u n c t i o n   s e t   i c o n ( l i n k a g e ) ;  
       p u b l i c   f u n c t i o n   i n i t ( V o i d ) : V o i d ;  
       p u b l i c   v a r   i n i t I c o n ;  
       p u b l i c   f u n c t i o n   i n v a l i d a t e S t y l e ( c : S t r i n g ) : V o i d ;  
       [ I n s p e c t a b l e ( d e f a u l t V a l u e = " B u t t o n " ) ]   f u n c t i o n   s e t   l a b e l ( l b l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l ( ) : S t r i n g ;  
       p u b l i c   v a r   l a b e l P a t h : O b j e c t ;  
       [ I n s p e c t a b l e ( e n u m e r a t i o n = " l e f t , r i g h t , t o p , b o t t o m " d e f a u l t V a l u e = " r i g h t " ) ]   f u n c t i o n   s e t   l a b e l P l a c e m e n t ( v a l : S t r i n g ) ;  
       f u n c t i o n   g e t   l a b e l P l a c e m e n t ( ) : S t r i n g ;  
       s t a t i c   v a r   m e r g e d C l i p P a r a m e t e r s : B o o l e a n ;  
       p u b l i c   f u n c t i o n   o n R e l e a s e ( V o i d ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t C o l o r ( c : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t E n a b l e d ( e n a b l e : B o o l e a n ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t H i t A r e a ( w : N u m b e r ,   h : N u m b e r ) ;  
       p u b l i c   f u n c t i o n   s e t L a b e l ( l a b e l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t L a b e l P l a c e m e n t ( v a l : S t r i n g ) : V o i d ;  
       p u b l i c   f u n c t i o n   s e t S k i n ( t a g : N u m b e r ,   l i n k a g e N a m e : S t r i n g ,   i n i t o b j : O b j e c t ) : M o v i e C l i p ;  
       p u b l i c   f u n c t i o n   s e t V i e w ( o f f s e t : N u m b e r ) : V o i d ;  
       p u b l i c   f u n c t i o n   s i z e ( V o i d ) : V o i d ;  
       s t a t i c   v a r   s y m b o l N a m e : S t r i n g ;  
       s t a t i c   v a r   s y m b o l O w n e r ;  
       p u b l i c   v a r   t r u e D i s a b l e d I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D i s a b l e d S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e D o w n S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e O v e r S k i n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p I c o n : S t r i n g ;  
       p u b l i c   v a r   t r u e U p S k i n : S t r i n g ;  
       s t a t i c   v a r   v e r s i o n : S t r i n g ;  
       p u b l i c   f u n c t i o n   v i e w S k i n ( v a r N a m e : S t r i n g ) : V o i d ;  
 } ;  
               
    h   h  h  h  h                    P r o p S h e e t : : A c t i v e T a b 7 6 4 1     !P u b l i s h G i f P r o p e r t i e s : : P a l e t t e N a m e   P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 5 6 K 0 "P u b l i s h H t m l P r o p e r t i e s : : S t a r t P a u s e d 0 %P u b l i s h F o r m a t P r o p e r t i e s : : h t m l F i l e N a m e s t o r a g e _ d i a l o g . h t m l  P u b l i s h Q T P r o p e r t i e s : : L a y e r O p t i o n   P u b l i s h Q T P r o p e r t i e s : : A l p h a O p t i o n  "P u b l i s h Q T P r o p e r t i e s : : M a t c h M o v i e D i m 1 V e c t o r : : D e b u g g i n g   P e r m i t t e d 0 P u b l i s h P r o f i l e P r o p e r t i e s : : n a m e D e f a u l t P u b l i s h H t m l P r o p e r t i e s : : L o o p 1 P u b l i s h F o r m a t P r o p e r t i e s : : j p e g 0 P u b l i s h Q T P r o p e r t i e s : : W i d t h 2 1 5 $P u b l i s h P N G P r o p e r t i e s : : O p t i m i z e C o l o r s 1 &P u b l i s h R N W K P r o p e r t i e s : : s p e e d S i n g l e I S D N 0 &P u b l i s h R N W K P r o p e r t i e s : : s i n g l e R a t e A u d i o 0 V e c t o r : : E x t e r n a l   P l a y e r  %P u b l i s h H t m l P r o p e r t i e s : : s h o w T a g W a r n M s g 1 P u b l i s h H t m l P r o p e r t i e s : : U n i t s 0 4P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t A l t e r n a t e F i l e n a m e 1 P u b l i s h G i f P r o p e r t i e s : : S m o o t h 1 %P u b l i s h R N W K P r o p e r t i e s : : m e d i a C o p y r i g h t ( c )   2 0 0 0 #P u b l i s h R N W K P r o p e r t i e s : : f l a s h B i t R a t e 1 2 0 0 V e c t o r : : C o m p r e s s   M o v i e 1 V e c t o r : : P a c k a g e   P a t h s  &P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h F i l e N a m e . . \ . . \ s t o r a g e _ d i a l o g . s w f 'P u b l i s h F o r m a t P r o p e r t i e s : : g i f D e f a u l t N a m e 1 %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c 0 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r O p t i o n  !P u b l i s h R N W K P r o p e r t i e s : : e x p o r t S M I L 1  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 3 8 4 K 0 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t A u d i o 1 V e c t o r : : F i r e F o x 0 P u b l i s h H t m l P r o p e r t i e s : : Q u a l i t y 4 (P u b l i s h H t m l P r o p e r t i e s : : V e r t i c a l A l i g n m e n t 1 $P u b l i s h F o r m a t P r o p e r t i e s : : p n g F i l e N a m e s t o r a g e _ d i a l o g . p n g P u b l i s h F o r m a t P r o p e r t i e s : : h t m l 0 "P u b l i s h P N G P r o p e r t i e s : : F i l t e r O p t i o n  'P u b l i s h R N W K P r o p e r t i e s : : m e d i a D e s c r i p t i o n  V e c t o r : : O v e r r i d e   S o u n d s 0 !P u b l i s h H t m l P r o p e r t i e s : : D e v i c e F o n t 0 -P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r D e f a u l t N a m e 1 P u b l i s h Q T P r o p e r t i e s : : F l a t t e n 1 P u b l i s h P N G P r o p e r t i e s : : B i t D e p t h 2 4 - b i t   w i t h   A l p h a P u b l i s h P N G P r o p e r t i e s : : S m o o t h 1 "P u b l i s h G i f P r o p e r t i e s : : D i t h e r S o l i d s 0 P u b l i s h G i f P r o p e r t i e s : : I n t e r l a c e 0 P u b l i s h J p e g P r o p e r t i e s : : D P I 4 7 1 8 5 9 2 V e c t o r : : Q u a l i t y 8 0 V e c t o r : : P r o t e c t 0 "P u b l i s h H t m l P r o p e r t i e s : : D i s p l a y M e n u 1 *P u b l i s h H t m l P r o p e r t i e s : : H o r i z o n t a l A l i g n m e n t 1 2P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n D e t e c t i o n I f A v a i l a b l e 0 V e c t o r : : T e m p l a t e 0 *P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r F i l e N a m e s t o r a g e _ d i a l o g . s w t (P u b l i s h F o r m a t P r o p e r t i e s : : r n w k D e f a u l t N a m e 1 (P u b l i s h F o r m a t P r o p e r t i e s : : j p e g D e f a u l t N a m e 1 P u b l i s h F o r m a t P r o p e r t i e s : : g i f 0 P u b l i s h G i f P r o p e r t i e s : : L o o p 1 P u b l i s h G i f P r o p e r t i e s : : W i d t h 2 1 5 $P u b l i s h R N W K P r o p e r t i e s : : m e d i a K e y w o r d s  !P u b l i s h R N W K P r o p e r t i e s : : m e d i a T i t l e  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 2 8 K 1 #P u b l i s h F o r m a t P r o p e r t i e s : : q t F i l e N a m e s t o r a g e _ d i a l o g . m o v "P u b l i s h P N G P r o p e r t i e s : : D i t h e r O p t i o n  #P u b l i s h G i f P r o p e r t i e s : : P a l e t t e O p t i o n  #P u b l i s h G i f P r o p e r t i e s : : M a t c h M o v i e D i m 1 $P u b l i s h R N W K P r o p e r t i e s : : s p e e d D u a l I S D N 0 $P u b l i s h R N W K P r o p e r t i e s : : r e a l V i d e o R a t e 1 0 0 0 0 0 P u b l i s h J p e g P r o p e r t i e s : : Q u a l i t y 8 0 P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h 1 #P u b l i s h P N G P r o p e r t i e s : : P a l e t t e O p t i o n  #P u b l i s h P N G P r o p e r t i e s : : M a t c h M o v i e D i m 1 $P u b l i s h J p e g P r o p e r t i e s : : M a t c h M o v i e D i m 1 V e c t o r : : P a c k a g e   E x p o r t   F r a m e 1 !P u b l i s h P r o f i l e P r o p e r t i e s : : v e r s i o n 1 P u b l i s h H t m l P r o p e r t i e s : : A l i g n 0 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n F i l e N a m e s t o r a g e _ d i a l o g . e x e 'P u b l i s h F o r m a t P r o p e r t i e s : : p n g D e f a u l t N a m e 1 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c D e f a u l t N a m e 1 #P u b l i s h Q T P r o p e r t i e s : : P l a y E v e r y F r a m e 0 "P u b l i s h P N G P r o p e r t i e s : : D i t h e r S o l i d s 0 "P u b l i s h J p e g P r o p e r t i e s : : P r o g r e s s i v e 0 V e c t o r : : D e b u g g i n g   P a s s w o r d  V e c t o r : : O m i t   T r a c e   A c t i o n s 0 P u b l i s h H t m l P r o p e r t i e s : : H e i g h t 1 3 8 P u b l i s h H t m l P r o p e r t i e s : : W i d t h 2 1 5 %P u b l i s h F o r m a t P r o p e r t i e s : : j p e g F i l e N a m e s t o r a g e _ d i a l o g . j p g )P u b l i s h F o r m a t P r o p e r t i e s : : f l a s h D e f a u l t N a m e 0 P u b l i s h P N G P r o p e r t i e s : : I n t e r l a c e 0 P u b l i s h G i f P r o p e r t i e s : : H e i g h t 1 3 8 P u b l i s h J p e g P r o p e r t i e s : : S i z e 0 V e c t o r : : D e v i c e S o u n d 0 V e c t o r : : T o p D o w n 0 'P u b l i s h H t m l P r o p e r t i e s : : T e m p l a t e F i l e N a m e C : \ D o c u m e n t s   a n d   S e t t i n g s \ b r a d n e u b e r g \ L o c a l   S e t t i n g s \ A p p l i c a t i o n   D a t a \ M a c r o m e d i a \ F l a s h   M X   2 0 0 4 \ e n \ C o n f i g u r a t i o n \ H t m l \ D e f a u l t . h t m l !P u b l i s h H t m l P r o p e r t i e s : : W i n d o w M o d e 0 2P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t C o n t e n t F i l e n a m e 1 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c F i l e N a m e s t o r a g e _ d i a l o g . h q x (P u b l i s h F o r m a t P r o p e r t i e s : : h t m l D e f a u l t N a m e 1 P u b l i s h F o r m a t P r o p e r t i e s : : r n w k 0 P u b l i s h F o r m a t P r o p e r t i e s : : p n g 0 P u b l i s h Q T P r o p e r t i e s : : H e i g h t 1 3 8 %P u b l i s h P N G P r o p e r t i e s : : R e m o v e G r a d i e n t s 0 P u b l i s h G i f P r o p e r t i e s : : M a x C o l o r s 2 5 5 'P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t O p t i o n  P u b l i s h G i f P r o p e r t i e s : : L o o p C o u n t  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 6 K 1 V e c t o r : : R e p o r t 0 +P u b l i s h H t m l P r o p e r t i e s : : O w n A l t e r n a t e F i l e n a m e  (P u b l i s h H t m l P r o p e r t i e s : : A l t e r n a t e F i l e n a m e  &P u b l i s h H t m l P r o p e r t i e s : : C o n t e n t F i l e n a m e  "P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r 0 $P u b l i s h G i f P r o p e r t i e s : : O p t i m i z e C o l o r s 1 "P u b l i s h R N W K P r o p e r t i e s : : a u d i o F o r m a t 0 V e c t o r : : V e r s i o n 7 V e c t o r : : E v e n t   F o r m a t 0 V e c t o r : : S t r e a m   C o m p r e s s 7 P u b l i s h F o r m a t P r o p e r t i e s : : q t 0 P u b l i s h P N G P r o p e r t i e s : : H e i g h t 1 3 8 P u b l i s h P N G P r o p e r t i e s : : W i d t h 2 1 5 %P u b l i s h G i f P r o p e r t i e s : : R e m o v e G r a d i e n t s 0  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 1 2 K 0 P u b l i s h J p e g P r o p e r t i e s : : H e i g h t 1 3 8 V e c t o r : : A c t i o n S c r i p t V e r s i o n 2 V e c t o r : : E v e n t   C o m p r e s s 7 P u b l i s h H t m l P r o p e r t i e s : : S c a l e 0 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n D e f a u l t N a m e 1 P u b l i s h Q T P r o p e r t i e s : : L o o p i n g 0 *P u b l i s h Q T P r o p e r t i e s : : U s e Q T S o u n d C o m p r e s s i o n 0 !P u b l i s h P N G P r o p e r t i e s : : P a l e t t e N a m e  !P u b l i s h P N G P r o p e r t i e s : : T r a n s p a r e n t 0 &P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t A l p h a 1 2 8 P u b l i s h G i f P r o p e r t i e s : : A n i m a t e d 0 "P u b l i s h R N W K P r o p e r t i e s : : m e d i a A u t h o r  (P u b l i s h R N W K P r o p e r t i e s : : s p e e d C o r p o r a t e L A N 0 &P u b l i s h R N W K P r o p e r t i e s : : s h o w B i t r a t e D l o g 1 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t F l a s h 1 P u b l i s h J p e g P r o p e r t i e s : : W i d t h 2 1 5 V e c t o r : : S t r e a m   F o r m a t 0 "P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n I n f o  $P u b l i s h F o r m a t P r o p e r t i e s : : g i f F i l e N a m e s t o r a g e _ d i a l o g . g i f &P u b l i s h F o r m a t P r o p e r t i e s : : q t D e f a u l t N a m e 1 "P u b l i s h Q T P r o p e r t i e s : : P a u s e d A t S t a r t 0 %P u b l i s h Q T P r o p e r t i e s : : C o n t r o l l e r O p t i o n 0 P u b l i s h P N G P r o p e r t i e s : : M a x C o l o r s 2 5 5 ,P u b l i s h H t m l P r o p e r t i e s : : U s i n g O w n A l t e r n a t e F i l e 0 %P u b l i s h F o r m a t P r o p e r t i e s : : r n w k F i l e N a m e s t o r a g e _ d i a l o g . s m i l %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n 0 %P u b l i s h F o r m a t P r o p e r t i e s : : d e f a u l t N a m e s 0           	 CColorDef                                  3   P    f   P  0     P  H     P  `     P  x 3        33   (   3f   <  0 3   C  H 3   F  ` 3   H  x f       0 f3     0 ff   (  0 f   5  H f   <  ` f   @  x            333      0              3      33  x    f3  d  0  3  ]  H  3  Z  `  3  X  x 3 3     333      0 3f3  P P H 33  P x ` 33  P  x 33  P   f 3    0 f33    P H ff3  ( P H f3  < x ` f3  C  x f3  F              fff      `              f    0  3f    0  ff  x  0  f  k  H  f  d  `  f  `  x 3 f    0 33f   P H 3ff  x P H 3f  d x ` 3f  ]  x 3f  Z   f f    0 f3f   P H fff      ` ff  P 0 x ff  P x  ff  P                                      H  3    H  f    H    x  H    n  `    h  x 3     H 33   x ` 3f   x ` 3  x x ` 3  k  x 3  d   f     H f3   x ` ff   0 x f  x 0 x f  d x  f  ]                                      `  3    `  f    `      `    x  `    p  x 3     ` 33    x 3f    x 3    x 3  x  x 3  n   f     ` f3    x ff   x  f   x  f  x x  f  k                                      x  3    x  f    x      x      x    x  x 3     x 33     3f     3     3     3  x   f     x f3     ff     f     f     f  x                     x                   H 3     H f     H    (  H    2  `    8  x        ` 3   
  ` f     `      `    (  `    0  x        x 3     x f     x      x       x    (  x                P  x             3    H 33    x ` f3   x ` 3  ( x ` 3  5  x 3  <    3    ` 33     x f3    x 3    x 3  (  x 3  2    3    x 33      f3  
   3     3     3  (                    x             f    H 3f   x ` ff    0 x f  ( 0 x f  < x  f  C    f    ` 3f    x ff    x  f   x  f  ( x  f  5    f    x 3f     ff      f     f     f  (                 (  x                 H 3   x ` f   0 x          P P    P        ` 3    x f   x      P    ( P    <        x 3     f                  (                 x  x                 ` 3    x f   x     P    x P    d        ` 3    x f   x     P           P        x 3     f                  (                   x                 x 3     f                 x        x 3     f                 x        x 3     f                                                                                                                                                                                                                                                         f`zf                                     * ]                                                                 "P u b l i s h Q T P r o p e r t i e s : : Q T S n d S e t t i n g s   CQTAudioSettings                           h                         
   
                               8 P u b l i s h J p e g P r o p e r t i e s : : S i z e 0 V e c t o r : : D e v i c e S o u n d 0 V e c t o r : : T o p D o w n 0 'P u b l i s h H t m l P r o p e r t i e s : : T e m p l a t e F i l e N a m e C : \ D o c u m e n t s   a n d   S e t t i n g s \ b r a d n e u b e r g \ L o c a l   S e t t i n g s \ A p p l i c a t i o n   D a t a \ M a c r o m e d i a \ F l a s h   M X   2 0 0 4 \ e n \ C o n f i g u r a t i o n \ H t m l \ D e f a u l t . h t m l !P u b l i s h H t m l P r o p e r t i e s : : W i n d o w M o d e 0 2P u b l i s h H t m l P r o p e r t i e s : : U s i n g D e f a u l t C o n t e n t F i l e n a m e 1 -P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r M a c F i l e N a m e s t o r a g e _ d i a l o g . h q x (P u b l i s h F o r m a t P r o p e r t i e s : : h t m l D e f a u l t N a m e 1 P u b l i s h F o r m a t P r o p e r t i e s : : r n w k 0 P u b l i s h F o r m a t P r o p e r t i e s : : p n g 0 P u b l i s h Q T P r o p e r t i e s : : H e i g h t 1 3 8 %P u b l i s h P N G P r o p e r t i e s : : R e m o v e G r a d i e n t s 0 P u b l i s h G i f P r o p e r t i e s : : M a x C o l o r s 2 5 5 'P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t O p t i o n  P u b l i s h G i f P r o p e r t i e s : : L o o p C o u n t  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 6 K 1 V e c t o r : : R e p o r t 0 +P u b l i s h H t m l P r o p e r t i e s : : O w n A l t e r n a t e F i l e n a m e  (P u b l i s h H t m l P r o p e r t i e s : : A l t e r n a t e F i l e n a m e  &P u b l i s h H t m l P r o p e r t i e s : : C o n t e n t F i l e n a m e  "P u b l i s h F o r m a t P r o p e r t i e s : : g e n e r a t o r 0 $P u b l i s h G i f P r o p e r t i e s : : O p t i m i z e C o l o r s 1 "P u b l i s h R N W K P r o p e r t i e s : : a u d i o F o r m a t 0 V e c t o r : : V e r s i o n 7 V e c t o r : : E v e n t   F o r m a t 0 V e c t o r : : S t r e a m   C o m p r e s s 7 P u b l i s h F o r m a t P r o p e r t i e s : : q t 0 P u b l i s h P N G P r o p e r t i e s : : H e i g h t 1 3 8 P u b l i s h P N G P r o p e r t i e s : : W i d t h 2 1 5 %P u b l i s h G i f P r o p e r t i e s : : R e m o v e G r a d i e n t s 0  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 1 2 K 0 P u b l i s h J p e g P r o p e r t i e s : : H e i g h t 1 3 8 V e c t o r : : A c t i o n S c r i p t V e r s i o n 2 V e c t o r : : E v e n t   C o m p r e s s 7 P u b l i s h H t m l P r o p e r t i e s : : S c a l e 0 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n D e f a u l t N a m e 1 P u b l i s h Q T P r o p e r t i e s : : L o o p i n g 0 *P u b l i s h Q T P r o p e r t i e s : : U s e Q T S o u n d C o m p r e s s i o n 0 !P u b l i s h P N G P r o p e r t i e s : : P a l e t t e N a m e  !P u b l i s h P N G P r o p e r t i e s : : T r a n s p a r e n t 0 &P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t A l p h a 1 2 8 P u b l i s h G i f P r o p e r t i e s : : A n i m a t e d 0 "P u b l i s h R N W K P r o p e r t i e s : : m e d i a A u t h o r  (P u b l i s h R N W K P r o p e r t i e s : : s p e e d C o r p o r a t e L A N 0 &P u b l i s h R N W K P r o p e r t i e s : : s h o w B i t r a t e D l o g 1 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t F l a s h 1 P u b l i s h J p e g P r o p e r t i e s : : W i d t h 2 1 5 V e c t o r : : S t r e a m   F o r m a t 0 "P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n I n f o  $P u b l i s h F o r m a t P r o p e r t i e s : : g i f F i l e N a m e s t o r a g e _ d i a l o g . g i f &P u b l i s h F o r m a t P r o p e r t i e s : : q t D e f a u l t N a m e 1 "P u b l i s h Q T P r o p e r t i e s : : P a u s e d A t S t a r t 0 %P u b l i s h Q T P r o p e r t i e s : : C o n t r o l l e r O p t i o n 0 P u b l i s h P N G P r o p e r t i e s : : M a x C o l o r s 2 5 5 ,P u b l i s h H t m l P r o p e r t i e s : : U s i n g O w n A l t e r n a t e F i l e 0 %P u b l i s h F o r m a t P r o p e r t i e s : : r n w k F i l e N a m e s t o r a g e _ d i a l o g . s m i l %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n 0 %P u b l i s h F o r m a t P r o p e r t i e s : : d e f a u l t N a m e s 0           	 CColorDef                                  3   P    f   P  0     P  H     P  `     P  x 3        33   (   3f   <  0 3   C  H 3   F  ` 3   H  x f       0 f3     0 ff   (  0 f   5  H f   <  ` f   @  x            333      0              3      33  x    f3  d  0  3  ]  H  3  Z  `  3  X  x 3 3     333      0 3f3  P P H 33  P x ` 33  P  x 33  P   f 3    0 f33    P H ff3  ( P H f3  < x ` f3  C  x f3  F              fff      `              f    0  3f    0  ff  x  0  f  k  H  f  d  `  f  `  x 3 f    0 33f   P H 3ff  x P H 3f  d x ` 3f  ]  x 3f  Z   f f    0 f3f   P H fff      ` ff  P 0 x ff  P x  ff  P                                      H  3    H  f    H    x  H    n  `    h  x 3     H 33   x ` 3f   x ` 3  x x ` 3  k  x 3  d   f     H f3   x ` ff   0 x f  x 0 x f  d x  f  ]                                      `  3    `  f    `      `    x  `    p  x 3     ` 33    x 3f    x 3    x 3  x  x 3  n   f     ` f3    x ff   x  f   x  f  x x  f  k                                      x  3    x  f    x      x      x    x  x 3     x 33     3f     3     3     3  x   f     x f3     ff     f     f     f  x                     x                   H 3     H f     H    (  H    2  `    8  x        ` 3   
  ` f     `      `    (  `    0  x        x 3     x f     x      x       x    (  x                P  x             3    H 33    x ` f3   x ` 3  ( x ` 3  5  x 3  <    3    ` 33     x f3    x 3    x 3  (  x 3  2    3    x 33      f3  
   3     3     3  (                    x             f    H 3f   x ` ff    0 x f  ( 0 x f  < x  f  C    f    ` 3f    x ff    x  f   x  f  ( x  f  5    f    x 3f     ff      f     f     f  (                 (  x                 H 3   x ` f   0 x          P P    P        ` 3    x f   x      P    ( P    <        x 3     f                  (                 x  x                 ` 3    x f   x     P    x P    d        ` 3    x f   x     P           P        x 3     f                  (                   x                 x 3     f                 x        x 3     f                 x        x 3     f                                                            R e m o v e G r a d i e n t s 0  P u b l i s h R N W K P r o p e r t i e s : : s p e e d 5 1 2 K 0 P u b l i s h J p e g P r o p e r t i e s : : H e i g h t 1 3 8 V e c t o r : : A c t i o n S c r i p t V e r s i o n 2 V e c t o r : : E v e n t   C o m p r e s s 7 P u b l i s h H t m l P r o p e r t i e s : : S c a l e 0 0P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n D e f a u l t N a m e 1 P u b l i s h Q T P r o p e r t i e s : : L o o p i n g 0 *P u b l i s h Q T P r o p e r t i e s : : U s e Q T S o u n d C o m p r e s s i o n 0 !P u b l i s h P N G P r o p e r t i e s : : P a l e t t e N a m e  !P u b l i s h P N G P r o p e r t i e s : : T r a n s p a r e n t 0 &P u b l i s h G i f P r o p e r t i e s : : T r a n s p a r e n t A l p h a 1 2 8 P u b l i s h G i f P r o p e r t i e s : : A n i m a t e d 0 "P u b l i s h R N W K P r o p e r t i e s : : m e d i a A u t h o r  (P u b l i s h R N W K P r o p e r t i e s : : s p e e d C o r p o r a t e L A N 0 &P u b l i s h R N W K P r o p e r t i e s : : s h o w B i t r a t e D l o g 1 "P u b l i s h R N W K P r o p e r t i e s : : e x p o r t F l a s h 1 P u b l i s h J p e g P r o p e r t i e s : : W i d t h 2 1 5 V e c t o r : : S t r e a m   F o r m a t 0 "P u b l i s h H t m l P r o p e r t i e s : : V e r s i o n I n f o  $P u b l i s h F o r m a t P r o p e r t i e s : : g i f F i l e N a m e s t o r a g e _ d i a l o g . g i f &P u b l i s h F o r m a t P r o p e r t i e s : : q t D e f a u l t N a m e 1 "P u b l i s h Q T P r o p e r t i e s : : P a u s e d A t S t a r t 0 %P u b l i s h Q T P r o p e r t i e s : : C o n t r o l l e r O p t i o n 0 P u b l i s h P N G P r o p e r t i e s : : M a x C o l o r s 2 5 5 ,P u b l i s h H t m l P r o p e r t i e s : : U s i n g O w n A l t e r n a t e F i l e 0 %P u b l i s h F o r m a t P r o p e r t i e s : : r n w k F i l e N a m e s t o r a g e _ d i a l o g . s m i l %P u b l i s h F o r m a t P r o p e r t i e s : : p r o j e c t o r W i n 0 %P u b l i s h F o r m a t P r o p e r t i e s : : d e f a u l t N a m e s 0           	 CColorDef                                  3   P    f   P  0     P  H     P  `     P  x 3        33   (   3f   <  0 3   C  H 3   F  ` 3   H  x f       0 f3                                                                                                                                                                                              f`zf                                     * ]                                                                 "P u b l i s h Q T P r o p e r t i e s : : Q T S n d S e t t i n g s   CQTAudioSettin    0 ff   (  0 f   5  H f   <  ` f   @  x            333      0              3      33  x    f3  d  0  3  ]  H  3  Z  `  3  X  x 3 3     333      0 3f3  P P H 33  P x ` 33  P  x 33  P   f 3    0 f33    P H ff3  ( P H f3  < x ` f3  C  x f3  F              fff      `              f    0  3f    0  ff  x  0  f  k  H  f  d  `  f gs                           h                         
   
                                                                                                                                                                                                                                                                                                                                                                                                                                    `  x 3 f    0 33f   P H 3ff  x P H 3f  d x ` 3f  ]  x 3f  Z   f f    0 f3f   P H fff      ` ff  P 0 x ff  P x  ff  P                                      H  3    H  f    H    x  H    n  `    h  x 3     H 33   x ` 3f   x ` 3  x x ` 3  k  x 3  d   f     H f3   x ` ff   0 x f  x 0 x f  d x  f  ]                                      `  3    `  f    `      `    x  `    p  x 3     ` 33    x 3f    x 3    x 3  x  x 3  n   f     ` f3    x ff   x  f   x  f  x x  f  k                                      x  3    x  f    x      x      x    x  x 3     x 33     3f     3     3     3  x   f     x f3     ff     f     f     f  x                     x                   H 3     H f     H    (  H    2  `    8  x        ` 3   
  ` f     `      `    (  `    0  x        x 3     x f     x      x       x    (  x                P  x             3    H 33    x ` f3   x ` 3  ( x ` 3  5  x 3  <    3    ` 33     x f3    x 3    x 3  (  x 3  2    3    x 33      f3  
   3     3     3  (                    x             f    H 3f   x ` ff    0 x f  ( 0 x f  < x  f  C    f    ` 3f    x ff    x  f   x  f  ( x  f  5    f    x 3f     ff      f     f     f  (                 (  x                 H 3   x ` f   0 x          P P    P        ` 3    x f   x      P    ( P    <        x 3     f                  (                 x  x                 ` 3    x f   x     P    x P    d        ` 3    x f   x     P           P        x 3     f                  (                   x                 x 3     f                 x        x 3     f                 x        x 3     f                                                                                                                                                                                                                                                         f`zf                                     * ]                                                                 "P u b l i s h Q T P r o p e r t i e s : : Q T S n d S e t t i n g s   CQTAudioSettings                           h                         
   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
__CPAN_FILE__ src/storage/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.storage"],
	browser: ["dojo.storage.browser"],
	dashboard: ["dojo.storage.dashboard"]
});
dojo.provide("dojo.storage.*");


__CPAN_DIR__ src/string
__CPAN_FILE__ src/string/Builder.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.string.Builder");
dojo.require("dojo.string");

// NOTE: testing shows that direct "+=" concatenation is *much* faster on
// Spidermoneky and Rhino, while arr.push()/arr.join() style concatenation is
// significantly quicker on IE (Jscript/wsh/etc.).

dojo.string.Builder = function(str){
	this.arrConcat = (dojo.render.html.capable && dojo.render.html["ie"]);

	var a = [];
	var b = str || "";
	var length = this.length = b.length;

	if(this.arrConcat){
		if(b.length > 0){
			a.push(b);
		}
		b = "";
	}

	this.toString = this.valueOf = function(){ 
		return (this.arrConcat) ? a.join("") : b;
	};

	this.append = function(s){
		if(this.arrConcat){
			a.push(s);
		}else{
			b+=s;
		}
		length += s.length;
		this.length = length;
		return this;
	};

	this.clear = function(){
		a = [];
		b = "";
		length = this.length = 0;
		return this;
	};

	this.remove = function(f,l){
		var s = ""; 
		if(this.arrConcat){
			b = a.join(""); 
		}
		a=[];
		if(f>0){
			s = b.substring(0, (f-1));
		}
		b = s + b.substring(f + l); 
		length = this.length = b.length; 
		if(this.arrConcat){
			a.push(b);
			b="";
		}
		return this;
	};

	this.replace = function(o,n){
		if(this.arrConcat){
			b = a.join(""); 
		}
		a = []; 
		b = b.replace(o,n); 
		length = this.length = b.length; 
		if(this.arrConcat){
			a.push(b);
			b="";
		}
		return this;
	};

	this.insert = function(idx,s){
		if(this.arrConcat){
			b = a.join(""); 
		}
		a=[];
		if(idx == 0){
			b = s + b;
		}else{
			var t = b.split("");
			t.splice(idx,0,s);
			b = t.join("")
		}
		length = this.length = b.length; 
		if(this.arrConcat){
			a.push(b); 
			b="";
		}
		return this;
	};
};

__CPAN_FILE__ src/string/common.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.string.common");

dojo.require("dojo.string");

/**
 * Trim whitespace from 'str'. If 'wh' > 0,
 * only trim from start, if 'wh' < 0, only trim
 * from end, otherwise trim both ends
 */
dojo.string.trim = function(str, wh){
	if(!str.replace){ return str; }
	if(!str.length){ return str; }
	var re = (wh > 0) ? (/^\s+/) : (wh < 0) ? (/\s+$/) : (/^\s+|\s+$/g);
	return str.replace(re, "");
}

/**
 * Trim whitespace at the beginning of 'str'
 */
dojo.string.trimStart = function(str) {
	return dojo.string.trim(str, 1);
}

/**
 * Trim whitespace at the end of 'str'
 */
dojo.string.trimEnd = function(str) {
	return dojo.string.trim(str, -1);
}

/**
 * Return 'str' repeated 'count' times, optionally
 * placing 'separator' between each rep
 */
dojo.string.repeat = function(str, count, separator) {
	var out = "";
	for(var i = 0; i < count; i++) {
		out += str;
		if(separator && i < count - 1) {
			out += separator;
		}
	}
	return out;
}

/**
 * Pad 'str' to guarantee that it is at least 'len' length
 * with the character 'c' at either the start (dir=1) or
 * end (dir=-1) of the string
 */
dojo.string.pad = function(str, len/*=2*/, c/*='0'*/, dir/*=1*/) {
	var out = String(str);
	if(!c) {
		c = '0';
	}
	if(!dir) {
		dir = 1;
	}
	while(out.length < len) {
		if(dir > 0) {
			out = c + out;
		} else {
			out += c;
		}
	}
	return out;
}

/** same as dojo.string.pad(str, len, c, 1) */
dojo.string.padLeft = function(str, len, c) {
	return dojo.string.pad(str, len, c, 1);
}

/** same as dojo.string.pad(str, len, c, -1) */
dojo.string.padRight = function(str, len, c) {
	return dojo.string.pad(str, len, c, -1);
}

__CPAN_FILE__ src/string/extras.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.string.extras");

dojo.require("dojo.string.common");
dojo.require("dojo.lang");

/**
 * Parameterized string function
 * str - formatted string with %{values} to be replaces
 * pairs - object of name: "value" value pairs
 * killExtra - remove all remaining %{values} after pairs are inserted
 */
dojo.string.paramString = function(str, pairs, killExtra) {
	for(var name in pairs) {
		var re = new RegExp("\\%\\{" + name + "\\}", "g");
		str = str.replace(re, pairs[name]);
	}

	if(killExtra) { str = str.replace(/%\{([^\}\s]+)\}/g, ""); }
	return str;
}

/** Uppercases the first letter of each word */
dojo.string.capitalize = function (str) {
	if (!dojo.lang.isString(str)) { return ""; }
	if (arguments.length == 0) { str = this; }
	var words = str.split(' ');
	var retval = "";
	var len = words.length;
	for (var i=0; i<len; i++) {
		var word = words[i];
		word = word.charAt(0).toUpperCase() + word.substring(1, word.length);
		retval += word;
		if (i < len-1)
			retval += " ";
	}
	
	return new String(retval);
}

/**
 * Return true if the entire string is whitespace characters
 */
dojo.string.isBlank = function (str) {
	if(!dojo.lang.isString(str)) { return true; }
	return (dojo.string.trim(str).length == 0);
}

dojo.string.encodeAscii = function(str) {
	if(!dojo.lang.isString(str)) { return str; }
	var ret = "";
	var value = escape(str);
	var match, re = /%u([0-9A-F]{4})/i;
	while((match = value.match(re))) {
		var num = Number("0x"+match[1]);
		var newVal = escape("&#" + num + ";");
		ret += value.substring(0, match.index) + newVal;
		value = value.substring(match.index+match[0].length);
	}
	ret += value.replace(/\+/g, "%2B");
	return ret;
}

dojo.string.escape = function(type, str) {
	var args = [];
	for(var i = 1; i < arguments.length; i++) { args.push(arguments[i]); }
	switch(type.toLowerCase()) {
		case "xml":
		case "html":
		case "xhtml":
			return dojo.string.escapeXml.apply(this, args);
		case "sql":
			return dojo.string.escapeSql.apply(this, args);
		case "regexp":
		case "regex":
			return dojo.string.escapeRegExp.apply(this, args);
		case "javascript":
		case "jscript":
		case "js":
			return dojo.string.escapeJavaScript.apply(this, args);
		case "ascii":
			// so it's encode, but it seems useful
			return dojo.string.encodeAscii.apply(this, args);
		default:
			return str;
	}
}

dojo.string.escapeXml = function(str, noSingleQuotes) {
	str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
		.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
	if(!noSingleQuotes) { str = str.replace(/'/gm, "&#39;"); }
	return str;
}

dojo.string.escapeSql = function(str) {
	return str.replace(/'/gm, "''");
}

dojo.string.escapeRegExp = function(str) {
	return str.replace(/\\/gm, "\\\\").replace(/([\f\b\n\t\r[\^$|?*+(){}])/gm, "\\$1");
}

dojo.string.escapeJavaScript = function(str) {
	return str.replace(/(["'\f\b\n\t\r])/gm, "\\$1");
}

dojo.string.escapeString = function(str){ 
	return ('"' + str.replace(/(["\\])/g, '\\$1') + '"'
		).replace(/[\f]/g, "\\f"
		).replace(/[\b]/g, "\\b"
		).replace(/[\n]/g, "\\n"
		).replace(/[\t]/g, "\\t"
		).replace(/[\r]/g, "\\r");
}

// TODO: make an HTML version
dojo.string.summary = function(str, len) {
	if(!len || str.length <= len) {
		return str;
	} else {
		return str.substring(0, len).replace(/\.+$/, "") + "...";
	}
}

/**
 * Returns true if 'str' ends with 'end'
 */
dojo.string.endsWith = function(str, end, ignoreCase) {
	if(ignoreCase) {
		str = str.toLowerCase();
		end = end.toLowerCase();
	}
	if((str.length - end.length) < 0){
		return false;
	}
	return str.lastIndexOf(end) == str.length - end.length;
}

/**
 * Returns true if 'str' ends with any of the arguments[2 -> n]
 */
dojo.string.endsWithAny = function(str /* , ... */) {
	for(var i = 1; i < arguments.length; i++) {
		if(dojo.string.endsWith(str, arguments[i])) {
			return true;
		}
	}
	return false;
}

/**
 * Returns true if 'str' starts with 'start'
 */
dojo.string.startsWith = function(str, start, ignoreCase) {
	if(ignoreCase) {
		str = str.toLowerCase();
		start = start.toLowerCase();
	}
	return str.indexOf(start) == 0;
}

/**
 * Returns true if 'str' starts with any of the arguments[2 -> n]
 */
dojo.string.startsWithAny = function(str /* , ... */) {
	for(var i = 1; i < arguments.length; i++) {
		if(dojo.string.startsWith(str, arguments[i])) {
			return true;
		}
	}
	return false;
}

/**
 * Returns true if 'str' starts with any of the arguments 2 -> n
 */
dojo.string.has = function(str /* , ... */) {
	for(var i = 1; i < arguments.length; i++) {
		if(str.indexOf(arguments[i]) > -1){
			return true;
		}
	}
	return false;
}

dojo.string.normalizeNewlines = function (text,newlineChar) {
	if (newlineChar == "\n") {
		text = text.replace(/\r\n/g, "\n");
		text = text.replace(/\r/g, "\n");
	} else if (newlineChar == "\r") {
		text = text.replace(/\r\n/g, "\r");
		text = text.replace(/\n/g, "\r");
	} else {
		text = text.replace(/([^\r])\n/g, "$1\r\n");
		text = text.replace(/\r([^\n])/g, "\r\n$1");
	}
	return text;
}

dojo.string.splitEscaped = function (str,charac) {
	var components = [];
	for (var i = 0, prevcomma = 0; i < str.length; i++) {
		if (str.charAt(i) == '\\') { i++; continue; }
		if (str.charAt(i) == charac) {
			components.push(str.substring(prevcomma, i));
			prevcomma = i + 1;
		}
	}
	components.push(str.substr(prevcomma));
	return components;
}

__CPAN_FILE__ src/string/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		"dojo.string",
		"dojo.string.common",
		"dojo.string.extras",
		"dojo.string.Builder"
	]
});
dojo.provide("dojo.string.*");

__CPAN_DIR__ src/text
__CPAN_FILE__ src/text/Builder.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.text.Builder");
dojo.require("dojo.string.Builder");

dojo.deprecated("dojo.text.Builder is deprecated, use dojo.string.Builder instead");

dojo.text.Builder = dojo.string.Builder;

__CPAN_FILE__ src/text/String.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.deprecated("dojo.text.String is being replaced by dojo.string");
dojo.require("dojo.string");

dojo.text = dojo.string;
dojo.provide("dojo.text.String");

__CPAN_FILE__ src/text/Text.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.deprecated("dojo.text.Text is being replaced by dojo.string");
dojo.require("dojo.string");

dojo.text = dojo.string;
dojo.provide("dojo.text.Text");

__CPAN_FILE__ src/text/textDirectory.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.text.textDirectory");
dojo.provide("dojo.text.textDirectory.Property");
dojo.provide("dojo.text.textDirectory.tokenise");
dojo.require("dojo.string");

/* adapted from Paul Sowden's iCalendar work */

dojo.textDirectoryTokeniser = function () {}

/*
 * This class parses a single line from a text/directory file
 * and returns an object with four named values; name, group, params
 * and value. name, group and value are strings containing the original
 * tokens unaltered and values is an array containing name/value pairs
 * or a single name token packed into arrays.
 */
dojo.textDirectoryTokeniser.Property = function (line) {
	// split into name/value pair
	var left = dojo.string.trim(line.substring(0, line.indexOf(':')));
	var right = dojo.string.trim(line.substr(line.indexOf(':') + 1));

	// seperate name and paramters	
	var parameters = dojo.string.splitEscaped(left,';');
	this.name = parameters[0]
	parameters.splice(0, 1);

	// parse paramters
	this.params = [];
	for (var i = 0; i < parameters.length; i++) {
		var arr = parameters[i].split("=");
		var key = dojo.string.trim(arr[0].toUpperCase());
		
		if (arr.length == 1) { this.params.push([key]); continue; }
		
		var values = dojo.string.splitEscaped(arr[1],',');
		for (var j = 0; j < values.length; j++) {
			if (dojo.string.trim(values[j]) != '') {
				this.params.push([key, dojo.string.trim(values[j])]);
			}
		}
	}

	// seperate group
	if (this.name.indexOf('.') > 0) {
		var arr = this.name.split('.');
		this.group = arr[0];
		this.name = arr[1];
	}
	
	// don't do any parsing, leave to implementation
	this.value = right;
}


// tokeniser, parses into an array of properties.
dojo.textDirectoryTokeniser.tokenise = function (text) {
	// normlize to one propterty per line and parse
	nText = dojo.string.normalizeNewlines(text,"\n");
	nText = nText.replace(/\n[ \t]/g, '');
	nText = nText.replace(/\x00/g, '');
		
	var lines = nText.split("\n");
	var properties = []

	for (var i = 0; i < lines.length; i++) {
		if (dojo.string.trim(lines[i]) == '') { continue; }
		var prop = new dojo.textDirectoryTokeniser.Property(lines[i]);
		properties.push(prop);
	}
	return properties;
}

__CPAN_FILE__ src/text/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		"dojo.text.String",
		"dojo.text.Builder"
	]
});
dojo.provide("dojo.text.*");

__CPAN_DIR__ src/undo
__CPAN_FILE__ src/undo/browser.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.undo.browser");
dojo.require("dojo.io");

try{
	if((!djConfig["preventBackButtonFix"])&&(!dojo.hostenv.post_load_)){
		document.write("<iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='"+(dojo.hostenv.getBaseScriptUri()+'iframe_history.html')+"'></iframe>");
	}
}catch(e){/* squelch */}

/* NOTES:
 *  Safari 1.2: 
 *	back button "works" fine, however it's not possible to actually
 *	DETECT that you've moved backwards by inspecting window.location.
 *	Unless there is some other means of locating.
 *	FIXME: perhaps we can poll on history.length?
 *  Safari 2.0.3+ (and probably 1.3.2+):
 *	works fine, except when changeUrl is used. When changeUrl is used,
 *	Safari jumps all the way back to whatever page was shown before
 *	the page that uses dojo.undo.browser support.
 *  IE 5.5 SP2:
 *	back button behavior is macro. It does not move back to the
 *	previous hash value, but to the last full page load. This suggests
 *	that the iframe is the correct way to capture the back button in
 *	these cases.
 *	Don't test this page using local disk for MSIE. MSIE will not create 
 *	a history list for iframe_history.html if served from a file: URL. 
 *	The XML served back from the XHR tests will also not be properly 
 *	created if served from local disk. Serve the test pages from a web 
 *	server to test in that browser.
 *  IE 6.0:
 *	same behavior as IE 5.5 SP2
 * Firefox 1.0:
 *	the back button will return us to the previous hash on the same
 *	page, thereby not requiring an iframe hack, although we do then
 *	need to run a timer to detect inter-page movement.
 */
dojo.undo.browser = {
	initialHref: window.location.href,
	initialHash: window.location.hash,

	moveForward: false,
	historyStack: [],
	forwardStack: [],
	historyIframe: null,
	bookmarkAnchor: null,
	locationTimer: null,

	/**
	 * setInitialState sets the state object and back callback for the very first page that is loaded.
	 * It is recommended that you call this method as part of an event listener that is registered via
	 * dojo.addOnLoad().
	 */
	setInitialState: function(args){
		this.initialState = {"url": this.initialHref, "kwArgs": args, "urlHash": this.initialHash};
	},

	//FIXME: Would like to support arbitrary back/forward jumps. Have to rework iframeLoaded among other things.
	//FIXME: is there a slight race condition in moz using change URL with the timer check and when
	//       the hash gets set? I think I have seen a back/forward call in quick succession, but not consistent.
	/**
	 * addToHistory takes one argument, and it is an object that defines the following functions:
	 * - To support getting back button notifications, the object argument should implement a
	 *   function called either "back", "backButton", or "handle". The string "back" will be
	 *   passed as the first and only argument to this callback.
	 * - To support getting forward button notifications, the object argument should implement a
	 *   function called either "forward", "forwardButton", or "handle". The string "forward" will be
	 *   passed as the first and only argument to this callback.
	 * - If you want the browser location string to change, define "changeUrl" on the object. If the
	 *   value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
	 *   identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
	 *   not evaluate to false, that value will be used as the fragment identifier. For example,
	 *   if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
	 *   
	 * Full example:
	 * 
	 * dojo.undo.browser.addToHistory({
	 *   back: function() { alert('back pressed'); },
	 *   forward: function() { alert('forward pressed'); },
	 *   changeUrl: true
	 * });
	 */
	addToHistory: function(args){
		var hash = null;
		if(!this.historyIframe){
			this.historyIframe = window.frames["djhistory"];
		}
		if(!this.bookmarkAnchor){
			this.bookmarkAnchor = document.createElement("a");
			(document.body||document.getElementsByTagName("body")[0]).appendChild(this.bookmarkAnchor);
			this.bookmarkAnchor.style.display = "none";
		}
		if((!args["changeUrl"])||(dojo.render.html.ie)){
			var url = dojo.hostenv.getBaseScriptUri()+"iframe_history.html?"+(new Date()).getTime();
			this.moveForward = true;
			dojo.io.setIFrameSrc(this.historyIframe, url, false);
		}
		if(args["changeUrl"]){
			this.changingUrl = true;
			hash = "#"+ ((args["changeUrl"]!==true) ? args["changeUrl"] : (new Date()).getTime());
			setTimeout("window.location.href = '"+hash+"'; dojo.undo.browser.changingUrl = false;", 1);
			this.bookmarkAnchor.href = hash;
			
			if(dojo.render.html.ie){
				var oldCB = args["back"]||args["backButton"]||args["handle"];

				//The function takes handleName as a parameter, in case the
				//callback we are overriding was "handle". In that case,
				//we will need to pass the handle name to handle.
				var tcb = function(handleName){
					if(window.location.hash != ""){
						setTimeout("window.location.href = '"+hash+"';", 1);
					}
					//Use apply to set "this" to args, and to try to avoid memory leaks.
					oldCB.apply(this, [handleName]);
				}
		
				//Set interceptor function in the right place.
				if(args["back"]){
					args.back = tcb;
				}else if(args["backButton"]){
					args.backButton = tcb;
				}else if(args["handle"]){
					args.handle = tcb;
				}
		
				//If addToHistory is called, then that means we prune the
				//forward stack -- the user went back, then wanted to
				//start a new forward path.
				this.forwardStack = []; 
				var oldFW = args["forward"]||args["forwardButton"]||args["handle"];
		
				//The function takes handleName as a parameter, in case the
				//callback we are overriding was "handle". In that case,
				//we will need to pass the handle name to handle.
				var tfw = function(handleName){
					if(window.location.hash != ""){
						window.location.href = hash;
					}
					if(oldFW){ // we might not actually have one
						//Use apply to set "this" to args, and to try to avoid memory leaks.
						oldFW.apply(this, [handleName]);
					}
				}

				//Set interceptor function in the right place.
				if(args["forward"]){
					args.forward = tfw;
				}else if(args["forwardButton"]){
					args.forwardButton = tfw;
				}else if(args["handle"]){
					args.handle = tfw;
				}

			}else if(dojo.render.html.moz){
				// start the timer
				if(!this.locationTimer){
					this.locationTimer = setInterval("dojo.undo.browser.checkLocation();", 200);
				}
			}
		}

		this.historyStack.push({"url": url, "kwArgs": args, "urlHash": hash});
	},

	checkLocation: function(){
		if (!this.changingUrl){
			var hsl = this.historyStack.length;
	
			if((window.location.hash == this.initialHash)||(window.location.href == this.initialHref)&&(hsl == 1)){
				// FIXME: could this ever be a forward button?
				// we can't clear it because we still need to check for forwards. Ugg.
				// clearInterval(this.locationTimer);
				this.handleBackButton();
				return;
			}
			// first check to see if we could have gone forward. We always halt on
			// a no-hash item.
			if(this.forwardStack.length > 0){
				if(this.forwardStack[this.forwardStack.length-1].urlHash == window.location.hash){
					this.handleForwardButton();
					return;
				}
			}
	
			// ok, that didn't work, try someplace back in the history stack
			if((hsl >= 2)&&(this.historyStack[hsl-2])){
				if(this.historyStack[hsl-2].urlHash==window.location.hash){
					this.handleBackButton();
					return;
				}
			}
		}
	},

	iframeLoaded: function(evt, ifrLoc){
		var query = this._getUrlQuery(ifrLoc.href);
		if(query == null){ 
			// alert("iframeLoaded");
			// we hit the end of the history, so we should go back
			if(this.historyStack.length == 1){
				this.handleBackButton();
			}
			return;
		}
		if(this.moveForward){
			// we were expecting it, so it's not either a forward or backward movement
			this.moveForward = false;
			return;
		}

		//Check the back stack first, since it is more likely.
		//Note that only one step back or forward is supported.
		if(this.historyStack.length >= 2 && query == this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){
			this.handleBackButton();
		}
		else if(this.forwardStack.length > 0 && query == this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){
			this.handleForwardButton();
		}
	},

	handleBackButton: function(){
		//The "current" page is always at the top of the history stack.
		var current = this.historyStack.pop();
		if(!current){ return; }
		var last = this.historyStack[this.historyStack.length-1];
		if(!last && this.historyStack.length == 0){
			last = this.initialState;
		}
		if (last){
			if(last.kwArgs["back"]){
				last.kwArgs["back"]();
			}else if(last.kwArgs["backButton"]){
				last.kwArgs["backButton"]();
			}else if(last.kwArgs["handle"]){
				last.kwArgs.handle("back");
			}
		}
		this.forwardStack.push(current);
	},

	handleForwardButton: function(){
		var last = this.forwardStack.pop();
		if(!last){ return; }
		if(last.kwArgs["forward"]){
			last.kwArgs.forward();
		}else if(last.kwArgs["forwardButton"]){
			last.kwArgs.forwardButton();
		}else if(last.kwArgs["handle"]){
			last.kwArgs.handle("forward");
		}
		this.historyStack.push(last);
	},

	_getUrlQuery: function(url){
		var segments = url.split("?");
		if (segments.length < 2){
			return null;
		}
		else{
			return segments[1];
		}
	}
}

__CPAN_FILE__ src/undo/Manager.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.undo.Manager");
dojo.require("dojo.lang");

dojo.undo.Manager = function(parent) {
	this.clear();
	this._parent = parent;
};
dojo.lang.extend(dojo.undo.Manager, {
	_parent: null,
	_undoStack: null,
	_redoStack: null,
	_currentManager: null,

	canUndo: false,
	canRedo: false,

	isUndoing: false,
	isRedoing: false,

	// these events allow you to hook in and update your code (UI?) as necessary
	onUndo: function(manager, item) {},
	onRedo: function(manager, item) {},

	// fired when you do *any* undo action, which means you'll have one for every item
	// in a transaction. this is usually only useful for debugging
	onUndoAny: function(manager, item) {},
	onRedoAny: function(manager, item) {},

	_updateStatus: function() {
		this.canUndo = this._undoStack.length > 0;
		this.canRedo = this._redoStack.length > 0;
	},

	clear: function() {
		this._undoStack = [];
		this._redoStack = [];
		this._currentManager = this;

		this.isUndoing = false;
		this.isRedoing = false;

		this._updateStatus();
	},

	undo: function() {
		if(!this.canUndo) { return false; }

		this.endAllTransactions();

		this.isUndoing = true;
		var top = this._undoStack.pop();
		if(top instanceof this.constructor) {
			top.undoAll();
		} else {
			top.undo();
		}
		if(top.redo) {
			this._redoStack.push(top);
		}
		this.isUndoing = false;

		this._updateStatus();
		this.onUndo(this, top);
		if(!(top instanceof this.constructor)) {
			this.getTop().onUndoAny(this, top);
		}
		return true;
	},

	redo: function() {
		if(!this.canRedo) { return false; }

		this.isRedoing = true;
		var top = this._redoStack.pop();
		if(top instanceof this.constructor) {
			top.redoAll();
		} else {
			top.redo();
		}
		this._undoStack.push(top);
		this.isRedoing = false;

		this._updateStatus();
		this.onRedo(this, top);
		if(!(top instanceof this.constructor)) {
			this.getTop().onRedoAny(this, top);
		}
		return true;
	},

	undoAll: function() {
		while(this._undoStack.length > 0) {
			this.undo();
		}
	},

	redoAll: function() {
		while(this._redoStack.length > 0) {
			this.redo();
		}
	},

	push: function(undo, redo /* optional */, description /* optional */) {
		if(!undo) { return; }

		if(this._currentManager == this) {
			this._undoStack.push({
				undo: undo,
				redo: redo,
				description: description
			});
		} else {
			this._currentManager.push.apply(this._currentManager, arguments);
		}
		// adding a new undo-able item clears out the redo stack
		this._redoStack = [];
		this._updateStatus();
	},

	concat: function(manager) {
		if ( !manager ) { return; }

		if (this._currentManager == this ) {
			for(var x=0; x < manager._undoStack.length; x++) {
				this._undoStack.push(manager._undoStack[x]);
			}
			this._updateStatus();
		} else {
			this._currentManager.concat.apply(this._currentManager, arguments);
		}
	},

	beginTransaction: function(description /* optional */) {
		if(this._currentManager == this) {
			var mgr = new dojo.undo.Manager(this);
			mgr.description = description ? description : "";
			this._undoStack.push(mgr);
			this._currentManager = mgr;
			return mgr;
		} else {
			//for nested transactions need to make sure the top level _currentManager is set
			this._currentManager = this._currentManager.beginTransaction.apply(this._currentManager, arguments);
		}
	},

	endTransaction: function(flatten /* optional */) {
		if(this._currentManager == this) {
			if(this._parent) {
				this._parent._currentManager = this._parent;
				// don't leave empty transactions hangin' around
				if(this._undoStack.length == 0 || flatten) {
					var idx = dojo.lang.find(this._parent._undoStack, this);
					if (idx >= 0) {
						this._parent._undoStack.splice(idx, 1);
						//add the current transaction to parents undo stack
						if (flatten) {
							for(var x=0; x < this._undoStack.length; x++){
								this._parent._undoStack.splice(idx++, 0, this._undoStack[x]);
							}
							this._updateStatus();
						}
					}
				}
				return this._parent;
			}
		} else {
			//for nested transactions need to make sure the top level _currentManager is set
			this._currentManager = this._currentManager.endTransaction.apply(this._currentManager, arguments);
		}
	},

	endAllTransactions: function() {
		while(this._currentManager != this) {
			this.endTransaction();
		}
	},

	// find the top parent of an undo manager
	getTop: function() {
		if(this._parent) {
			return this._parent.getTop();
		} else {
			return this;
		}
	}
});

__CPAN_FILE__ src/undo/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.undo.Manager");
dojo.provide("dojo.undo.*");

__CPAN_DIR__ src/uri
__CPAN_FILE__ src/uri/Uri.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.uri.Uri");

dojo.uri = new function() {
	this.joinPath = function() {
		// DEPRECATED: use the dojo.uri.Uri object instead
		var arr = [];
		for(var i = 0; i < arguments.length; i++) { arr.push(arguments[i]); }
		return arr.join("/").replace(/\/{2,}/g, "/").replace(/((https*|ftps*):)/i, "$1/");
	}
	
	this.dojoUri = function (uri) {
		// returns a Uri object resolved relative to the dojo root
		return new dojo.uri.Uri(dojo.hostenv.getBaseScriptUri(), uri);
	}
		
	this.Uri = function (/*uri1, uri2, [...]*/) {
		// An object representing a Uri.
		// Each argument is evaluated in order relative to the next until
		// a conanical uri is producued. To get an absolute Uri relative
		// to the current document use
		//      new dojo.uri.Uri(document.baseURI, uri)

		// TODO: support for IPv6, see RFC 2732

		// resolve uri components relative to each other
		var uri = arguments[0];
		for (var i = 1; i < arguments.length; i++) {
			if(!arguments[i]) { continue; }

			// Safari doesn't support this.constructor so we have to be explicit
			var relobj = new dojo.uri.Uri(arguments[i].toString());
			var uriobj = new dojo.uri.Uri(uri.toString());

			if (relobj.path == "" && relobj.scheme == null &&
				relobj.authority == null && relobj.query == null) {
				if (relobj.fragment != null) { uriobj.fragment = relobj.fragment; }
				relobj = uriobj;
			} else if (relobj.scheme == null) {
				relobj.scheme = uriobj.scheme;
			
				if (relobj.authority == null) {
					relobj.authority = uriobj.authority;
					
					if (relobj.path.charAt(0) != "/") {
						var path = uriobj.path.substring(0,
							uriobj.path.lastIndexOf("/") + 1) + relobj.path;

						var segs = path.split("/");
						for (var j = 0; j < segs.length; j++) {
							if (segs[j] == ".") {
								if (j == segs.length - 1) { segs[j] = ""; }
								else { segs.splice(j, 1); j--; }
							} else if (j > 0 && !(j == 1 && segs[0] == "") &&
								segs[j] == ".." && segs[j-1] != "..") {

								if (j == segs.length - 1) { segs.splice(j, 1); segs[j - 1] = ""; }
								else { segs.splice(j - 1, 2); j -= 2; }
							}
						}
						relobj.path = segs.join("/");
					}
				}
			}

			uri = "";
			if (relobj.scheme != null) { uri += relobj.scheme + ":"; }
			if (relobj.authority != null) { uri += "//" + relobj.authority; }
			uri += relobj.path;
			if (relobj.query != null) { uri += "?" + relobj.query; }
			if (relobj.fragment != null) { uri += "#" + relobj.fragment; }
		}

		this.uri = uri.toString();

		// break the uri into its main components
		var regexp = "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$";
	    var r = this.uri.match(new RegExp(regexp));

		this.scheme = r[2] || (r[1] ? "" : null);
		this.authority = r[4] || (r[3] ? "" : null);
		this.path = r[5]; // can never be undefined
		this.query = r[7] || (r[6] ? "" : null);
		this.fragment  = r[9] || (r[8] ? "" : null);
		
		if (this.authority != null) {
			// server based naming authority
			regexp = "^((([^:]+:)?([^@]+))@)?([^:]*)(:([0-9]+))?$";
			r = this.authority.match(new RegExp(regexp));
			
			this.user = r[3] || null;
			this.password = r[4] || null;
			this.host = r[5];
			this.port = r[7] || null;
		}
	
		this.toString = function(){ return this.uri; }
	}
};

__CPAN_FILE__ src/uri/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.uri.Uri", false, false]
});
dojo.provide("dojo.uri.*");

__CPAN_DIR__ src/uuid
__CPAN_FILE__ src/uuid/LightweightGenerator.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.uuid.LightweightGenerator");

/**
 * The LightweightGenerator is intended to be small and fast,
 * but not necessarily good.
 * 
 * Small: The LightweightGenerator has a small footprint. 
 * Once comments are stripped, it's only about 25 lines of 
 * code, and it doesn't dojo.require() any other packages.
 *
 * Fast: The LightweightGenerator can generate lots of new 
 * UUIDs fairly quickly (at least, more quickly than the other 
 * dojo UUID generators).
 *
 * Not necessarily good: We use Math.random() as our source
 * of randomness, which may or may not provide much randomness. 
 */
dojo.uuid.LightweightGenerator = new function() {

	var HEX_RADIX = 16;

// --------------------------------------------------
// Private functions
// --------------------------------------------------
	function _generateRandomEightCharacterHexString() {
		// Make random32bitNumber be a randomly generated floating point number
		// between 0 and (4,294,967,296 - 1), inclusive.
		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
		var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
		while (eightCharacterHexString.length < 8) {
			eightCharacterHexString = "0" + eightCharacterHexString;
		}
		return eightCharacterHexString; // for example: "3B12F1DF"
	}

// --------------------------------------------------
// Public functions
// --------------------------------------------------

/**
 * This function generates random UUIDs, meaning "version 4" UUIDs.
 * For example, a typical generated value would be something like
 * "3b12f1df-5232-4804-897e-917bf397618a".
 *
 * Examples:
 * <pre>
 *   var string = dojo.uuid.LightweightGenerator.generate();
 *   var string = dojo.uuid.LightweightGenerator.generate(String);
 *   var uuid   = dojo.uuid.LightweightGenerator.generate(dojo.uuid.Uuid);
 * </pre>
 *
 * @param	returnType	Optional. The type of instance to return.
 * @return	A newly generated version 4 UUID.
 */
	this.generate = function(returnType) {
		var hyphen = "-";
		var versionCodeForRandomlyGeneratedUuids = "4"; // 8 == binary2hex("0100")
		var variantCodeForDCEUuids = "8"; // 8 == binary2hex("1000")
		var a = _generateRandomEightCharacterHexString();
		var b = _generateRandomEightCharacterHexString();
		b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
		var c = _generateRandomEightCharacterHexString();
		c = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);
		var d = _generateRandomEightCharacterHexString();
		var returnValue = a + hyphen + b + hyphen + c + d;
		returnValue = returnValue.toLowerCase();
		if (returnType && (returnType != String)) {
			returnValue = new returnType(returnValue);
		}
		return returnValue;
	};
}();

__CPAN_FILE__ src/uuid/NameBasedGenerator.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.uuid.NameBasedGenerator");

dojo.uuid.NameBasedGenerator = new function() {

/**
 * This function generates name-based UUIDs, meaning "version 3" 
 * and "version 5" UUIDs.
 *
 * Examples:
 * <pre>
 *   var string = dojo.uuid.NameBasedGenerator.generate();
 *   var string = dojo.uuid.NameBasedGenerator.generate(String);
 *   var uuid   = dojo.uuid.NameBasedGenerator.generate(dojo.uuid.Uuid);
 * </pre>
 *
 * @param	returnType	Optional. The type of instance to return.
 * @return	A newly generated version 3 or version 5 UUID.
 */
	this.generate = function(returnType) {
		dojo.unimplemented('dojo.uuid.NameBasedGenerator.generate');
		
		// FIXME:
		// For an algorithm to generate name-based UUIDs, 
		// see sections 4.3 of RFC 4122:
		//  http://www.ietf.org/rfc/rfc4122.txt
		
		var returnValue = "00000000-0000-0000-0000-000000000000"; // FIXME
		if (returnType && (returnType != String)) {
			returnValue = new returnType(returnValue);
		}
		return returnValue;
	};
}();
__CPAN_FILE__ src/uuid/NilGenerator.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.uuid.NilGenerator");

dojo.uuid.NilGenerator = new function() {

/**
 * This function returns the Nil UUID: 
 * "00000000-0000-0000-0000-000000000000".
 * The Nil UUID is described in section 4.1.7 of
 * RFC 4122: http://www.ietf.org/rfc/rfc4122.txt
 *
 * Examples:
 * <pre>
 *   var string = dojo.uuid.NilGenerator.generate();
 *   var string = dojo.uuid.NilGenerator.generate(String);
 *   var uuid   = dojo.uuid.NilGenerator.generate(dojo.uuid.Uuid);
 * </pre>
 *
 * @param	returnType	Optional. The type of instance to return.
 * @return	The nil UUID.
 */
	this.generate = function(returnType) {
		var returnValue = "00000000-0000-0000-0000-000000000000";
		if (returnType && (returnType != String)) {
			returnValue = new returnType(returnValue);
		}
		return returnValue;
	};
}();
__CPAN_FILE__ src/uuid/RandomGenerator.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.uuid.RandomGenerator");

dojo.uuid.RandomGenerator = new function() {

/**
 * This function generates random UUIDs, meaning "version 4" UUIDs.
 * For example, a typical generated value would be something like
 * "3b12f1df-5232-4804-897e-917bf397618a".
 *
 * Examples:
 * <pre>
 *   var string = dojo.uuid.RandomGenerator.generate();
 *   var string = dojo.uuid.RandomGenerator.generate(String);
 *   var uuid   = dojo.uuid.RandomGenerator.generate(dojo.uuid.Uuid);
 * </pre>
 *
 * @param	returnType	Optional. The type of instance to return.
 * @return	A newly generated version 4 UUID.
 */
	this.generate = function(returnType) {
		dojo.unimplemented('dojo.uuid.RandomGenerator.generate');
		
		// FIXME:
		// For an algorithm to generate a random UUID, see
		// sections 4.4 and 4.5 of RFC 4122:
		//  http://www.ietf.org/rfc/rfc4122.txt
		
		var returnValue = "00000000-0000-0000-0000-000000000000"; // FIXME
		if (returnType && (returnType != String)) {
			returnValue = new returnType(returnValue);
		}
		return returnValue;
	};
}();

__CPAN_FILE__ src/uuid/TimeBasedGenerator.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.uuid.TimeBasedGenerator");
dojo.require("dojo.lang.*");

dojo.uuid.TimeBasedGenerator = new function() {

// --------------------------------------------------
// Public constants
// --------------------------------------------------
	// Number of hours between October 15, 1582 and January 1, 1970:
	this.GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
	
	// Number of seconds between October 15, 1582 and January 1, 1970:
	//   this.GREGORIAN_CHANGE_OFFSET_IN_SECONDS = 12219292800;	
	
// --------------------------------------------------
// Private variables
// --------------------------------------------------
	var _uuidPseudoNodeString = null;
	var _uuidClockSeqString = null;
	var _dateValueOfPreviousUuid = null;
	var _nextIntraMillisecondIncrement = 0;
	var _cachedMillisecondsBetween1582and1970 = null;
	var _cachedHundredNanosecondIntervalsPerMillisecond = null;
	var _uniformNode = null;
	var HEX_RADIX = 16;

// --------------------------------------------------
// Private functions
// --------------------------------------------------

/**
 * Given an array which holds a 64-bit number broken into 4 16-bit elements,
 * this method carries any excess bits (greater than 16-bits) from each array
 * element into the next.
 *
 * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
 */
	function _carry(arrayA) {
		arrayA[2] += arrayA[3] >>> 16;
		arrayA[3] &= 0xFFFF;
		arrayA[1] += arrayA[2] >>> 16;
		arrayA[2] &= 0xFFFF;
		arrayA[0] += arrayA[1] >>> 16;
		arrayA[1] &= 0xFFFF;
		dojo.lang.assert((arrayA[0] >>> 16) === 0);
	}

/**
 * Given a floating point number, this method returns an array which holds a
 * 64-bit number broken into 4 16-bit elements.
 *
 * @param	x	A floating point number.
 * @return   An array with 4 elements, each of which is a 16-bit number.
 */
	function _get64bitArrayFromFloat(x) {
		var result = new Array(0, 0, 0, 0);
		result[3] = x % 0x10000;
		x -= result[3];
		x /= 0x10000;
		result[2] = x % 0x10000;
		x -= result[2];
		x /= 0x10000;
		result[1] = x % 0x10000;
		x -= result[1];
		x /= 0x10000;
		result[0] = x;
		return result;
	}

/**
 * Takes two arrays, each of which holds a 64-bit number broken into 4
 * 16-bit elements, and returns a new array that holds a 64-bit number
 * that is the sum of the two original numbers.
 *
 * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
 * @param	arrayB	An array with 4 elements, each of which is a 16-bit number.
 * @return   An array with 4 elements, each of which is a 16-bit number.
 */
	function _addTwo64bitArrays(arrayA, arrayB) {
		dojo.lang.assertType(arrayA, Array);
		dojo.lang.assertType(arrayB, Array);
		dojo.lang.assert(arrayA.length == 4);
		dojo.lang.assert(arrayB.length == 4);
	
		var result = new Array(0, 0, 0, 0);
		result[3] = arrayA[3] + arrayB[3];
		result[2] = arrayA[2] + arrayB[2];
		result[1] = arrayA[1] + arrayB[1];
		result[0] = arrayA[0] + arrayB[0];
		_carry(result);
		return result;
	}

/**
 * Takes two arrays, each of which holds a 64-bit number broken into 4
 * 16-bit elements, and returns a new array that holds a 64-bit number
 * that is the product of the two original numbers.
 *
 * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
 * @param	arrayB	An array with 4 elements, each of which is a 16-bit number.
 * @return   An array with 4 elements, each of which is a 16-bit number.
 */
	function _multiplyTwo64bitArrays(arrayA, arrayB) {
		dojo.lang.assertType(arrayA, Array);
		dojo.lang.assertType(arrayB, Array);
		dojo.lang.assert(arrayA.length == 4);
		dojo.lang.assert(arrayB.length == 4);
	
		var overflow = false;
		if (arrayA[0] * arrayB[0] !== 0) { overflow = true; }
		if (arrayA[0] * arrayB[1] !== 0) { overflow = true; }
		if (arrayA[0] * arrayB[2] !== 0) { overflow = true; }
		if (arrayA[1] * arrayB[0] !== 0) { overflow = true; }
		if (arrayA[1] * arrayB[1] !== 0) { overflow = true; }
		if (arrayA[2] * arrayB[0] !== 0) { overflow = true; }
		dojo.lang.assert(!overflow);
	
		var result = new Array(0, 0, 0, 0);
		result[0] += arrayA[0] * arrayB[3];
		_carry(result);
		result[0] += arrayA[1] * arrayB[2];
		_carry(result);
		result[0] += arrayA[2] * arrayB[1];
		_carry(result);
		result[0] += arrayA[3] * arrayB[0];
		_carry(result);
		result[1] += arrayA[1] * arrayB[3];
		_carry(result);
		result[1] += arrayA[2] * arrayB[2];
		_carry(result);
		result[1] += arrayA[3] * arrayB[1];
		_carry(result);
		result[2] += arrayA[2] * arrayB[3];
		_carry(result);
		result[2] += arrayA[3] * arrayB[2];
		_carry(result);
		result[3] += arrayA[3] * arrayB[3];
		_carry(result);
		return result;
	}

/**
 * Pads a string with leading zeros and returns the result.
 * For example:
 * <pre>
 *   result = _padWithLeadingZeros("abc", 6);
 *   dojo.lang.assert(result == "000abc");
 * </pre>
 *
 * @param	string	A string to add padding to.
 * @param	desiredLength	The number of characters the return string should have.
 * @return   A string.
 */
	function _padWithLeadingZeros(string, desiredLength) {
		while (string.length < desiredLength) {
			string = "0" + string;
		}
		return string;
	}

/**
 * Returns a randomly generated 8-character string of hex digits.
 *
 * @return   An 8-character hex string.
 */
	function _generateRandomEightCharacterHexString() {
		// FIXME: This probably isn't a very high quality random number.
	
		// Make random32bitNumber be a randomly generated floating point number
		// between 0 and (4,294,967,296 - 1), inclusive.
		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
	
		var eightCharacterString = random32bitNumber.toString(HEX_RADIX);
		while (eightCharacterString.length < 8) {
			eightCharacterString = "0" + eightCharacterString;
		}
		return eightCharacterString;
	}

/**
 * Generates a time-based UUID, meaning a version 1 UUID.  JavaScript
 * code running in a browser doesn't have access to the IEEE 802.3 address
 * of the computer, so if a node value isn't supplied, we generate a random 
 * pseudonode value instead.
 *
 * @param	node	Optional. A 12-character string to use as the node in the new UUID.
 * @return   Returns a 36 character string, which will look something like "b4308fb0-86cd-11da-a72b-0800200c9a66".
 */
	function _generateUuidString(node) {
		dojo.lang.assertType(node, [String, "optional"]);
		if (node) {
			dojo.lang.assert(node.length == 12);
		} else {
			if (_uniformNode) {
				node = _uniformNode;
			} else {
				if (!_uuidPseudoNodeString) {
					var pseudoNodeIndicatorBit = 0x8000;
					var random15bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 15) );
					var leftmost4HexCharacters = (pseudoNodeIndicatorBit | random15bitNumber).toString(HEX_RADIX);
					_uuidPseudoNodeString = leftmost4HexCharacters + _generateRandomEightCharacterHexString();
				}
				node = _uuidPseudoNodeString;
			}
		}
		if (!_uuidClockSeqString) {
			var variantCodeForDCEUuids = 0x8000; // 10--------------, i.e. uses only first two of 16 bits.
			var random14bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 14) );
			_uuidClockSeqString = (variantCodeForDCEUuids | random14bitNumber).toString(HEX_RADIX);
		}
	
		// Maybe we should think about trying to make the code more readable to
		// newcomers by creating a class called "WholeNumber" that encapsulates
		// the methods and data structures for working with these arrays that
		// hold 4 16-bit numbers?  And then these variables below have names
		// like "wholeSecondsPerHour" rather than "arraySecondsPerHour"?
		var now = new Date();
		var millisecondsSince1970 = now.valueOf(); // milliseconds since midnight 01 January, 1970 UTC.
		var nowArray = _get64bitArrayFromFloat(millisecondsSince1970);
		if (!_cachedMillisecondsBetween1582and1970) {
			var arraySecondsPerHour = _get64bitArrayFromFloat(60 * 60);
			var arrayHoursBetween1582and1970 = _get64bitArrayFromFloat(dojo.uuid.TimeBasedGenerator.GREGORIAN_CHANGE_OFFSET_IN_HOURS);
			var arraySecondsBetween1582and1970 = _multiplyTwo64bitArrays(arrayHoursBetween1582and1970, arraySecondsPerHour);
			var arrayMillisecondsPerSecond = _get64bitArrayFromFloat(1000);
			_cachedMillisecondsBetween1582and1970 = _multiplyTwo64bitArrays(arraySecondsBetween1582and1970, arrayMillisecondsPerSecond);
			_cachedHundredNanosecondIntervalsPerMillisecond = _get64bitArrayFromFloat(10000);
		}
		var arrayMillisecondsSince1970 = nowArray;
		var arrayMillisecondsSince1582 = _addTwo64bitArrays(_cachedMillisecondsBetween1582and1970, arrayMillisecondsSince1970);
		var arrayHundredNanosecondIntervalsSince1582 = _multiplyTwo64bitArrays(arrayMillisecondsSince1582, _cachedHundredNanosecondIntervalsPerMillisecond);
	
		if (now.valueOf() == _dateValueOfPreviousUuid) {
			arrayHundredNanosecondIntervalsSince1582[3] += _nextIntraMillisecondIncrement;
			_carry(arrayHundredNanosecondIntervalsSince1582);
			_nextIntraMillisecondIncrement += 1;
			if (_nextIntraMillisecondIncrement == 10000) {
				// If we've gotten to here, it means we've already generated 10,000
				// UUIDs in this single millisecond, which is the most that the UUID
				// timestamp field allows for.  So now we'll just sit here and wait
				// for a fraction of a millisecond, so as to ensure that the next
				// time this method is called there will be a different millisecond
				// value in the timestamp field.
				while (now.valueOf() == _dateValueOfPreviousUuid) {
					now = new Date();
				}
			}
		} else {
			_dateValueOfPreviousUuid = now.valueOf();
			_nextIntraMillisecondIncrement = 1;
		}
	
		var hexTimeLowLeftHalf  = arrayHundredNanosecondIntervalsSince1582[2].toString(HEX_RADIX);
		var hexTimeLowRightHalf = arrayHundredNanosecondIntervalsSince1582[3].toString(HEX_RADIX);
		var hexTimeLow = _padWithLeadingZeros(hexTimeLowLeftHalf, 4) + _padWithLeadingZeros(hexTimeLowRightHalf, 4);
		var hexTimeMid = arrayHundredNanosecondIntervalsSince1582[1].toString(HEX_RADIX);
		hexTimeMid = _padWithLeadingZeros(hexTimeMid, 4);
		var hexTimeHigh = arrayHundredNanosecondIntervalsSince1582[0].toString(HEX_RADIX);
		hexTimeHigh = _padWithLeadingZeros(hexTimeHigh, 3);
		var hyphen = "-";
		var versionCodeForTimeBasedUuids = "1"; // binary2hex("0001")
		var resultUuid = hexTimeLow + hyphen + hexTimeMid + hyphen +
					versionCodeForTimeBasedUuids + hexTimeHigh + hyphen +
					_uuidClockSeqString + hyphen + node;
		resultUuid = resultUuid.toLowerCase();
		return resultUuid;
	}

// --------------------------------------------------
// Public functions
// --------------------------------------------------

/**
 * Sets the 'node' value that will be included in generated UUIDs.
 *
 * @param	node	A 12-character hex string representing a pseudoNode or hardwareNode.
 */
	this.setNode = function(node) {
		dojo.lang.assert((node === null) || (node.length == 12));
		_uniformNode = node;
	};

/**
 * Returns the 'node' value that will be included in generated UUIDs.
 *
 * @return	A 12-character hex string representing a pseudoNode or hardwareNode.
 */
	this.getNode = function() {
		return _uniformNode;
	};

/**
 * This function generates time-based UUIDs, meaning "version 1" UUIDs.
 *
 * For more info, see
 *   http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt
 *   http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm
 *   http://kruithof.xs4all.nl/uuid/uuidgen
 *   http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20
 *   http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html
 *
 * Examples:
 * <pre>
 *   var generate = dojo.uuid.TimeBasedGenerator.generate;
 *   var uuid;   // an instance of dojo.uuid.Uuid
 *   var string; // a simple string literal
 *   string = generate();
 *   string = generate(String);
 *   uuid   = generate(dojo.uuid.Uuid);
 *   string = generate("017bf397618a");
 *   string = generate({node: "017bf397618a"});         // hardwareNode
 *   string = generate({node: "f17bf397618a"});         // pseudoNode
 *   string = generate({hardwareNode: "017bf397618a"});
 *   string = generate({pseudoNode:   "f17bf397618a"});
 *   string = generate({node: "017bf397618a", returnType: String});
 *   uuid   = generate({node: "017bf397618a", returnType: dojo.uuid.Uuid});
 *   dojo.uuid.TimeBasedGenerator.setNode("017bf397618a");
 *   string = generate(); // the generated UUID has node == "017bf397618a"
 *   uuid   = generate(dojo.uuid.Uuid); // the generated UUID has node == "017bf397618a"
 * </pre>
 *
 * @param	class	The type of instance to return.
 * @param	node	A 12-character hex string representing a pseudoNode or hardwareNode.
 * @namedParam	node	A 12-character hex string representing a pseudoNode or hardwareNode.
 * @namedParam	hardwareNode	A 12-character hex string containing an IEEE 802.3 network node identificator.
 * @namedParam	pseudoNode	A 12-character hex string representing a pseudoNode.
 * @namedParam	returnType	The type of instance to return.
 * @return	A newly generated version 1 UUID.
 */
	this.generate = function(input) {
		var nodeString = null;
		var returnType = null;
		
		if (input) {
			if (dojo.lang.isObject(input) && !dojo.lang.isBuiltIn(input)) {
				var namedParameters = input;
				dojo.lang.assertValidKeywords(namedParameters, ["node", "hardwareNode", "pseudoNode", "returnType"]);
				var node = namedParameters["node"];
				var hardwareNode = namedParameters["hardwareNode"];
				var pseudoNode = namedParameters["pseudoNode"];
				nodeString = (node || pseudoNode || hardwareNode);
				if (nodeString) {
					var firstCharacter = nodeString.charAt(0);
					var firstDigit = parseInt(firstCharacter, HEX_RADIX);
					if (hardwareNode) {
						dojo.lang.assert((firstDigit >= 0x0) && (firstDigit <= 0x7));
					}
					if (pseudoNode) {
						dojo.lang.assert((firstDigit >= 0x8) && (firstDigit <= 0xF));
					}
				}
				returnType = namedParameters["returnType"];
				dojo.lang.assertType(returnType, [Function, "optional"]);
			} else {
				if (dojo.lang.isString(input)) {
					nodeString = input;
					returnType = null;
				} else {
					if (dojo.lang.isFunction(input)) {
						nodeString = null;
						returnType = input;
					}
				}
			}
			if (nodeString) {
				dojo.lang.assert(nodeString.length == 12);
				var integer = parseInt(nodeString, HEX_RADIX);
				dojo.lang.assert(isFinite(integer));
			}
			dojo.lang.assertType(returnType, [Function, "optional"]);
		}
		
		var uuidString = _generateUuidString(nodeString);
		var returnValue;
		if (returnType && (returnType != String)) {
			returnValue = new returnType(uuidString);
		} else {
			returnValue = uuidString;
		}
		return returnValue;
	};
}();

__CPAN_FILE__ src/uuid/Uuid.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.uuid.Uuid");
dojo.require("dojo.lang.*");

// -------------------------------------------------------------------
// Constructor
// -------------------------------------------------------------------
/**
 * The Uuid class offers methods for inspecting existing UUIDs.
 *
 * Examples:
 * <pre>
 *   var uuid;
 *   uuid = new dojo.uuid.Uuid("3b12f1df-5232-4804-897e-917bf397618a");
 *   uuid = new dojo.uuid.Uuid(); // "00000000-0000-0000-0000-000000000000"
 *   uuid = new dojo.uuid.Uuid(dojo.uuid.RandomGenerator);
 *   uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator);
 *
 *   dojo.uuid.Uuid.setGenerator(dojo.uuid.RandomGenerator);
 *   uuid = new dojo.uuid.Uuid();
 *   dojo.lang.assert(!uuid.isEqual(dojo.uuid.Uuid.NIL_UUID));
 * </pre>
 *
 * @scope	public instance constructor
 * @param	uuidString	A 36-character string that conforms to the UUID spec.
 * @param	generator	A UUID generator, such as dojo.uuid.TimeBasedGenerator.
 */
dojo.uuid.Uuid = function(input) {
	this._uuidString = dojo.uuid.Uuid.NIL_UUID;
	if (input) {
		if (dojo.lang.isString(input)) {
			this._uuidString = input.toLowerCase();
			dojo.lang.assert(this.isValid());
		} else {
			if (dojo.lang.isObject(input) && input.generate) {
				var generator = input;
				this._uuidString = generator.generate();
				dojo.lang.assert(this.isValid());
			} else {
				// we got passed something other than a string
				dojo.lang.assert(false, "The dojo.uuid.Uuid() constructor must be initializated with a UUID string.");
			}
		}
	} else {
		var ourGenerator = dojo.uuid.Uuid.getGenerator();
		if (ourGenerator) {
			this._uuidString = ourGenerator.generate();
			dojo.lang.assert(this.isValid());
		}
	}
};

// -------------------------------------------------------------------
// Public constants
// -------------------------------------------------------------------
dojo.uuid.Uuid.NIL_UUID = "00000000-0000-0000-0000-000000000000";
dojo.uuid.Uuid.Version = {
	UNKNOWN: 0,
	TIME_BASED: 1,
	DCE_SECURITY: 2,
	NAME_BASED_MD5: 3,
	RANDOM: 4,
	NAME_BASED_SHA1: 5 };
dojo.uuid.Uuid.Variant = {
	NCS: "0",
	DCE: "10",
	MICROSOFT: "110",
	UNKNOWN: "111" };
dojo.uuid.Uuid.HEX_RADIX = 16;

// -------------------------------------------------------------------
// Public class methods
// -------------------------------------------------------------------
/**
 * Given two UUIDs to compare, this method returns 0, 1, or -1.
 * This method is designed to be used by sorting routines, like
 * the JavaScript built-in Array sort() method.
 * This implementation is intended to match the sample 
 * implementation in IETF RFC 4122: 
 * http://www.ietf.org/rfc/rfc4122.txt
 * 
 * Example:
 * <pre>
 *   var generator = dojo.uuid.TimeBasedGenerator;
 *   var a = new dojo.uuid.Uuid(generator);
 *   var b = new dojo.uuid.Uuid(generator);
 *   var c = new dojo.uuid.Uuid(generator);
 *   var array = new Array(a, b, c);
 *   array.sort(dojo.uuid.Uuid.compare);
 * </pre>
 *
 * @param	uuidOne	A dojo.uuid.Uuid instance, or a string representing a UUID.
 * @param	uuidTwo	A dojo.uuid.Uuid instance, or a string representing a UUID.
 * @return   Returns either 0, 1, or -1.
 */
dojo.uuid.Uuid.compare = function(uuidOne, uuidTwo) {
	var uuidStringOne = uuidOne.toString();
	var uuidStringTwo = uuidTwo.toString();
	if (uuidStringOne > uuidStringTwo) return 1;
	if (uuidStringOne < uuidStringTwo) return -1;
	return 0;
};

/**
 * Sets the default generator, which will be used by the 
 * "new dojo.uuid.Uuid()" constructor if no parameters
 * are passed in.
 *
 * @param	generator	A UUID generator, such as dojo.uuid.TimeBasedGenerator.
 * @return   Returns true or false. True if this UUID is equal to the otherUuid.
 */
dojo.uuid.Uuid.setGenerator = function(generator) {
	dojo.lang.assert(!generator || (dojo.lang.isObject(generator) && generator.generate));
	dojo.uuid.Uuid._ourGenerator = generator;
};

/**
 * Returns the default generator.  See setGenerator().
 *
 * @return   A UUID generator, such as dojo.uuid.TimeBasedGenerator.
 */
dojo.uuid.Uuid.getGenerator = function(generator) {
	return dojo.uuid.Uuid._ourGenerator;
};

// -------------------------------------------------------------------
// Public instance methods
// -------------------------------------------------------------------
/**
 * Returns a 36-character string representing the UUID, such 
 * as "3b12f1df-5232-4804-897e-917bf397618a".
 * 
 * Examples:
 * <pre>
 *   var uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator);
 *   var s;
 *   s = uuid.toString();       //  eb529fec-6498-11d7-b236-000629ba5445
 *   s = uuid.toString('{}');   // {eb529fec-6498-11d7-b236-000629ba5445}
 *   s = uuid.toString('()');   // (eb529fec-6498-11d7-b236-000629ba5445)
 *   s = uuid.toString('""');   // "eb529fec-6498-11d7-b236-000629ba5445"
 *   s = uuid.toString("''");   // 'eb529fec-6498-11d7-b236-000629ba5445'
 *   s = uuid.toString('!-');   //  eb529fec649811d7b236000629ba5445
 *   s = uuid.toString('urn');  //  urn:uuid:eb529fec-6498-11d7-b236-000629ba5445
 * </pre>
 *
 * @param	uuidOne	A dojo.uuid.Uuid instance, or a string representing a UUID.
 * @return   Returns a standard 36-character UUID string, or something similar. 
 */
dojo.uuid.Uuid.prototype.toString = function(format) {
	if (format) {
		switch (format) {
			case '{}':
				return '{' + this._uuidString + '}';
				break;
			case '()':
				return '(' + this._uuidString + ')';
				break;
			case '""':
				return '"' + this._uuidString + '"';
				break;
			case "''":
				return "'" + this._uuidString + "'";
				break;
			case 'urn':
				return 'urn:uuid:' + this._uuidString;
				break;
			case '!-':
				return this._uuidString.split('-').join('');
				break;
			default:
				// we got passed something other than what we expected
				dojo.lang.assert(false, "The toString() method of dojo.uuid.Uuid was passed a bogus format.");
		}
	} else {
		return this._uuidString;
	}
};

/**
 * Compares this UUID to another UUID, and returns 0, 1, or -1.
 * This implementation is intended to match the sample 
 * implementation in IETF RFC 4122: 
 * http://www.ietf.org/rfc/rfc4122.txt
 *
 * @param	otherUuid	A dojo.uuid.Uuid instance, or a string representing a UUID.
 * @return   Returns either 0, 1, or -1.
 */
dojo.uuid.Uuid.prototype.compare = function(otherUuid) {
	return dojo.uuid.Uuid.compare(this, otherUuid);
};

/**
 * Returns true if this UUID is equal to the otherUuid, or
 * false otherwise.
 *
 * @param	otherUuid	A dojo.uuid.Uuid instance, or a string representing a UUID.
 * @return   Returns true or false. True if this UUID is equal to the otherUuid.
 */
dojo.uuid.Uuid.prototype.isEqual = function(otherUuid) {
	return (this.compare(otherUuid) == 0);
};

/**
 * Returns true if the UUID was initialized with a valid value.
 *
 * @return   True if the UUID is valid, or false if it is not.
 */
dojo.uuid.Uuid.prototype.isValid = function() {
	try {
		dojo.lang.assertType(this._uuidString, String);
		dojo.lang.assert(this._uuidString.length == 36);
		dojo.lang.assert(this._uuidString == this._uuidString.toLowerCase());
		var arrayOfParts = this._uuidString.split("-");
		dojo.lang.assert(arrayOfParts.length == 5);
		dojo.lang.assert(arrayOfParts[0].length == 8);
		dojo.lang.assert(arrayOfParts[1].length == 4);
		dojo.lang.assert(arrayOfParts[2].length == 4);
		dojo.lang.assert(arrayOfParts[3].length == 4);
		dojo.lang.assert(arrayOfParts[4].length == 12);
		for (var i in arrayOfParts) {
			var part = arrayOfParts[i];
			var integer = parseInt(part, dojo.uuid.Uuid.HEX_RADIX);
			dojo.lang.assert(isFinite(integer));
		}
		return true;
	} catch (e) {
		return false;
	}
};

/**
 * Returns a variant code that indicates what type of UUID this is.
 * For example:
 * <pre>
 *   var uuid = new dojo.uuid.Uuid("3b12f1df-5232-4804-897e-917bf397618a");
 *   var variant = uuid.getVariant();
 *   dojo.lang.assert(variant == dojo.uuid.Uuid.Variant.DCE);
 * </pre>
 *
 * @return   Returns one of the enumarted dojo.uuid.Uuid.Variant values.
 */
dojo.uuid.Uuid.prototype.getVariant = function() {
	// "3b12f1df-5232-4804-897e-917bf397618a"
	//                     ^
	//                     |
	//         (variant "10__" == DCE)
	var variantCharacter = this._uuidString.charAt(19);
	var variantNumber = parseInt(variantCharacter, dojo.uuid.Uuid.HEX_RADIX);
	dojo.lang.assert((variantNumber >= 0) && (variantNumber <= 16));

	if (!dojo.uuid.Uuid._ourVariantLookupTable) {
		var Variant = dojo.uuid.Uuid.Variant;
		var lookupTable = [];

		lookupTable[0x0] = Variant.NCS;       // 0000
		lookupTable[0x1] = Variant.NCS;       // 0001
		lookupTable[0x2] = Variant.NCS;       // 0010
		lookupTable[0x3] = Variant.NCS;       // 0011

		lookupTable[0x4] = Variant.NCS;       // 0100
		lookupTable[0x5] = Variant.NCS;       // 0101
		lookupTable[0x6] = Variant.NCS;       // 0110
		lookupTable[0x7] = Variant.NCS;       // 0111

		lookupTable[0x8] = Variant.DCE;       // 1000
		lookupTable[0x9] = Variant.DCE;       // 1001
		lookupTable[0xA] = Variant.DCE;       // 1010
		lookupTable[0xB] = Variant.DCE;       // 1011

		lookupTable[0xC] = Variant.MICROSOFT; // 1100
		lookupTable[0xD] = Variant.MICROSOFT; // 1101
		lookupTable[0xE] = Variant.UNKNOWN;   // 1110
		lookupTable[0xF] = Variant.UNKNOWN;   // 1111
		
		dojo.uuid.Uuid._ourVariantLookupTable = lookupTable;
	}

	return dojo.uuid.Uuid._ourVariantLookupTable[variantNumber];
};

/**
 * Returns a version number that indicates what type of UUID this is.
 * For example:
 * <pre>
 *   var uuid = new dojo.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
 *   var version = uuid.getVersion();
 *   dojo.lang.assert(version == dojo.uuid.Uuid.Version.TIME_BASED);
 * </pre>
 *
 * @return   Returns one of the enumerated dojo.uuid.Uuid.Version values.
 * @throws   Throws an Error if this is not a DCE Variant UUID.
 */
dojo.uuid.Uuid.prototype.getVersion = function() {
	if (!this._versionNumber) {
		var errorMessage = "Called getVersion() on a dojo.uuid.Uuid that was not a DCE Variant UUID.";
		dojo.lang.assert(this.getVariant() == dojo.uuid.Uuid.Variant.DCE, errorMessage);
	
		// "b4308fb0-86cd-11da-a72b-0800200c9a66"
		//                ^
		//                |
		//       (version 1 == TIME_BASED)
		var versionCharacter = this._uuidString.charAt(14);
		this._versionNumber = parseInt(versionCharacter, dojo.uuid.Uuid.HEX_RADIX);
	}
	return this._versionNumber;
};

/**
 * If this is a version 1 UUID (a time-based UUID), this method returns a 
 * 12-character string with the "node" or "pseudonode" portion of the UUID, 
 * which is the rightmost 12 characters.  
 * Throws an Error if this is not a version 1 UUID.
 *
 * @return   Returns a 12-character string, which will look something like "917bf397618a".
 * @throws   Throws an Error if this is not a version 1 UUID.
 */
dojo.uuid.Uuid.prototype.getNode = function() {
	if (!this._nodeString) {
		var errorMessage = "Called getNode() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.";
		dojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);

		var arrayOfStrings = this._uuidString.split('-');
		this._nodeString = arrayOfStrings[4];
	}
	return this._nodeString;
};

/**
 * If this is a version 1 UUID (a time-based UUID), this method returns 
 * the timestamp value encoded in the UUID.  The caller can ask for the
 * timestamp to be returned either as a JavaScript Date object or as a 
 * 15-character string of hex digits.
 * Throws an Error if this is not a version 1 UUID.
 *
 * Examples:
 * <pre>
 *   var uuid = new dojo.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
 *   var date, string, hexString;
 *   date   = uuid.getTimestamp();         // returns a JavaScript Date
 *   date   = uuid.getTimestamp(Date);     // 
 *   string = uuid.getTimestamp(String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
 *   hexString = uuid.getTimestamp("hex"); // "1da86cdb4308fb0"
 * </pre>
 *
 * @return   Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
 * @throws   Throws an Error if this is not a version 1 UUID.
 */
dojo.uuid.Uuid.prototype.getTimestamp = function(returnType) {
	var errorMessage = "Called getTimestamp() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.";
	dojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);
	
	if (!returnType) {returnType = null};
	switch (returnType) {
		case "string":
		case String:
			return this.getTimestamp(Date).toUTCString();
			break;
		case "hex":
			// Return a 15-character string of hex digits containing the 
			// timestamp for this UUID, with the high-order bits first.
			if (!this._timestampAsHexString) {
				var arrayOfStrings = this._uuidString.split('-');
				var hexTimeLow = arrayOfStrings[0];
				var hexTimeMid = arrayOfStrings[1];
				var hexTimeHigh = arrayOfStrings[2];
			
				// Chop off the leading "1" character, which is the UUID 
				// version number for time-based UUIDs.
				hexTimeHigh = hexTimeHigh.slice(1);
			
				this._timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;
				dojo.lang.assert(this._timestampAsHexString.length == 15);
			}
			return this._timestampAsHexString;
			break;
		case null: // no returnType was specified, so default to Date
		case "date":
		case Date:
			// Return a JavaScript Date object. 
			if (!this._timestampAsDate) {
				var GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
			
				var arrayOfParts = this._uuidString.split('-');
				var timeLow = parseInt(arrayOfParts[0], dojo.uuid.Uuid.HEX_RADIX);
				var timeMid = parseInt(arrayOfParts[1], dojo.uuid.Uuid.HEX_RADIX);
				var timeHigh = parseInt(arrayOfParts[2], dojo.uuid.Uuid.HEX_RADIX);
				var hundredNanosecondIntervalsSince1582 = timeHigh & 0x0FFF;
				hundredNanosecondIntervalsSince1582 <<= 16;
				hundredNanosecondIntervalsSince1582 += timeMid;
				// What we really want to do next is shift left 32 bits, but the 
				// result will be too big to fit in an int, so we'll multiply by 2^32,
				// and the result will be a floating point approximation.
				hundredNanosecondIntervalsSince1582 *= 0x100000000;
				hundredNanosecondIntervalsSince1582 += timeLow;
				var millisecondsSince1582 = hundredNanosecondIntervalsSince1582 / 10000;
			
				// Again, this will be a floating point approximation.
				// We can make things exact later if we need to.
				var secondsPerHour = 60 * 60;
				var hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;
				var secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;
				var millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;
				var millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;
			
				this._timestampAsDate = new Date(millisecondsSince1970);
			}
			return this._timestampAsDate;
			break;
		default:
			// we got passed something other than a valid returnType
			dojo.lang.assert(false, "The getTimestamp() method dojo.uuid.Uuid was passed a bogus returnType: " + returnType);
			break;
	}
};

__CPAN_FILE__ src/uuid/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: [
		"dojo.uuid.Uuid",
		"dojo.uuid.LightweightGenerator",
		"dojo.uuid.RandomGenerator",
		"dojo.uuid.TimeBasedGenerator",
		"dojo.uuid.NameBasedGenerator",
		"dojo.uuid.NilGenerator"
	]
});
dojo.provide("dojo.uuid.*");


__CPAN_DIR__ src/widget
__CPAN_FILE__ src/widget/AccordionContainer.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.AccordionContainer");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.AccordionPane");

dojo.widget.AccordionContainer = function(){
	dojo.widget.HtmlWidget.call(this);
	this.widgetType = "AccordionContainer";
	this.isContainer=true;	

	this.labelNodeClass="";
	this.containerNodeClass="";

	this.allowCollapse=false;
}

dojo.inherits(dojo.widget.AccordionContainer, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.AccordionContainer, {
	addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){

		if (widget.widgetType != "AccordionPane") {
			var wrapper=dojo.widget.createWidget("AccordionPane",{label: widget.label, open: widget.open, labelNodeClass: this.labelNodeClass, containerNodeClass: this.containerNodeClass, allowCollapse: this.allowCollapse });
			wrapper.addChild(widget);
			this.addWidgetAsDirectChild(wrapper);
			this.registerChild(wrapper);
			wrapper.setSizes();
			return wrapper;
		} else {
			dojo.html.addClass(widget.containerNode, this.containerNodeClass);
			dojo.html.addClass(widget.labelNode, this.labelNodeClass);
			this.addWidgetAsDirectChild(widget);
			this.registerChild(widget);	
			widget.setSizes();
			return widget;
		}
        },

	postCreate: function() {
		var tmpChildren = this.children;
		this.children=[];
		dojo.html.removeChildren(this.domNode);
		dojo.lang.forEach(tmpChildren, dojo.lang.hitch(this,"addChild"));
	},

	removeChild: function(widget) {
		dojo.widget.AccordionContainer.superclass.removeChild.call(this, widget.parent);
		this.children[0].setSizes();
	},
	
	onResized: function(){
		this.children[0].setSizes();
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:AccordionContainer");

// These arguments can be specified for the children of a Accordion
// Since any widget can be specified as a child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.lang.extend(dojo.widget.Widget, {
        label: "",
	open: false
});


__CPAN_FILE__ src/widget/AccordionPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.AccordionPane");
dojo.requireAfterIf("html", "dojo.widget.html.AccordionPane");

__CPAN_FILE__ src/widget/Button.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Button");
dojo.provide("dojo.widget.DropDownButton");
dojo.provide("dojo.widget.ComboButton");
dojo.require("dojo.widget.Widget");

dojo.widget.tags.addParseTreeHandler("dojo:Button");
dojo.widget.tags.addParseTreeHandler("dojo:dropdownButton");
dojo.widget.tags.addParseTreeHandler("dojo:comboButton");

dojo.widget.Button = function(){
}
dojo.lang.extend(dojo.widget.Button, {
	widgetType: "Button",
	isContainer: true,

	// Constructor arguments
	caption: "",
	disabled: false,
	onClick: function(){ }
});

dojo.widget.DropDownButton = function(){
}
dojo.inherits(dojo.widget.DropDownButton, dojo.widget.Button);
dojo.lang.extend(dojo.widget.DropDownButton, {
	widgetType: "DropDownButton",
	isContainer: true,

	// constructor arguments
	menuId: ''
});

dojo.widget.ComboButton = function(){
}
dojo.inherits(dojo.widget.ComboButton, dojo.widget.Button);
dojo.lang.extend(dojo.widget.ComboButton, {
	widgetType: "ComboButton",
	isContainer: true,

	// constructor arguments
	menuId: ''
});

dojo.requireAfterIf("html", "dojo.widget.html.Button");

__CPAN_FILE__ src/widget/Button2.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Button2");
dojo.require("dojo.widget.Button");
dojo.require("dojo.widget.*");

dojo.widget.tags.addParseTreeHandler("dojo:button2");
dojo.widget.tags.addParseTreeHandler("dojo:dropdownbutton2");
dojo.widget.tags.addParseTreeHandler("dojo:combobutton2");

dojo.deprecated("dojo.widget.Button2", "Use dojo.widget.Button instead", "0.4");

dojo.requireAfterIf("html", "dojo.widget.html.Button2");

dojo.widget.Button2 = function(){}
dojo.inherits(dojo.widget.Button2, dojo.widget.Button);
dojo.lang.extend(dojo.widget.Button2, { widgetType: "Button2" });

dojo.widget.DropDownButton2 = function(){}
dojo.inherits(dojo.widget.DropDownButton2, dojo.widget.DropDownButton);
dojo.lang.extend(dojo.widget.DropDownButton2, { widgetType: "DropDownButton2" });

dojo.widget.ComboButton2 = function(){}
dojo.inherits(dojo.widget.ComboButton2, dojo.widget.ComboButton);
dojo.lang.extend(dojo.widget.ComboButton2, { widgetType: "ComboButton2" });

__CPAN_FILE__ src/widget/Chart.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Chart");
dojo.provide("dojo.widget.Chart.PlotTypes");
dojo.provide("dojo.widget.Chart.DataSeries");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.Widget");
dojo.require("dojo.graphics.color");
dojo.require("dojo.graphics.color.hsl");
dojo.widget.tags.addParseTreeHandler("dojo:chart");

dojo.widget.Chart=function(){
	dojo.widget.Widget.call(this);
	this.widgetType="Chart";
	this.isContainer=false;
	this.series=[];
	this.assignColors=function(){
		var hue=30, sat=120, lum=120;
		var steps = Math.round(330/this.series.length);
		for (var i=0; i<this.series.length; i++){
			var c=dojo.graphics.color.hsl2rgb(hue,sat,lum);
			if (!this.series[i].color) 
				this.series[i].color=dojo.graphics.color.rgb2hex(c[0],c[1],c[2]);
			hue+=steps;
		}
	};
}
dojo.inherits(dojo.widget.Chart, dojo.widget.Widget);

dojo.widget.Chart.PlotTypes = {
	Bar:"bar",
	Line:"line",
	Scatter:"scatter",
	Bubble:"bubble"
};

/*  Every chart has a set of data series; this is the series.
	Note that each member of value is an object and in the
	minimum has 2 properties: .x and .value.
 */
dojo.widget.Chart.DataSeries=function(key, label, plotType, color){
	this.id="DataSeries"+dojo.widget.Chart.DataSeries.count++;
	this.key=key;
	this.label=label||this.id;
	this.plotType=plotType||0;
	this.color=color;
	this.values=[];
};
dojo.widget.Chart.DataSeries.prototype={
	add:function(v){
		if(v.x==null||v.value==null){
			dojo.raise("dojo.widget.Chart.DataSeries.add: v must have both an 'x' and 'value' property.");
		}
		this.values.push(v);
	},
	clear:function(){
		this.values=[];
	},
	createRange:function(len){
		var idx=this.values.length-1;
		var length=len||this.values.length;
		return {index:idx, length:length, start:Math.max(idx-length,0)};
	},
	//	trend values
	getMean:function(len){
		var range=this.createRange(len);
		if (range.index<0) return 0;
		var t=0, c=0;
		for (var i=range.index; i>=range.start; i--){
			var n=parseFloat(this.values[i].value);
			if (!isNaN(n)){
				t+=n; c++;
			}
		}
		t/=Math.max(c,1);
		return t;
	},
	getMovingAverage:function(len){
		var range=this.createRange(len);
		if (range.index<0) return 0;
		var t=0, c=0;
		for (var i=range.index; i>=range.start; i--){
			var n=parseFloat(this.values[i].value);
			if (!isNaN(n)){
				t+=n; c++;
			}
		}
		t/=Math.max(c,1);
		return t;
	},
	getVariance:function(len){
		var range=this.createRange(len);
		if (range.index < 0) return 0;
		var t=0, s=0, c=0;
		for (var i=range.index; i>=range.start; i--){
			var n=parseFloat(this.values[i].value);
			if (!isNaN(n)){
				t+=n;
				s+=Math.pow(n,2);
				c++;
			}
		}
		return (s/c)-Math.pow(t/c,2);
	},
	getStandardDeviation:function(len){
		return Math.sqrt(this.getVariance(len));
	},
	getMax:function(len){
		var range=this.createRange(len);
		if (range.index < 0) return 0;
		var t=0;
		for (var i=range.index; i>=range.start; i--){
			var n=parseFloat(this.values[i].value);
			if (!isNaN(n)){
				t=Math.max(n,t);
			}
		}
		return t;
	},
	getMin:function(len){
		var range=this.createRange(len);
		if (range.index < 0) return 0;
		var t=0;
		for (var i=range.index; i>=range.start; i--){
			var n=parseFloat(this.values[i].value);
			if (!isNaN(n)){
				t=Math.min(n,t);
			}
		}
		return t;
	},
	getMedian:function(len){
		var range=this.createRange(len);
		if (range.index<0) return 0;
		var a=[];
		for (var i=range.index; i>=range.start; i--){
			var n=parseFloat(this.values[i].value);
			if (!isNaN(n)){
				var b=false;
				for(var j=0; j<a.length&&!b; j++){
					if (n==a[j]) b=true; 
				}
				if(!b) a.push(n);
			}
		}
		a.sort();
		if(a.length>0) return a[Math.ceil(a.length/2)];
		return 0;
	},
	getMode:function(len){
		var range=this.createRange(len);
		if (range.index<0) return 0;
		var o={}, ret=0, m=0;
		for (var i=range.index; i>=range.start; i--){
			var n=parseFloat(this.values[i].value);
			if (!isNaN(n)){
				if (!o[this.values[i].value]) o[this.values[i].value] = 1;
				else o[this.values[i].value]++;
			}
		}
		for (var p in o){
			if(m<o[p]){
				m=o[p]; ret=p;
			}
		}
		return parseFloat(ret);
	}
};

if(dojo.render.svg.support.builtin){
	dojo.require("dojo.widget.svg.Chart");
}else if(dojo.render.html.ie){
	dojo.require("dojo.widget.vml.Chart");
}

__CPAN_FILE__ src/widget/Checkbox.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Checkbox");

dojo.require("dojo.widget.*");
dojo.require("dojo.event");
dojo.require("dojo.html");

dojo.widget.tags.addParseTreeHandler("dojo:Checkbox");

dojo.widget.Checkbox = function(){
	dojo.widget.Widget.call(this);
};
dojo.inherits(dojo.widget.Checkbox, dojo.widget.Widget);

dojo.lang.extend(dojo.widget.Checkbox, {
	widgetType: "Checkbox"
});

dojo.requireAfterIf("html", "dojo.widget.html.Checkbox");

__CPAN_FILE__ src/widget/CiviCrmDatePicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.CiviCrmDatePicker");
dojo.provide("dojo.widget.HtmlCiviCrmDatePicker");
dojo.require("dojo.widget.*");
dojo.require("dojo.event.*");
dojo.require("dojo.widget.DatePicker");
dojo.require("dojo.widget.html.DatePicker");
dojo.require("dojo.widget.html.TimePicker");
dojo.require("dojo.html");

dojo.widget.HtmlCiviCrmDatePicker = function(){
	this.widgetType = "CiviCrmDatePicker";
	this.idPrefix = "scheduled_date_time";
	this.mode = "datetime"; // can also be date or time

	this.datePicker = null;
	this.timePicker = null;

	// html nodes
	this.dateHolderTd = null;
	this.timeHolderTd = null;
	this.formItemsTd = null;
	this.formItemsTr = null;

	this.monthSelect = null;
	this.daySelect = null;
	this.yearSelect = null;
	this.hourSelect = null;
	this.minSelect = null;
	this.apSelect = null;

	this.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlCiviCrmDatePicker.html");

	this.modeFormats = {
		date: "MdY",
		time: "hiA"
	};

	this.formatMappings = {
		"M": "monthSelect",
		"d": "daySelect",
		"Y": "yearSelect",
		"h": "hourSelect",
		"i": "minSelect",
		"A": "apSelect"
	};

	this.setDateSelects = function(){
		var dateObj = this.datePicker.date;
		this.monthSelect.value = new String(dateObj.getMonth()+1);
		this.daySelect.value = new String(dateObj.getDate());
		this.yearSelect.value = new String(dateObj.getFullYear());
	}

	this.setTimeSelects = function(){
		var st = this.timePicker.selectedTime;
		this.hourSelect.value = new String(st.hour);
		this.minSelect.value = new String(st.minute);
		this.apSelect.value = st.amPm.toUpperCase();
	}

	this.fillInTemplate = function(args, frag){
		var nr = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
		var sref = {};
		while(nr.firstChild){
			if(nr.firstChild.name){
				sref[nr.firstChild.name] = nr.firstChild;
			}
			this.formItemsTd.appendChild(nr.firstChild);
		}

		if(this.mode.indexOf("date") != -1){
			this.datePicker = dojo.widget.createWidget("DatePicker", {}, this.dateHolderTd);
			dojo.event.connect(	this.datePicker, "onSetDate", 
								this, "setDateSelects");

			var mfd = this.modeFormats.date;
			for(var x=0; x<mfd.length; x++){
				this[this.formatMappings[mfd[x]]] = sref[this.idPrefix+"["+mfd[x]+"]"];
				fr = this[this.formatMappings[mfd[x]]].form;
			}
		}
		if(this.mode.indexOf("time") != -1){
			this.timePicker = dojo.widget.createWidget("TimePicker", {}, this.timeHolderTd);
			dojo.event.connect(	this.timePicker, "onSetTime", 
								this, "setTimeSelects");
			var mfd = this.modeFormats.time;
			for(var x=0; x<mfd.length; x++){
				this[this.formatMappings[mfd[x]]] = sref[this.idPrefix+"["+mfd[x]+"]"];
			}
		}
	}

	this.unhide = function(){
		this.formItemsTr.style.display = "";
	}

	this.postCreate = function(){
		dojo.event.kwConnect({
			type: "before", 
			srcObj: dojo.html.getParentByType(this.domNode, "form"),
			srcFunc: "onsubmit", 
			targetObj: this,
			targetFunc: "unhide"
		});
	}
}
dojo.inherits(dojo.widget.HtmlCiviCrmDatePicker, dojo.widget.HtmlWidget);
dojo.widget.tags.addParseTreeHandler("dojo:civicrmdatepicker");


__CPAN_FILE__ src/widget/ColorPalette.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.ColorPalette");
dojo.provide("dojo.widget.html.ColorPalette");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.Toolbar");
dojo.require("dojo.html");

dojo.widget.tags.addParseTreeHandler("dojo:ToolbarColorDialog");

dojo.widget.html.ToolbarColorDialog = function(){
	dojo.widget.html.ToolbarDialog.call(this);
	
	/*
	FIXME: 	why the fuck did anyone ever think this kind of expensive iteration
			was a good idea?

	for (var method in this.constructor.prototype) {
		this[method] = this.constructor.prototype[method];
	}
	*/
}

dojo.inherits(dojo.widget.html.ToolbarColorDialog, dojo.widget.html.ToolbarDialog);

dojo.lang.extend(dojo.widget.html.ToolbarColorDialog, {

	widgetType: "ToolbarColorDialog",

	palette: "7x10",

	fillInTemplate: function (args, frag) {
		dojo.widget.html.ToolbarColorDialog.superclass.fillInTemplate.call(this, args, frag);
		this.dialog = dojo.widget.createWidget("ColorPalette", {palette: this.palette});
		this.dialog.domNode.style.position = "absolute";

		dojo.event.connect(this.dialog, "onColorSelect", this, "_setValue");
	},

	_setValue: function(color) {
		this._value = color;
		this._fireEvent("onSetValue", color);
	},
	
	showDialog: function (e) {
		dojo.widget.html.ToolbarColorDialog.superclass.showDialog.call(this, e);
		var x = dojo.html.getAbsoluteX(this.domNode);
		var y = dojo.html.getAbsoluteY(this.domNode) + dojo.html.getInnerHeight(this.domNode);
		this.dialog.showAt(x, y);
	},
	
	hideDialog: function (e) {
		dojo.widget.html.ToolbarColorDialog.superclass.hideDialog.call(this, e);
		this.dialog.hide();
	}
});



dojo.widget.tags.addParseTreeHandler("dojo:colorpalette");

dojo.widget.html.ColorPalette = function () {
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.html.ColorPalette, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.ColorPalette, {

	widgetType: "colorpalette",
	
	palette: "7x10",

	bgIframe: null,
	
	palettes: {
		"7x10": [["fff", "fcc", "fc9", "ff9", "ffc", "9f9", "9ff", "cff", "ccf", "fcf"],
			["ccc", "f66", "f96", "ff6", "ff3", "6f9", "3ff", "6ff", "99f", "f9f"],
			["c0c0c0", "f00", "f90", "fc6", "ff0", "3f3", "6cc", "3cf", "66c", "c6c"],
			["999", "c00", "f60", "fc3", "fc0", "3c0", "0cc", "36f", "63f", "c3c"],
			["666", "900", "c60", "c93", "990", "090", "399", "33f", "60c", "939"],
			["333", "600", "930", "963", "660", "060", "366", "009", "339", "636"],
			["000", "300", "630", "633", "330", "030", "033", "006", "309", "303"]],
	
		"3x4": [["ffffff"/*white*/, "00ff00"/*lime*/, "008000"/*green*/, "0000ff"/*blue*/],
			["c0c0c0"/*silver*/, "ffff00"/*yellow*/, "ff00ff"/*fuchsia*/, "000080"/*navy*/],
			["808080"/*gray*/, "ff0000"/*red*/, "800080"/*purple*/, "000000"/*black*/]]
			//["00ffff"/*aqua*/, "808000"/*olive*/, "800000"/*maroon*/, "008080"/*teal*/]];
	},

	buildRendering: function () {
		
		this.domNode = document.createElement("table");
		dojo.html.disableSelection(this.domNode);
		dojo.event.connect(this.domNode, "onmousedown", function (e) {
			e.preventDefault();
		});
		with (this.domNode) { // set the table's properties
			cellPadding = "0"; cellSpacing = "1"; border = "1";
			style.backgroundColor = "white"; //style.position = "absolute";
		}
		var tbody = document.createElement("tbody");
		this.domNode.appendChild(tbody);
		var colors = this.palettes[this.palette];
		for (var i = 0; i < colors.length; i++) {
			var tr = document.createElement("tr");
			for (var j = 0; j < colors[i].length; j++) {
				if (colors[i][j].length == 3) {
					colors[i][j] = colors[i][j].replace(/(.)(.)(.)/, "$1$1$2$2$3$3");
				}
	
				var td = document.createElement("td");
				with (td.style) {
					backgroundColor = "#" + colors[i][j];
					border = "1px solid gray";
					width = height = "15px";
					fontSize = "1px";
				}
	
				td.color = "#" + colors[i][j];
	
				td.onmouseover = function (e) { this.style.borderColor = "white"; }
				td.onmouseout = function (e) { this.style.borderColor = "gray"; }
				dojo.event.connect(td, "onmousedown", this, "click");
	
				td.innerHTML = "&nbsp;";
				tr.appendChild(td);
			}
			tbody.appendChild(tr);
		}

		if(dojo.render.html.ie){
			this.bgIframe = document.createElement("<iframe frameborder='0' src='javascript:void(0);'>");
			with(this.bgIframe.style){
				position = "absolute";
				left = top = "0px";
				display = "none";
			}
			document.body.appendChild(this.bgIframe);
			dojo.style.setOpacity(this.bgIframe, 0);
		}
	},

	click: function (e) {
		this.onColorSelect(e.currentTarget.color);
		e.currentTarget.style.borderColor = "gray";
	},

	onColorSelect: function (color) { },

	hide: function (){
		this.domNode.parentNode.removeChild(this.domNode);
		if(this.bgIframe){
			this.bgIframe.style.display = "none";
		}
	},
	
	showAt: function (x, y) {
		with(this.domNode.style){
			top = y + "px";
			left = x + "px";
			zIndex = 999;
		}
		document.body.appendChild(this.domNode);
		if(this.bgIframe){
			with(this.bgIframe.style){
				display = "block";
				top = y + "px";
				left = x + "px";
				zIndex = 998;
				width = dojo.html.getOuterWidth(this.domNode) + "px";
				height = dojo.html.getOuterHeight(this.domNode) + "px";
			}

		}
	}

});

__CPAN_FILE__ src/widget/ComboBox.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.ComboBox");

dojo.require("dojo.widget.*");
dojo.require("dojo.event.*");

dojo.widget.incrementalComboBoxDataProvider = function(url, limit, timeout){
	this.searchUrl = url;
	this.inFlight = false;
	this.activeRequest = null;
	this.allowCache = false;

	this.cache = {};
	this.addToCache = function(keyword, data){
		if(this.allowCache){
			this.cache[keyword] = data;
		}
	}

	this.startSearch = function(searchStr, type, ignoreLimit){
		if(this.inFlight){
			// FIXME: implement backoff!
		}
		var tss = encodeURIComponent(searchStr);
		var realUrl = dojo.string.paramString(this.searchUrl, {"searchString": tss});
		var _this = this;
		var request = dojo.io.bind({
			url: realUrl,
			method: "get",
			mimetype: "text/json",
			load: function(type, data, evt){
				_this.inFlight = false;
				if(!dojo.lang.isArray(data)){
					var arrData = [];
					for(var key in data){
						arrData.push([data[key], key]);
					}
					data = arrData;
				}
				_this.addToCache(searchStr, data);
				_this.provideSearchResults(data);
			}
		});
		this.inFlight = true;
	}
}

dojo.widget.ComboBoxDataProvider = function(dataPairs, limit, timeout){
	// NOTE: this data provider is designed as a naive reference
	// implementation, and as such it is written more for readability than
	// speed. A deployable data provider would implement lookups, search
	// caching (and invalidation), and a significantly less naive data
	// structure for storage of items.

	this.data = [];
	this.searchTimeout = 500;
	this.searchLimit = 30;
	this.searchType = "STARTSTRING"; // may also be "STARTWORD" or "SUBSTRING"
	this.caseSensitive = false;
	// for caching optimizations
	this._lastSearch = "";
	this._lastSearchResults = null;

	this.startSearch = function(searchStr, type, ignoreLimit){
		// FIXME: need to add timeout handling here!!
		this._preformSearch(searchStr, type, ignoreLimit);
	}

	this._preformSearch = function(searchStr, type, ignoreLimit){
		//
		//	NOTE: this search is LINEAR, which means that it exhibits perhaps
		//	the worst possible speed charachteristics of any search type. It's
		//	written this way to outline the responsibilities and interfaces for
		//	a search.
		//
		var st = type||this.searchType;
		// FIXME: this is just an example search, which means that we implement
		// only a linear search without any of the attendant (useful!) optimizations
		var ret = [];
		if(!this.caseSensitive){
			searchStr = searchStr.toLowerCase();
		}
		for(var x=0; x<this.data.length; x++){
			if((!ignoreLimit)&&(ret.length >= this.searchLimit)){
				break;
			}
			// FIXME: we should avoid copies if possible!
			var dataLabel = new String((!this.caseSensitive) ? this.data[x][0].toLowerCase() : this.data[x][0]);
			if(dataLabel.length < searchStr.length){
				// this won't ever be a good search, will it? What if we start
				// to support regex search?
				continue;
			}

			if(st == "STARTSTRING"){
				// jum.debug(dataLabel.substr(0, searchStr.length))
				// jum.debug(searchStr);
				if(searchStr == dataLabel.substr(0, searchStr.length)){
					ret.push(this.data[x]);
				}
			}else if(st == "SUBSTRING"){
				// this one is a gimmie
				if(dataLabel.indexOf(searchStr) >= 0){
					ret.push(this.data[x]);
				}
			}else if(st == "STARTWORD"){
				// do a substring search and then attempt to determine if the
				// preceeding char was the beginning of the string or a
				// whitespace char.
				var idx = dataLabel.indexOf(searchStr);
				if(idx == 0){
					// implicit match
					ret.push(this.data[x]);
				}
				if(idx <= 0){
					// if we didn't match or implicily matched, march onward
					continue;
				}
				// otherwise, we have to go figure out if the match was at the
				// start of a word...
				// this code is taken almost directy from nWidgets
				var matches = false;
				while(idx!=-1){
					// make sure the match either starts whole string, or
					// follows a space, or follows some punctuation
					if(" ,/(".indexOf(dataLabel.charAt(idx-1)) != -1){
						// FIXME: what about tab chars?
						matches = true; break;
					}
					idx = dataLabel.indexOf(searchStr, tti+1);
				}
				if(!matches){
					continue;
				}else{
					ret.push(this.data[x]);
				}
			}
		}
		this.provideSearchResults(ret);
	}

	this.provideSearchResults = function(resultsDataPairs){
	}

	this.addData = function(pairs){
		// FIXME: incredibly naive and slow!
		this.data = this.data.concat(pairs);
	}

	this.setData = function(pdata){
		// populate this.data and initialize lookup structures
		this.data = pdata;
	}
	
	if(dataPairs){
		this.setData(dataPairs);
	}
}

dojo.widget.ComboBox = function(){
	dojo.widget.Widget.call(this);
}

dojo.inherits(dojo.widget.ComboBox, dojo.widget.Widget);

dojo.widget.ComboBox.defaults = {
	widgetType: "ComboBox",
	isContainer: false,

	forceValidOption: false,
	searchType: "stringstart",
	dataProvider: null,

	startSearch: function(searchString){},
	openResultList: function(results){},
	clearResultList: function(){},
	hideResultList: function(){},
	selectNextResult: function(){},
	selectPrevResult: function(){},
	setSelectedResult: function(){}
};

dojo.lang.extend(dojo.widget.ComboBox, dojo.widget.ComboBox.defaults);

dojo.widget.DomComboBox = function(){
	dojo.widget.ComboBox.call(this);
	dojo.widget.DomWidget.call(this, true);
}

dojo.inherits(dojo.widget.DomComboBox, dojo.widget.DomWidget);
dojo.widget.tags.addParseTreeHandler("dojo:combobox");

// render-specific includes
dojo.requireAfterIf("html", "dojo.widget.html.ComboBox");


__CPAN_FILE__ src/widget/ContentPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

// This widget doesn't do anything; is basically the same as <div>.
// It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
// But note that those classes can contain any widget as a child.

dojo.provide("dojo.widget.ContentPane");
dojo.requireAfterIf("html", "dojo.widget.html.ContentPane");

__CPAN_FILE__ src/widget/ContextMenu.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.ContextMenu");

dojo.deprecated("dojo.widget.ContextMenu",  "use dojo.widget.Menu2", "0.4");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.DomWidget");

dojo.widget.ContextMenu = function(){
	dojo.widget.Widget.call(this);
	this.widgetType = "ContextMenu";
	this.isContainer = true;
	this.isOpened = false;
	
	// copy children widgets output directly to parent (this node), to avoid
	// errors trying to insert an <li> under a <div>
	this.snarfChildDomOutput = true;

}

dojo.inherits(dojo.widget.ContextMenu, dojo.widget.Widget);
dojo.widget.tags.addParseTreeHandler("dojo:contextmenu");

dojo.requireAfterIf("html", "dojo.widget.html.ContextMenu");

__CPAN_FILE__ src/widget/DatePicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DatePicker");
dojo.provide("dojo.widget.DatePicker.util");
dojo.require("dojo.widget.DomWidget");
dojo.require("dojo.date");

dojo.widget.DatePicker = function(){
	dojo.widget.Widget.call(this);
	this.widgetType = "DatePicker";
	this.isContainer = false;
	// the following aliases prevent breaking people using 0.2.x
	this.months = dojo.date.months;
	this.weekdays = dojo.date.days;
	this.toRfcDate = dojo.widget.DatePicker.util.toRfcDate;
	this.fromRfcDate = dojo.widget.DatePicker.util.fromRfcDate;
	this.initFirstSaturday = dojo.widget.DatePicker.util.initFirstSaturday;
}

dojo.inherits(dojo.widget.DatePicker, dojo.widget.Widget);
dojo.widget.tags.addParseTreeHandler("dojo:datepicker");

dojo.requireAfterIf("html", "dojo.widget.html.DatePicker");

dojo.widget.DatePicker.util = new function() {
	this.months = dojo.date.months;
	this.weekdays = dojo.date.days;
	
	this.toRfcDate = function(jsDate) {
		if(!jsDate) {
			var jsDate = new Date();
		}
		// because this is a date picker and not a time picker, we don't return a time
		return dojo.date.format(jsDate, "%Y-%m-%d");
	}
	
	this.fromRfcDate = function(rfcDate) {
		// backwards compatible support for use of "any" instead of just not 
		// including the time
		if(rfcDate.indexOf("Tany")!=-1) {
			rfcDate = rfcDate.replace("Tany","");
		}
		var jsDate = new Date();
		dojo.date.setIso8601(jsDate, rfcDate);
		return jsDate;
	}
	
	this.initFirstSaturday = function(month, year) {
		if(!month) {
			month = this.date.getMonth();
		}
		if(!year) {
			year = this.date.getFullYear();
		}
		var firstOfMonth = new Date(year, month, 1);
		return {year: year, month: month, date: 7 - firstOfMonth.getDay()};
	}
}

__CPAN_FILE__ src/widget/DebugConsole.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DebugConsole");
dojo.require("dojo.widget.Widget");

dojo.widget.DebugConsole= function(){
	dojo.widget.Widget.call(this);

	this.widgetType = "DebugConsole";
	this.isContainer = true;
}
dojo.inherits(dojo.widget.DebugConsole, dojo.widget.Widget);
dojo.widget.tags.addParseTreeHandler("dojo:debugconsole");
dojo.requireAfterIf("html", "dojo.widget.html.DebugConsole");

__CPAN_FILE__ src/widget/DemoEngine.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DemoEngine");
dojo.requireAfterIf("html", "dojo.widget.html.DemoEngine");

__CPAN_FILE__ src/widget/Dialog.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Dialog");
dojo.provide("dojo.widget.html.Dialog");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.ContentPane");
dojo.require("dojo.event.*");
dojo.require("dojo.graphics.color");
dojo.require("dojo.html");

dojo.widget.defineWidget(
	"dojo.widget.html.Dialog",
	dojo.widget.html.ContentPane,
	{
		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlDialog.html"),
		isContainer: true,
		_scrollConnected: false,
		
		// provide a focusable element or element id if you need to
		// work around FF's tendency to send focus into outer space on hide
		focusElement: "",

		bg: null,
		bgColor: "black",
		bgOpacity: 0.4,
		followScroll: true,
		_fromTrap: false,
		anim: null,
		blockDuration: 0,
		lifetime: 0,

		trapTabs: function(e){
			if(e.target == this.tabStart) {
				if(this._fromTrap) {
					this._fromTrap = false;
				} else {
					this._fromTrap = true;
					this.tabEnd.focus();
				}
			} else if(e.target == this.tabEnd) {
				if(this._fromTrap) {
					this._fromTrap = false;
				} else {
					this._fromTrap = true;
					this.tabStart.focus();
				}
			}
		},

		clearTrap: function(e) {
			var _this = this;
			setTimeout(function() {
				_this._fromTrap = false;
			}, 100);
		},

		postCreate: function(args, frag, parentComp) {
			with(this.domNode.style) {
				position = "absolute";
				zIndex = 999;
				display = "none";
				overflow = "visible";
			}
			var b = document.body;
			b.appendChild(this.domNode);

			this.bg = document.createElement("div");
			this.bg.className = "dialogUnderlay";
			with(this.bg.style) {
				position = "absolute";
				left = top = "0px";
				zIndex = 998;
				display = "none";
			}
			this.setBackgroundColor(this.bgColor);
			b.appendChild(this.bg);

			this.bgIframe = new dojo.html.BackgroundIframe(this.bg);
		},

		setBackgroundColor: function(color) {
			if(arguments.length >= 3) {
				color = new dojo.graphics.color.Color(arguments[0], arguments[1], arguments[2]);
			} else {
				color = new dojo.graphics.color.Color(color);
			}
			this.bg.style.backgroundColor = color.toString();
			return this.bgColor = color;
		},
		
		setBackgroundOpacity: function(op) {
			if(arguments.length == 0) { op = this.bgOpacity; }
			dojo.style.setOpacity(this.bg, op);
			try {
				this.bgOpacity = dojo.style.getOpacity(this.bg);
			} catch (e) {
				this.bgOpacity = op;
			}
			return this.bgOpacity;
		},

		sizeBackground: function() {
			if(this.bgOpacity > 0) {
				var h = Math.max(
					document.documentElement.scrollHeight || document.body.scrollHeight,
					dojo.html.getViewportHeight());
				var w = dojo.html.getViewportWidth();
				this.bg.style.width = w + "px";
				this.bg.style.height = h + "px";
			}
			this.bgIframe.onResized();
		},

		showBackground: function() {
			this.sizeBackground();
			if(this.bgOpacity > 0) {
				this.bg.style.display = "block";
			}
		},

		placeDialog: function() {
			var scroll_offset = dojo.html.getScrollOffset();
			var viewport_size = dojo.html.getViewportSize();

			// find the size of the dialog
			var w = dojo.style.getOuterWidth(this.containerNode);
			var h = dojo.style.getOuterHeight(this.containerNode);

			var x = scroll_offset[0] + (viewport_size[0] - w)/2;
			var y = scroll_offset[1] + (viewport_size[1] - h)/2;

			with(this.domNode.style) {
				left = x + "px";
				top = y + "px";
			}
		},

		show: function() {
			this.setBackgroundOpacity();
			this.showBackground();

			dojo.widget.html.Dialog.superclass.show.call(this);

			// FIXME: moz doesn't generate onscroll events for mouse or key scrolling (wtf)
			// we should create a fake event by polling the scrolltop/scrollleft every X ms.
			// this smells like it should be a dojo feature rather than just for this widget.

			if (this.followScroll && !this._scrollConnected){
				this._scrollConnected = true;
				dojo.event.connect(window, "onscroll", this, "onScroll");
			}
			
			if(this.lifetime){
				this.timeRemaining = this.lifetime;
				if(!this.blockDuration){
					dojo.event.connect(this.bg, "onclick", this, "hide");
				}else{
					dojo.event.disconnect(this.bg, "onclick", this, "hide");
				}
				if(this.timerNode){
					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
				}
				if(this.blockDuration && this.closeNode){
					if(this.lifetime > this.blockDuration){
						this.closeNode.style.visibility = "hidden";
					}else{
						this.closeNode.style.display = "none";
					}
				}
				this.timer = setInterval(dojo.lang.hitch(this, "onTick"), 100);
			}

			this.onParentResized();
		},

		onLoad: function(){
			// when href is specified we need to reposition
			// the dialog after the data is loaded
			this.placeDialog();
		},
		
		fillInTemplate: function(){
			// dojo.event.connect(this.domNode, "onclick", this, "killEvent");
		},

		hide: function(){
			// workaround for FF focus going into outer space
			if (this.focusElement) { 
				dojo.byId(this.focusElement).focus(); 
				dojo.byId(this.focusElement).blur();
			}
			
			if(this.timer){
				clearInterval(this.timer);
			}

			this.bg.style.display = "none";
			this.bg.style.width = this.bg.style.height = "1px";

			dojo.widget.html.Dialog.superclass.hide.call(this);

			if (this._scrollConnected){
				this._scrollConnected = false;
				dojo.event.disconnect(window, "onscroll", this, "onScroll");
			}
		},
		
		setTimerNode: function(node){
			this.timerNode = node;
		},

		setCloseControl: function(node) {
			this.closeNode = node;
			dojo.event.connect(node, "onclick", this, "hide");
		},

		setShowControl: function(node) {
			dojo.event.connect(node, "onclick", this, "show");
		},
		
		onTick: function(){
			if(this.timer){
				this.timeRemaining -= 100;
				if(this.lifetime - this.timeRemaining >= this.blockDuration){
					dojo.event.connect(this.bg, "onclick", this, "hide");
					if(this.closeNode){
						this.closeNode.style.visibility = "visible";
					}
				}
				if(!this.timeRemaining){
					clearInterval(this.timer);
					this.hide();
				}else if(this.timerNode){
					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
				}
			}
		},

		onScroll: function(){
			this.placeDialog();
			this.domNode.style.display = "block";
		},

		// Called when the browser window's size is changed
		onParentResized: function() {
			if(this.isShowing()){
				this.sizeBackground();
				this.placeDialog();
				this.domNode.style.display="block";
				this.onResized();
			}
		},
		
		killEvent: function(evt){
			evt.preventDefault();
			evt.stopPropagation();
		}

	}
);

__CPAN_FILE__ src/widget/DocPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DocPane");
dojo.requireAfterIf("html", "dojo.widget.html.DocPane");

__CPAN_FILE__ src/widget/DomWidget.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DomWidget");

dojo.require("dojo.event.*");
dojo.require("dojo.widget.Widget");
dojo.require("dojo.dom");
dojo.require("dojo.xml.Parse");
dojo.require("dojo.uri.*");
dojo.require("dojo.lang.func");

dojo.widget._cssFiles = {};
dojo.widget._cssStrings = {};
dojo.widget._templateCache = {};

dojo.widget.defaultStrings = {
	dojoRoot: dojo.hostenv.getBaseScriptUri(),
	baseScriptUri: dojo.hostenv.getBaseScriptUri()
};

dojo.widget.buildFromTemplate = function() {
	dojo.lang.forward("fillFromTemplateCache");
}

// static method to build from a template w/ or w/o a real widget in place
dojo.widget.fillFromTemplateCache = function(obj, templatePath, templateCssPath, templateString, avoidCache){
	// dojo.debug("avoidCache:", avoidCache);
	var tpath = templatePath || obj.templatePath;
	var cpath = templateCssPath || obj.templateCssPath;

	// DEPRECATED: use Uri objects, not strings
	if (tpath && !(tpath instanceof dojo.uri.Uri)) {
		tpath = dojo.uri.dojoUri(tpath);
		dojo.deprecated("templatePath should be of type dojo.uri.Uri");
	}
	if (cpath && !(cpath instanceof dojo.uri.Uri)) {
		cpath = dojo.uri.dojoUri(cpath);
		dojo.deprecated("templateCssPath should be of type dojo.uri.Uri");
	}
	
	var tmplts = dojo.widget._templateCache;
	if(!obj["widgetType"]) { // don't have a real template here
		do {
			var dummyName = "__dummyTemplate__" + dojo.widget._templateCache.dummyCount++;
		} while(tmplts[dummyName]);
		obj.widgetType = dummyName;
	}
	var wt = obj.widgetType;

	if((!obj.templateCssString)&&(cpath)&&(!dojo.widget._cssFiles[cpath])){
		obj.templateCssString = dojo.hostenv.getText(cpath);
		obj.templateCssPath = null;
		dojo.widget._cssFiles[cpath] = true;
	}
	if((obj["templateCssString"])&&(!obj.templateCssString["loaded"])){
		dojo.style.insertCssText(obj.templateCssString, null, cpath);
		if(!obj.templateCssString){ obj.templateCssString = ""; }
		obj.templateCssString.loaded = true;
	}

	var ts = tmplts[wt];
	if(!ts){
		tmplts[wt] = { "string": null, "node": null };
		if(avoidCache){
			ts = {};
		}else{
			ts = tmplts[wt];
		}
	}
	if(!obj.templateString){
		obj.templateString = templateString || ts["string"];
	}
	if(!obj.templateNode){
		obj.templateNode = ts["node"];
	}
	if((!obj.templateNode)&&(!obj.templateString)&&(tpath)){
		// fetch a text fragment and assign it to templateString
		// NOTE: we rely on blocking IO here!
		var tstring = dojo.hostenv.getText(tpath);
		if(tstring){
			var matches = tstring.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
			if(matches){
				tstring = matches[1];
			}
		}else{
			tstring = "";
		}
		obj.templateString = tstring;
		if(!avoidCache){
			tmplts[wt]["string"] = tstring;
		}
	}
	if((!ts["string"])&&(!avoidCache)){
		ts.string = obj.templateString;
	}
}
dojo.widget._templateCache.dummyCount = 0;

dojo.widget.attachProperties = ["dojoAttachPoint", "id"];
dojo.widget.eventAttachProperty = "dojoAttachEvent";
dojo.widget.onBuildProperty = "dojoOnBuild";

dojo.widget.attachTemplateNodes = function(rootNode, targetObj, events){
	// FIXME: this method is still taking WAAAY too long. We need ways of optimizing:
	//	a.) what we are looking for on each node
	//	b.) the nodes that are subject to interrogation (use xpath instead?)
	//	c.) how expensive event assignment is (less eval(), more connect())
	// var start = new Date();
	var elementNodeType = dojo.dom.ELEMENT_NODE;

	function trim(str){
		return str.replace(/^\s+|\s+$/g, "");
	}

	if(!rootNode){ 
		rootNode = targetObj.domNode;
	}

	if(rootNode.nodeType != elementNodeType){
		return;
	}
	// alert(events.length);

	var nodes = rootNode.all || rootNode.getElementsByTagName("*");
	var _this = targetObj;
	for(var x=-1; x<nodes.length; x++){
		var baseNode = (x == -1) ? rootNode : nodes[x];
		// FIXME: is this going to have capitalization problems?  Could use getAttribute(name, 0); to get attributes case-insensitve
		var attachPoint = [];
		for(var y=0; y<this.attachProperties.length; y++){
			var tmpAttachPoint = baseNode.getAttribute(this.attachProperties[y]);
			if(tmpAttachPoint){
				attachPoint = tmpAttachPoint.split(";");
				for(var z=0; z<attachPoint.length; z++){
					if(dojo.lang.isArray(targetObj[attachPoint[z]])){
						targetObj[attachPoint[z]].push(baseNode);
					}else{
						targetObj[attachPoint[z]]=baseNode;
					}
				}
				break;
			}
		}
		// continue;

		// FIXME: we need to put this into some kind of lookup structure
		// instead of direct assignment
		var tmpltPoint = baseNode.getAttribute(this.templateProperty);
		if(tmpltPoint){
			targetObj[tmpltPoint]=baseNode;
		}

		var attachEvent = baseNode.getAttribute(this.eventAttachProperty);
		if(attachEvent){
			// NOTE: we want to support attributes that have the form
			// "domEvent: nativeEvent; ..."
			var evts = attachEvent.split(";");
			for(var y=0; y<evts.length; y++){
				if((!evts[y])||(!evts[y].length)){ continue; }
				var thisFunc = null;
				var tevt = trim(evts[y]);
				if(evts[y].indexOf(":") >= 0){
					// oh, if only JS had tuple assignment
					var funcNameArr = tevt.split(":");
					tevt = trim(funcNameArr[0]);
					thisFunc = trim(funcNameArr[1]);
				}
				if(!thisFunc){
					thisFunc = tevt;
				}

				var tf = function(){ 
					var ntf = new String(thisFunc);
					return function(evt){
						if(_this[ntf]){
							_this[ntf](dojo.event.browser.fixEvent(evt, this));
						}
					};
				}();
				dojo.event.browser.addListener(baseNode, tevt, tf, false, true);
				// dojo.event.browser.addListener(baseNode, tevt, dojo.lang.hitch(_this, thisFunc));
			}
		}

		for(var y=0; y<events.length; y++){
			//alert(events[x]);
			var evtVal = baseNode.getAttribute(events[y]);
			if((evtVal)&&(evtVal.length)){
				var thisFunc = null;
				var domEvt = events[y].substr(4); // clober the "dojo" prefix
				thisFunc = trim(evtVal);
				var funcs = [thisFunc];
				if(thisFunc.indexOf(";")>=0){
					funcs = dojo.lang.map(thisFunc.split(";"), trim);
				}
				for(var z=0; z<funcs.length; z++){
					if(!funcs[z].length){ continue; }
					var tf = function(){ 
						var ntf = new String(funcs[z]);
						return function(evt){
							if(_this[ntf]){
								_this[ntf](dojo.event.browser.fixEvent(evt, this));
							}
						}
					}();
					dojo.event.browser.addListener(baseNode, domEvt, tf, false, true);
					// dojo.event.browser.addListener(baseNode, domEvt, dojo.lang.hitch(_this, funcs[z]));
				}
			}
		}

		var onBuild = baseNode.getAttribute(this.onBuildProperty);
		if(onBuild){
			eval("var node = baseNode; var widget = targetObj; "+onBuild);
		}
	}

}

dojo.widget.getDojoEventsFromStr = function(str){
	// var lstr = str.toLowerCase();
	var re = /(dojoOn([a-z]+)(\s?))=/gi;
	var evts = str ? str.match(re)||[] : [];
	var ret = [];
	var lem = {};
	for(var x=0; x<evts.length; x++){
		if(evts[x].legth < 1){ continue; }
		var cm = evts[x].replace(/\s/, "");
		cm = (cm.slice(0, cm.length-1));
		if(!lem[cm]){
			lem[cm] = true;
			ret.push(cm);
		}
	}
	return ret;
}

/*
dojo.widget.buildAndAttachTemplate = function(obj, templatePath, templateCssPath, templateString, targetObj) {
	this.buildFromTemplate(obj, templatePath, templateCssPath, templateString);
	var node = dojo.dom.createNodesFromText(obj.templateString, true)[0];
	this.attachTemplateNodes(node, targetObj||obj, dojo.widget.getDojoEventsFromStr(templateString));
	return node;
}
*/

dojo.declare("dojo.widget.DomWidget", dojo.widget.Widget, {
	initializer: function() {
		if((arguments.length>0)&&(typeof arguments[0] == "object")){
			this.create(arguments[0]);
		}
	},
								 
	templateNode: null,
	templateString: null,
	templateCssString: null,
	preventClobber: false,
	domNode: null, // this is our visible representation of the widget!
	containerNode: null, // holds child elements

	// Process the given child widget, inserting it's dom node as a child of our dom node
	// FIXME: should we support addition at an index in the children arr and
	// order the display accordingly? Right now we always append.
	addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
		if(!this.isContainer){ // we aren't allowed to contain other widgets, it seems
			dojo.debug("dojo.widget.DomWidget.addChild() attempted on non-container widget");
			return null;
		}else{
			this.addWidgetAsDirectChild(widget, overrideContainerNode, pos, ref, insertIndex);
			this.registerChild(widget, insertIndex);
		}
		return widget;
	},
	
	addWidgetAsDirectChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
		if((!this.containerNode)&&(!overrideContainerNode)){
			this.containerNode = this.domNode;
		}
		var cn = (overrideContainerNode) ? overrideContainerNode : this.containerNode;
		if(!pos){ pos = "after"; }
		if(!ref){ 
			// if(!cn){ cn = document.body; }
			if(!cn){ cn = document.body; }
			ref = cn.lastChild; 
		}
		if(!insertIndex) { insertIndex = 0; }
		widget.domNode.setAttribute("dojoinsertionindex", insertIndex);

		// insert the child widget domNode directly underneath my domNode, in the
		// specified position (by default, append to end)
		if(!ref){
			cn.appendChild(widget.domNode);
		}else{
			// FIXME: was this meant to be the (ugly hack) way to support insert @ index?
			//dojo.dom[pos](widget.domNode, ref, insertIndex);

			// CAL: this appears to be the intended way to insert a node at a given position...
			if (pos == 'insertAtIndex'){
				// dojo.debug("idx:", insertIndex, "isLast:", ref === cn.lastChild);
				dojo.dom.insertAtIndex(widget.domNode, ref.parentNode, insertIndex);
			}else{
				// dojo.debug("pos:", pos, "isLast:", ref === cn.lastChild);
				if((pos == "after")&&(ref === cn.lastChild)){
					cn.appendChild(widget.domNode);
				}else{
					dojo.dom.insertAtPosition(widget.domNode, cn, pos);
				}
			}
		}
	},

	// Record that given widget descends from me
	registerChild: function(widget, insertionIndex){

		// we need to insert the child at the right point in the parent's 
		// 'children' array, based on the insertionIndex

		widget.dojoInsertionIndex = insertionIndex;

		var idx = -1;
		for(var i=0; i<this.children.length; i++){
			if (this.children[i].dojoInsertionIndex < insertionIndex){
				idx = i;
			}
		}

		this.children.splice(idx+1, 0, widget);

		widget.parent = this;
		widget.addedTo(this);
		
		// If this widget was created programatically, then it was erroneously added
		// to dojo.widget.manager.topWidgets.  Fix that here.
		delete dojo.widget.manager.topWidgets[widget.widgetId];
	},

	removeChild: function(widget){
		// detach child domNode from parent domNode
		dojo.dom.removeNode(widget.domNode);

		// remove child widget from parent widget
		return dojo.widget.DomWidget.superclass.removeChild.call(this, widget);
	},

	getFragNodeRef: function(frag){
		if( !frag || !frag["dojo:"+this.widgetType.toLowerCase()] ){
			dojo.raise("Error: no frag for widget type " + this.widgetType +
				", id " + this.widgetId + " (maybe a widget has set it's type incorrectly)");
		}
		return (frag ? frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"] : null);
	},
	
	// Replace source domNode with generated dom structure, and register
	// widget with parent.
	postInitialize: function(args, frag, parentComp){
		var sourceNodeRef = this.getFragNodeRef(frag);
		// Stick my generated dom into the output tree
		//alert(this.widgetId + ": replacing " + sourceNodeRef + " with " + this.domNode.innerHTML);
		if (parentComp && (parentComp.snarfChildDomOutput || !sourceNodeRef)){
			// Add my generated dom as a direct child of my parent widget
			// This is important for generated widgets, and also cases where I am generating an
			// <li> node that can't be inserted back into the original DOM tree
			parentComp.addWidgetAsDirectChild(this, "", "insertAtIndex", "",  args["dojoinsertionindex"], sourceNodeRef);
		} else if (sourceNodeRef){
			// Do in-place replacement of the my source node with my generated dom
			if(this.domNode && (this.domNode !== sourceNodeRef)){
				var oldNode = sourceNodeRef.parentNode.replaceChild(this.domNode, sourceNodeRef);
			}
		}

		// Register myself with my parent, or with the widget manager if
		// I have no parent
		// TODO: the code below erroneously adds all programatically generated widgets
		// to topWidgets (since we don't know who the parent is until after creation finishes)
		if ( parentComp ) {
			parentComp.registerChild(this, args.dojoinsertionindex);
		} else {
			dojo.widget.manager.topWidgets[this.widgetId]=this;
		}

		// Expand my children widgets
		if(this.isContainer){
			//alert("recurse from " + this.widgetId);
			// build any sub-components with us as the parent
			var fragParser = dojo.widget.getParser();
			fragParser.createSubComponents(frag, this);
		}
	},

	// method over-ride
	buildRendering: function(args, frag){
		// DOM widgets construct themselves from a template
		var ts = dojo.widget._templateCache[this.widgetType];
		if(	
			(!this.preventClobber)&&(
				(this.templatePath)||
				(this.templateNode)||
				(
					(this["templateString"])&&(this.templateString.length) 
				)||
				(
					(typeof ts != "undefined")&&( (ts["string"])||(ts["node"]) )
				)
			)
		){
			// if it looks like we can build the thing from a template, do it!
			this.buildFromTemplate(args, frag);
		}else{
			// otherwise, assign the DOM node that was the source of the widget
			// parsing to be the root node
			this.domNode = this.getFragNodeRef(frag);
		}
		this.fillInTemplate(args, frag); 	// this is where individual widgets
											// will handle population of data
											// from properties, remote data
											// sets, etc.
	},

	buildFromTemplate: function(args, frag){
		// var start = new Date();
		// copy template properties if they're already set in the templates object
		// dojo.debug("buildFromTemplate:", this);
		var avoidCache = false;
		if(args["templatecsspath"]){
			args["templateCssPath"] = args["templatecsspath"];
		}
		if(args["templatepath"]){
			avoidCache = true;
			args["templatePath"] = args["templatepath"];
		}
		dojo.widget.fillFromTemplateCache(	this, 
											args["templatePath"], 
											args["templateCssPath"],
											null,
											avoidCache);
		var ts = dojo.widget._templateCache[this.widgetType];
		if((ts)&&(!avoidCache)){
			if(!this.templateString.length){
				this.templateString = ts["string"];
			}
			if(!this.templateNode){
				this.templateNode = ts["node"];
			}
		}
		var matches = false;
		var node = null;
		// var tstr = new String(this.templateString); 
		var tstr = this.templateString; 
		// attempt to clone a template node, if there is one
		if((!this.templateNode)&&(this.templateString)){
			matches = this.templateString.match(/\$\{([^\}]+)\}/g);
			if(matches) {
				// if we do property replacement, don't create a templateNode
				// to clone from.
				var hash = this.strings || {};
				// FIXME: should this hash of default replacements be cached in
				// templateString?
				for(var key in dojo.widget.defaultStrings) {
					if(dojo.lang.isUndefined(hash[key])) {
						hash[key] = dojo.widget.defaultStrings[key];
					}
				}
				// FIXME: this is a lot of string munging. Can we make it faster?
				for(var i = 0; i < matches.length; i++) {
					var key = matches[i];
					key = key.substring(2, key.length-1);
					var kval = (key.substring(0, 5) == "this.") ? this[key.substring(5)] : hash[key];
					var value;
					if((kval)||(dojo.lang.isString(kval))){
						value = (dojo.lang.isFunction(kval)) ? kval.call(this, key, this.templateString) : kval;
						tstr = tstr.replace(matches[i], value);
					}
				}
			}else{
				// otherwise, we are required to instantiate a copy of the template
				// string if one is provided.
				
				// FIXME: need to be able to distinguish here what should be done
				// or provide a generic interface across all DOM implementations
				// FIMXE: this breaks if the template has whitespace as its first 
				// characters
				// node = this.createNodesFromText(this.templateString, true);
				// this.templateNode = node[0].cloneNode(true); // we're optimistic here
				this.templateNode = this.createNodesFromText(this.templateString, true)[0];
				ts.node = this.templateNode;
			}
		}
		if((!this.templateNode)&&(!matches)){ 
			dojo.debug("weren't able to create template!");
			return false;
		}else if(!matches){
			node = this.templateNode.cloneNode(true);
			if(!node){ return false; }
		}else{
			node = this.createNodesFromText(tstr, true)[0];
		}

		// recurse through the node, looking for, and attaching to, our
		// attachment points which should be defined on the template node.

		this.domNode = node;
		// dojo.profile.start("attachTemplateNodes");
		this.attachTemplateNodes(this.domNode, this);
		// dojo.profile.end("attachTemplateNodes");
		
		// relocate source contents to templated container node
		// this.containerNode must be able to receive children, or exceptions will be thrown
		if (this.isContainer && this.containerNode){
			var src = this.getFragNodeRef(frag);
			if (src){
				dojo.dom.moveChildren(src, this.containerNode);
			}
		}
	},

	attachTemplateNodes: function(baseNode, targetObj){
		if(!targetObj){ targetObj = this; }
		return dojo.widget.attachTemplateNodes(baseNode, targetObj, 
					dojo.widget.getDojoEventsFromStr(this.templateString));
	},

	fillInTemplate: function(){
		// dojo.unimplemented("dojo.widget.DomWidget.fillInTemplate");
	},
	
	// method over-ride
	destroyRendering: function(){
		try{
			delete this.domNode;
		}catch(e){ /* squelch! */ }
	},

	// FIXME: method over-ride
	cleanUp: function(){},
	
	getContainerHeight: function(){
		dojo.unimplemented("dojo.widget.DomWidget.getContainerHeight");
	},

	getContainerWidth: function(){
		dojo.unimplemented("dojo.widget.DomWidget.getContainerWidth");
	},

	createNodesFromText: function(){
		dojo.unimplemented("dojo.widget.DomWidget.createNodesFromText");
	}
});

__CPAN_FILE__ src/widget/DropdownButton.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DropdownButton");

dojo.deprecated("dojo.widget.DropdownButton",  "use dojo.widget.ComboButton", "0.4");

// Draws a button with a down arrow;
// when you press the down arrow something appears (usually a menu)

dojo.require("dojo.widget.*");

dojo.widget.tags.addParseTreeHandler("dojo:dropdownbutton");

dojo.widget.DropdownButton = function(){
	dojo.widget.Widget.call(this);

	this.widgetType = "DropdownButton";
}
dojo.inherits(dojo.widget.DropdownButton, dojo.widget.Widget);

dojo.requireAfterIf("html", "dojo.widget.html.DropdownButton");

__CPAN_FILE__ src/widget/DropdownContainer.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DropdownContainer");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.event.*");
dojo.require("dojo.html");

dojo.widget.defineWidget(
	"dojo.widget.DropdownContainer",
	dojo.widget.HtmlWidget,
	{
		initializer: function(){
		},

		isContainer: true,
		snarfChildDomOutput: true,
		
		inputWidth: "7em",
		inputId: "",
		inputName: "",
		iconURL: null,
		iconAlt: null,

		inputNode: null,
		buttonNode: null,
		containerNode: null,
		subWidgetNode: null,

		templateString: '<div><span style="white-space:nowrap"><input type="text" value="" style="vertical-align:middle;" dojoAttachPoint="inputNode" autocomplete="off" /> <img src="" alt="" dojoAttachPoint="buttonNode" dojoAttachEvent="onclick: onIconClick;" style="vertical-align:middle; cursor:pointer; cursor:hand;" /></span><br /><div dojoAttachPoint="containerNode" style="display:none;position:absolute;width:12em;background-color:#fff;"></div></div>',
		templateCssPath: "",

		fillInTemplate: function(args, frag){
			var source = this.getFragNodeRef(frag);
			
			if(args.inputId){ this.inputId = args.inputId; }
			if(args.inputName){ this.inputName = args.inputName; }
			if(args.iconURL){ this.iconURL = args.iconURL; }
			if(args.iconAlt){ this.iconAlt = args.iconAlt; }

			this.containerNode.style.left = "";
			this.containerNode.style.top = "";

			if(this.inputId){ this.inputNode.id = this.inputId; }
			if(this.inputName){ this.inputNode.name = this.inputName; }
			this.inputNode.style.width = this.inputWidth;

			if(this.iconURL){ this.buttonNode.src = this.iconURL; }
			if(this.iconAlt){ this.buttonNode.alt = this.iconAlt; }

			dojo.event.connect(this.inputNode, "onchange", this, "onInputChange");
			
			this.containerIframe = new dojo.html.BackgroundIframe(this.containerNode);
			this.containerIframe.size([0,0,0,0]);
		},

		onIconClick: function(evt){
			this.toggleContainerShow();
		},

		toggleContainerShow: function(){
			if(dojo.html.isShowing(this.containerNode)){
				dojo.html.hide(this.containerNode);
			}else{
				this.showContainer();
			}
		},
		
		showContainer: function(){
			dojo.html.show(this.containerNode);
			this.sizeBackgroundIframe();
		},
		
		onHide: function(evt){
			dojo.html.hide(this.containerNode);
		},
		
		sizeBackgroundIframe: function(){
			var w = dojo.style.getOuterWidth(this.containerNode);
			var h = dojo.style.getOuterHeight(this.containerNode);
			if(w==0||h==0){
				// need more time to calculate size
				dojo.lang.setTimeout(this, "sizeBackgroundIframe", 100);
				return;
			}
			if(dojo.html.isShowing(this.containerNode)){
				this.containerIframe.size([0,0,w,h]);
			}
		},

		onInputChange: function(){}
	},
	"html"
);

dojo.widget.tags.addParseTreeHandler("dojo:dropdowncontainer");
__CPAN_FILE__ src/widget/DropdownDatePicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.DropdownDatePicker");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.DropdownContainer");
dojo.require("dojo.widget.DatePicker");
dojo.require("dojo.event.*");
dojo.require("dojo.html");

dojo.widget.defineWidget(
	"dojo.widget.DropdownDatePicker",
	dojo.widget.DropdownContainer,
	{
		iconURL: dojo.uri.dojoUri("src/widget/templates/images/dateIcon.gif"),
		iconAlt: "Select a Date",
		iconTitle: "Select a Date",
		
		datePicker: null,
		
		dateFormat: "%m/%d/%Y",
		date: null,
		
		fillInTemplate: function(args, frag){
			dojo.widget.DropdownDatePicker.superclass.fillInTemplate.call(this, args, frag);
			var source = this.getFragNodeRef(frag);
			
			if(args.dateFormat){ this.dateFormat = args.dateFormat; }
			if(args.date){ this.date = new Date(args.date); }
			
			var dpNode = document.createElement("div");
			this.containerNode.appendChild(dpNode);
			
			var dateProps = { widgetContainerId: this.widgetId };
			if(this.date){
				dateProps["date"] = this.date;
				dateProps["storedDate"] = dojo.widget.DatePicker.util.toRfcDate(this.date);
				this.inputNode.value = dojo.date.format(this.date, this.dateFormat);
			}
			this.datePicker = dojo.widget.createWidget("DatePicker", dateProps, dpNode);
			dojo.event.connect(this.datePicker, "onSetDate", this, "onSetDate");
		},
		
		onSetDate: function(){
			this.inputNode.value = dojo.date.format(this.datePicker.date, this.dateFormat);
			this.onHide();
		},
		
		onInputChange: function(){
			var tmp = new Date(this.inputNode.value);
			this.datePicker.date = tmp;
			this.datePicker.setDate(dojo.widget.DatePicker.util.toRfcDate(tmp));
			this.datePicker.initData();
			this.datePicker.initUI();
		}
	},
	"html"
);

dojo.widget.tags.addParseTreeHandler("dojo:dropdowndatepicker");
__CPAN_FILE__ src/widget/Editor.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/* TODO:
 * - font selector
 * - test, bug fix, more features :)
*/
dojo.provide("dojo.widget.Editor");
dojo.provide("dojo.widget.html.Editor");
dojo.require("dojo.io.*");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.Toolbar");
dojo.require("dojo.widget.RichText");
dojo.require("dojo.widget.ColorPalette");
dojo.require("dojo.string.extras");

dojo.widget.tags.addParseTreeHandler("dojo:Editor");

dojo.widget.html.Editor = function() {
	dojo.widget.HtmlWidget.call(this);
	this.contentFilters = [];
	this._toolbars = [];
}
dojo.inherits(dojo.widget.html.Editor, dojo.widget.HtmlWidget);

dojo.widget.html.Editor.itemGroups = {
	textGroup: ["bold", "italic", "underline", "strikethrough"],
	blockGroup: ["formatBlock", "fontName", "fontSize"],
	justifyGroup: ["justifyleft", "justifycenter", "justifyright"],
	commandGroup: ["save", "cancel"],
	colorGroup: ["forecolor", "hilitecolor"],
	listGroup: ["insertorderedlist", "insertunorderedlist"],
	indentGroup: ["outdent", "indent"],
	linkGroup: ["createlink", "insertimage", "inserthorizontalrule"]
};

dojo.widget.html.Editor.formatBlockValues = {
	"Normal": "p",
	"Main heading": "h2",
	"Sub heading": "h3",
	"Sub sub heading": "h4",
	"Preformatted": "pre"
};

dojo.widget.html.Editor.fontNameValues = {
	"Arial": "Arial, Helvetica, sans-serif",
	"Verdana": "Verdana, sans-serif",
	"Times New Roman": "Times New Roman, serif",
	"Courier": "Courier New, monospace"
};

dojo.widget.html.Editor.fontSizeValues = {
	"1 (8 pt)" : "1",
	"2 (10 pt)": "2",
	"3 (12 pt)": "3",
	"4 (14 pt)": "4",
	"5 (18 pt)": "5",
	"6 (24 pt)": "6",
	"7 (36 pt)": "7"
};

dojo.widget.html.Editor.defaultItems = [
	"commandGroup", "|", "blockGroup", "|", "textGroup", "|", "colorGroup", "|", "justifyGroup", "|", "listGroup", "indentGroup", "|", "linkGroup"
];

// ones we support by default without asking the RichText component
// NOTE: you shouldn't put buttons like bold, italic, etc in here
dojo.widget.html.Editor.supportedCommands = ["save", "cancel", "|", "-", "/", " "];

dojo.lang.extend(dojo.widget.html.Editor, {
	widgetType: "Editor",

	saveUrl: "",
	saveMethod: "post",
	saveArgName: "editorContent",
	closeOnSave: false,
	items: dojo.widget.html.Editor.defaultItems,
	formatBlockItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.formatBlockValues),
	fontNameItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.fontNameValues),
	fontSizeItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.fontSizeValues),

	// used to get the properties of an item if it is given as a string
	getItemProperties: function(name) {
		var props = {};
		switch(name.toLowerCase()) {
			case "bold":
			case "italic":
			case "underline":
			case "strikethrough":
				props.toggleItem = true;
				break;

			case "justifygroup":
				props.defaultButton = "justifyleft";
				props.preventDeselect = true;
				props.buttonGroup = true;
				break;

			case "listgroup":
				props.buttonGroup = true;
				break;

			case "save":
			case "cancel":
				props.label = dojo.string.capitalize(name);
				break;

			case "forecolor":
			case "hilitecolor":
				props.name = name;
				props.toggleItem = true; // FIXME: they aren't exactly toggle items
				props.icon = this.getCommandImage(name);
				break;

			case "formatblock":
				props.name = "formatBlock";
				props.values = this.formatBlockItems;
				break;

			case "fontname":
				props.name = "fontName";
				props.values = this.fontNameItems;

			case "fontsize":
				props.name = "fontSize";
				props.values = this.fontSizeItems;
		}
		return props;
	},

	validateItems: true, // set to false to add items, regardless of support
	focusOnLoad: true,
	minHeight: "1em",

	_richText: null, // RichText widget
	_richTextType: "RichText",

	_toolbarContainer: null, // ToolbarContainer widget
	_toolbarContainerType: "ToolbarContainer",

	_toolbars: [],
	_toolbarType: "Toolbar",

	_toolbarItemType: "ToolbarItem",

	buildRendering: function(args, frag) {
		// get the node from args/frag
		var node = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
		var trt = dojo.widget.createWidget(this._richTextType, {
			focusOnLoad: this.focusOnLoad,
			minHeight: this.minHeight
		}, node)
		var _this = this;
		// this appears to fix a weird timing bug on Safari
		setTimeout(function(){
			_this.setRichText(trt);

			_this.initToolbar();

			_this.fillInTemplate(args, frag);
		}, 0);
	},

	setRichText: function(richText) {
		if(this._richText && this._richText == richText) {
			dojo.debug("Already set the richText to this richText!");
			return;
		}

		if(this._richText && !this._richText.isClosed) {
			dojo.debug("You are switching richTexts yet you haven't closed the current one. Losing reference!");
		}
		this._richText = richText;
		dojo.event.connect(this._richText, "close", this, "onClose");
		dojo.event.connect(this._richText, "onLoad", this, "onLoad");
		dojo.event.connect(this._richText, "onDisplayChanged", this, "updateToolbar");
		if(this._toolbarContainer) {
			this._toolbarContainer.enable();
			this.updateToolbar(true);
		}
	},

	initToolbar: function() {
		// var tic = new Date();
		if(this._toolbarContainer) { return; } // only create it once
		this._toolbarContainer = dojo.widget.createWidget(this._toolbarContainerType);
		var tb = this.addToolbar();
		var last = true;
		for(var i = 0; i < this.items.length; i++) {
			if(this.items[i] == "\n") { // new row
				tb = this.addToolbar();
			} else {
				if((this.items[i] == "|")&&(!last)){
					last = true;
				}else{
					last = this.addItem(this.items[i], tb);
				}
			}
		}
		this.insertToolbar(this._toolbarContainer.domNode, this._richText.domNode);
		// alert(new Date - tic);
	},

	// allow people to override this so they can make their own placement logic
	insertToolbar: function(tbNode, richTextNode) {
		dojo.html.insertBefore(tbNode, richTextNode);
		//dojo.html.insertBefore(this._toolbarContainer.domNode, this._richText.domNode);
	},

	addToolbar: function(toolbar) {
		this.initToolbar();
		if(!(toolbar instanceof dojo.widget.html.Toolbar)) {
			toolbar = dojo.widget.createWidget(this._toolbarType);
		}
		this._toolbarContainer.addChild(toolbar);
		this._toolbars.push(toolbar);
		return toolbar;
	},

	addItem: function(item, tb, dontValidate) {
		if(!tb) { tb = this._toolbars[0]; }
		var cmd = ((item)&&(!dojo.lang.isUndefined(item["getValue"]))) ?  cmd = item["getValue"](): item;

		var groups = dojo.widget.html.Editor.itemGroups;
		if(item instanceof dojo.widget.ToolbarItem) {
			tb.addChild(item);
		} else if(groups[cmd]) {
			var group = groups[cmd];
			var worked = true;
			if(cmd == "justifyGroup" || cmd == "listGroup") {
				var btnGroup = [cmd];
				for(var i = 0 ; i < group.length; i++) {
					if(dontValidate || this.isSupportedCommand(group[i])) {
						btnGroup.push(this.getCommandImage(group[i]));
					}else{
						worked = false;
					}
				}
				if(btnGroup.length){
					/*
					// the addChild interface is assinine. Work around it.
					var tprops = this.getItemProperties(cmd);
					var tmpGroup = dojo.widget.createWidget("ToolbarButtonGroup", tprops);
					dojo.debug(btnGroup);
					dojo.event.connect(tmpGroup, "onClick", this, "_action");
					dojo.event.connect(tmpGroup, "onChangeSelect", this, "_action");
					*/
					var btn = tb.addChild(btnGroup, null, this.getItemProperties(cmd));
					dojo.event.connect(btn, "onClick", this, "_action");
					dojo.event.connect(btn, "onChangeSelect", this, "_action");
				}
				return worked;
			} else {
				for(var i = 0; i < group.length; i++) {
					if(!this.addItem(group[i], tb)){
						worked = false;
					}
				}
				return worked;
			}
		} else {
			if((!dontValidate)&&(!this.isSupportedCommand(cmd))){
				return false;
			}
			if(dontValidate || this.isSupportedCommand(cmd)) {
				cmd = cmd.toLowerCase();
				if(cmd == "formatblock") {
					var select = dojo.widget.createWidget("ToolbarSelect", {
						name: "formatBlock",
						values: this.formatBlockItems
					});
					tb.addChild(select);
					var _this = this;
					dojo.event.connect(select, "onSetValue", function(item, value) {
						_this.onAction("formatBlock", value);
					});
				} else if(cmd == "fontname") {
					var select = dojo.widget.createWidget("ToolbarSelect", {
						name: "fontName",
						values: this.fontNameItems
					});
					tb.addChild(select);
					dojo.event.connect(select, "onSetValue", dojo.lang.hitch(this, function(item, value) {
						this.onAction("fontName", value);
					}));
				} else if(cmd == "fontsize") {
					var select = dojo.widget.createWidget("ToolbarSelect", {
						name: "fontSize",
						values: this.fontSizeItems
					});
					tb.addChild(select);
					dojo.event.connect(select, "onSetValue", dojo.lang.hitch(this, function(item, value) {
						this.onAction("fontSize", value);
					}));
				} else if(dojo.lang.inArray(cmd, ["forecolor", "hilitecolor"])) {
					var btn = tb.addChild(dojo.widget.createWidget("ToolbarColorDialog", this.getItemProperties(cmd)));
					dojo.event.connect(btn, "onSetValue", this, "_setValue");
				} else {
					var btn = tb.addChild(this.getCommandImage(cmd), null, this.getItemProperties(cmd));
					if(cmd == "save"){
						dojo.event.connect(btn, "onClick", this, "_save");
					}else if(cmd == "cancel"){
						dojo.event.connect(btn, "onClick", this, "_close");
					} else {
						dojo.event.connect(btn, "onClick", this, "_action");
						dojo.event.connect(btn, "onChangeSelect", this, "_action");
					}
				}
			}
		}
		return true;
	},

	enableToolbar: function() {
		if(this._toolbarContainer) {
			this._toolbarContainer.domNode.style.display = "";
			this._toolbarContainer.enable();
		}
	},

	disableToolbar: function(hide){
		if(hide){
			if(this._toolbarContainer){
				this._toolbarContainer.domNode.style.display = "none";
			}
		}else{
			if(this._toolbarContainer){
				this._toolbarContainer.disable();
			}
		}
	},

	_updateToolbarLastRan: null,
	_updateToolbarTimer: null,
	_updateToolbarFrequency: 500,

	updateToolbar: function(force) {
		if(!this._toolbarContainer) { return; }

		// keeps the toolbar from updating too frequently
		// TODO: generalize this functionality?
		var diff = new Date() - this._updateToolbarLastRan;
		if(!force && this._updateToolbarLastRan && (diff < this._updateToolbarFrequency)) {
			clearTimeout(this._updateToolbarTimer);
			var _this = this;
			this._updateToolbarTimer = setTimeout(function() {
				_this.updateToolbar();
			}, this._updateToolbarFrequency/2);
			return;
		} else {
			this._updateToolbarLastRan = new Date();
		}
		// end frequency checker

		var items = this._toolbarContainer.getItems();
		for(var i = 0; i < items.length; i++) {
			var item = items[i];
			if(item instanceof dojo.widget.html.ToolbarSeparator) { continue; }
			var cmd = item._name;
			if (cmd == "save" || cmd == "cancel") { continue; }
			else if(cmd == "justifyGroup") {
				try {
					if(!this._richText.queryCommandEnabled("justifyleft")) {
						item.disable(false, true);
					} else {
						item.enable(false, true);
						var jitems = item.getItems();
						for(var j = 0; j < jitems.length; j++) {
							var name = jitems[j]._name;
							var value = this._richText.queryCommandValue(name);
							if(typeof value == "boolean" && value) {
								value = name;
								break;
							} else if(typeof value == "string") {
								value = "justify"+value;
							} else {
								value = null;
							}
						}
						if(!value) { value = "justifyleft"; } // TODO: query actual style
						item.setValue(value, false, true);
					}
				} catch(err) {}
			} else if(cmd == "listGroup") {
				var litems = item.getItems();
				for(var j = 0; j < litems.length; j++) {
					this.updateItem(litems[j]);
				}
			} else {
				this.updateItem(item);
			}
		}
	},

	updateItem: function(item) {
		try {
			var cmd = item._name;
			var enabled = this._richText.queryCommandEnabled(cmd);
			item.setEnabled(enabled, false, true);

			var active = this._richText.queryCommandState(cmd);
			if(active && cmd == "underline") {
				// don't activate underlining if we are on a link
				active = !this._richText.queryCommandEnabled("unlink");
			}
			item.setSelected(active, false, true);
			return true;
		} catch(err) {
			return false;
		}
	},

	supportedCommands: dojo.widget.html.Editor.supportedCommands.concat(),

	isSupportedCommand: function(cmd) {
		// FIXME: how do we check for ActiveX?
		var yes = dojo.lang.inArray(cmd, this.supportedCommands);
		if(!yes) {
			try {
				var richText = this._richText || dojo.widget.HtmlRichText.prototype;
				yes = richText.queryCommandAvailable(cmd);
			} catch(E) {}
		}
		return yes;
	},

	getCommandImage: function(cmd) {
		if(cmd == "|") {
			return cmd;
		} else {
			return dojo.uri.dojoUri("src/widget/templates/buttons/" + cmd + ".gif");
		}
	},

	_action: function(e) {
		this._fire("onAction", e.getValue());
	},

	_setValue: function(a, b) {
		this._fire("onAction", a.getValue(), b);
	},

	_save: function(e){
		// FIXME: how should this behave when there's a larger form in play?
		if(!this._richText.isClosed){
			if(this.saveUrl.length){
				var content = {};
				content[this.saveArgName] = this.getHtml();
				dojo.io.bind({
					method: this.saveMethod,
					url: this.saveUrl,
					content: content
				});
			}else{
				dojo.debug("please set a saveUrl for the editor");
			}
			if(this.closeOnSave){
				this._richText.close(e.getName().toLowerCase() == "save");
			}
		}
	},

	_close: function(e) {
		if(!this._richText.isClosed) {
			this._richText.close(e.getName().toLowerCase() == "save");
		}
	},

	onAction: function(cmd, value) {
		switch(cmd) {
			case "createlink":
				if(!(value = prompt("Please enter the URL of the link:", "http://"))) {
					return;
				}
				break;
			case "insertimage":
				if(!(value = prompt("Please enter the URL of the image:", "http://"))) {
					return;
				}
				break;
		}
		this._richText.execCommand(cmd, value);
	},

	fillInTemplate: function(args, frag) {
		// dojo.event.connect(this, "onResized", this._richText, "onResized");
	},

	_fire: function(eventName) {
		if(dojo.lang.isFunction(this[eventName])) {
			var args = [];
			if(arguments.length == 1) {
				args.push(this);
			} else {
				for(var i = 1; i < arguments.length; i++) {
					args.push(arguments[i]);
				}
			}
			this[eventName].apply(this, args);
		}
	},

	getHtml: function(){
		this._richText.contentFilters = this._richText.contentFilters.concat(this.contentFilters);
		return this._richText.getEditorContent();
	},

	getEditorContent: function(){
		return this.getHtml();
	},

	onClose: function(save, hide){
		this.disableToolbar(hide);
		if(save) {
			this._fire("onSave");
		} else {
			this._fire("onCancel");
		}
	},

	// events baby!
	onLoad: function(){},
	onSave: function(){},
	onCancel: function(){}
});


__CPAN_FILE__ src/widget/Editor2.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/* TODO:
 * - font selector
 * - test, bug fix, more features :)
*/
dojo.provide("dojo.widget.Editor2");
dojo.provide("dojo.widget.html.Editor2");
dojo.require("dojo.io.*");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.RichText");
dojo.require("dojo.widget.Editor2Toolbar");
// dojo.require("dojo.widget.ColorPalette");
// dojo.require("dojo.string.extras");

dojo.widget.defineWidget(
	"dojo.widget.html.Editor2",
	dojo.widget.html.RichText,
	{
		saveUrl: "",
		saveMethod: "post",
		saveArgName: "editorContent",
		closeOnSave: false,
		shareToolbar: false,
		toolbarAlwaysVisible: false,
		htmlEditing: false,
		_inHtmlMode: false,
		_htmlEditNode: null,

		commandList: dojo.widget.html.Editor2Toolbar.prototype.commandList,
		toolbarWidget: null,
		scrollInterval: null,
		

		editorOnLoad: function(){
			var toolbars = dojo.widget.byType("Editor2Toolbar");
			if((!toolbars.length)||(!this.shareToolbar)){
				var tbOpts = {};
				tbOpts.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlEditorToolbarOneline.html");
				this.toolbarWidget = dojo.widget.createWidget("Editor2Toolbar", 
										tbOpts, this.domNode, "before");
				dojo.event.connect(this, "destroy", this.toolbarWidget, "destroy");
				this.toolbarWidget.hideUnusableButtons(this);

				if(this.object){
					this.tbBgIframe = new dojo.html.BackgroundIframe(this.toolbarWidget.domNode);
					this.tbBgIframe.iframe.style.height = "30px";
				}

				// need to set position fixed to wherever this thing has landed
				if(this.toolbarAlwaysVisible){
					var src = document["documentElement"]||window;
					this.scrollInterval = setInterval(dojo.lang.hitch(this, "globalOnScrollHandler"), 100);
					// dojo.event.connect(src, "onscroll", this, "globalOnScrollHandler");
					dojo.event.connect("before", this, "destroyRendering", this, "unhookScroller");
				}
			}else{
				// FIXME: 	should we try harder to explicitly manage focus in
				// 			order to prevent too many editors from all querying
				// 			for button status concurrently?
				// FIXME: 	selecting in one shared toolbar doesn't clobber
				// 			selection in the others. This is problematic.
				this.toolbarWidget = toolbars[0];
			}
			dojo.event.topic.registerPublisher("Editor2.clobberFocus", this.editNode, "onfocus");
			// dojo.event.topic.registerPublisher("Editor2.clobberFocus", this.editNode, "onclick");
			dojo.event.topic.subscribe("Editor2.clobberFocus", this, "setBlur");
			dojo.event.connect(this.editNode, "onfocus", this, "setFocus");
			dojo.event.connect(this.toolbarWidget.linkButton, "onclick", 
				dojo.lang.hitch(this, function(){
					var range;
					if(this.document.selection){
						range = this.document.selection.createRange().text;
					}else if(dojo.render.html.mozilla){
						range = this.window.getSelection().toString();
					}
					if(range.length){
						this.toolbarWidget.exec("createlink", 
							prompt("Please enter the URL of the link:", "http://"));
					}else{
						alert("Please select text to link");
					}
				})
			);

			var focusFunc = dojo.lang.hitch(this, function(){ 
				if(dojo.render.html.ie){
					this.editNode.focus();
				}else{
					this.window.focus(); 
				}
			});

			dojo.event.connect(this.toolbarWidget, "formatSelectClick", focusFunc);
			dojo.event.connect(this, "execCommand", focusFunc);

			if(this.htmlEditing){
				var tb = this.toolbarWidget.htmltoggleButton;
				if(tb){
					tb.style.display = "";
					dojo.event.connect(this.toolbarWidget, "htmltoggleClick",
										this, "toggleHtmlEditing");
				}
			}
		},

		toggleHtmlEditing: function(){
			if(!this._inHtmlMode){
				this._inHtmlMode = true;
				this.toolbarWidget.highlightButton("htmltoggle");
				if(!this._htmlEditNode){
					this._htmlEditNode = document.createElement("textarea");
					dojo.html.insertBefore(this._htmlEditNode, this.domNode);
				}
				this._htmlEditNode.style.display = "";
				this._htmlEditNode.style.width = "100%";
				this._htmlEditNode.style.height = dojo.style.getInnerHeight(this.editNode)+"px";
				this._htmlEditNode.value = this.editNode.innerHTML;
				this.domNode.style.display = "none";
			}else{
				this._inHtmlMode = false;
				this.domNode.style.display = "";
				this.toolbarWidget.unhighlightButton("htmltoggle");
				dojo.lang.setTimeout(this, "replaceEditorContent", 1, this._htmlEditNode.value);
				this._htmlEditNode.style.display = "none";
				this.editNode.focus();
			}
		},

		setFocus: function(){
			// dojo.debug("setFocus:", this);
			dojo.event.connect(this.toolbarWidget, "exec", this, "execCommand");
		},

		setBlur: function(){
			// dojo.debug("setBlur:", this);
			dojo.event.disconnect(this.toolbarWidget, "exec", this, "execCommand");
		},

		_scrollSetUp: false,
		_fixEnabled: false,
		_scrollThreshold: false,
		_handleScroll: true,
		globalOnScrollHandler: function(){
			var isIE = dojo.render.html.ie;
			if(!this._handleScroll){ return; }
			var ds = dojo.style;
			var tdn = this.toolbarWidget.domNode;
			var db = document["body"];
			var totalHeight = ds.getOuterHeight(tdn);
			if(!this._scrollSetUp){
				this._scrollSetUp = true;
				var editorWidth =  ds.getOuterWidth(this.domNode); 
				this._scrollThreshold = ds.abs(tdn, false).y;
				// dojo.debug("threshold:", this._scrollThreshold);
				if((isIE)&&(db)&&(ds.getStyle(db, "background-image")=="none")){
					with(db.style){
						backgroundImage = "url(" + dojo.uri.dojoUri("src/widget/templates/images/blank.gif") + ")";
						backgroundAttachment = "fixed";
					}
				}
			}

			var scrollPos = (window["pageYOffset"]) ? window["pageYOffset"] : (document["documentElement"]||document["body"]).scrollTop;

			// FIXME: need to have top and bottom thresholds so toolbar doesn't keep scrolling past the bottom
			if(scrollPos > this._scrollThreshold){
				// dojo.debug(scrollPos);
				if(!this._fixEnabled){
					this.domNode.style.marginTop = totalHeight+"px";
					if(isIE){
						// FIXME: should we just use setBehvior() here instead?
						var cl = dojo.style.abs(tdn).x;
						document.body.appendChild(tdn);
						tdn.style.left = cl+dojo.style.getPixelValue(document.body, "margin-left")+"px";
						dojo.html.addClass(tdn, "IEFixedToolbar");
						if(this.object){
							dojo.html.addClass(this.tbBgIframe, "IEFixedToolbar");
						}
						
					}else{
						with(tdn.style){
							position = "fixed";
							top = "0px";
						}
					}
					tdn.style.zIndex = 1000;
					this._fixEnabled = true;
				}
			}else if(this._fixEnabled){
				this.domNode.style.marginTop = null;
				with(tdn.style){
					position = "";
					top = "";
					zIndex = "";
					if(isIE){
						marginTop = "";
					}
				}
				if(isIE){
					dojo.html.removeClass(tdn, "IEFixedToolbar");
					dojo.html.insertBefore(tdn, this._htmlEditNode||this.domNode);
				}
				this._fixEnabled = false;
			}
		},

		unhookScroller: function(){
			this._handleScroll = false;
			clearInterval(this.scrollInterval);
			// var src = document["documentElement"]||window;
			// dojo.event.disconnect(src, "onscroll", this, "globalOnScrollHandler");
			if(dojo.render.html.ie){
				dojo.html.removeClass(this.toolbarWidget.domNode, "IEFixedToolbar");
			}
		},

		_updateToolbarLastRan: null,
		_updateToolbarTimer: null,
		_updateToolbarFrequency: 500,

		updateToolbar: function(force){
			if((!this.isLoaded)||(!this.toolbarWidget)){ return; }

			// keeps the toolbar from updating too frequently
			// TODO: generalize this functionality?
			var diff = new Date() - this._updateToolbarLastRan;
			if( (!force)&&(this._updateToolbarLastRan)&&
				((diff < this._updateToolbarFrequency)) ){

				clearTimeout(this._updateToolbarTimer);
				var _this = this;
				this._updateToolbarTimer = setTimeout(function() {
					_this.updateToolbar();
				}, this._updateToolbarFrequency/2);
				return;

			}else{
				this._updateToolbarLastRan = new Date();
			}
			// end frequency checker

			dojo.lang.forEach(this.commandList, function(cmd){
					if(cmd == "inserthtml"){ return; }
					try{
						if(this.queryCommandEnabled(cmd)){
							if(this.queryCommandState(cmd)){
								this.toolbarWidget.highlightButton(cmd);
							}else{
								this.toolbarWidget.unhighlightButton(cmd);
							}
						}
					}catch(e){
						// alert(cmd+":"+e);
					}
				}, this);

			var h = dojo.render.html;
			
			// safari f's us for selection primitives
			if(h.safari){ return; }

			var selectedNode = (h.ie) ? this.document.selection.createRange().parentElement() : this.window.getSelection().anchorNode;
			// make sure we actuall have an element
			while((selectedNode)&&(selectedNode.nodeType != 1)){
				selectedNode = selectedNode.parentNode;
			}
			if(!selectedNode){ return; }

			var formats = ["p", "pre", "h1", "h2", "h3", "h4"];
			// gotta run some specialized updates for the various
			// formatting options
			var type = formats[dojo.lang.find(formats, selectedNode.nodeName.toLowerCase())];
			while((selectedNode)&&(selectedNode!=this.editNode)&&(!type)){
				selectedNode = selectedNode.parentNode;
				type = formats[dojo.lang.find(formats, selectedNode.nodeName.toLowerCase())];
			}
			if(!type){
				type = "";
			}else{
				if(type.charAt(0)=="h"){
					this.toolbarWidget.unhighlightButton("bold");
				}
			}
			this.toolbarWidget.selectFormat(type);
		},

		updateItem: function(item) {
			try {
				var cmd = item._name;
				var enabled = this._richText.queryCommandEnabled(cmd);
				item.setEnabled(enabled, false, true);

				var active = this._richText.queryCommandState(cmd);
				if(active && cmd == "underline") {
					// don't activate underlining if we are on a link
					active = !this._richText.queryCommandEnabled("unlink");
				}
				item.setSelected(active, false, true);
				return true;
			} catch(err) {
				return false;
			}
		},


		_save: function(e){
			// FIXME: how should this behave when there's a larger form in play?
			if(!this.isClosed){
				if(this.saveUrl.length){
					var content = {};
					content[this.saveArgName] = this.getHtml();
					dojo.io.bind({
						method: this.saveMethod,
						url: this.saveUrl,
						content: content
					});
				}else{
					dojo.debug("please set a saveUrl for the editor");
				}
				if(this.closeOnSave){
					this.close(e.getName().toLowerCase() == "save");
				}
			}
		},

		wireUpOnLoad: function(){
			if(!dojo.render.html.ie){
				/*
				dojo.event.kwConnect({
					srcObj:		this.document,
					srcFunc:	"click", 
					targetObj:	this.toolbarWidget,
					targetFunc:	"hideAllDropDowns",
					once:		true
				});
				*/
			}
		}
	},
	"html",
	function(){
		var cp = dojo.widget.html.Editor2.prototype;
		if(!cp._wrappersSet){
			cp._wrappersSet = true;
			cp.fillInTemplate = (function(fit){
				return function(){
					fit.call(this);
					this.editorOnLoad();
				};
			})(cp.fillInTemplate);
		
			cp.onDisplayChanged = (function(odc){
				return function(){
					try{
						odc.call(this);
						this.updateToolbar();
					}catch(e){}
				};
			})(cp.onDisplayChanged);

			cp.onLoad = (function(ol){
				return function(){
					ol.call(this);
					this.wireUpOnLoad();
				};
			})(cp.onLoad);
		}
	}
);

__CPAN_FILE__ src/widget/Editor2Toolbar.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Editor2Toolbar");
dojo.provide("dojo.widget.html.Editor2Toolbar");

dojo.require("dojo.lang.*");
dojo.require("dojo.widget.*");
dojo.require("dojo.event.*");
dojo.require("dojo.widget.RichText");
dojo.require("dojo.widget.ColorPalette");

dojo.widget.defineWidget(
	"dojo.widget.html.Editor2Toolbar",
	dojo.widget.HtmlWidget,
	{
		commandList: [ "bold", "italic", "underline", "subscript", "superscript",
			"fontname", "fontsize", "forecolor", "hilitecolor", "justifycenter",
			"justifyfull", "justifyleft", "justifyright", "cut", "copy", "paste",
			"delete", "undo", "redo", "createlink", "unlink", "removeformat",
			"inserthorizontalrule", "insertimage", "insertorderedlist",
			"insertunorderedlist", "indent", "outdent", "formatblock", "strikethrough", 
			"inserthtml", "blockdirltr", "blockdirrtl", "dirltr", "dirrtl",
			"inlinedirltr", "inlinedirrtl", "inserttable", "insertcell",
			"insertcol", "insertrow", "deletecells", "deletecols", "deleterows",
			"mergecells", "splitcell"
		],

		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlEditorToolbar.html"),
		templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlEditorToolbar.css"),

		forecolorPalette: null,
		hilitecolorPalette: null,

		// DOM Nodes
		wikiwordButton: null,
		htmltoggleButton: null,
		insertimageButton: null,
		styleDropdownButton: null,
		styleDropdownContainer: null,
		copyButton: null,
		boldButton: null,
		italicButton: null,
		underlineButton: null,
		justifycenterButton: null,
		justifyleftButton: null,
		justifyfullButton: null,
		justifyrightButton: null,
		pasteButton: null,
		undoButton: null,
		redoButton: null,
		linkButton: null,
		insertunorderedlistButton: null,
		insertorderedlistButton: null,
		forecolorButton: null,
		forecolorDropDown: null,
		hilitecolorButton: null,
		hilitecolorDropDown: null,
		formatSelectBox: null,
		inserthorizontalruleButton: null,
		strikethroughButton: null,
		clickInterceptDiv: null,
		oneLineTr: null,

		buttonClick: function(e){ e.preventDefault(); /* dojo.debug("buttonClick"); */ },

		buttonMouseOver: function(e){  },
		buttonMouseOut: function(e){  },


		// event signals
		preventSelect: function(e){ if(dojo.render.html.safari){ e.preventDefault(); } },
		wikiwordClick: function(){ },
		insertimageClick: function(){ },
		htmltoggleClick: function(){ },

		styleDropdownClick: function(){
			dojo.debug("styleDropdownClick:", this.styleDropdownContainer);
			dojo.style.toggleShowing(this.styleDropdownContainer);
		},


		copyClick: function(){ this.exec("copy"); },
		boldClick: function(){ this.exec("bold"); },
		italicClick: function(){ this.exec("italic"); },
		underlineClick: function(){ this.exec("underline"); },
		justifyleftClick: function(){ this.exec("justifyleft"); },
		justifycenterClick: function(){ this.exec("justifycenter"); },
		justifyfullClick: function(){ this.exec("justifyfull"); },
		justifyrightClick: function(){ this.exec("justifyright"); },
		pasteClick: function(){ this.exec("paste"); },
		undoClick: function(){ this.exec("undo"); },
		redoClick: function(){ this.exec("redo"); },
		linkClick: function(){ 
			// FIXME: we need to alert the user if they haven't selected any text
			// this.exec(	"createlink", 
			// 			prompt("Please enter the URL of the link:", "http://"));
		},
		insertunorderedlistClick: function(){ this.exec("insertunorderedlist"); },
		insertorderedlistClick: function(){ this.exec("insertorderedlist"); },
		inserthorizontalruleClick: function(){ this.exec("inserthorizontalrule"); },
		strikethroughClick: function(){ this.exec("strikethrough"); },

		formatSelectClick: function(){ 
			var sv = this.formatSelectBox.value.toLowerCase();
			this.exec("formatblock", sv);
		},

		normalTextClick: function(){ this.exec("formatblock", "p"); },
		h1TextClick: function(){ this.exec("formatblock", "h1"); },
		h2TextClick: function(){ this.exec("formatblock", "h2"); },
		h3TextClick: function(){ this.exec("formatblock", "h3"); },
		h4TextClick: function(){ this.exec("formatblock", "h4"); },
		indentClick: function(){ this.exec("indent"); },
		outdentClick: function(){ this.exec("outdent"); },


		hideAllDropDowns: function(){
			this.domNode.style.height = "";
			dojo.lang.forEach(dojo.widget.byType("Editor2Toolbar"), function(tb){
				try{
					dojo.style.hide(tb.forecolorDropDown);
					dojo.style.hide(tb.hilitecolorDropDown);
					dojo.style.hide(tb.styleDropdownContainer);
					if(tb.clickInterceptDiv){
						dojo.style.hide(tb.clickInterceptDiv);
					}
				}catch(e){}
				if(dojo.render.html.ie){
					try{
						dojo.style.hide(tb.forecolorPalette.bgIframe);
					}catch(e){}
					try{
						dojo.style.hide(tb.hilitecolorPalette.bgIframe);
					}catch(e){}
				}
			});
		},

		selectFormat: function(format){
			dojo.lang.forEach(this.formatSelectBox.options, function(item){
				if(item.value.toLowerCase() == format.toLowerCase()){
					item.selected = true;
				}
			});
		},

		forecolorClick: function(e){
			this.colorClick(e, "forecolor");
		},

		hilitecolorClick: function(e){
			this.colorClick(e, "hilitecolor");
		},

		// FIXME: these methods aren't currently dealing with clicking in the
		// general document to hide the menu
		colorClick: function(e, type){
			var h = dojo.render.html;
			this.hideAllDropDowns();
			// FIXME: if we've been "popped out", we need to set the height of the toolbar.
			e.stopPropagation();
			var dd = this[type+"DropDown"];
			var pal = this[type+"Palette"];
			dojo.style.toggleShowing(dd);
			if(!pal){
				pal = this[type+"Palette"] = dojo.widget.createWidget("ColorPalette", {}, dd, "first");
				var fcp = pal.domNode;
				with(dd.style){
					width = dojo.html.getOuterWidth(fcp) + "px";
					height = dojo.html.getOuterHeight(fcp) + "px";
					zIndex = 1002;
					position = "absolute";
				}

				dojo.event.connect(	"after",
									pal, "onColorSelect",
									this, "exec",
									function(mi){ mi.args.unshift(type); return mi.proceed(); }
				);

				dojo.event.connect(	"after",
									pal, "onColorSelect",
									dojo.style, "toggleShowing",
									this, function(mi){ mi.args.unshift(dd); return mi.proceed(); }
				);

				var cid = this.clickInterceptDiv;
				if(!cid){
					cid = this.clickInterceptDiv = document.createElement("div");
					document.body.appendChild(cid);
					with(cid.style){
						backgroundColor = "transparent";
						top = left = "0px";
						height = width = "100%";
						position = "absolute";
						border = "none";
						display = "none";
						zIndex = 1001;
					}
					dojo.event.connect(cid, "onclick", function(){ cid.style.display = "none"; });
				}
				dojo.event.connect(pal, "onColorSelect", function(){ cid.style.display = "none"; });

				dojo.event.kwConnect({
					srcObj:		document.body, 
					srcFunc:	"onclick", 
					targetObj:	this,
					targetFunc:	"hideAllDropDowns",
					once:		true
				});
				document.body.appendChild(dd);
			}
			dojo.style.toggleShowing(this.clickInterceptDiv);
			var pos = dojo.style.abs(this[type+"Button"]);
			dojo.html.placeOnScreenPoint(dd, pos.x, pos.y, 0, false);
			if(pal.bgIframe){
				with(pal.bgIframe.style){
					display = "block";
					left = dd.style.left;
					top = dd.style.top;
					width = dojo.style.getOuterWidth(dd)+"px";
					height = dojo.style.getOuterHeight(dd)+"px";
				}
			}
		},

		uninitialize: function(){
			dojo.event.kwDisconnect({
				srcObj:		document.body, 
				srcFunc:	"onclick", 
				targetObj:	this,
				targetFunc:	"hideAllDropDowns",
				once:		true
			});
		},

		// stub for observers
		exec: function(what, arg){ /* dojo.debug(what, new Date()); */ },

		hideUnusableButtons: function(obj){
			var op = obj||dojo.widget.html.RichText.prototype;
			dojo.lang.forEach(this.commandList,
				function(cmd){
					if(this[cmd+"Button"]){
						var cb = this[cmd+"Button"];
						if(!op.queryCommandAvailable(cmd)){
							cb.style.display = "none";
							cb.parentNode.style.display = "none";
						}
					}
				},
				this);
				if(this.oneLineTr){
					var lastVisibleIsSpacer = false;
					var lastVisible = false;
					var tds = this.oneLineTr.getElementsByTagName("td");
					dojo.lang.forEach(tds, function(td){
						if(td.getAttribute("isSpacer")){
							if(td.style.display != "none"){
								if(lastVisibleIsSpacer){
									td.style.display = "none";
								}
								lastVisibleIsSpacer = true;
							}else{
								lastVisible = td;
								lastVisibleIsSpacer = true;
							}
						}else{
							if(td.style.display != "none"){
								lastVisible = td;
								lastVisibleIsSpacer = false;
							}
						}
					});
				}
		},

		highlightButton: function(name){
			var bn = name+"Button";
			if(this[bn]){
				with(this[bn].style){
					backgroundColor = "White";
					border = "1px solid #aeaeab";
				}
			}
		},

		unhighlightButton: function(name){
			var bn = name+"Button";
			if(this[bn]){
				// dojo.debug("unhighlighting:", name);
				with(this[bn].style){
					backgroundColor = "";
					border = "";
				}
			}
		}
	},
	"html",
	function(){
		// dojo.event.connect(this, "fillInTemplate", this, "hideUnusableButtons");
		dojo.event.connect(this, "fillInTemplate", dojo.lang.hitch(this, function(){
			if(dojo.render.html.ie){
				this.domNode.style.zoom = 1.0;
			}
		}));
	}
);

__CPAN_FILE__ src/widget/FisheyeList.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.FisheyeList");
dojo.provide("dojo.widget.html.FisheyeList");
dojo.provide("dojo.widget.html.FisheyeListItem");

//
// TODO
// fix SVG support, and turn it on only if the browser supports it
// fix really long labels in vertical mode
//

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.dom");
dojo.require("dojo.html");
dojo.require("dojo.style");
dojo.require("dojo.event");

dojo.widget.tags.addParseTreeHandler("dojo:FisheyeList");
dojo.widget.tags.addParseTreeHandler("dojo:FisheyeListItem");

dojo.widget.html.FisheyeList = function(){
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.html.FisheyeList, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.FisheyeList, {

	templateString: '<div class="dojoHtmlFisheyeListBar"></div>',
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlFisheyeList.css"),
	widgetType: "FisheyeList",

	EDGE: {
		CENTER: 0,
		LEFT: 1,
		RIGHT: 2,
		TOP: 3,
		BOTTOM: 4
	},

	isContainer: true,
	snarfChildDomOutput: true,
	
	pos: {x: -1, y: -1},		// current cursor position, relative to the grid
	
	// for conservative trigger mode, when triggered, timerScale is gradually increased from 0 to 1
	timerScale: 1.0,

	/////////////////////////////////////////////////////////////////
	//
	// i spy OPTIONS!!!!
	//

	itemWidth: 40,
	itemHeight: 40,

	itemMaxWidth: 150,
	itemMaxHeight: 150,

	orientation: 'horizontal',
	
	conservativeTrigger: false,		// don't active menu until mouse is over an image (macintosh style)

	effectUnits: 2,
	itemPadding: 10,

	attachEdge: 'center',
	labelEdge: 'bottom',

	enableCrappySvgSupport: false,


	//
	//
	//
	/////////////////////////////////////////////////////////////////

	fillInTemplate: function(args, frag) {
		//dojo.debug(this.orientation);

		dojo.html.disableSelection(this.domNode);

		this.isHorizontal = (this.orientation == 'horizontal') ? 1 : 0;
		this.selectedNode = -1;

		this.isOver = false;
		this.hitX1 = -1;
		this.hitY1 = -1;
		this.hitX2 = -1;
		this.hitY2 = -1;

		//
		// only some edges make sense...
		//

		this.anchorEdge = this.toEdge(this.attachEdge, this.EDGE.CENTER);
		this.labelEdge  = this.toEdge(this.labelEdge,  this.EDGE.TOP);

		if ( this.isHorizontal && (this.anchorEdge == this.EDGE.LEFT  )){ this.anchorEdge = this.EDGE.CENTER; }
		if ( this.isHorizontal && (this.anchorEdge == this.EDGE.RIGHT )){ this.anchorEdge = this.EDGE.CENTER; }
		if (!this.isHorizontal && (this.anchorEdge == this.EDGE.TOP   )){ this.anchorEdge = this.EDGE.CENTER; }
		if (!this.isHorizontal && (this.anchorEdge == this.EDGE.BOTTOM)){ this.anchorEdge = this.EDGE.CENTER; }

		if (this.labelEdge == this.EDGE.CENTER){ this.labelEdge = this.EDGE.TOP; }
		if ( this.isHorizontal && (this.labelEdge == this.EDGE.LEFT  )){ this.labelEdge = this.EDGE.TOP; }
		if ( this.isHorizontal && (this.labelEdge == this.EDGE.RIGHT )){ this.labelEdge = this.EDGE.TOP; }
		if (!this.isHorizontal && (this.labelEdge == this.EDGE.TOP   )){ this.labelEdge = this.EDGE.LEFT; }
		if (!this.isHorizontal && (this.labelEdge == this.EDGE.BOTTOM)){ this.labelEdge = this.EDGE.LEFT; }


		//
		// figure out the proximity size
		//

		this.proximityLeft   = this.itemWidth  * (this.effectUnits - 0.5);
		this.proximityRight  = this.itemWidth  * (this.effectUnits - 0.5);
		this.proximityTop    = this.itemHeight * (this.effectUnits - 0.5);
		this.proximityBottom = this.itemHeight * (this.effectUnits - 0.5);

		if (this.anchorEdge == this.EDGE.LEFT){
			this.proximityLeft = 0;
		}
		if (this.anchorEdge == this.EDGE.RIGHT){
			this.proximityRight = 0;
		}
		if (this.anchorEdge == this.EDGE.TOP){
			this.proximityTop = 0;
		}
		if (this.anchorEdge == this.EDGE.BOTTOM){
			this.proximityBottom = 0;
		}
		if (this.anchorEdge == this.EDGE.CENTER){
			this.proximityLeft   /= 2;
			this.proximityRight  /= 2;
			this.proximityTop    /= 2;
			this.proximityBottom /= 2;
		}
	},
	
	postCreate: function(args, frag) {

		this.itemCount = this.children.length;

		this.barWidth  = (this.isHorizontal ? this.itemCount : 1) * this.itemWidth;
		this.barHeight = (this.isHorizontal ? 1 : this.itemCount) * this.itemHeight;

		this.totalWidth  = this.proximityLeft + this.proximityRight  + this.barWidth;
		this.totalHeight = this.proximityTop  + this.proximityBottom + this.barHeight;

		//
		// calculate effect ranges for each item
		//

		for (var i=0; i<this.children.length; i++){

			this.children[i].posX = this.itemWidth  * (this.isHorizontal ? i : 0);
			this.children[i].posY = this.itemHeight * (this.isHorizontal ? 0 : i);

			this.children[i].cenX = this.children[i].posX + (this.itemWidth  / 2);
			this.children[i].cenY = this.children[i].posY + (this.itemHeight / 2);

			var isz = this.isHorizontal ? this.itemWidth : this.itemHeight;
			var r = this.effectUnits * isz;
			var c = this.isHorizontal ? this.children[i].cenX : this.children[i].cenY;
			var lhs = this.isHorizontal ? this.proximityLeft : this.proximityTop;
			var rhs = this.isHorizontal ? this.proximityRight : this.proximityBottom;
			var siz = this.isHorizontal ? this.barWidth : this.barHeight;

			var range_lhs = r;
			var range_rhs = r;

			if (range_lhs > c+lhs){ range_lhs = c+lhs; }
			if (range_rhs > (siz-c+rhs)){ range_rhs = siz-c+rhs; }

			this.children[i].effectRangeLeft = range_lhs / isz;
			this.children[i].effectRangeRght = range_rhs / isz;

			//dojo.debug('effect range for '+i+' is '+range_lhs+'/'+range_rhs);
		}


		//
		// create the bar
		//

		this.domNode.style.width = this.barWidth + 'px';
		this.domNode.style.height = this.barHeight + 'px';


		//
		// position the items
		//
		for (var i=0; i<this.children.length; i++){
			var itm = this.children[i];
			var elm = itm.domNode;
			elm.style.left   = itm.posX + 'px';
			elm.style.top    = itm.posY + 'px';
			elm.style.width  = this.itemWidth + 'px';
			elm.style.height = this.itemHeight + 'px';
			
			if ( itm.svgNode ) {
				itm.svgNode.style.position = 'absolute';
				itm.svgNode.style.left = this.itemPadding+'%';
				itm.svgNode.style.top = this.itemPadding+'%';
				itm.svgNode.style.width = (100 - 2 * this.itemPadding) + '%';
				itm.svgNode.style.height = (100 - 2 * this.itemPadding) + '%';
				itm.svgNode.style.zIndex = 1;
	
				itm.svgNode.setSize(this.itemWidth, this.itemHeight);
			} else {
				itm.imgNode.style.left = this.itemPadding+'%';
				itm.imgNode.style.top = this.itemPadding+'%';
				itm.imgNode.style.width = (100 - 2 * this.itemPadding) + '%';
				itm.imgNode.style.height = (100 - 2 * this.itemPadding) + '%';
			}
		}

		//
		// calc the grid
		//

		this.calcHitGrid();

		//
		// in liberal trigger mode, activate menu whenever mouse is close
		//
		if( !this.conservativeTrigger ){
			dojo.event.connect(document.documentElement, "onmousemove", this, "mouseHandler");
		}
		
		// Deactivate the menu if mouse is moved off screen (doesn't work for FF?)
		dojo.event.connect(document.documentElement, "onmouseout", this, "onBodyOut");
	},

	onBodyOut: function(e){
		// clicking over an object inside of body causes this event to fire; ignore that case
		if( dojo.html.overElement(document.body, e) ){
			return;
		}
		this.setDormant(e);
	},

	// when mouse moves out of menu's range
	setDormant: function(e){
		if( !this.isOver ){ return; }	// already dormant?
		this.isOver = false;

		if ( this.conservativeTrigger ) {
			// user can't re-trigger the menu expansion
			// until he mouses over a icon again
			dojo.event.disconnect(document.documentElement, "onmousemove", this, "mouseHandler");
		}
		this.onGridMouseMove(-1, -1);
	},

	// when mouse is moved into menu's range
	setActive: function(e){
		if( this.isOver ){ return; }	// already activated?
		this.isOver = true;

		if ( this.conservativeTrigger ) {
			// switch event handlers so that we handle mouse events from anywhere near
			// the menu
			dojo.event.connect(document.documentElement, "onmousemove", this, "mouseHandler");

			this.timerScale=0.0;

			// call mouse handler to do some initial necessary calculations/positioning
			this.mouseHandler(e);

			// slowly expand the icon size so it isn't jumpy
			this.expandSlowly();
		}
	},

	// when mouse is moved
	mouseHandler: function(e) {
		if ((e.pageX >= this.hitX1) && (e.pageX <= this.hitX2) &&
			(e.pageY >= this.hitY1) && (e.pageY <= this.hitY2)){
			if( !this.isOver ){
				this.setActive(e);
			}
			this.onGridMouseMove(e.pageX-this.hitX1, e.pageY-this.hitY1);
		}else{
			if (this.isOver){
				this.setDormant(e);
			}
		}
	},

	onResized: function() {
		this.calcHitGrid();
	},

	onGridMouseMove: function(x, y){
		this.pos = {x:x, y:y};
		this.paint();
	},
	
	paint: function(){
		var x=this.pos.x;
		var y=this.pos.y;

		if( this.itemCount <= 0 ){ return; }

		//
		// figure out our main index
		//

		var pos = this.isHorizontal ? x : y;
		var prx = this.isHorizontal ? this.proximityLeft : this.proximityTop;
		var siz = this.isHorizontal ? this.itemWidth : this.itemHeight;
		var sim = this.isHorizontal ? 
			(1.0-this.timerScale)*this.itemWidth + this.timerScale*this.itemMaxWidth :
			(1.0-this.timerScale)*this.itemHeight + this.timerScale*this.itemMaxHeight ;

		var cen = ((pos - prx) / siz) - 0.5;
		var max_off_cen = (sim / siz) - 0.5;

		if (max_off_cen > this.effectUnits){ max_off_cen = this.effectUnits; }


		//
		// figure out our off-axis weighting
		//

		var off_weight = 0;

		if (this.anchorEdge == this.EDGE.BOTTOM){
			var cen2 = (y - this.proximityTop) / this.itemHeight;
			off_weight = (cen2 > 0.5) ? 1 : y / (this.proximityTop + (this.itemHeight / 2));
		}
		if (this.anchorEdge == this.EDGE.TOP){
			var cen2 = (y - this.proximityTop) / this.itemHeight;
			off_weight = (cen2 < 0.5) ? 1 : (this.totalHeight - y) / (this.proximityBottom + (this.itemHeight / 2));
		}
		if (this.anchorEdge == this.EDGE.RIGHT){
			var cen2 = (x - this.proximityLeft) / this.itemWidth;
			off_weight = (cen2 > 0.5) ? 1 : x / (this.proximityLeft + (this.itemWidth / 2));
		}
		if (this.anchorEdge == this.EDGE.LEFT){
			var cen2 = (x - this.proximityLeft) / this.itemWidth;
			off_weight = (cen2 < 0.5) ? 1 : (this.totalWidth - x) / (this.proximityRight + (this.itemWidth / 2));
		}
		if (this.anchorEdge == this.EDGE.CENTER){

			if (this.isHorizontal){
				off_weight = y / (this.totalHeight);
			}else{
				off_weight = x / (this.totalWidth);
			}

			if (off_weight > 0.5){
				off_weight = 1 - off_weight;
			}

			off_weight *= 2;
		}


		//
		// set the sizes
		//

		for(var i=0; i<this.itemCount; i++){

			var weight = this.weightAt(cen, i);

			if (weight < 0){weight = 0;}

			this.setitemsize(i, weight * off_weight);
		}

		//
		// set the positions
		//

		var main_p = Math.round(cen);
		var offset = 0;

		if (cen < 0){
			main_p = 0;

		}else if (cen > this.itemCount - 1){

			main_p = this.itemCount -1;

		}else{

			offset = (cen - main_p) * ((this.isHorizontal ? this.itemWidth : this.itemHeight) - this.children[main_p].sizeMain);
		}

		this.positionElementsFrom(main_p, offset);
	},

	weightAt: function(cen, i){

		var dist = Math.abs(cen - i);

		var limit = ((cen - i) > 0) ? this.children[i].effectRangeRght : this.children[i].effectRangeLeft;

		return (dist > limit) ? 0 : (1 - dist / limit);
	},

	positionFromNode: function(p, w){

		//
		// we need to grow all the nodes growing out from node 'i'
		//

		this.setitemsize(p, w);

		var wx = w;
		for(var i=p; i<this.itemCount; i++){
			wx = 0.8 * wx;
			this.setitemsize(i, wx);
		}

		var wx = w;
		for(var i=p; i>=0; i--){
			wx = 0.8 * wx;
			this.setitemsize(i, wx);
		}
	},

	setitemsize: function(p, scale){
		scale *= this.timerScale;
		var w = Math.round(this.itemWidth  + ((this.itemMaxWidth  - this.itemWidth ) * scale));
		var h = Math.round(this.itemHeight + ((this.itemMaxHeight - this.itemHeight) * scale));

		if (this.isHorizontal){

			this.children[p].sizeW = w;
			this.children[p].sizeH = h;

			this.children[p].sizeMain = w;
			this.children[p].sizeOff  = h;

			var y = 0;

			if (this.anchorEdge == this.EDGE.TOP){

				y = (this.children[p].cenY - (this.itemHeight / 2));

			}else if (this.anchorEdge == this.EDGE.BOTTOM){

				y = (this.children[p].cenY - (h - (this.itemHeight / 2)));

			}else{

				y = (this.children[p].cenY - (h / 2));
			}

			this.children[p].usualX = Math.round(this.children[p].cenX - (w / 2));
			
			this.children[p].domNode.style.top  = y + 'px';

			this.children[p].domNode.style.left  = this.children[p].usualX + 'px';

		}else{

			this.children[p].sizeW = w;
			this.children[p].sizeH = h;

			this.children[p].sizeOff  = w;
			this.children[p].sizeMain = h;

			var x = 0;

			if (this.anchorEdge == this.EDGE.LEFT){

				x = this.children[p].cenX - (this.itemWidth / 2);

			}else if (this.anchorEdge == this.EDGE.RIGHT){

				x = this.children[p].cenX - (w - (this.itemWidth / 2));
			}else{

				x = this.children[p].cenX - (w / 2);
			}

			this.children[p].domNode.style.left = x + 'px';
			this.children[p].usualY = Math.round(this.children[p].cenY - (h / 2));

			this.children[p].domNode.style.top  = this.children[p].usualY + 'px';
		}

		this.children[p].domNode.style.width  = w + 'px';
		this.children[p].domNode.style.height = h + 'px';

		if (this.children[p].svgNode){
			this.children[p].svgNode.setSize(w, h);
		}
	},

	positionElementsFrom: function(p, offset){

		var pos = 0;

		if (this.isHorizontal){
			pos = Math.round(this.children[p].usualX + offset);
			this.children[p].domNode.style.left = pos + 'px';
		}else{
			pos = Math.round(this.children[p].usualY + offset);
			this.children[p].domNode.style.top = pos + 'px';
		}
		this.positionLabel(this.children[p]);


		//
		// position before
		//

		var bpos = pos;

		for(var i=p-1; i>=0; i--){

			bpos -= this.children[i].sizeMain;

			if (this.isHorizontal){
				this.children[i].domNode.style.left = bpos + 'px';
			}else{
				this.children[i].domNode.style.top = bpos + 'px';
			}
			this.positionLabel(this.children[i]);
		}

		//
		// position after
		//

		var apos = pos;

		for(var i=p+1; i<this.itemCount; i++){

			apos += this.children[i-1].sizeMain;

			if (this.isHorizontal){
				this.children[i].domNode.style.left = apos + 'px';
			}else{
				this.children[i].domNode.style.top = apos + 'px';
			}
			this.positionLabel(this.children[i]);
		}

	},

	positionLabel: function(itm){

		var x = 0;
		var y = 0;
		
		var labelW = dojo.style.getOuterWidth(itm.lblNode);
		var labelH = dojo.style.getOuterHeight(itm.lblNode);

		if (this.labelEdge == this.EDGE.TOP){
			x = Math.round((itm.sizeW / 2) - (labelW / 2));
			y = -labelH;
		}

		if (this.labelEdge == this.EDGE.BOTTOM){
			x = Math.round((itm.sizeW / 2) - (labelW / 2));
			y = itm.sizeH;
		}

		if (this.labelEdge == this.EDGE.LEFT){
			x = -labelW;
			y = Math.round((itm.sizeH / 2) - (labelH / 2));
		}

		if (this.labelEdge == this.EDGE.RIGHT){
			x = itm.sizeW;
			y = Math.round((itm.sizeH / 2) - (labelH / 2));
		}

		itm.lblNode.style.left = x + 'px';
		itm.lblNode.style.top  = y + 'px';
	},

	calcHitGrid: function(){

		var pos = dojo.style.getAbsolutePosition(this.domNode, true);

		this.hitX1 = pos.x - this.proximityLeft;
		this.hitY1 = pos.y - this.proximityTop;
		this.hitX2 = this.hitX1 + this.totalWidth;
		this.hitY2 = this.hitY1 + this.totalHeight;

		//dojo.debug(this.hitX1+','+this.hitY1+' // '+this.hitX2+','+this.hitY2);
	},

	toEdge: function(inp, def){
		return this.EDGE[inp.toUpperCase()] || def;
	},
	
	// slowly expand the image to user specified max size
	expandSlowly: function(){
		if( !this.isOver ){ return; }
		this.timerScale += 0.2;
		this.paint();
		if ( this.timerScale<1.0 ) {
			dojo.lang.setTimeout(this, "expandSlowly", 10);
		}
	}

});

dojo.widget.html.FisheyeListItem = function(){
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.html.FisheyeListItem, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.FisheyeListItem, {
	widgetType: "FisheyeListItem",
	
	// Constructor arguments
	iconSrc: "",
	svgSrc: "",
	caption: "",

	blankImgPath: dojo.uri.dojoUri("src/widget/templates/images/blank.gif"),

	templateString:
		'<div class="dojoHtmlFisheyeListItem">' +
		'  <img class="dojoHtmlFisheyeListItemImage" dojoAttachPoint="imgNode" dojoAttachEvent="onMouseOver;onMouseOut;onClick">' +
		'  <div class="dojoHtmlFisheyeListItemLabel" dojoAttachPoint="lblNode"></div>' +
		'</div>',
	
	imgNode: null,

	fillInTemplate: function() {
		//
		// set image
		// TODO: turn on/off SVG support based on browser version.
		// this.parent.enableCrappySvgSupport is not available to this function
		//
		if (this.svgSrc != ""){
			this.svgNode = this.createSvgNode(this.svgSrc);
			this.domNode.appendChild(this.svgNode);
			this.imgNode.style.display = 'none';
		} else if((this.iconSrc.toLowerCase().substring(this.iconSrc.length-4)==".png")&&(dojo.render.html.ie)){
			this.imgNode.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+this.iconSrc+"', sizingMethod='scale')";
			this.imgNode.src = this.blankImgPath.toString();
		} else {
			this.imgNode.src = this.iconSrc;
		}

		//
		// Label
		//
		if ( this.lblNode ) {
			this.lblNode.appendChild(document.createTextNode(this.caption));
		}
		dojo.html.disableSelection(this.domNode);
	},
	
	createSvgNode: function(src){

		var elm = document.createElement('embed');
		elm.src = src;
		elm.type = 'image/svg+xml';
		//elm.style.border = '1px solid black';
		elm.style.width = '1px';
		elm.style.height = '1px';
		elm.loaded = 0;
		elm.setSizeOnLoad = false;

		elm.onload = function(){
			this.svgRoot = this.getSVGDocument().rootElement;
			this.svgDoc = this.getSVGDocument().documentElement;
			this.zeroWidth = this.svgRoot.width.baseVal.value;
			this.zeroHeight = this.svgRoot.height.baseVal.value;
			this.loaded = true;

			if (this.setSizeOnLoad){
				this.setSize(this.setWidth, this.setHeight);
			}
		}

		elm.setSize = function(w, h){
			if (!this.loaded){
				this.setWidth = w;
				this.setHeight = h;
				this.setSizeOnLoad = true;
				return;
			}

			this.style.width = w+'px';
			this.style.height = h+'px';
			this.svgRoot.width.baseVal.value = w;
			this.svgRoot.height.baseVal.value = h;

			var scale_x = w / this.zeroWidth;
			var scale_y = h / this.zeroHeight;

			for(var i=0; i<this.svgDoc.childNodes.length; i++){
				if (this.svgDoc.childNodes[i].setAttribute){
					this.svgDoc.childNodes[i].setAttribute( "transform", "scale("+scale_x+","+scale_y+")" );
				}
			}
		}

		return elm;
	},

	onMouseOver: function(e) {
		// in conservative mode, don't activate the menu until user mouses over an icon
		if( !this.parent.isOver ){
			this.parent.setActive(e);
		}
		if ( this.caption != "" ) {
			dojo.html.addClass(this.lblNode, "selected");
			this.parent.positionLabel(this);
		}
	},
	
	onMouseOut: function() {
		dojo.html.removeClass(this.lblNode, "selected");
	},

	onClick: function() {
	}
});


__CPAN_FILE__ src/widget/FloatingPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.FloatingPane");
dojo.provide("dojo.widget.html.FloatingPane");

//
// this widget provides a window-like floating pane
//

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.Manager");
dojo.require("dojo.html");
dojo.require("dojo.html.shadow");
dojo.require("dojo.style");
dojo.require("dojo.dom");
dojo.require("dojo.html.layout");
dojo.require("dojo.widget.ContentPane");
dojo.require("dojo.dnd.HtmlDragMove");
dojo.require("dojo.dnd.HtmlDragMoveSource");
dojo.require("dojo.dnd.HtmlDragMoveObject");
dojo.require("dojo.widget.ResizeHandle");

dojo.widget.html.FloatingPane = function(){
	dojo.widget.html.ContentPane.call(this);
}

dojo.inherits(dojo.widget.html.FloatingPane, dojo.widget.html.ContentPane);

dojo.lang.extend(dojo.widget.html.FloatingPane, {
	widgetType: "FloatingPane",

	// Constructor arguments
	title: '',
	iconSrc: '',
	hasShadow: false,
	constrainToContainer: false,
	taskBarId: "",
	resizable: true,
	titleBarDisplay: "fancy",

	windowState: "normal",
	displayCloseAction: false,
	displayMinimizeAction: false,
	displayMaximizeAction: false,

	maxTaskBarConnectAttempts: 5,
	taskBarConnectAttempts: 0,

	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlFloatingPane.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlFloatingPane.css"),

	fillInTemplate: function(args, frag){
		// Copy style info from input node to output node
		var source = this.getFragNodeRef(frag);
		// get around opera wich doesnt have cssText, and IE wich bugs on setAttribute 
		if(dojo.lang.isUndefined(source.style.cssText)){ 
			this.domNode.setAttribute("style", source.getAttribute("style")); 
		}else{
			this.domNode.style.cssText = source.style.cssText; 
		}
		dojo.html.addClass(this.domNode, dojo.html.getClass(source));

		// necessary for safari, khtml (for computing width/height)
		document.body.appendChild(this.domNode);

		// if display:none then state=minimized, otherwise state=normal
		if(!this.isShowing()){
			this.windowState="minimized";
		}

		// <img src=""> can hang IE!  better get rid of it
		if(this.iconSrc==""){
			dojo.dom.removeNode(this.titleBarIcon);
		}else{
			this.titleBarIcon.src = this.iconSrc.toString();// dojo.uri.Uri obj req. toString()
		}

		if(this.titleBarDisplay!="none"){	
			this.titleBar.style.display="";
			dojo.html.disableSelection(this.titleBar);

			this.titleBarIcon.style.display = (this.iconSrc=="" ? "none" : "");

			this.minimizeAction.style.display = (this.displayMinimizeAction ? "" : "none");
			this.maximizeAction.style.display= 
				(this.displayMaximizeAction && this.windowState!="maximized" ? "" : "none");
			this.restoreAction.style.display= 
				(this.displayMaximizeAction && this.windowState=="maximized" ? "" : "none");
			this.closeAction.style.display= (this.displayCloseAction ? "" : "none");
			var drag = new dojo.dnd.HtmlDragMoveSource(this.domNode);	
			if (this.constrainToContainer) {
				drag.constrainTo();
			}
			drag.setDragHandle(this.titleBar);
		}

		if(this.resizable){
			this.resizeBar.style.display="";
			var rh = dojo.widget.createWidget("ResizeHandle", {targetElmId: this.widgetId, id:this.widgetId+"_resize"});
			this.resizeBar.appendChild(rh.domNode);
		}

		// add a drop shadow
		if(this.hasShadow){
			this.shadow=new dojo.html.shadow(this.domNode);
		}

		// Prevent IE bleed-through problem
		this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);

		if( this.taskBarId ){
			this.taskBarSetup();
		}

		if (dojo.hostenv.post_load_) {
			this.setInitialWindowState();
		} else {
			dojo.addOnLoad(this, "setInitialWindowState");
		}

		// counteract body.appendChild above
		document.body.removeChild(this.domNode);

		dojo.widget.html.FloatingPane.superclass.fillInTemplate.call(this, args, frag);
	},

	postCreate: function(){
		if(this.isShowing()){
			this.width=-1;	// force resize
			this.resizeTo(dojo.style.getOuterWidth(this.domNode), dojo.style.getOuterHeight(this.domNode));
		}
	},

	maximizeWindow: function(evt) {
		this.previous={
			width: dojo.style.getOuterWidth(this.domNode) || this.width,
			height: dojo.style.getOuterHeight(this.domNode) || this.height,
			left: this.domNode.style.left,
			top: this.domNode.style.top,
			bottom: this.domNode.style.bottom,
			right: this.domNode.style.right
		};
		this.domNode.style.left =
			dojo.style.getPixelValue(this.domNode.parentNode, "padding-left", true) + "px";
		this.domNode.style.top =
			dojo.style.getPixelValue(this.domNode.parentNode, "padding-top", true) + "px";

		if ((this.domNode.parentNode.nodeName.toLowerCase() == 'body')) {
			this.resizeTo(
				dojo.html.getViewportWidth()-dojo.style.getPaddingWidth(document.body),
				dojo.html.getViewportHeight()-dojo.style.getPaddingHeight(document.body)
			);
		} else {
			this.resizeTo(
				dojo.style.getContentWidth(this.domNode.parentNode),
				dojo.style.getContentHeight(this.domNode.parentNode)
			);
		}
		this.maximizeAction.style.display="none";
		this.restoreAction.style.display="";
		this.windowState="maximized";
	},

	minimizeWindow: function(evt) {
		this.hide();
		this.windowState = "minimized";
	},

	restoreWindow: function(evt) {
		for(var attr in this.previous){
			this.domNode.style[attr] = this.previous[attr];
		}
		this.resizeTo(this.previous.width, this.previous.height);
		this.previous=null;

		this.restoreAction.style.display="none";
		this.maximizeAction.style.display=this.displayMaximizeAction ? "" : "none";

		this.windowState="normal";
	},

	closeWindow: function(evt) {
		dojo.dom.removeNode(this.domNode);
		this.destroy();
	},

	onMouseDown: function(evt) {
		this.bringToTop();
	},

	bringToTop: function() {
		var floatingPanes= dojo.widget.manager.getWidgetsByType(this.widgetType);
		var windows = [];
		for (var x=0; x<floatingPanes.length; x++) {
			if (this.widgetId != floatingPanes[x].widgetId) {
					windows.push(floatingPanes[x]);
			}
		}

		windows.sort(function(a,b) {
			return a.domNode.style.zIndex - b.domNode.style.zIndex;
		});
		
		windows.push(this);

		var floatingPaneStartingZ = 100;
		for (x=0; x<windows.length;x++) {
			windows[x].domNode.style.zIndex = floatingPaneStartingZ + x;
		}
	},

	setInitialWindowState: function() {
		if (this.windowState == "maximized") {
			this.maximizeWindow();
			this.show();
			return;
		}

		if (this.windowState=="normal") {
			this.show();
			return;
		}

		if (this.windowState=="minimized") {
			this.hide();
			return;
		}

		this.windowState="minimized";
	},

	// add icon to task bar, connected to me
	taskBarSetup: function() {
		var taskbar = dojo.widget.getWidgetById(this.taskBarId);
		if (!taskbar){
			if (this.taskBarConnectAttempts <  this.maxTaskBarConnectAttempts) {
				dojo.lang.setTimeout(this, this.taskBarSetup, 50);
				this.taskBarConnectAttempts++;
			} else {
				dojo.debug("Unable to connect to the taskBar");
			}
			return;
		}
		taskbar.addChild(this);
	},

	show: function(){
		dojo.widget.html.FloatingPane.superclass.show.apply(this, arguments);
		this.bringToTop();
	},

	onShow: function(){
		dojo.widget.html.FloatingPane.superclass.onShow.call(this);
		this.resizeTo(dojo.style.getOuterWidth(this.domNode), dojo.style.getOuterHeight(this.domNode));
	},

	// This is called when the user adjusts the size of the floating pane
	resizeTo: function(w, h){
		dojo.style.setOuterWidth(this.domNode, w);
		dojo.style.setOuterHeight(this.domNode, h);

		dojo.html.layout(this.domNode,
			[
			  {domNode: this.titleBar, layoutAlign: "top"},
			  {domNode: this.resizeBar, layoutAlign: "bottom"},
			  {domNode: this.containerNode, layoutAlign: "client"}
			] );

		// If any of the children have layoutAlign specified, obey it
		dojo.html.layout(this.containerNode, this.children, "top-bottom");
		
		this.bgIframe.onResized();
		if(this.shadow){ this.shadow.size(w, h); }
		this.onResized();
	},

	onParentResized: function() {
		// onParentResized() is called when the user has resized the browser window,
		// but that doesn't affect this widget (or this widget's children)
		// so it can be safely ignored...
		// TODO: unless we are maximized.  then we should resize ourself.
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:FloatingPane");

__CPAN_FILE__ src/widget/GoogleMap.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.GoogleMap");
dojo.provide("dojo.widget.GoogleMap.Controls");
dojo.require("dojo.widget.*");
dojo.widget.tags.addParseTreeHandler("dojo:googlemap");

dojo.widget.GoogleMap=function(){
	//	summary
	//	base class for the Google Map widget
	dojo.widget.Widget.call(this);
	this.widgetType="GoogleMap";
	this.isContainer=false;
}
dojo.inherits(dojo.widget.GoogleMap, dojo.widget.Widget);

dojo.widget.GoogleMap.Controls={
	LargeMap:"largemap",
	SmallMap:"smallmap",
	SmallZoom:"smallzoom",
	Scale:"scale",
	MapType:"maptype",
	Overview:"overview",
	get:function(s){
		for(var p in this){
			if(typeof(this[p])=="string"
				&& this[p]==s
			){
				return p;
			}
		}
		return null;
	}
};

dojo.requireAfterIf("html", "dojo.widget.html.GoogleMap");

__CPAN_FILE__ src/widget/HslColorPicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.HslColorPicker");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.Widget");
dojo.require("dojo.graphics.color");
dojo.widget.tags.addParseTreeHandler("dojo:hslcolorpicker");

dojo.requireAfterIf(dojo.render.svg.support.builtin, "dojo.widget.svg.HslColorPicker");

dojo.widget.HslColorPicker=function(){
	dojo.widget.Widget.call(this);
	this.widgetType = "HslColorPicker";
	this.isContainer = false;
}
dojo.inherits(dojo.widget.HslColorPicker, dojo.widget.Widget);

__CPAN_FILE__ src/widget/HtmlWidget.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.DomWidget");
dojo.require("dojo.html");
dojo.require("dojo.html.extras");
dojo.require("dojo.lang.extras");
dojo.require("dojo.lang.func");
dojo.require("dojo.lfx.toggle");

dojo.declare("dojo.widget.HtmlWidget", dojo.widget.DomWidget, {								 
	widgetType: "HtmlWidget",

	templateCssPath: null,
	templatePath: null,

	// for displaying/hiding widget
	toggle: "plain",
	toggleDuration: 150,

	animationInProgress: false,

	initialize: function(args, frag){
	},

	postMixInProperties: function(args, frag){
		// now that we know the setting for toggle, get toggle object
		// (default to plain toggler if user specified toggler not present)
		this.toggleObj =
			dojo.lfx.toggle[this.toggle.toLowerCase()] || dojo.lfx.toggle.plain;
	},

	getContainerHeight: function(){
		// NOTE: container height must be returned as the INNER height
		dojo.unimplemented("dojo.widget.HtmlWidget.getContainerHeight");
	},

	getContainerWidth: function(){
		return this.parent.domNode.offsetWidth;
	},

	setNativeHeight: function(height){
		var ch = this.getContainerHeight();
	},

	createNodesFromText: function(txt, wrap){
		return dojo.html.createNodesFromText(txt, wrap);
	},

	destroyRendering: function(finalize){
		try{
			if(!finalize){
				dojo.event.browser.clean(this.domNode);
			}
			this.domNode.parentNode.removeChild(this.domNode);
			delete this.domNode;
		}catch(e){ /* squelch! */ }
	},

	/////////////////////////////////////////////////////////
	// Displaying/hiding the widget
	/////////////////////////////////////////////////////////
	isShowing: function(){
		return dojo.style.isShowing(this.domNode);
	},

	toggleShowing: function(){
		// dojo.style.toggleShowing(this.domNode);
		if(this.isHidden){
			this.show();
		}else{
			this.hide();
		}
	},

	show: function(){
		this.animationInProgress=true;
		this.isHidden = false;
		this.toggleObj.show(this.domNode, this.toggleDuration, null,
			dojo.lang.hitch(this, this.onShow), this.explodeSrc);
	},

	// called after the show() animation has completed
	onShow: function(){
		this.animationInProgress=false;
	},

	hide: function(){
		this.animationInProgress = true;
		this.isHidden = true;
		this.toggleObj.hide(this.domNode, this.toggleDuration, null,
			dojo.lang.hitch(this, this.onHide), this.explodeSrc);
	},

	// called after the hide() animation has completed
	onHide: function(){
		this.animationInProgress=false;
	},

	//////////////////////////////////////////////////////////////////////////////
	// Sizing related methods
	//  If the parent changes size then for each child it should call either
	//   - resizeTo(): size the child explicitly
	//   - or onParentResized(): notify the child the the parent has changed size
	//////////////////////////////////////////////////////////////////////////////

	// Test if my size has changed.
	// If width & height are specified then that's my new size; otherwise,
	// query outerWidth/outerHeight of my domNode
	_isResized: function(w, h){
		// If I'm not being displayed then disregard (show() must
		// check if the size has changed)
		if(!this.isShowing()){ return false; }

		// If my parent has been resized and I have style="height: 100%"
		// or something similar then my size has changed too.
		w=w||dojo.style.getOuterWidth(this.domNode);
		h=h||dojo.style.getOuterHeight(this.domNode);
		if(this.width == w && this.height == h){ return false; }

		this.width=w;
		this.height=h;
		return true;
	},

	// Called when my parent has changed size, but my parent won't call resizeTo().
	// This is useful if my size is height:100% or something similar
	onParentResized: function(){
		if(!this._isResized()){ return; }
		this.onResized();
	},

	// Explicitly set this widget's size (in pixels).
	resizeTo: function(w, h){
		if(!this._isResized(w,h)){ return; }
		dojo.style.setOuterWidth(this.domNode, w);
		dojo.style.setOuterHeight(this.domNode, h);
		this.onResized();
	},

	resizeSoon: function(){
		if(this.isShowing()){
			dojo.lang.setTimeout(this, this.onResized, 0);
		}
	},

	// Called when my size has changed.
	// Must notify children if their size has (possibly) changed
	onResized: function(){
		dojo.lang.forEach(this.children, function(child){ child.onParentResized(); });
	}
});

__CPAN_FILE__ src/widget/InlineEditBox.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.InlineEditBox");
dojo.provide("dojo.widget.html.InlineEditBox");

dojo.require("dojo.widget.*");
dojo.require("dojo.fx.*");
dojo.require("dojo.graphics.color");
dojo.require("dojo.string");
dojo.require("dojo.style");
dojo.require("dojo.html");

dojo.widget.tags.addParseTreeHandler("dojo:inlineeditbox");

dojo.widget.html.InlineEditBox = function(){
	dojo.widget.HtmlWidget.call(this);
	// mutable objects need to be in constructor to give each instance its own copy
	this.history = [];
}

dojo.inherits(dojo.widget.html.InlineEditBox, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.InlineEditBox, {
	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlInlineEditBox.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlInlineEditBox.css"),
	widgetType: "InlineEditBox",

	form: null,
	editBox: null,
	edit: null,
	text: null,
	textarea: null,
	submitButton: null,
	cancelButton: null,
	mode: "text",

	minWidth: 100, //px. minimum width of edit box
	minHeight: 200, //px. minimum width of edit box, if it's a TA

	editing: false,
	textValue: "",
	defaultText: "",
	doFade: false,
	
	onSave: function(newValue, oldValue){},
	onUndo: function(value){},

	postCreate: function(args, frag){
		// put original node back in the document, and attach handlers
		// which hide it and display the editor
		this.editable = this.getFragNodeRef(frag);
		dojo.dom.insertAfter(this.editable, this.form);
		dojo.event.connect(this.editable, "onmouseover", this, "mouseover");
		dojo.event.connect(this.editable, "onmouseout", this, "mouseout");
		dojo.event.connect(this.editable, "onclick", this, "beginEdit");

		this.textValue = dojo.string.trim(this.editable.innerHTML);
		if(dojo.string.trim(this.textValue).length == 0){
			this.editable.innerHTML = this.defaultText;
		}		
	},

	mouseover: function(e){
		if(!this.editing){
			dojo.html.addClass(this.editable, "editableRegion");
			if(this.mode == "textarea"){
				dojo.html.addClass(this.editable, "editableTextareaRegion");
			}
		}
	},

	mouseout: function(e){
		if(!this.editing){
			dojo.html.removeClass(this.editable, "editableRegion");
			dojo.html.removeClass(this.editable, "editableTextareaRegion");
		}
	},

	// When user clicks the text, then start editing.
	// Hide the text and display the form instead.
	beginEdit: function(e){
		if(this.editing){ return; }
		this.mouseout();
		this.editing = true;

		// setup the form's <input> or <textarea> field, as specified by mode
		var ee = this[this.mode.toLowerCase()];
		ee.value = dojo.string.trim(this.textValue);
		ee.style.fontSize = dojo.style.getStyle(this.editable, "font-size");
		ee.style.fontWeight = dojo.style.getStyle(this.editable, "font-weight");
		ee.style.fontStyle = dojo.style.getStyle(this.editable, "font-style");
		ee.style.width = Math.max(dojo.html.getInnerWidth(this.editable), this.minWidth) + "px";
		if(this.mode.toLowerCase()=="textarea"){
			ee.style.display = "block";
			ee.style.height = Math.max(dojo.html.getInnerHeight(this.editable), this.minHeight) + "px";
		} else {
			ee.style.display = "";
		}

		// show the edit form and hide the read only version of the text
		this.form.style.display = "";
		this.editable.style.display = "none";

		ee.select();
		this.submitButton.disabled = true;
	},

	saveEdit: function(e){
		e.preventDefault();
		e.stopPropagation();
		var ee = this[this.mode.toLowerCase()];
		if((this.textValue != ee.value)&&
			(dojo.string.trim(ee.value) != "")){
			this.doFade = true;
			this.history.push(this.textValue);
			this.onSave(ee.value, this.textValue);
			this.textValue = ee.value;
			this.editable.innerHTML = this.textValue;
		}else{
			this.doFade = false;
		}
		this.finishEdit(e);
	},

	cancelEdit: function(e){
		if(!this.editing){ return false; }
		this.editing = false;
		this.form.style.display="none";
		this.editable.style.display = "";
		return true;
	},

	finishEdit: function(e){
		if(!this.cancelEdit(e)){ return; }
		if(this.doFade) {
			dojo.lfx.highlight(this.editable, dojo.graphics.color.hex2rgb("#ffc"), 700).play(300);
		}
		this.doFade = false;
	},

	setText: function(txt){
		// sets the text without informing the server
		var tt = dojo.string.trim(txt);
		this.textValue = tt
		this.editable.innerHTML = tt;
	},

	undo: function(){
		if(this.history.length > 0){
			var value = this.history.pop();
			this.editable.innerHTML = value;
			this.textValue = value;
			this.onUndo(value);
		}
	},

	checkForValueChange: function(){
		var ee = this[this.mode.toLowerCase()];
		if((this.textValue != ee.value)&&
			(dojo.string.trim(ee.value) != "")){
			this.submitButton.disabled = false;
		}
	}
});

__CPAN_FILE__ src/widget/LayoutContainer.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

//
// this widget provides Delphi-style panel layout semantics
//

dojo.provide("dojo.widget.LayoutContainer");
dojo.provide("dojo.widget.html.LayoutContainer");

dojo.require("dojo.widget.*");
dojo.require("dojo.html.layout");

dojo.widget.html.LayoutContainer = function(){
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.html.LayoutContainer, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.LayoutContainer, {
	widgetType: "LayoutContainer",
	isContainer: true,

	layoutChildPriority: 'top-bottom',

	postCreate: function(){
		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
	},

	addChild: function(child, overrideContainerNode, pos, ref, insertIndex){
		dojo.widget.html.LayoutContainer.superclass.addChild.call(this, child, overrideContainerNode, pos, ref, insertIndex);
		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
	},

	removeChild: function(pane){
		dojo.widget.html.LayoutContainer.superclass.removeChild.call(this,pane);
		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
	},

	onResized: function(){
		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
	},

	show: function(){
		// If this node was created while display=="none" then it
		// hasn't been laid out yet.  Do that now.
		this.domNode.style.display="";
		this.onParentResized();
		this.domNode.style.display="none";
		this.domNode.style.visibility="";

		dojo.widget.html.LayoutContainer.superclass.show.call(this);
	}
});

// This argument can be specified for the children of a LayoutContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.lang.extend(dojo.widget.Widget, {
	layoutAlign: 'none'
});

dojo.widget.tags.addParseTreeHandler("dojo:LayoutContainer");

__CPAN_FILE__ src/widget/LinkPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.LinkPane");

dojo.require("dojo.widget.*");
dojo.requireAfterIf("html", "dojo.widget.html.LinkPane");
dojo.widget.tags.addParseTreeHandler("dojo:LinkPane");

// NOTE: there's no stub file for this widget

__CPAN_FILE__ src/widget/Manager.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Manager");
dojo.require("dojo.lang.array");
dojo.require("dojo.lang.func");
dojo.require("dojo.event.*");

// Manager class
dojo.widget.manager = new function(){
	this.widgets = [];
	this.widgetIds = [];
	
	// map of widgetId-->widget for widgets without parents (top level widgets)
	this.topWidgets = {};

	var widgetTypeCtr = {};
	var renderPrefixCache = [];

	this.getUniqueId = function (widgetType) {
		return widgetType + "_" + (widgetTypeCtr[widgetType] != undefined ?
			++widgetTypeCtr[widgetType] : widgetTypeCtr[widgetType] = 0);
	}

	this.add = function(widget){
		dojo.profile.start("dojo.widget.manager.add");
		this.widgets.push(widget);
		// Opera9 uses ID (caps)
		if(!widget.extraArgs["id"]){
			widget.extraArgs["id"] = widget.extraArgs["ID"];
		}
		// FIXME: the rest of this method is very slow!
		if(widget.widgetId == ""){
			if(widget["id"]){
				widget.widgetId = widget["id"];
			}else if(widget.extraArgs["id"]){
				widget.widgetId = widget.extraArgs["id"];
			}else{
				widget.widgetId = this.getUniqueId(widget.widgetType);
			}
		}
		if(this.widgetIds[widget.widgetId]){
			dojo.debug("widget ID collision on ID: "+widget.widgetId);
		}
		this.widgetIds[widget.widgetId] = widget;
		// Widget.destroy already calls removeById(), so we don't need to
		// connect() it here
		dojo.profile.end("dojo.widget.manager.add");
	}

	this.destroyAll = function(){
		for(var x=this.widgets.length-1; x>=0; x--){
			try{
				// this.widgets[x].destroyChildren();
				this.widgets[x].destroy(true);
				delete this.widgets[x];
			}catch(e){ }
		}
	}

	// FIXME: we should never allow removal of the root widget until all others
	// are removed!
	this.remove = function(widgetIndex){
		var tw = this.widgets[widgetIndex].widgetId;
		delete this.widgetIds[tw];
		this.widgets.splice(widgetIndex, 1);
	}
	
	// FIXME: suboptimal performance
	this.removeById = function(id) {
		for (var i=0; i<this.widgets.length; i++){
			if(this.widgets[i].widgetId == id){
				this.remove(i);
				break;
			}
		}
	}

	this.getWidgetById = function(id){
		return this.widgetIds[id];
	}

	this.getWidgetsByType = function(type){
		var lt = type.toLowerCase();
		var ret = [];
		dojo.lang.forEach(this.widgets, function(x){
			if(x.widgetType.toLowerCase() == lt){
				ret.push(x);
			}
		});
		return ret;
	}

	this.getWidgetsOfType = function (id) {
		dojo.deprecated("getWidgetsOfType is depecrecated, use getWidgetsByType");
		return dojo.widget.manager.getWidgetsByType(id);
	}

	this.getWidgetsByFilter = function(unaryFunc, onlyOne){
		var ret = [];
		dojo.lang.every(this.widgets, function(x){
			if(unaryFunc(x)){
				ret.push(x);
				if(onlyOne){return false;}
			}
			return true;
		});
		return (onlyOne ? ret[0] : ret);
	}

	this.getAllWidgets = function() {
		return this.widgets.concat();
	}

	//	added, trt 2006-01-20
	this.getWidgetByNode = function(/* DOMNode */ node){
		var w=this.getAllWidgets();
		for (var i=0; i<w.length; i++){
			if (w[i].domNode==node){
				return w[i];
			}
		}
		return null;
	}

	// shortcuts, baby
	this.byId = this.getWidgetById;
	this.byType = this.getWidgetsByType;
	this.byFilter = this.getWidgetsByFilter;
	this.byNode = this.getWidgetByNode;

	// map of previousally discovered implementation names to constructors
	var knownWidgetImplementations = {};

	// support manually registered widget packages
	var widgetPackages = ["dojo.widget"];
	for (var i=0; i<widgetPackages.length; i++) {
		// convenience for checking if a package exists (reverse lookup)
		widgetPackages[widgetPackages[i]] = true;
	}

	this.registerWidgetPackage = function(pname) {
		if(!widgetPackages[pname]){
			widgetPackages[pname] = true;
			widgetPackages.push(pname);
		}
	}
	
	this.getWidgetPackageList = function() {
		return dojo.lang.map(widgetPackages, function(elt) { return(elt!==true ? elt : undefined); });
	}
	
	this.getImplementation = function(widgetName, ctorObject, mixins){
		// try and find a name for the widget
		var impl = this.getImplementationName(widgetName);
		if(impl){ 
			// var tic = new Date();
			var ret = new impl(ctorObject);
			// dojo.debug(new Date() - tic);
			return ret;
		}
	}

	this.getImplementationName = function(widgetName){
		/*
		 * This is the overly-simplistic implemention of getImplementation (har
		 * har). In the future, we are going to want something that allows more
		 * freedom of expression WRT to specifying different specializations of
		 * a widget.
		 *
		 * Additionally, this implementation treats widget names as case
		 * insensitive, which does not necessarialy mesh with the markup which
		 * can construct a widget.
		 */

		var lowerCaseWidgetName = widgetName.toLowerCase();

		var impl = knownWidgetImplementations[lowerCaseWidgetName];
		if(impl){
			return impl;
		}

		// first store a list of the render prefixes we are capable of rendering
		if(!renderPrefixCache.length){
			for(var renderer in dojo.render){
				if(dojo.render[renderer]["capable"] === true){
					var prefixes = dojo.render[renderer].prefixes;
					for(var i = 0; i < prefixes.length; i++){
						renderPrefixCache.push(prefixes[i].toLowerCase());
					}
				}
			}
			// make sure we don't HAVE to prefix widget implementation names
			// with anything to get them to render
			renderPrefixCache.push("");
		}

		// look for a rendering-context specific version of our widget name
		for(var i = 0; i < widgetPackages.length; i++){
			var widgetPackage = dojo.evalObjPath(widgetPackages[i]);
			if(!widgetPackage) { continue; }

			for (var j = 0; j < renderPrefixCache.length; j++) {
				if (!widgetPackage[renderPrefixCache[j]]) { continue; }
				for (var widgetClass in widgetPackage[renderPrefixCache[j]]) {
					if (widgetClass.toLowerCase() != lowerCaseWidgetName) { continue; }
					knownWidgetImplementations[lowerCaseWidgetName] =
						widgetPackage[renderPrefixCache[j]][widgetClass];
					return knownWidgetImplementations[lowerCaseWidgetName];
				}
			}

			for (var j = 0; j < renderPrefixCache.length; j++) {
				for (var widgetClass in widgetPackage) {
					if (widgetClass.toLowerCase() !=
						(renderPrefixCache[j] + lowerCaseWidgetName)) { continue; }
	
					knownWidgetImplementations[lowerCaseWidgetName] =
						widgetPackage[widgetClass];
					return knownWidgetImplementations[lowerCaseWidgetName];
				}
			}
		}
		
		throw new Error('Could not locate "' + widgetName + '" class');
	}

	// FIXME: does it even belong in this name space?
	// NOTE: this method is implemented by DomWidget.js since not all
	// hostenv's would have an implementation.
	/*this.getWidgetFromPrimitive = function(baseRenderType){
		dojo.unimplemented("dojo.widget.manager.getWidgetFromPrimitive");
	}

	this.getWidgetFromEvent = function(nativeEvt){
		dojo.unimplemented("dojo.widget.manager.getWidgetFromEvent");
	}*/

	// Catch window resize events and notify top level widgets
	this.resizing=false;
	this.onWindowResized = function(){
		if(this.resizing){
			return;	// duplicate event
		}
		try{
			this.resizing=true;
			for(var id in this.topWidgets){
				var child = this.topWidgets[id];
				if(child.onParentResized ){
					child.onParentResized();
				}
			};
		}catch(e){
		}finally{
			this.resizing=false;
		}
	}
	if(typeof window != "undefined") {
		dojo.addOnLoad(this, 'onWindowResized');							// initial sizing
		dojo.event.connect(window, 'onresize', this, 'onWindowResized');	// window resize
	}

	// FIXME: what else?
};

(function(){
	var dw = dojo.widget;
	var dwm = dw.manager;
	var h = dojo.lang.curry(dojo.lang, "hitch", dwm);
	var g = function(oldName, newName){
		dw[(newName||oldName)] = h(oldName);
	}
	// copy the methods from the default manager (this) to the widget namespace
	g("add", "addWidget");
	g("destroyAll", "destroyAllWidgets");
	g("remove", "removeWidget");
	g("removeById", "removeWidgetById");
	g("getWidgetById");
	g("getWidgetById", "byId");
	g("getWidgetsByType");
	g("getWidgetsByFilter");
	g("getWidgetsByType", "byType");
	g("getWidgetsByFilter", "byFilter");
	g("getWidgetByNode", "byNode");
	dw.all = function(n){
		var widgets = dwm.getAllWidgets.apply(dwm, arguments);
		if(arguments.length > 0) {
			return widgets[n];
		}
		return widgets;
	}
	g("registerWidgetPackage");
	g("getImplementation", "getWidgetImplementation");
	g("getImplementationName", "getWidgetImplementationName");

	dw.widgets = dwm.widgets;
	dw.widgetIds = dwm.widgetIds;
	dw.root = dwm.root;
})();

__CPAN_FILE__ src/widget/Menu.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Menu");
dojo.provide("dojo.widget.DomMenu");

dojo.deprecated("dojo.widget.Menu, dojo.widget.DomMenu",  "use dojo.widget.Menu2", "0.4");

dojo.require("dojo.widget.*");

dojo.widget.tags.addParseTreeHandler("dojo:menu");

/* Menu
 *******/

dojo.widget.Menu = function () {
	dojo.widget.Menu.superclass.constructor.call(this);
}
dojo.inherits(dojo.widget.Menu, dojo.widget.Widget);

dojo.lang.extend(dojo.widget.Menu, {
	widgetType: "Menu",
	isContainer: true,
	
	items: [],
	push: function(item){
		dojo.connect.event(item, "onSelect", this, "onSelect");
		this.items.push(item);
	},
	onSelect: function(){}
});


/* DomMenu
 **********/

dojo.widget.DomMenu = function(){
	dojo.widget.DomMenu.superclass.constructor.call(this);
}
dojo.inherits(dojo.widget.DomMenu, dojo.widget.DomWidget);

dojo.lang.extend(dojo.widget.DomMenu, {
	widgetType: "Menu",
	isContainer: true,

	push: function (item) {
		dojo.widget.Menu.call(this, item);
		this.domNode.appendChild(item.domNode);
	}
});

dojo.requireAfterIf("html", "dojo.widget.html.Menu");

__CPAN_FILE__ src/widget/Menu2.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Menu2");
dojo.provide("dojo.widget.html.Menu2");
dojo.provide("dojo.widget.PopupMenu2");
dojo.provide("dojo.widget.MenuItem2");
dojo.provide("dojo.widget.MenuBar2");

dojo.require("dojo.html");
dojo.require("dojo.style");
dojo.require("dojo.event.*");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");


dojo.widget.PopupMenu2 = function(){
	dojo.widget.HtmlWidget.call(this);
	this.items = [];	// unused???
	this.targetNodeIds = []; // fill this with nodeIds upon widget creation and it becomes context menu for those nodes
	this.queueOnAnimationFinish = [];

	this.eventNames =  {
		open: ""
	};

}

dojo.inherits(dojo.widget.PopupMenu2, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.PopupMenu2, {
	widgetType: "PopupMenu2",
	isContainer: true,

	snarfChildDomOutput: true,

	currentSubmenu: null,
	currentSubmenuTrigger: null,
	parentMenu: null,
	parentMenuBar: null,
	isShowingNow: false,
	menuX: 0,
	menuY: 0,
	menuWidth: 0,
	menuHeight: 0,
	menuIndex: 0,

	domNode: null,
	containerNode: null,

	eventNaming: "default",


	templateString: '<div class="dojoPopupMenu2" style="left:-9999px; top:-9999px; display: none;"><div dojoAttachPoint="containerNode" class="dojoPopupMenu2Client"></div></div>',
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlMenu2.css"),

	itemHeight: 18,
	iconGap: 1,
	accelGap: 10,
	submenuGap: 2,
	finalGap: 5,
	submenuIconSize: 4,
	separatorHeight: 9,
	submenuDelay: 500,
	submenuOverlap: 5,
	contextMenuForWindow: false,
	openEvent: null,

	submenuIconSrc: dojo.uri.dojoUri("src/widget/templates/images/submenu_off.gif").toString(),
	submenuIconOnSrc: dojo.uri.dojoUri("src/widget/templates/images/submenu_on.gif").toString(),

	initialize: function(args, frag) {

		if (this.eventNaming == "default") {
			for (eventName in this.eventNames) {
				this.eventNames[eventName] = this.widgetId+"/"+eventName;
			}
		}

	},

	postCreate: function(){
		if (this.domNode.style.display=="none"){
			this.domNode.style.display = "";
		}
		this.domNode.style.left = '-9999px'
		this.domNode.style.top = '-9999px'

		// attach menu to document body if it's not already there
		if (this.domNode.parentNode != document.body){
			document.body.appendChild(this.domNode);
		}


		if (this.contextMenuForWindow){
			var doc = document.documentElement  || document.body;
			dojo.widget.Menu2.OperaAndKonqFixer.fixNode(doc);
			dojo.event.connect(doc, "oncontextmenu", this, "onOpen");
		} else if ( this.targetNodeIds.length > 0 ){
			for(var i=0; i<this.targetNodeIds.length; i++){
				this.bindDomNode(this.targetNodeIds[i]);
			}
		}

		this.subscribeSubitemsOnOpen();

		this.layoutMenuSoon();
	},

	subscribeSubitemsOnOpen: function() {
		var subItems = this.getChildrenOfType(dojo.widget.MenuItem2);

		//dojo.debug(subItems)

		for(var i=0; i<subItems.length; i++) {
			//dojo.debug(subItems[i]);
			dojo.event.topic.subscribe(this.eventNames.open, subItems[i], "menuOpen")
		}
	},

	// get open event for current menu
	getTopOpenEvent: function() {
		var menu = this;
		while (menu.parent){ menu = menu.parent; }
		return menu.openEvent;
	},

	// attach menu to given node
	bindDomNode: function(nodeName){
		var node = dojo.byId(nodeName);

		// fixes node so that it supports oncontextmenu if not natively supported, Konqueror, Opera more?
		dojo.widget.Menu2.OperaAndKonqFixer.fixNode(node);

		dojo.event.kwConnect({
			srcObj:     node,
			srcFunc:    "oncontextmenu",
			targetObj:  this,
			targetFunc: "onOpen",
			once:       true
		});
	},

	// detach menu from given node
	unBindDomNode: function(nodeName){
		var node = dojo.byId(nodeName);
		dojo.event.kwDisconnect({
			srcObj:     node,
			srcFunc:    "oncontextmenu",
			targetObj:  this,
			targetFunc: "onOpen",
			once:       true
		});

		// cleans a fixed node, konqueror and opera
		dojo.widget.Menu2.OperaAndKonqFixer.cleanNode(node);
	},

	layoutMenuSoon: function(){
		dojo.lang.setTimeout(this, "layoutMenu", 0);
	},

	layoutMenu: function(){

        // menu must be attached to DOM for size calculations to work

        var parent = this.domNode.parentNode;
        if (! parent || parent == undefined) {
            document.body.appendChild(this.domNode);
        }

        // determine menu width

		var max_label_w = 0;
		var max_accel_w = 0;

		for(var i=0; i<this.children.length; i++){

			if (this.children[i].getLabelWidth){

				max_label_w = Math.max(max_label_w, this.children[i].getLabelWidth());
			}

			if (dojo.lang.isFunction(this.children[i].getAccelWidth)){

				max_accel_w = Math.max(max_accel_w, this.children[i].getAccelWidth());
			}
		}

		if( isNaN(max_label_w) || isNaN(max_accel_w) ){
			// Browser needs some more time to calculate sizes
			this.layoutMenuSoon();
			return;
		}

		var clientLeft = dojo.style.getPixelValue(this.domNode, "padding-left", true) + dojo.style.getPixelValue(this.containerNode, "padding-left", true);
		var clientTop  = dojo.style.getPixelValue(this.domNode, "padding-top", true)  + dojo.style.getPixelValue(this.containerNode, "padding-top", true);

		if( isNaN(clientLeft) || isNaN(clientTop) ){
			// Browser needs some more time to calculate sizes
			this.layoutMenuSoon();
			return;
		}

		var y = clientTop;
		var max_item_width = 0;

		for(var i=0; i<this.children.length; i++){

			var ch = this.children[i];

			ch.layoutItem(max_label_w, max_accel_w);

			ch.topPosition = y;

			y += dojo.style.getOuterHeight(ch.domNode);
			max_item_width = Math.max(max_item_width, dojo.style.getOuterWidth(ch.domNode));
		}

		dojo.style.setContentWidth(this.containerNode, max_item_width);
		dojo.style.setContentHeight(this.containerNode, y-clientTop);

		dojo.style.setContentWidth(this.domNode, dojo.style.getOuterWidth(this.containerNode));
		dojo.style.setContentHeight(this.domNode, dojo.style.getOuterHeight(this.containerNode));

		this.menuWidth = dojo.style.getOuterWidth(this.domNode);
		this.menuHeight = dojo.style.getOuterHeight(this.domNode);
	},

	/**
	 * Open the menu at position (x,y), relative to the viewport
	 * (usually positions are relative to the document; why is this different??)
	 */
	open: function(x, y, parent, explodeSrc){

		// if explodeSrc isn't specified then explode from my parent widget
		explodeSrc = explodeSrc || parent["domNode"] || [];

		if (this.isShowingNow){ return; }

		var parentMenu = (parent && parent.widgetType=="PopupMenu2") ? parent : null;

		if ( !parentMenu ) {
			// record whenever a top level menu is opened
			// explodeSrc may or may not be a node - it may also be an [x,y] position array
			var button = explodeSrc instanceof Array ? null : explodeSrc;
			dojo.widget.html.Menu2Manager.opened(this, button);
		}

		//dojo.debug("open called for animation "+this.animationInProgress)

		// if I click  right button and menu is opened, then it gets 2 commands: close -> open
		// so close enables animation and next "open" is put to queue to occur at new location
		if(this.animationInProgress){
			this.queueOnAnimationFinish.push(this.open, arguments);
			return;
		}

		var viewport = dojo.html.getViewportSize();
		var scrolloffset = dojo.html.getScrollOffset();

		var clientRect = {
			'left'  : scrolloffset[0],
			'right' : scrolloffset[0] + viewport[0],
			'top'   : scrolloffset[1],
			'bottom': scrolloffset[1] + viewport[1]
		};

		if (parentMenu){
			// submenu is opening

			if (x + this.menuWidth > clientRect.right){ x = x - (this.menuWidth + parentMenu.menuWidth - (2 * this.submenuOverlap)); }

			if (y + this.menuHeight > clientRect.bottom){ y = y -
			(this.menuHeight - (this.itemHeight + 5)); } // TODO: why 5?

		}else{
			// top level menu is opening
			x+=scrolloffset[0];
			y+=scrolloffset[1];
			explodeSrc[0] += scrolloffset[0];
			explodeSrc[1] += scrolloffset[1];

			if (x < clientRect.left){ x = clientRect.left; }
			if (x + this.menuWidth > clientRect.right){ x = x - this.menuWidth; }

			if (y < clientRect.top){ y = clientRect.top; }
			if (y + this.menuHeight > clientRect.bottom){ y = y - this.menuHeight; }
		}

		this.parentMenu = parentMenu;
		this.explodeSrc = explodeSrc;
		this.menuIndex = parentMenu ? parentMenu.menuIndex + 1 : 1;

		this.menuX = x;
		this.menuY = y;

		// move the menu into position but make it invisible
		// (because when menus are initially constructed they are visible but off-screen)
		this.domNode.style.zIndex = 200 + this.menuIndex;
		this.domNode.style.left = x + 'px';
		this.domNode.style.top = y + 'px';
		this.domNode.style.display='none';
		this.domNode.style.position='absolute';

		// then use the user defined method to display it
		this.show();

		this.isShowingNow = true;
	},

	close: function(){
		// If we are in the process of opening the menu and we are asked to close it,
		// we should really cancel the current animation, but for simplicity we will
		// just ignore the request
		if(this.animationInProgress){
			this.queueOnAnimationFinish.push(this.close, []);
			return;
		}

		this.closeSubmenu();
		this.hide();
		this.isShowingNow = false;
		dojo.widget.html.Menu2Manager.closed(this);

		if (this.parentMenuBar){
			this.parentMenuBar.closedMenu(this);
		}
	},

	onShow: function() {
		dojo.widget.HtmlWidget.prototype.onShow.call(this);
		this.processQueue();
	},

	// do events from queue
	processQueue: function() {
		if (!this.queueOnAnimationFinish.length) return;

		var func = this.queueOnAnimationFinish.shift();
		var args = this.queueOnAnimationFinish.shift();

		func.apply(this, args);
	},

	onHide: function() {
		dojo.widget.HtmlWidget.prototype.onHide.call(this);

		this.processQueue();
	},


	closeAll: function(){
		if (this.parentMenu){
			this.parentMenu.closeAll();
		}else{
			this.close();
		}
	},

	closeSubmenu: function(){
		if (this.currentSubmenu == null){ return; }

		this.currentSubmenu.close();
		this.currentSubmenu = null;

		this.currentSubmenuTrigger.is_open = false;
		this.currentSubmenuTrigger.closedSubmenu();
		this.currentSubmenuTrigger = null;
	},

	openSubmenu: function(submenu, from_item){

		var our_x = dojo.style.getPixelValue(this.domNode, 'left');
		var our_y = dojo.style.getPixelValue(this.domNode, 'top');
		var our_w = dojo.style.getOuterWidth(this.domNode);
		var item_y = from_item.topPosition;

		var x = our_x + our_w - this.submenuOverlap;
		var y = our_y + item_y;

		this.currentSubmenu = submenu;
		this.currentSubmenu.open(x, y, this, from_item.domNode);

		this.currentSubmenuTrigger = from_item;
		this.currentSubmenuTrigger.is_open = true;
	},

	onOpen: function(e){
		this.openEvent = e;

		//dojo.debugShallow(e);
		this.open(e.clientX, e.clientY, null, [e.clientX, e.clientY]);

		if(e["preventDefault"]){
			e.preventDefault();
		}
	},

	isPointInMenu: function(x, y){

		if (x < this.menuX){ return false; }
		if (x > this.menuX + this.menuWidth){ return false; }

		if (y < this.menuY){ return false; }
		if (y > this.menuY + this.menuHeight){ return false; }

		return true;
	}
});


dojo.widget.MenuItem2 = function(){
	dojo.widget.HtmlWidget.call(this);

	this.eventNames = {
		engage: ""
	};
}

dojo.inherits(dojo.widget.MenuItem2, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.MenuItem2, {
	widgetType: "MenuItem2",
	templateString:
			 '<div class="dojoMenuItem2">'
			+'<div dojoAttachPoint="iconNode" class="dojoMenuItem2Icon"></div>'
			+'<span dojoAttachPoint="labelNode" class="dojoMenuItem2Label"><span><span></span></span></span>'
			+'<span dojoAttachPoint="accelNode" class="dojoMenuItem2Accel"><span><span></span></span></span>'
			+'<div dojoAttachPoint="submenuNode" class="dojoMenuItem2Submenu"></div>'
			+'<div dojoAttachPoint="targetNode" class="dojoMenuItem2Target" dojoAttachEvent="onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;">&nbsp;</div>'
			+'</div>',

	//
	// nodes
	//

	domNode: null,
	iconNode: null,
	labelNode: null,
	accelNode: null,
	submenuNode: null,
	targetNode: null,

	//
	// internal settings
	//

	is_hovering: false,
	hover_timer: null,
	is_open: false,
	topPosition: 0,

	//
	// options
	//

	caption: 'Untitled',
	accelKey: '',
	iconSrc: '',
	submenuId: '',
	disabled: false,
	eventNaming: "default",


	postCreate: function(){

		dojo.html.disableSelection(this.domNode);

		if (this.disabled){
			this.setDisabled(true);
		}

		this.labelNode.childNodes[0].appendChild(document.createTextNode(this.caption));
		this.accelNode.childNodes[0].appendChild(document.createTextNode(this.accelKey));

		this.labelShadowNode = this.labelNode.childNodes[0].childNodes[0];
		this.accelShadowNode = this.accelNode.childNodes[0].childNodes[0];

		this.labelShadowNode.appendChild(document.createTextNode(this.caption));
		this.accelShadowNode.appendChild(document.createTextNode(this.accelKey));

		if (this.eventNaming == "default") {
			for (eventName in this.eventNames) {
				this.eventNames[eventName] = this.widgetId+"/"+eventName;
			}
		}
	},

	layoutItem: function(label_w, accel_w){

		var x_label = this.parent.itemHeight + this.parent.iconGap;
		var x_accel = x_label + label_w + this.parent.accelGap;
		var x_submu = x_accel + accel_w + this.parent.submenuGap;
		var total_w = x_submu + this.parent.submenuIconSize + this.parent.finalGap;


		this.iconNode.style.left = '0px';
		this.iconNode.style.top = '0px';


		if (this.iconSrc){

			if ((this.iconSrc.toLowerCase().substring(this.iconSrc.length-4) == ".png") && (dojo.render.html.ie)){

				this.iconNode.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+this.iconSrc+"', sizingMethod='image')";
				this.iconNode.style.backgroundImage = '';
			}else{
				this.iconNode.style.backgroundImage = 'url('+this.iconSrc+')';
			}
		}else{
			this.iconNode.style.backgroundImage = '';
		}

		dojo.style.setOuterWidth(this.iconNode, this.parent.itemHeight);
		dojo.style.setOuterHeight(this.iconNode, this.parent.itemHeight);

		dojo.style.setOuterHeight(this.labelNode, this.parent.itemHeight);
		dojo.style.setOuterHeight(this.accelNode, this.parent.itemHeight);

		dojo.style.setContentWidth(this.domNode, total_w);
		dojo.style.setContentHeight(this.domNode, this.parent.itemHeight);

		this.labelNode.style.left = x_label + 'px';
		this.accelNode.style.left = x_accel + 'px';
		this.submenuNode.style.left = x_submu + 'px';

		dojo.style.setOuterWidth(this.submenuNode, this.parent.submenuIconSize);
		dojo.style.setOuterHeight(this.submenuNode, this.parent.itemHeight);

		this.submenuNode.style.display = this.submenuId ? 'block' : 'none';
		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconSrc+')';

		dojo.style.setOuterWidth(this.targetNode, total_w);
		dojo.style.setOuterHeight(this.targetNode, this.parent.itemHeight);
	},

	onHover: function(){

		if (this.is_hovering){ return; }
		if (this.is_open){ return; }

		this.parent.closeSubmenu();
		this.highlightItem();

		if (this.is_hovering){ this.stopSubmenuTimer(); }
		this.is_hovering = true;
		this.startSubmenuTimer();
	},

	onUnhover: function(){
		if (!this.is_open){ this.unhighlightItem(); }

		this.is_hovering = false;
		this.stopSubmenuTimer();
	},

	// Internal function for clicks
	_onClick: function(){
		if (this.disabled){ return; }

		if (this.submenuId){
			if (!this.is_open){
				this.stopSubmenuTimer();
				this.openSubmenu();
			}
		}else{
			this.parent.closeAll();
		}

		// for some browsers the onMouseOut doesn't get called (?), so call it manually
		this.onUnhover();

		// user defined handler for click
		this.onClick();

		dojo.event.topic.publish(this.eventNames.engage, this);
	},

	// User defined function to handle clicks
	onClick: function() { },

	highlightItem: function(){
		dojo.html.addClass(this.domNode, 'dojoMenuItem2Hover');
		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconOnSrc+')';
	},

	unhighlightItem: function(){
		dojo.html.removeClass(this.domNode, 'dojoMenuItem2Hover');
		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconSrc+')';
	},

	startSubmenuTimer: function(){
		this.stopSubmenuTimer();

		if (this.disabled){ return; }

		var self = this;
		var closure = function(){ return function(){ self.openSubmenu(); } }();

		this.hover_timer = window.setTimeout(closure, this.parent.submenuDelay);
	},

	stopSubmenuTimer: function(){
		if (this.hover_timer){
			window.clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	openSubmenu: function(){
		// first close any other open submenu
		this.parent.closeSubmenu();

		var submenu = dojo.widget.getWidgetById(this.submenuId);
		if (submenu){

			this.parent.openSubmenu(submenu, this);
		}

		//dojo.debug('open submenu for item '+this.widgetId);
	},

	closedSubmenu: function(){

		this.onUnhover();
	},

	setDisabled: function(value){
		this.disabled = value;

		if (this.disabled){
			dojo.html.addClass(this.domNode, 'dojoMenuItem2Disabled');
		}else{
			dojo.html.removeClass(this.domNode, 'dojoMenuItem2Disabled');
		}
	},

	getLabelWidth: function(){

		var node = this.labelNode.childNodes[0];

		return dojo.style.getOuterWidth(node);
	},

	getAccelWidth: function(){

		var node = this.accelNode.childNodes[0];

		return dojo.style.getOuterWidth(node);
	},

	menuOpen: function(message) {
	}

});


dojo.widget.MenuSeparator2 = function(){
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.MenuSeparator2, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.MenuSeparator2, {
	widgetType: "MenuSeparator2",

	domNode: null,
	topNode: null,
	bottomNode: null,

	templateString: '<div class="dojoMenuSeparator2">'
			+'<div dojoAttachPoint="topNode" class="dojoMenuSeparator2Top"></div>'
			+'<div dojoAttachPoint="bottomNode" class="dojoMenuSeparator2Bottom"></div>'
			+'</div>',

	postCreate: function(){
		dojo.html.disableSelection(this.domNode);
		this.layoutItem();
	},

	layoutItem: function(label_w, accel_w){

		var full_width = this.parent.itemHeight
				+ this.parent.iconGap
				+ label_w
				+ this.parent.accelGap
				+ accel_w
				+ this.parent.submenuGap
				+ this.parent.submenuIconSize
				+ this.parent.finalGap;

		if (isNaN(full_width)){ return; }

		dojo.style.setContentHeight(this.domNode, this.parent.separatorHeight);
		dojo.style.setContentWidth(this.domNode, full_width);
	}
});

//
// the menu manager makes sure we don't have several menus
// open at once. the root menu in an opening sequence calls
// opened(). when a root menu closes it calls closed(). then
// everything works. lovely.
//

dojo.widget.html.Menu2Manager = new function(){

	this.currentMenu = null;
	this.currentButton = null;		// button that opened current menu (if any)
	this.focusNode = null;

	dojo.event.connect(document, 'onmousedown', this, 'onClick');
	dojo.event.connect(window, "onscroll", this, "onClick");

	this.closed = function(menu){
		if (this.currentMenu == menu){
			this.currentMenu = null;
			this.currentButton = null;
		}
	};

	this.opened = function(menu, button){
		if (menu == this.currentMenu){ return; }

		if (this.currentMenu){
			this.currentMenu.close();
		}

		this.currentMenu = menu;
		this.currentButton = button;
	};

	this.onClick = function(e){

		if (!this.currentMenu){ return; }

		var scrolloffset = dojo.html.getScrollOffset();

		var x = e.clientX + scrolloffset[0];
		var y = e.clientY + scrolloffset[1];

		var m = this.currentMenu;

		// starting from the base menu, perform a hit test
		// and exit when one succeeds

		while (m){

			if (m.isPointInMenu(x, y)){

				return;
			}

			m = m.currentSubmenu;
		}

		// Also, if user clicked the button that opened this menu, then
		// that button will send the menu a close() command, so this code
		// shouldn't try to close the menu.  Closing twice messes up animation.
		if (this.currentButton && dojo.html.overElement(this.currentButton, e)){
			return;
		}

		// the click didn't fall within the open menu tree
		// so close it

		this.currentMenu.close();
	};
}

// ************************** make contextmenu work in konqueror and opera *********************
dojo.widget.Menu2.OperaAndKonqFixer = new function(){
 	var implement = true;
 	var delfunc = false;

 	/** 	dom event check
 	*
 	*	make a event and dispatch it and se if it calls function below,
 	*	if it does its supported and we dont need to implement our own
 	*/

 	// gets called if we have support for oncontextmenu
 	if (!dojo.lang.isFunction(document.oncontextmenu)){
 		document.oncontextmenu = function(){
 			implement = false;
 			delfunc = true;
 		}
 	}

 	if (document.createEvent){ // moz, safari has contextmenu event, need to do livecheck on this env.
 		try {
 			var e = document.createEvent("MouseEvents");
 			e.initMouseEvent("contextmenu", 1, 1, window, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
 			document.dispatchEvent(e);
 		} catch (e) {/* assume not supported */}
 	} else {
 		// IE no need to implement custom contextmenu
 		implement = false;
 	}

 	// clear this one if it wasn't there before
 	if (delfunc){
 		delete document.oncontextmenu;
 	}
 	/***** end dom event check *****/


 	/**
 	*	this fixes a dom node by attaching a custom oncontextmenu function that gets called when apropriate
 	*	@param	node	a dom node
 	*
 	*	no returns
 	*/
 	this.fixNode = function(node){
 		if (implement){
 			// attach stub oncontextmenu function
 			if (!dojo.lang.isFunction(node.oncontextmenu)){
 				node.oncontextmenu = function(e){/*stub*/}
 			}

 			// attach control function for oncontextmenu
 			if (window.opera){
 				// opera
 				// listen to ctrl-click events
 				node._menufixer_opera = function(e){
 					if (e.ctrlKey){
 						this.oncontextmenu(e);
 					}
 				};

 				dojo.event.connect(node, "onclick", node, "_menufixer_opera");

 			} else {
 				// konqueror
 				// rightclick, listen to mousedown events
 				node._menufixer_konq = function(e){
 					if (e.button==2 ){
 						e.preventDefault(); // need to prevent browsers menu
 						this.oncontextmenu(e);
 					}
 				};

 				dojo.event.connect(node, "onmousedown", node, "_menufixer_konq");
 			}
 		}
 	}

 	/**
 	*	this cleans up a fixed node, prevent memoryleak?
 	*	@param node	node to clean
 	*
 	*	no returns
 	*/
 	this.cleanNode = function(node){
 		if (implement){
 			// checks needed if we gets a non fixed node
 			if (node._menufixer_opera){
 				dojo.event.disconnect(node, "onclick", node, "_menufixer_opera");
 				delete node._menufixer_opera;
 			} else if(node._menufixer_konq){
 				dojo.event.disconnect(node, "onmousedown", node, "_menufixer_konq");
 				delete node._menufixer_konq;
 			}
 			if (node.oncontextmenu){
 				delete node.oncontextmenu;
 			}
 		}
 	}
};


dojo.widget.MenuBar2 = function(){
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.MenuBar2, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.MenuBar2, {
	widgetType: "MenuBar2",
	isContainer: true,

	snarfChildDomOutput: true,

	currentItem: null,
	isExpanded: false,

	currentSubmenu: null,
	currentSubmenuTrigger: null,

	domNode: null,
	containerNode: null,

	templateString: '<div class="dojoMenuBar2"><div dojoAttachPoint="containerNode" class="dojoMenuBar2Client"></div></div>',
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlMenu2.css"),

	itemHeight: 18,
	openEvent: null,


	postCreate: function(){

		// do something here

		this.layoutMenuSoon();
	},

	layoutMenuSoon: function(){
		dojo.lang.setTimeout(this, "layoutMenu", 0);
	},

	layoutMenu: function(){

		// menu must be attached to DOM for size calculations to work

		var parent = this.domNode.parentNode;
		if (! parent || parent == undefined) {
			document.body.appendChild(this.domNode);
		}


		// determine menu height

		var max_label_h = 0;

		for(var i=0; i<this.children.length; i++){

			if (this.children[i].getLabelHeight){

				max_label_h = Math.max(max_label_h, this.children[i].getLabelHeight());
			}
		}

		if (isNaN(max_label_h)){
			// Browser needs some more time to calculate sizes
			this.layoutMenuSoon();
			return;
		}

		var clientLeft = dojo.style.getPixelValue(this.domNode, "padding-left", true)
				+ dojo.style.getPixelValue(this.containerNode, "margin-left", true)
				+ dojo.style.getPixelValue(this.containerNode, "padding-left", true);
		var clientTop  = dojo.style.getPixelValue(this.domNode, "padding-top", true)
				+ dojo.style.getPixelValue(this.containerNode, "padding-top", true);

		if (isNaN(clientLeft) || isNaN(clientTop)){
			// Browser needs some more time to calculate sizes
			this.layoutMenuSoon();
			return;
		}

		var max_item_height = 0;
		var x = clientLeft;

		for (var i=0; i<this.children.length; i++){

			var ch = this.children[i];

			ch.layoutItem(max_label_h);

			ch.leftPosition = x;
			ch.domNode.style.left = x + 'px';

			x += dojo.style.getOuterWidth(ch.domNode);
			max_item_height = Math.max(max_item_height, dojo.style.getOuterHeight(ch.domNode));
		}

		dojo.style.setContentHeight(this.containerNode, max_item_height);
		dojo.style.setContentHeight(this.domNode, dojo.style.getOuterHeight(this.containerNode));
	},

	openSubmenu: function(submenu, from_item){

		var our_pos = dojo.style.getAbsolutePosition(this.domNode, false);

		var our_h = dojo.style.getOuterHeight(this.domNode);
		var item_x = from_item.leftPosition;

		var x = our_pos.x + item_x;
		var y = our_pos.y + our_h;

		this.currentSubmenu = submenu;
		this.currentSubmenu.open(x, y, this, from_item.domNode);
		this.currentSubmenu.parentMenuBar = this;
	},

	closeSubmenu: function(){

		if (this.currentSubmenu == null){ return; }

		var menu = this.currentSubmenu;
		this.currentSubmenu = null;
		menu.close();
	},

	itemHover: function(item){

		if (item == this.currentItem) return;

		if (this.currentItem){
			this.currentItem.unhighlightItem();

			if (this.isExpanded){
				this.closeSubmenu();
			}
		}

		this.currentItem = item;
		this.currentItem.highlightItem();

		if (this.isExpanded){
			this.currentItem.expandMenu();
		}
	},

	itemUnhover: function(item){

		if (item != this.currentItem) return;

		if (this.currentItem && !this.isExpanded){
			this.currentItem.unhighlightItem();
			this.currentItem = null;
		}
	},

	itemClick: function(item){

		if (item != this.currentItem){

			this.itemHover(item);
		}

		if (this.isExpanded){

			this.isExpanded = false;
			this.closeSubmenu();

		}else{

			this.isExpanded = true;
			this.currentItem.expandMenu();
		}
	},

	closedMenu: function(menu){

		if (this.currentSubmenu == menu){

			this.isExpanded = false;
			this.itemUnhover(this.currentItem);
		}
	}
});


dojo.widget.MenuBarItem2 = function(){
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.MenuBarItem2, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.MenuBarItem2, {

	widgetType: "MenuBarItem2",
	templateString:
			 '<div class="dojoMenuBarItem2">'
			+'<span dojoAttachPoint="labelNode" class="dojoMenuBarItem2Label"><span><span></span></span></span>'
			+'<div dojoAttachPoint="targetNode" class="dojoMenuBarItem2Target" dojoAttachEvent="onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;">&nbsp;</div>'
			+'</div>',

	//
	// nodes
	//

	domNode: null,
	labelNode: null,
	targetNode: null,

	//
	// internal settings
	//

	is_hovering: false,
	hover_timer: null,
	is_open: false,

	//
	// options
	//

	caption: 'Untitled',
	accelKey: '',
	iconSrc: '',
	submenuId: '',
	disabled: false,
	eventNaming: "default",


	postCreate: function(){

		dojo.html.disableSelection(this.domNode);

		if (this.disabled){
			this.setDisabled(true);
		}

		this.labelNode.childNodes[0].appendChild(document.createTextNode(this.caption));

		this.labelShadowNode = this.labelNode.childNodes[0].childNodes[0];
		this.labelShadowNode.appendChild(document.createTextNode(this.caption));

		if (this.eventNaming == "default") {
			for (eventName in this.eventNames) {
				this.eventNames[eventName] = this.widgetId+"/"+eventName;
			}
		}
	},

	layoutItem: function(item_h){

		var label_w = dojo.style.getOuterWidth(this.labelNode);

		var clientLeft = dojo.style.getPixelValue(this.domNode, "padding-left", true);
		var clientTop  = dojo.style.getPixelValue(this.domNode, "padding-top", true);

		this.labelNode.style.left = clientLeft + 'px';

		dojo.style.setOuterHeight(this.labelNode, item_h);
		dojo.style.setContentWidth(this.domNode, label_w);
		dojo.style.setContentHeight(this.domNode, item_h);

		this.labelNode.style.left = '0px';

		dojo.style.setOuterWidth(this.targetNode, label_w);
		dojo.style.setOuterHeight(this.targetNode, item_h);
	},

	getLabelHeight: function(){

		return dojo.style.getOuterHeight(this.labelNode);
	},

	onHover: function(){
		this.parent.itemHover(this);
	},

	onUnhover: function(){
		this.parent.itemUnhover(this);
	},

	_onClick: function(){
		this.parent.itemClick(this);
	},

	highlightItem: function(){
		dojo.html.addClass(this.domNode, 'dojoMenuBarItem2Hover');
	},

	unhighlightItem: function(){
		dojo.html.removeClass(this.domNode, 'dojoMenuBarItem2Hover');
	},

	expandMenu: function(){

		var submenu = dojo.widget.getWidgetById(this.submenuId);
		if (submenu){

			this.parent.openSubmenu(submenu, this);
		}
	},

	setDisabled: function(value){
		this.disabled = value;

		if (this.disabled){
			dojo.html.addClass(this.domNode, 'dojoMenuBarItem2Disabled');
		}else{
			dojo.html.removeClass(this.domNode, 'dojoMenuBarItem2Disabled');
		}
	}
});

// make it a tag
dojo.widget.tags.addParseTreeHandler("dojo:MenuBar2");
dojo.widget.tags.addParseTreeHandler("dojo:MenuBarItem2");
dojo.widget.tags.addParseTreeHandler("dojo:PopupMenu2");
dojo.widget.tags.addParseTreeHandler("dojo:MenuItem2");
dojo.widget.tags.addParseTreeHandler("dojo:MenuSeparator2");


__CPAN_FILE__ src/widget/MenuItem.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.MenuItem");
dojo.provide("dojo.widget.DomMenuItem");

dojo.deprecated("dojo.widget.MenuItem, dojo.widget.DomMenuItem",  "use dojo.widget.Menu2", "0.4");

dojo.require("dojo.string");
dojo.require("dojo.widget.*");

dojo.widget.tags.addParseTreeHandler("dojo:MenuItem");

/* MenuItem
 ***********/
 
dojo.widget.MenuItem = function(){
	dojo.widget.MenuItem.superclass.constructor.call(this);
}
dojo.inherits(dojo.widget.MenuItem, dojo.widget.Widget);

dojo.lang.extend(dojo.widget.MenuItem, {
	widgetType: "MenuItem",
	isContainer: true
});


/* DomMenuItem
 **************/
dojo.widget.DomMenuItem = function(){
	dojo.widget.DomMenuItem.superclass.constructor.call(this);
}
dojo.inherits(dojo.widget.DomMenuItem, dojo.widget.DomWidget);

dojo.lang.extend(dojo.widget.DomMenuItem, {
	widgetType: "MenuItem"
});

dojo.requireAfterIf("html", "dojo.html");
dojo.requireAfterIf("html", "dojo.widget.html.MenuItem");

__CPAN_FILE__ src/widget/MonthlyCalendar.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.MonthlyCalendar");
dojo.provide("dojo.widget.MonthlyCalendar.util");
dojo.require("dojo.widget.DomWidget");
dojo.require("dojo.date");

dojo.widget.MonthlyCalendar= function(){
	dojo.widget.Widget.call(this);
	this.widgetType = "MonthlyCalendar";
	this.isContainer = false;
	// the following aliases prevent breaking people using 0.2.x
	this.months = dojo.date.months;
	this.weekdays = dojo.date.days;
	this.toRfcDate = dojo.widget.MonthlyCalendar.util.toRfcDate;
	this.fromRfcDate = dojo.widget.MonthlyCalendar.util.fromRfcDate;
	this.initFirstSaturday = dojo.widget.MonthlyCalendar.util.initFirstSaturday;
}

dojo.inherits(dojo.widget.MonthlyCalendar, dojo.widget.Widget);
dojo.widget.tags.addParseTreeHandler("dojo:monthlycalendar");

dojo.requireAfterIf("html", "dojo.widget.html.MonthlyCalendar");

dojo.widget.MonthlyCalendar.util= new function() {
	this.months = dojo.date.months;
	this.weekdays = dojo.date.days;
	
	this.toRfcDate = function(jsDate) {
		if(!jsDate) {
			jsDate = this.today;
		}
		var year = jsDate.getFullYear();
		var month = jsDate.getMonth() + 1;
		if (month < 10) {
			month = "0" + month.toString();
		}
		var date = jsDate.getDate();
		if (date < 10) {
			date = "0" + date.toString();
		}
		// because this is a date picker and not a time picker, we treat time 
		// as zero
		return year + "-" + month + "-" + date + "T00:00:00+00:00";
	}
	
	this.fromRfcDate = function(rfcDate) {
		var tempDate = rfcDate.split("-");
		if(tempDate.length < 3) {
			return new Date();
		}
		// fullYear, month, date
		return new Date(parseInt(tempDate[0]), (parseInt(tempDate[1], 10) - 1), parseInt(tempDate[2].substr(0,2), 10));
	}
	
	this.initFirstSaturday = function(month, year) {
		if(!month) {
			month = this.date.getMonth();
		}
		if(!year) {
			year = this.date.getFullYear();
		}
		var firstOfMonth = new Date(year, month, 1);
		return {year: year, month: month, date: 7 - firstOfMonth.getDay()};
	}
}

__CPAN_FILE__ src/widget/Parse.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Parse");

dojo.require("dojo.widget.Manager");
dojo.require("dojo.dom");

dojo.widget.Parse = function(fragment) {
	this.propertySetsList = [];
	this.fragment = fragment;
	
	this.createComponents = function(frag, parentComp){
		var comps = [ ];
		var built = false;
		// if we have items to parse/create at this level, do it!
		try{
			if((frag)&&(frag["tagName"])&&(frag!=frag["nodeRef"])){
				var djTags = dojo.widget.tags;
				// we split so that you can declare multiple
				// non-destructive widgets from the same ctor node
				var tna = String(frag["tagName"]).split(";");
				for(var x=0; x<tna.length; x++){
					var ltn = (tna[x].replace(/^\s+|\s+$/g, "")).toLowerCase();
					if(djTags[ltn]){
						built = true;
						frag.tagName = ltn;
						var ret = djTags[ltn](frag, this, parentComp, frag["index"]);
						comps.push(ret);
					}else{
						if((dojo.lang.isString(ltn))&&(ltn.substr(0, 5)=="dojo:")){
							dojo.debug("no tag handler registed for type: ", ltn);
						}
					}
				}
			}
		}catch(e){
			dojo.debug("dojo.widget.Parse: error:", e);
			// throw(e);
			// IE is such a bitch sometimes
		}
		// if there's a sub-frag, build widgets from that too
		if(!built){
			comps = comps.concat(this.createSubComponents(frag, parentComp));
		}
		return comps;
	}

	/*	createSubComponents recurses over a raw JavaScript object structure,
			and calls the corresponding handler for its normalized tagName if it exists
	*/
	this.createSubComponents = function(fragment, parentComp){
		var frag, comps = [];
		for(var item in fragment){
			frag = fragment[item];
			if ((frag)&&(typeof frag == "object")&&(frag!=fragment.nodeRef)&&(frag!=fragment["tagName"])){
				comps = comps.concat(this.createComponents(frag, parentComp));
			}
		}
		return comps;
	}

	/*  parsePropertySets checks the top level of a raw JavaScript object
			structure for any propertySets.  It stores an array of references to 
			propertySets that it finds.
	*/
	this.parsePropertySets = function(fragment) {
		return [];
		var propertySets = [];
		for(var item in fragment){
			if(	(fragment[item]["tagName"] == "dojo:propertyset") ) {
				propertySets.push(fragment[item]);
			}
		}
		// FIXME: should we store these propertySets somewhere for later retrieval
		this.propertySetsList.push(propertySets);
		return propertySets;
	}
	
	/*  parseProperties checks a raw JavaScript object structure for
			properties, and returns an array of properties that it finds.
	*/
	this.parseProperties = function(fragment) {
		var properties = {};
		for(var item in fragment){
			// FIXME: need to check for undefined?
			// case: its a tagName or nodeRef
			if((fragment[item] == fragment["tagName"])||
				(fragment[item] == fragment.nodeRef)){
				// do nothing
			}else{
				if((fragment[item]["tagName"])&&
					(dojo.widget.tags[fragment[item].tagName.toLowerCase()])){
					// TODO: it isn't a property or property set, it's a fragment, 
					// so do something else
					// FIXME: needs to be a better/stricter check
					// TODO: handle xlink:href for external property sets
				}else if((fragment[item][0])&&(fragment[item][0].value!="")&&(fragment[item][0].value!=null)){
					try{
						// FIXME: need to allow more than one provider
						if(item.toLowerCase() == "dataprovider") {
							var _this = this;
							this.getDataProvider(_this, fragment[item][0].value);
							properties.dataProvider = this.dataProvider;
						}
						properties[item] = fragment[item][0].value;
						var nestedProperties = this.parseProperties(fragment[item]);
						// FIXME: this kind of copying is expensive and inefficient!
						for(var property in nestedProperties){
							properties[property] = nestedProperties[property];
						}
					}catch(e){ dojo.debug(e); }
				}
			}
		}
		return properties;
	}

	/* getPropertySetById returns the propertySet that matches the provided id
	*/
	
	this.getDataProvider = function(objRef, dataUrl) {
		// FIXME: this is currently sync.  To make this async, we made need to move 
		//this step into the widget ctor, so that it is loaded when it is needed 
		// to populate the widget
		dojo.io.bind({
			url: dataUrl,
			load: function(type, evaldObj){
				if(type=="load"){
					objRef.dataProvider = evaldObj;
				}
			},
			mimetype: "text/javascript",
			sync: true
		});
	}

	
	this.getPropertySetById = function(propertySetId){
		for(var x = 0; x < this.propertySetsList.length; x++){
			if(propertySetId == this.propertySetsList[x]["id"][0].value){
				return this.propertySetsList[x];
			}
		}
		return "";
	}
	
	/* getPropertySetsByType returns the propertySet(s) that match(es) the
	 * provided componentClass
	 */
	this.getPropertySetsByType = function(componentType){
		var propertySets = [];
		for(var x=0; x < this.propertySetsList.length; x++){
			var cpl = this.propertySetsList[x];
			var cpcc = cpl["componentClass"]||cpl["componentType"]||null;
			if((cpcc)&&(propertySetId == cpcc[0].value)){
				propertySets.push(cpl);
			}
		}
		return propertySets;
	}
	
	/* getPropertySets returns the propertySet for a given component fragment
	*/
	this.getPropertySets = function(fragment){
		var ppl = "dojo:propertyproviderlist";
		var propertySets = [];
		var tagname = fragment["tagName"];
		if(fragment[ppl]){ 
			var propertyProviderIds = fragment[ppl].value.split(" ");
			// FIXME: should the propertyProviderList attribute contain #
			// 		  syntax for reference to ids or not?
			// FIXME: need a better test to see if this is local or external
			// FIXME: doesn't handle nested propertySets, or propertySets that
			// 		  just contain information about css documents, etc.
			for(propertySetId in propertyProviderIds){
				if((propertySetId.indexOf("..")==-1)&&(propertySetId.indexOf("://")==-1)){
					// get a reference to a propertySet within the current parsed structure
					var propertySet = this.getPropertySetById(propertySetId);
					if(propertySet != ""){
						propertySets.push(propertySet);
					}
				}else{
					// FIXME: add code to parse and return a propertySet from
					// another document
					// alex: is this even necessaray? Do we care? If so, why?
				}
			}
		}
		// we put the typed ones first so that the parsed ones override when
		// iteration happens.
		return (this.getPropertySetsByType(tagname)).concat(propertySets);
	}
	
	/* 
		nodeRef is the node to be replaced... in the future, we might want to add 
		an alternative way to specify an insertion point

		componentName is the expected dojo widget name, i.e. Button of ContextMenu

		properties is an object of name value pairs
	*/
	this.createComponentFromScript = function(nodeRef, componentName, properties){
		var ltn = "dojo:" + componentName.toLowerCase();
		if(dojo.widget.tags[ltn]){
			properties.fastMixIn = true;
			return [dojo.widget.tags[ltn](properties, this, null, null, properties)];
		}else{
			if(ltn.substr(0, 5)=="dojo:"){
				dojo.debug("no tag handler registed for type: ", ltn);
			}
		}
	}
}


dojo.widget._parser_collection = {"dojo": new dojo.widget.Parse() };
dojo.widget.getParser = function(name){
	if(!name){ name = "dojo"; }
	if(!this._parser_collection[name]){
		this._parser_collection[name] = new dojo.widget.Parse();
	}
	return this._parser_collection[name];
}

/**
 * Creates widget.
 *
 * @param name     The name of the widget to create
 * @param props    Key-Value pairs of properties of the widget
 * @param refNode  If the last argument is specified this node is used as
 *                 a reference for inserting this node into a DOM tree else
 *                 it beomces the domNode
 * @param position The position to insert this widget's node relative to the
 *                 refNode argument
 * @return The new Widget object
 */
 
dojo.widget.createWidget = function(name, props, refNode, position){
	var lowerCaseName = name.toLowerCase();
	var namespacedName = "dojo:" + lowerCaseName;
	var isNode = ( dojo.byId(name) && (!dojo.widget.tags[namespacedName]) );

	// if we got a node or an unambiguious ID, build a widget out of it
	if(	(arguments.length==1) && ((typeof name != "string")||(isNode)) ){
		// we got a DOM node
		var xp = new dojo.xml.Parse();
		// FIXME: we should try to find the parent!
		var tn = (isNode) ? dojo.byId(name) : name;
		return dojo.widget.getParser().createComponents(xp.parseElement(tn, null, true))[0];
	}

	function fromScript (placeKeeperNode, name, props) {
		props[namespacedName] = { 
			dojotype: [{value: lowerCaseName}],
			nodeRef: placeKeeperNode,
			fastMixIn: true
		};
		return dojo.widget.getParser().createComponentFromScript(
			placeKeeperNode, name, props, true);
	}

	if (typeof name != "string" && typeof props == "string") {
		dojo.deprecated("dojo.widget.createWidget", 
			"argument order is now of the form " +
			"dojo.widget.createWidget(NAME, [PROPERTIES, [REFERENCENODE, [POSITION]]])");
		return fromScript(name, props, refNode);
	}
	
	props = props||{};
	var notRef = false;
	var tn = null;
	var h = dojo.render.html.capable;
	if(h){
		tn = document.createElement("span");
	}
	if(!refNode){
		notRef = true;
		refNode = tn;
		if(h){
			document.body.appendChild(refNode);
		}
	}else if(position){
		dojo.dom.insertAtPosition(tn, refNode, position);
	}else{ // otherwise don't replace, but build in-place
		tn = refNode;
	}
	var widgetArray = fromScript(tn, name, props);
	if (!widgetArray[0] || typeof widgetArray[0].widgetType == "undefined") {
		throw new Error("createWidget: Creation of \"" + name + "\" widget failed.");
	}
	if (notRef) {
		if (widgetArray[0].domNode.parentNode) {
			widgetArray[0].domNode.parentNode.removeChild(widgetArray[0].domNode);
		}
	}
	return widgetArray[0]; // just return the widget
}
 
dojo.widget.fromScript = function(name, props, refNode, position){
	dojo.deprecated("dojo.widget.fromScript", " use " +
		"dojo.widget.createWidget instead");
	return dojo.widget.createWidget(name, props, refNode, position);
}

__CPAN_FILE__ src/widget/PopUpButton.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.PopUpButton");
dojo.provide("dojo.widget.DomPopUpButton");
dojo.provide("dojo.widget.HtmlPopUpButton");

dojo.deprecated("dojo.widget.PopUpButton, dojo.widget.DomPopUpButton, dojo.widget.HtmlPopUpButton",  "use dojo.widget.DropDownButton", "0.4");

//dojo.require("dojo.widget.Button");
//dojo.require("dojo.widget.HtmlButton");

dojo.require("dojo.widget.Menu");
dojo.require("dojo.widget.MenuItem");

dojo.require("dojo.html");

dojo.widget.tags.addParseTreeHandler("dojo:PopUpButton");

/* PopUpButton
 **************/
 
dojo.widget.PopUpButton = function () {
	dojo.widget.PopUpButton.superclass.constructor.call(this);
}
dojo.inherits(dojo.widget.PopUpButton, dojo.widget.Widget);

dojo.lang.extend(dojo.widget.PopUpButton, {
	widgetType: "PopUpButton",
	
	label: ""
});


/* DomPopUpButton
 *****************/
dojo.widget.DomPopUpButton = function(){
	dojo.widget.DomPopUpButton.superclass.constructor.call(this);
}
dojo.inherits(dojo.widget.DomPopUpButton, dojo.widget.DomWidget);

dojo.lang.extend(dojo.widget.DomPopUpButton, {
	widgetType: dojo.widget.PopUpButton.prototype.widgetType
});


/* HtmlPopUpButton
 ******************/

dojo.widget.HtmlPopUpButton = function () {
	dojo.widget.HtmlPopUpButton.superclass.constructor.call(this);
}
dojo.inherits(dojo.widget.HtmlPopUpButton, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.HtmlPopUpButton, {
	widgetType: dojo.widget.PopUpButton.prototype.widgetType,
	templateString: null,
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/PopUpButton.css"),
	
	buildRendering: function (args, frag) {
		dojo.style.insertCssFile(this.templateCssPath, null, true);
	
		this.domNode = document.createElement("a");
		this.domNode.className = "PopUpButton";
		dojo.event.connect(this.domNode, "onmousedown", this, "onMouseDown");
		
		// draw the arrow
		var arrow = document.createElement("img");
		arrow.src = dojo.uri.dojoUri("src/widget/templates/images/dropdownButtonsArrow.gif");
		dojo.html.setClass(arrow, "downArrow");
		this.domNode.appendChild(arrow);

		this.menu = dojo.widget.fromScript("Menu");
		dojo.html.addClass(this.menu.domNode, "PopUpButtonMenu");
		dojo.event.connect(this.menu, "onSelect", this, "onSelect");
		
		if (frag["dojo:" + this.widgetType.toLowerCase()].nodeRef) {
			var node = frag["dojo:" + this.widgetType.toLowerCase()].nodeRef;
			var options = node.getElementsByTagName("option");
			for (var i = 0; i < options.length; i++) {
				var properties = {
					title: dojo.dom.textContent(options[i]),
					value: options[i].value
				}
				this.addItem(dojo.widget.fromScript("MenuItem", properties));
			}
		}
	},

	addItem: function (item) {
		// TODO: should be dojo.widget.MenuItem
		if (item instanceof dojo.widget.html.MenuItem) {
			this.menu.push(item);
		} else {
			// TODO: create one
			var menuItem = dojo.widget.fromScript("MenuItem", {title: item});
			this.menu.push(menuItem);
		}
	},
	
	
/* Enabled utility methods
 **************************/
	
	_enabled: true,
	
	isEnabled: function() { return this._enabled; },
	
	setEnabled: function(enabled, force, preventEvent) {
		enabled = Boolean(enabled);
		if (force || this._enabled != enabled) {
			this._enabled = enabled;
			if (!preventEvent) {
				this._fireEvent(this._enabled ? "onEnable" : "onDisable");
				this._fireEvent("onChangeEnabled");
			}
		}
		
		dojo.html[(this._enabled ? "add" : "remove")
			+ "Class"](this.domNode, "disabled");
		
		return this._enabled;
	},
	
	enable: function(force, preventEvent) {
		return this.setEnabled(true, force, preventEvent);
	},
	
	disable: function(force, preventEvent) {
		return this.setEnabled(false, force, preventEvent);
	},
	
	toggleEnabled: function(force, preventEvent) {
		return this.setEnabled(!this._enabled, force, preventEvent);
	},


/* Select utility methods
 **************************/

	onSelect: function (item, e) {
		this.domNode.firstChild.nodeValue = item.title;
	},
	
	onMouseDown: function (e) {
		if (!this._menuVisible) {
			this._showMenu(e);
			dojo.lang.setTimeout(dojo.event.connect, 1, document, "onmousedown", this, "_hideMenu");
		}
	},
	
	
	_fireEvent: function(evt) {
		if(typeof this[evt] == "function") {
			var args = [this];
			for(var i = 1; i < arguments.length; i++) {
				args.push(arguments[i]);
			}
			this[evt].apply(this, args);
		}
	},

	
	_showMenu: function (e) {
		if (!this._enabled) { return; }
		this._menuVisible = true;
		with (dojo.html) {
			var y = getAbsoluteY(this.domNode) + getInnerHeight(this.domNode);
			var x = getAbsoluteX(this.domNode);
		}
	
		document.body.appendChild(this.menu.domNode);
		with (this.menu.domNode.style) {
			top = y + "px";
			left = x + "px";
		}
	},
	
	_hideMenu: function (e) {
		this.menu.domNode.parentNode.removeChild(this.menu.domNode);
		dojo.event.disconnect(document, "onmousedown", this, "_hideMenu");
		this._menuVisible = false;
	}

});

__CPAN_FILE__ src/widget/ResizableTextarea.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.ResizableTextarea");
dojo.require("dojo.html");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.LayoutContainer");
dojo.require("dojo.widget.ResizeHandle");

dojo.widget.tags.addParseTreeHandler("dojo:resizabletextarea");

dojo.widget.ResizableTextarea = function(){
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.ResizableTextarea, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.ResizableTextarea, {
	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlResizableTextarea.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlResizableTextarea.css"),
	widgetType: "ResizableTextarea",
	tagName: "dojo:resizabletextarea",
	isContainer: false,
	textAreaNode: null,
	textAreaContainer: null,
	textAreaContainerNode: null,
	statusBar: null,
	statusBarContainerNode: null,
	statusLabelNode: null,
	statusLabel: null,
	rootLayoutNode: null,
	resizeHandleNode: null,
	resizeHandle: null,

	fillInTemplate: function(args, frag){
		this.textAreaNode = this.getFragNodeRef(frag).cloneNode(true);

		// FIXME: Safari apparently needs this!
		document.body.appendChild(this.domNode);

		this.rootLayout = dojo.widget.createWidget(
			"LayoutContainer",
			{
				minHeight: 50,
				minWidth: 100
			},
			this.rootLayoutNode
		);


		this.textAreaContainer = dojo.widget.createWidget(
			"LayoutContainer",
			{ layoutAlign: "client" },
			this.textAreaContainerNode
		);
		this.rootLayout.addChild(this.textAreaContainer);

		this.textAreaContainer.domNode.appendChild(this.textAreaNode);
		with(this.textAreaNode.style){
			width="100%";
			height="100%";
		}

		this.statusBar = dojo.widget.createWidget(
			"LayoutContainer",
			{ 
				layoutAlign: "bottom", 
				minHeight: 28
			},
			this.statusBarContainerNode
		);
		this.rootLayout.addChild(this.statusBar);

		this.statusLabel = dojo.widget.createWidget(
			"LayoutContainer",
			{ 
				layoutAlign: "client", 
				minWidth: 50
			},
			this.statusLabelNode
		);
		this.statusBar.addChild(this.statusLabel);

		this.resizeHandle = dojo.widget.createWidget(
			"ResizeHandle", 
			{ targetElmId: this.rootLayout.widgetId },
			this.resizeHandleNode
		);
		this.statusBar.addChild(this.resizeHandle);
		// dojo.debug(this.rootLayout.widgetId);

		// dojo.event.connect(this.resizeHandle, "beginSizing", this, "hideContent");
		// dojo.event.connect(this.resizeHandle, "endSizing", this, "showContent");
	},

	hideContent: function(){
		this.textAreaNode.style.display = "none";
	},

	showContent: function(){
		this.textAreaNode.style.display = "";
	}
});

__CPAN_FILE__ src/widget/ResizeHandle.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.ResizeHandle");
dojo.provide("dojo.widget.html.ResizeHandle");

dojo.require("dojo.widget.*");
dojo.require("dojo.html");
dojo.require("dojo.style");
dojo.require("dojo.dom");
dojo.require("dojo.event");

dojo.widget.html.ResizeHandle = function(){
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.html.ResizeHandle, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.ResizeHandle, {
	widgetType: "ResizeHandle",

	isSizing: false,
	startPoint: null,
	startSize: null,
	minSize: null,

	targetElmId: '',

	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlResizeHandle.css"),
	templateString: '<div class="dojoHtmlResizeHandle"><div></div></div>',

	postCreate: function(){
		dojo.event.connect(this.domNode, "onmousedown", this, "beginSizing");
	},

	beginSizing: function(e){
		if (this.isSizing){ return false; }

		this.targetElm = dojo.widget.byId(this.targetElmId);
		if (!this.targetElm){ return; }

		this.isSizing = true;
		this.startPoint  = {'x':e.clientX, 'y':e.clientY};
		this.startSize  = {'w':dojo.style.getOuterWidth(this.targetElm.domNode), 'h':dojo.style.getOuterHeight(this.targetElm.domNode)};

		dojo.event.kwConnect({
			srcObj: document.body, 
			srcFunc: "onmousemove",
			targetObj: this,
			targetFunc: "changeSizing",
			rate: 25
		});
		dojo.event.connect(document.body, "onmouseup", this, "endSizing");

		e.preventDefault();
	},

	changeSizing: function(e){
		// On IE, if you move the mouse above/to the left of the object being resized,
		// sometimes clientX/Y aren't set, apparently.  Just ignore the event.
		try{
			if(!e.clientX  || !e.clientY){ return; }
		}catch(e){
			// sometimes you get an exception accessing above fields...
			return;
		}
		var dx = this.startPoint.x - e.clientX;
		var dy = this.startPoint.y - e.clientY;
		
		var newW = this.startSize.w - dx;
		var newH = this.startSize.h - dy;

		// minimum size check
		if (this.minSize) {
			if (newW < this.minSize.w) {
				newW = dojo.style.getOuterWidth(this.targetElm.domNode);
			}
			if (newH < this.minSize.h) {
				newH = dojo.style.getOuterHeight(this.targetElm.domNode);
			}
		}
		
		this.targetElm.resizeTo(newW, newH);
		
		e.preventDefault();
	},

	endSizing: function(e){
		dojo.event.disconnect(document.body, "onmousemove", this, "changeSizing");
		dojo.event.disconnect(document.body, "onmouseup", this, "endSizing");

		this.isSizing = false;
	}


});

dojo.widget.tags.addParseTreeHandler("dojo:ResizeHandle");

__CPAN_FILE__ src/widget/RichText.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

 /* -*- tab-width: 4 -*- */
dojo.provide("dojo.widget.RichText");
dojo.provide("dojo.widget.html.RichText");

dojo.require("dojo.widget.*");
dojo.require("dojo.dom");
dojo.require("dojo.html");
dojo.require("dojo.event.*");
dojo.require("dojo.style");
dojo.require("dojo.string");

// used to save content
try {
	document.write('<textarea id="dojo.widget.RichText.savedContent" ' +
		'style="display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;"></textarea>');
}catch(e){ }

dojo.widget.defineWidget(
	"dojo.widget.html.RichText",
	dojo.widget.HtmlWidget,
	{
		/** whether to inherit the parent's width or simply use 100% */
		inheritWidth: false,
		focusOnLoad: true,
		
		/**
		 * If a save name is specified the content is saved and restored if the
		 * editor is not properly closed after editing has started.
		 */
		saveName: "",
		_content: "",
		
		/* set height to fix the editor at a specific height, with scrolling */
		height: null,

		/** The minimum height that the editor should have */
		minHeight: "1em",
		
		isClosed: true,
		isLoaded: false,
		
		/** whether to use the active-x object in IE */
		useActiveX: false,

		/* whether to use relative URLs for images - if this is enabled
       	images will be given absolute URLs when inside the editor but
       	will be changed to use relative URLs (to the current page) on save
		*/
		relativeImageUrls: false,
		
		_SEPARATOR: "@@**%%__RICHTEXTBOUNDRY__%%**@@",

		// contentFilters: [],

		/*
		defaultContentCleaner: function(content){
			if(!dojo.render.html.ie){
				return content;
			}

			content = content.replace(/\x20/g, " ");
			// alert(content);
			return content;
		},
		*/

	/* Init
	 *******/

		fillInTemplate: function(){
			this.open();

			// add the formatting functions
			var funcs = ["queryCommandEnabled", "queryCommandState",
				"queryCommandValue", "execCommand"];
			for(var i = 0; i < funcs.length; i++){
				dojo.event.connect("around", this, funcs[i], this, "_normalizeCommand");
			}
			
			// backwards compatibility, needs to be removed
			dojo.event.connect(this, "onKeyPressed", this, "afterKeyPress");
			dojo.event.connect(this, "onKeyPress", this, "keyPress");
			dojo.event.connect(this, "onKeyDown", this, "keyDown");
			dojo.event.connect(this, "onKeyUp", this, "keyUp");

			// add default some key handlers		
			var ctrl = this.KEY_CTRL;
			var exec = function (cmd, arg) {
				return arguments.length == 1 ? function () { this.execCommand(cmd); } :
					function () { this.execCommand(cmd, arg); }
			}
				
			this.addKeyHandler("b", ctrl, exec("bold"));
			this.addKeyHandler("i", ctrl, exec("italic"));
			this.addKeyHandler("u", ctrl, exec("underline"));
			this.addKeyHandler("a", ctrl, exec("selectall"));
			//this.addKeyHandler("k", ctrl, exec("createlink", ""));
			//this.addKeyHandler("K", ctrl, exec("unlink"));
			this.addKeyHandler("s", ctrl, function () { this.save(true); });
			
			this.addKeyHandler("1", ctrl, exec("formatblock", "h1"));
			this.addKeyHandler("2", ctrl, exec("formatblock", "h2"));
			this.addKeyHandler("3", ctrl, exec("formatblock", "h3"));
			this.addKeyHandler("4", ctrl, exec("formatblock", "h4"));
					
			this.addKeyHandler("\\", ctrl, exec("insertunorderedlist"));
			if(!dojo.render.html.ie){
				this.addKeyHandler("Z", ctrl, exec("redo"));
			}
		},


		events: ["onBlur", "onFocus", "onKeyPress", "onKeyDown", "onKeyUp", "onClick"],

		/**
		 * Transforms the node referenced in this.domNode into a rich text editing
		 * node. This can result in the creation and replacement with an <iframe> if
		 * designMode is used, an <object> and active-x component if inside of IE or
		 * a reguler element if contentEditable is available.
		 */
		open: function (element) {
			dojo.event.topic.publish("dojo.widget.RichText::open", this);

			if (!this.isClosed) { this.close(); }
			this._content = "";
			if((arguments.length == 1)&&(element["nodeName"])){ this.domNode = element; } // else unchanged

			if(	(this.domNode["nodeName"])&&
				(this.domNode.nodeName.toLowerCase() == "textarea")){
				this.textarea = this.domNode;
				var html = dojo.string.trim(this.textarea.value);
				if(html == ""){ html = "&nbsp;"; }
				this.domNode = document.createElement("div");
				with(this.textarea.style){
					display = "block";
					position = "absolute";
					width = "1px";
					height = "1px";
					border = margin = padding = "0px";
					visiblity = "hidden";
					if(dojo.render.html.ie){
						overflow = "hidden";
					}
				}
				dojo.dom.insertBefore(this.domNode, this.textarea);
				this.domNode.innerHTML = html;
				
				if(this.textarea.form){
					dojo.event.connect(this.textarea.form, "onsubmit", 
						// FIXME: should we be calling close() here instead?
						dojo.lang.hitch(this, function(){
							this.textarea.value = this.getEditorContent();
						})
					);
				}
				
				// dojo plucks our original domNode from the document so we need
				// to go back and put ourselves back in
				var editor = this;
				dojo.event.connect(this, "postCreate", function (){
					dojo.dom.insertAfter(editor.textarea, editor.domNode);
				});
			}else{
				var html = dojo.string.trim(this.domNode.innerHTML);
				if(html == ""){ html = "&nbsp;"; }
			}
					
			this._oldHeight = dojo.style.getContentHeight(this.domNode);
			this._oldWidth = dojo.style.getContentWidth(this.domNode);

			this._firstChildContributingMargin = this._getContributingMargin(this.domNode, "top");
			this._lastChildContributingMargin = this._getContributingMargin(this.domNode, "bottom");

			this.savedContent = document.createElement("div");
			while (this.domNode.hasChildNodes()) {
				this.savedContent.appendChild(this.domNode.firstChild);
			}
			
			// If we're a list item we have to put in a blank line to force the
			// bullet to nicely align at the top of text
			if(	(this.domNode["nodeName"])&&
				(this.domNode.nodeName == "LI")){
				this.domNode.innerHTML = " <br>";
			}
					
			if(this.saveName != ""){
				var saveTextarea = document.getElementById("dojo.widget.RichText.savedContent");
				if (saveTextarea.value != "") {
					var datas = saveTextarea.value.split(this._SEPARATOR);
					for (var i = 0; i < datas.length; i++) {
						var data = datas[i].split(":");
						if (data[0] == this.saveName) {
							html = data[1];
							datas.splice(i, 1);
							break;
						}
					}				
				}
				dojo.event.connect("before", window, "onunload", this, "_saveContent");
				// dojo.event.connect(window, "onunload", this, "_saveContent");
			}

			// Safari's selections go all out of whack if we do it inline,
			// so for now IE is our only hero
			//if (typeof document.body.contentEditable != "undefined") {
			if (this.useActiveX && dojo.render.html.ie) { // active-x
				this._drawObject(html);
				// dojo.debug(this.object.document);
			} else if (dojo.render.html.ie) { // contentEditable, easy
				this.editNode = document.createElement("div");
				with (this.editNode) {
					innerHTML = html;
					contentEditable = true;
					style.height = this.height ? this.height : this.minHeight;
				}

				if(this.height){ this.editNode.style.overflowY="scroll"; }
				// FIXME: setting contentEditable on switches this element to
				// IE's hasLayout mode, triggering weird margin collapsing
				// behavior. It's particularly bad if the element you're editing
				// contains childnodes that don't have margin: defined in local
				// css rules. It would be nice if it was possible to hack around
				// this. Sadly _firstChildContributingMargin and 
				// _lastChildContributingMargin don't work on IE unless all
				// elements have margins set in CSS :-(

				this.domNode.appendChild(this.editNode);

				dojo.lang.forEach(this.events, function(e){
					dojo.event.connect(this.editNode, e.toLowerCase(), this, e);
				}, this);
			
				this.window = window;
				this.document = document;
				
				this.onLoad();
			} else { // designMode in iframe
				this._drawIframe(html);
			}

			// TODO: this is a guess at the default line-height, kinda works
			if (this.domNode.nodeName == "LI") { this.domNode.lastChild.style.marginTop = "-1.2em"; }
			dojo.html.addClass(this.domNode, "RichTextEditable");
			
			this.isClosed = false;
		},

		_hasCollapseableMargin: function(element, side) {
			// check if an element has padding or borders on the given side
			// which would prevent it from collapsing margins
			if (dojo.style.getPixelValue(element, 
										 'border-'+side+'-width', 
										 false)) {
				return false;
			} else if (dojo.style.getPixelValue(element, 
												'padding-'+side,
												false)) {
				return false;
			} else {
				return true;
			}
		},

		_getContributingMargin:	function(element, topOrBottom) {
			// calculate how much margin this element and its first or last
			// child are contributing to the total margin between this element
			// and the adjacent node. CSS border collapsing makes this
			// necessary.

			if (topOrBottom == "top") {
				var siblingAttr = "previousSibling";
				var childSiblingAttr = "nextSibling";
				var childAttr = "firstChild";
				var marginProp = "margin-top";
				var siblingMarginProp = "margin-bottom";
			} else {
				var siblingAttr = "nextSibling";
				var childSiblingAttr = "previousSibling";
				var childAttr = "lastChild";
				var marginProp = "margin-bottom";
				var siblingMarginProp = "margin-top";
			}

			var elementMargin = dojo.style.getPixelValue(element, marginProp, false);

			function isSignificantNode(element) {
				// see if an node is significant in the current context
				// for calulating margins
				return !(element.nodeType==3 && dojo.string.isBlank(element.data)) 
					&& dojo.style.getStyle(element, "display") != "none" 
					&& !dojo.style.isPositionAbsolute(element);
			}

			// walk throuh first/last children to find total collapsed margin size
			var childMargin = 0;
			var child = element[childAttr];
			while (child) {
				// skip over insignificant elements (whitespace, etc)
				while ((!isSignificantNode(child)) && child[childSiblingAttr]) {
					child = child[childSiblingAttr];
				}
						  
				childMargin = Math.max(childMargin, dojo.style.getPixelValue(child, marginProp, false));
				// stop if we hit a bordered/padded element
				if (!this._hasCollapseableMargin(child, topOrBottom)) break;
				child = child[childAttr];								   
			}

			// if this element has a border, return full child margin immediately
			// as there won't be any margin collapsing
			if (!this._hasCollapseableMargin(element, topOrBottom)){ return parseInt(childMargin); }

			// find margin supplied by nearest sibling
			var contextMargin = 0;
			var sibling = element[siblingAttr];
			while (sibling) {
				if (isSignificantNode(sibling)) {
					contextMargin = dojo.style.getPixelValue(sibling, 
															 siblingMarginProp, 
															 false);
					break;
				}
				sibling = sibling[siblingAttr];
			}
			if (!sibling) { // no sibling, look at parent's margin instead
				contextMargin = dojo.style.getPixelValue(element.parentNode, 
												marginProp, false);
			}

			if (childMargin > elementMargin) {
				return parseInt(Math.max((childMargin-elementMargin)-contextMargin, 0));
			} else {
				return 0;
			}
			
		},
		
		/** Draws an iFrame using the existing one if one exists. 
			Used by Mozilla, Safari, and Opera */
		_drawIframe: function (html) {

			// detect firefox < 1.5, which has some iframe loading issues
			var oldMoz = Boolean(dojo.render.html.moz && (
									typeof window.XML == 'undefined'))

			if (!this.iframe) {
				var currentDomain = (new dojo.uri.Uri(document.location)).host;
				this.iframe = document.createElement("iframe");
				with (this.iframe) {
					scrolling = this.height ? "auto" : "no";
					style.border = "none";
					style.lineHeight = "0"; // squash line height
					style.verticalAlign = "bottom";
				}
			}
			// opera likes this to be outside the with block
			this.iframe.src = dojo.uri.dojoUri("src/widget/templates/richtextframe.html") + "#" + ((document.domain != currentDomain) ? document.domain : "");
			this.iframe.width = this.inheritWidth ? this._oldWidth : "100%";
			if (this.height) {
				this.iframe.style.height = this.height;
			} else {
				var height = this._oldHeight;
				if (this._hasCollapseableMargin(this.domNode, 'top')) {
					height += this._firstChildContributingMargin;
				}
				if (this._hasCollapseableMargin(this.domNode, 'bottom')) {
					height += this._lastChildContributingMargin;
				}
				this.iframe.height = height;
			}

			var tmpContent = document.createElement('div');
			tmpContent.innerHTML = html;

			// make relative image urls absolute
			if (this.relativeImageUrls) {
				var imgs = tmpContent.getElementsByTagName('img');
				for (var i=0; i<imgs.length; i++) {
					imgs[i].src = (new dojo.uri.Uri(window.location, imgs[i].src)).toString();
				}
				html = tmpContent.innerHTML;
			}

			// fix margins on tmpContent
			var firstChild = dojo.dom.firstElement(tmpContent);
			var lastChild = dojo.dom.lastElement(tmpContent);
			if(firstChild){
				firstChild.style.marginTop = this._firstChildContributingMargin+"px";
			}
			if(lastChild){
				lastChild.style.marginBottom = this._lastChildContributingMargin+"px";
			}

			// show existing content behind iframe for now
			tmpContent.style.position = "absolute";
			this.domNode.appendChild(tmpContent);
			this.domNode.appendChild(this.iframe);

			var _iframeInitialized = false;

			// now we wait for onload. Janky hack!
			var ifrFunc = dojo.lang.hitch(this, function(){
				if(!_iframeInitialized){
					_iframeInitialized = true;
				}else{ return; }
				if(!this.editNode){
					if(this.iframe.contentWindow){
						this.window = this.iframe.contentWindow;
					}else{
						// for opera
						this.window = this.iframe.contentDocument.window;
					}
					if(dojo.render.html.moz){
						this.document = this.iframe.contentWindow.document
					}else{
						this.document = this.iframe.contentDocument;
					}

					// curry the getStyle function
					var getStyle = (function (domNode) { return function (style) {
						return dojo.style.getStyle(domNode, style);
					}; })(this.domNode);

					var font =
						getStyle('font-weight') + " " +
						getStyle('font-size') + " " +
						getStyle('font-family');
					
					// line height is tricky - applying a units value will mess things up.
					// if we can't get a non-units value, bail out.
					var lineHeight = "1.0";
					var lineHeightStyle = dojo.style.getUnitValue(this.domNode, 'line-height');
					if (lineHeightStyle.value && lineHeightStyle.units=="") {
						lineHeight = lineHeightStyle.value;
					}

					dojo.style.insertCssText(
						'    body,html { background: transparent; padding: 0; margin: 0; }\n' +
						// TODO: left positioning will case contents to disappear out of view
						//       if it gets too wide for the visible area
						'    body { top: 0; left: 0; right: 0;' +
						(this.height ? '' : ' position: fixed; ') + 
						'        font: ' + font + ';\n' + 
						'        min-height: ' + this.minHeight + '; \n' +
						'        line-height: ' + lineHeight + '} \n' +
						'    p { margin: 1em 0 !important; }\n' +
						'    body > *:first-child { padding-top: 0 !important; margin-top: ' + this._firstChildContributingMargin + 'px !important; }\n' + // FIXME: test firstChild nodeType
						'    body > *:last-child { padding-bottom: 0 !important; margin-bottom: ' + this._lastChildContributingMargin + 'px !important; }\n' +
						'    li > ul:-moz-first-node, li > ol:-moz-first-node { padding-top: 1.2em; }\n' +
						'    li { min-height: 1.2em; }\n' +
						//'    p,ul,li { padding-top: 0; padding-bottom: 0; margin-top:0; margin-bottom: 0; }\n' + 
						'', this.document);

					tmpContent.parentNode.removeChild(tmpContent);
					this.document.body.innerHTML = html;
					if(oldMoz){
						this.document.designMode = "on";
					}
					this.onLoad();
				}else{
					tmpContent.parentNode.removeChild(tmpContent);
					this.editNode.innerHTML = html;
					this.onDisplayChanged();
				}
			});

			if(this.editNode){
				ifrFunc(); // iframe already exists, just set content
			}else if(dojo.render.html.moz){
				// FIXME: if we put this on a delay, we get a height of 20px.
				// Otherwise we get the correctly specified minHeight value.
				this.iframe.onload = function(){
					setTimeout(ifrFunc, 250);
				}
			}else{ // new mozillas, opera, safari
				this.iframe.onload = ifrFunc;
			}
		},
		
		/** Draws an active x object, used by IE */
		_drawObject: function (html) {
			this.object = document.createElement("object");

			with (this.object) {
				classid = "clsid:2D360201-FFF5-11D1-8D03-00A0C959BC0A";
				width = this.inheritWidth ? this._oldWidth : "100%";
				style.height = this.height ? this.height : (this._oldHeight+"px");
				Scrollbars = this.height ? true : false;
				Appearance = this._activeX.appearance.flat;
			}
			this.domNode.appendChild(this.object);

			this.object.attachEvent("DocumentComplete", dojo.lang.hitch(this, "onLoad"));
			this.object.attachEvent("DisplayChanged", dojo.lang.hitch(this, "_updateHeight"));
			this.object.attachEvent("DisplayChanged", dojo.lang.hitch(this, "onDisplayChanged"));

			dojo.lang.forEach(this.events, function(e){
				this.object.attachEvent(e.toLowerCase(), dojo.lang.hitch(this, e));
			}, this);

			this.object.DocumentHTML = '<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">' +
				'<title></title>' +
				'<style type="text/css">' +
				'    body,html { padding: 0; margin: 0; }' + //font: ' + font + '; }' +
				(this.height ? '' : '    body { overflow: hidden; }') +
				//'    #bodywrapper {  }' +
				'</style>' +
				//'<base href="' + window.location + '">' +
				'<body><div id="bodywrapper">' + html + '</div></body>';
		},

	/* Event handlers
	 *****************/

	 	_isResized: function(){ return false; },

		onLoad: function(e){
			this.isLoaded = true;
			if (this.object){
				this.document = this.object.DOM;
				this.window = this.document.parentWindow;
				this.editNode = this.document.body.firstChild;
				this.domNode.style.height = this.height ? this.height : this.minHeight;
				this.connect(this, "onDisplayChanged", "_updateHeight");
			}else if (this.iframe){
				this.editNode = this.document.body;
				this.connect(this, "onDisplayChanged", "_updateHeight");
		
				try { // sanity check for Mozilla
					this.document.execCommand("useCSS", false, true); // old moz call
					this.document.execCommand("styleWithCSS", false, false); // new moz call
					//this.document.execCommand("insertBrOnReturn", false, false); // new moz call
				}catch(e2){ }
				
				if (dojo.render.html.safari) {
					/*
					this.iframe.style.visiblity = "visible";
					this.iframe.style.border = "1px solid black";
					this.editNode.style.visiblity = "visible";
					this.editNode.style.border = "1px solid black";
					*/
					// this.onDisplayChanged();
					this.connect(this.editNode, "onblur", "onBlur");
					this.connect(this.editNode, "onfocus", "onFocus");
				
					this.interval = setInterval(dojo.lang.hitch(this, "onDisplayChanged"), 750);
					// dojo.raise("onload");
					// dojo.debug(this.editNode.parentNode.parentNode.parentNode.nodeName);
				} else if (dojo.render.html.mozilla || dojo.render.html.opera) {

					// We need to unhook the blur event listener on close as we
					// can encounter a garunteed crash in FF if another event is
					// also fired
					var doc = this.document;
					var blurfp = dojo.event.browser.addListener(this.document, "blur", dojo.lang.hitch(this, "onBlur"));
					var unBlur = { unBlur: function(e){
							dojo.event.browser.removeListener(doc, "blur", blurfp);
					} };
					dojo.event.connect("before", this, "close", unBlur, "unBlur");
					dojo.event.browser.addListener(this.document, "focus", dojo.lang.hitch(this, "onFocus"));
				
					// safari can't handle key listeners, it kills the speed
					var addListener = dojo.event.browser.addListener;
					addListener(this.document, "keypress", dojo.lang.hitch(this, "onKeyPress"));
					addListener(this.document, "keydown", dojo.lang.hitch(this, "onKeyDown"));
					addListener(this.document, "keyup", dojo.lang.hitch(this, "onKeyUp"));
					addListener(this.document, "click", dojo.lang.hitch(this, "onClick"));
				}

				// FIXME: when scrollbars appear/disappear this needs to be fired						
			}else if(dojo.render.html.ie){
				// IE contentEditable
				this.editNode.style.zoom = 1.0;
			}
			
			if(this.focusOnLoad){
				this.focus();
			}
			this.onDisplayChanged(e);
		},

		/** Fired on keydown */
		onKeyDown: function(e){
			if((!e)&&(this.object)){
				e = dojo.event.browser.fixEvent(this.window.event);
			}
			dojo.debug("onkeydown:", e.keyCode);
			// we need this event at the moment to get the events from control keys
			// such as the backspace. It might be possible to add this to Dojo, so that
			// keyPress events can be emulated by the keyDown and keyUp detection.
			if((dojo.render.html.ie)&&(e.keyCode == e.KEY_TAB)){
				e.preventDefault();
				e.stopPropagation();
				// FIXME: this is a poor-man's indent/outdent. It would be
				// better if it added 4 "&nbsp;" chars in an undoable way.
				// Unfortuantly pasteHTML does not prove to be undoable 
				this.execCommand((e.shiftKey ? "outdent" : "indent"));
			}else if(dojo.render.html.ie){
				if((65 <= e.keyCode)&&(e.keyCode <= 90)){
					e.charCode = e.keyCode;
					this.onKeyPress(e);
				}
				// dojo.debug(e.ctrlKey);
				// dojo.debug(e.keyCode);
				// dojo.debug(e.charCode);
				// this.onKeyPress(e);
			}
		},
		
		/** Fired on keyup */
		onKeyUp: function(e){
			return;
		},
		
		KEY_CTRL: 1,
		
		/** Fired on keypress. */
		onKeyPress: function(e){
			if((!e)&&(this.object)){
				e = dojo.event.browser.fixEvent(this.window.event);
			}
			// handle the various key events

			var character = e.charCode > 0 ? String.fromCharCode(e.charCode) : null;
			var code = e.keyCode;

			var modifiers = e.ctrlKey ? this.KEY_CTRL : 0;

			if (this._keyHandlers[character]) {
				dojo.debug("char:", character);
				var handlers = this._keyHandlers[character], i = 0, handler;
				while (handler = handlers[i++]) {
					if (modifiers == handler.modifiers) {
						handler.handler.call(this);
						e.preventDefault();
						break;
					}
				}
			}
			
			/*
			// define some key combos
			if (e.ctrlKey || e.metaKey) { // modifier pressed
				switch (character) {
					case "b": this.execCommand("bold"); break;
					case "i": this.execCommand("italic"); break;
					case "u": this.execCommand("underline"); break;
					//case "a": this.execCommand("selectall"); break;
					//case "k": this.execCommand("createlink", ""); break;
					//case "K": this.execCommand("unlink"); break;
					case "Z": this.execCommand("redo"); break;
					case "s": this.close(true); break; // saves
					
					case "1": this.execCommand("formatblock", "h1"); break;
					case "2": this.execCommand("formatblock", "h2"); break;
					case "3": this.execCommand("formatblock", "h3"); break;
					case "4": this.execCommand("formatblock", "h4"); break;
					
					case "\\": this.execCommand("insertunorderedlist"); break;
					
					default: switch (code) {
						case e.KEY_LEFT_ARROW:
						case e.KEY_RIGHT_ARROW:
							//break; // preventDefault stops the browser
								   // going through its history
						default:
							preventDefault = false; break; // didn't handle here
					}
				}
			} else {
				switch (code) {
					case e.KEY_TAB:
					  // commenting out bcs it's crashing FF
						// this.execCommand(e.shiftKey ? "unindent" : "indent");
						// break;
					default:
						preventDefault = false; break; // didn't handle here
				}
			}
			
			if (preventDefault) { e.preventDefault(); }
			*/

			// function call after the character has been inserted
			dojo.lang.setTimeout(this, this.onKeyPressed, 1, e);
		},
		
		addKeyHandler: function (key, modifiers, handler) {
			if (!(this._keyHandlers[key] instanceof Array)) { this._keyHandlers[key] = []; }
			this._keyHandlers[key].push({
				modifiers: modifiers || 0,
				handler: handler
			});
		},
		
		
		
		/**
		 * Fired after a keypress event has occured and it's action taken. This
		 * is useful if action needs to be taken after text operations have
		 * finished
		 */
		onKeyPressed: function (e) {
			// Mozilla adds a single <p> with an embedded <br> when you hit enter once:
			//   <p><br>\n</p>
			// when you hit enter again it adds another <br> inside your enter
			//   <p><br>\n<br>\n</p>
			// and if you hit enter again it splits the <br>s over 2 <p>s
			//   <p><br>\n</p>\n<p><br>\n</p>
			// now this assumes that <p>s have double the line-height of <br>s to work
			// and so we need to remove the <p>s to ensure the position of the cursor
			// changes from the users perspective when they hit enter, as the second two
			// html snippets render the same when margins are set to 0.
			
			// TODO: doesn't really work; is this really needed?
			//if (dojo.render.html.moz) {
			//	for (var i = 0; i < this.document.getElementsByTagName("p").length; i++) {
			//		var p = this.document.getElementsByTagName("p")[i];
			//		if (p.innerHTML.match(/^<br>\s$/m)) {
			//			while (p.hasChildNodes()) { p.parentNode.insertBefore(p.firstChild, p); }
			//			p.parentNode.removeChild(p);
			//		}
			//	}
			//}
			this.onDisplayChanged(/*e*/); // can't pass in e
		},
		
		onClick: function(e){ this.onDisplayChanged(e); },
		onBlur: function(e){ },
		_initialFocus: true,
		onFocus: function(e){ 
			if( (dojo.render.html.mozilla)&&(this._initialFocus) ){
				this._initialFocus = false;
				if(dojo.string.trim(this.editNode.innerHTML) == "&nbsp;"){
					this.execCommand("selectall");
					this.window.getSelection().collapseToStart();
				}
			}
		},

		blur: function () {
			if (this.iframe) { this.window.blur(); }
			else if (this.editNode) { this.editNode.blur(); }
		},
		
		focus: function () {
			if(this.iframe){
				this.window.focus();
			}else if(this.editNode){
				this.editNode.focus();
			}
		},
		
		/** this event will be fired everytime the display context changes and the
		 result needs to be reflected in the UI */
		onDisplayChanged: function (e){ },
		

	/* Formatting commands
	 **********************/
		
		/** IE's Active X codes */
		_activeX: {
			command: {
				bold: 5000,
				italic: 5023,
				underline: 5048,

				justifycenter: 5024,
				justifyleft: 5025,
				justifyright: 5026,

				cut: 5003,
				copy: 5002,
				paste: 5032,
				"delete": 5004,

				undo: 5049,
				redo: 5033,

				removeformat: 5034,
				selectall: 5035,
				unlink: 5050,

				indent: 5018,
				outdent: 5031,

				insertorderedlist: 5030,
				insertunorderedlist: 5051,

				// table commands
				inserttable: 5022,
				insertcell: 5019,
				insertcol: 5020,
				insertrow: 5021,
				deletecells: 5005,
				deletecols: 5006,
				deleterows: 5007,
				mergecells: 5029,
				splitcell: 5047,
				
				// the command need mapping, they don't translate directly
				// to the contentEditable commands
				setblockformat: 5043,
				getblockformat: 5011,
				getblockformatnames: 5012,
				setfontname: 5044,
				getfontname: 5013,
				setfontsize: 5045,
				getfontsize: 5014,
				setbackcolor: 5042,
				getbackcolor: 5010,
				setforecolor: 5046,
				getforecolor: 5015,
				
				findtext: 5008,
				font: 5009,
				hyperlink: 5016,
				image: 5017,
				
				lockelement: 5027,
				makeabsolute: 5028,
				sendbackward: 5036,
				bringforward: 5037,
				sendbelowtext: 5038,
				bringabovetext: 5039,
				sendtoback: 5040,
				bringtofront: 5041,
				
				properties: 5052
			},
			
			ui: {
				"default": 0,
				prompt: 1,
				noprompt: 2
			},
			
			status: {
				notsupported: 0,
				disabled: 1,
				enabled: 3,
				latched: 7,
				ninched: 11
			},
			
			appearance: {
				flat: 0,
				inset: 1
			},
			
			state: {
				unchecked: 0,
				checked: 1,
				gray: 2
			}
		},
		
		/**
		 * Used as the advice function by dojo.event.connect to map our
		 * normalized set of commands to those supported by the target
		 * browser
		 *
		 * @param arugments The arguments Array, containing at least one
		 *                  item, the command and an optional second item,
		 *                  an argument.
		 */
		_normalizeCommand: function (joinObject){
			var drh = dojo.render.html;
			
			var command = joinObject.args[0].toLowerCase();
			if(command == "formatblock"){
				if(drh.safari){ command = "heading"; }
				if(drh.ie){ joinObject.args[1] = "<"+joinObject.args[1]+">"; }
			}
			if (command == "hilitecolor" && !drh.mozilla) { command = "backcolor"; }
			joinObject.args[0] = command;
			
			if (joinObject.args.length > 1) { // a command was specified
				var argument = joinObject.args[1];
				if (command == "heading") { throw new Error("unimplemented"); }
				joinObject.args[1] = argument;
			}
			
			return joinObject.proceed();
		},
		
		/**
		 * Tests whether a command is supported by the host. Clients SHOULD check
		 * whether a command is supported before attempting to use it, behaviour
		 * for unsupported commands is undefined.
		 *
		 * @param command The command to test for
		 * @return true if the command is supported, false otherwise
		 */
		queryCommandAvailable: function (command) {
			var ie = 1;
			var mozilla = 1 << 1;
			var safari = 1 << 2;
			var opera = 1 << 3;
			function isSupportedBy (browsers) {
				return {
					ie: Boolean(browsers & ie),
					mozilla: Boolean(browsers & mozilla),
					safari: Boolean(browsers & safari),
					opera: Boolean(browsers & opera)
				}
			}

			var supportedBy = null;
			
			switch (command.toLowerCase()) {
				case "bold": case "italic": case "underline":
				case "subscript": case "superscript":
				case "fontname": case "fontsize":
				case "forecolor": case "hilitecolor":
				case "justifycenter": case "justifyfull": case "justifyleft": 
				case "justifyright": case "delete": case "undo": case "redo":
					supportedBy = isSupportedBy(mozilla | ie | safari | opera);
					break;
					
				case "createlink": case "unlink": case "removeformat":
				case "inserthorizontalrule": case "insertimage":
				case "insertorderedlist": case "insertunorderedlist":
				case "indent": case "outdent": case "formatblock": 
				case "inserthtml":
					supportedBy = isSupportedBy(mozilla | ie | opera);
					break;
					
				case "strikethrough": 
					supportedBy = isSupportedBy(mozilla |  opera | (this.object ? 0 : ie));
					break;

				case "blockdirltr": case "blockdirrtl":
				case "dirltr": case "dirrtl":
				case "inlinedirltr": case "inlinedirrtl":
				case "cut": case "copy": case "paste": 
					supportedBy = isSupportedBy(ie);
					break;
				
				case "inserttable":
					supportedBy = isSupportedBy(mozilla | (this.object ? ie : 0));
					break;
				
				case "insertcell": case "insertcol": case "insertrow":
				case "deletecells": case "deletecols": case "deleterows":
				case "mergecells": case "splitcell":
					supportedBy = isSupportedBy(this.object ? ie : 0);
					break;
				
				default: return false;
			}
			
			return (dojo.render.html.ie && supportedBy.ie) ||
				(dojo.render.html.mozilla && supportedBy.mozilla) ||
				(dojo.render.html.safari && supportedBy.safari) ||
				(dojo.render.html.opera && supportedBy.opera);
		},

		/**
		 * Executes a command in the Rich Text area
		 *
		 * @param command The command to execute
		 * @param argument An optional argument to the command
		 */
		execCommand: function (command, argument) {
			var returnValue;
			if (this.object) {
				if (command == "forecolor") { command = "setforecolor"; }
				else if (command == "backcolor") { command = "setbackcolor"; }
			
				//if (typeof this._activeX.command[command] == "undefined") { return null; }
			
				if (command == "inserttable") {
					var tableInfo = this.constructor._tableInfo;
					if (!tableInfo) {
						tableInfo = document.createElement("object");
						tableInfo.classid = "clsid:47B0DFC7-B7A3-11D1-ADC5-006008A5848C";
						document.body.appendChild(tableInfo);
						this.constructor._table = tableInfo;
					}
					
					tableInfo.NumRows = argument.rows;
					tableInfo.NumCols = argument.cols;
					tableInfo.TableAttrs = argument["TableAttrs"];
					tableInfo.CellAttrs = arr["CellAttrs"];
					tableInfo.Caption = arr["Caption"];
				}
			
				if(command == "inserthtml"){
					var insertRange = this.document.selection.createRange();
					insertRange.select();
					insertRange.pasteHTML(argument);
					insertRange.collapse(true);
					return true;
				}else if(arguments.length == 1){
					return this.object.ExecCommand(this._activeX.command[command],
						this._activeX.ui.noprompt);
				}else{
					return this.object.ExecCommand(this._activeX.command[command],
						this._activeX.ui.noprompt, argument);
				}
		
			/* */
			}else if(command == "inserthtml"){
				// on IE, we can use the pasteHTML method of the textRange object
				// to get an undo-able innerHTML modification
				if(dojo.render.html.ie){
					dojo.debug("inserthtml breaks the undo stack when not using the ActiveX version of the control!");
					var insertRange = this.document.selection.createRange();
					insertRange.select();
					insertRange.pasteHTML(argument);
					insertRange.collapse(true);
					return true;
				}else{
					return this.document.execCommand(command, false, argument);			
				}
			/* */
			// fix up unlink in Mozilla to unlink the link and not just the selection
			} else if (command == "unlink" &&
				this.queryCommandEnabled("unlink") && dojo.render.html.mozilla) {
				// grab selection
				// Mozilla gets upset if we just store the range so we have to
				// get the basic properties and recreate to save the selection
				var selection = this.window.getSelection();
				var selectionRange = selection.getRangeAt(0);
				var selectionStartContainer = selectionRange.startContainer;
				var selectionStartOffset = selectionRange.startOffset;
				var selectionEndContainer = selectionRange.endContainer;
				var selectionEndOffset = selectionRange.endOffset;
				
				// select our link and unlink
				var range = document.createRange();
				var a = this.getSelectedNode();
				while (a.nodeName != "A") { a = a.parentNode; }
				range.selectNode(a);
				selection.removeAllRanges();
				selection.addRange(range);
				
				returnValue = this.document.execCommand("unlink", false, null);
				
				// restore original selection
				var selectionRange = document.createRange();
				selectionRange.setStart(selectionStartContainer, selectionStartOffset);
				selectionRange.setEnd(selectionEndContainer, selectionEndOffset);
				selection.removeAllRanges();
				selection.addRange(selectionRange);
				
				return returnValue;
			} else if (command == "inserttable" && dojo.render.html.mozilla) {

				var cols = "<tr>";
				for (var i = 0; i < argument.cols; i++) { cols += "<td></td>"; }
				cols += "</tr>";
			
				var table = "<table><tbody>";
				for (var i = 0; i < argument.rows; i++) { table += cols; }
				table += "</tbody></table>";
				returnValue = this.document.execCommand("inserthtml", false, table);

			} else if (command == "hilitecolor" && dojo.render.html.mozilla) {
				// mozilla doesn't support hilitecolor properly when useCSS is
				// set to false (bugzilla #279330)
				
				this.document.execCommand("useCSS", false, false);
				returnValue = this.document.execCommand(command, false, argument);			
				this.document.execCommand("useCSS", false, true);
			
			} else if ((dojo.render.html.ie)&&( (command == "backcolor")||(command == "forecolor")) ){
				// IE weirdly collapses ranges when we exec these commands, so prevent it	
				var tr = this.document.selection.createRange();
				argument = arguments.length > 1 ? argument : null;
				returnValue = this.document.execCommand(command, false, argument);
				// timeout is workaround for weird IE behavior were the text
				// selection gets correctly re-created, but subsequent input
				// apparently isn't bound to it
				setTimeout(function(){tr.select();}, 1);
			} else {
				// dojo.debug("command:", command, "arg:", argument);

				argument = arguments.length > 1 ? argument : null;
				if(dojo.render.html.moz){
					this.document = this.iframe.contentWindow.document
				}
				returnValue = this.document.execCommand(command, false, argument);

				// try{
				// }catch(e){
				// 	dojo.debug(e);
				// }
			}
			
			this.onDisplayChanged();
			return returnValue;
		},

		queryCommandEnabled: function (command, argument) {
			if (this.object) {
				if (command == "forecolor") { command = "setforecolor"; }
				else if (command == "backcolor") { command = "setbackcolor"; }

				if (typeof this._activeX.command[command] == "undefined") { return false; }
				var status = this.object.QueryStatus(this._activeX.command[command]);
				return (status != this.activeX.status.notsupported && 
					status != this.activeX.status.diabled);
			} else {
				// mozilla returns true always
				if (command == "unlink" && dojo.render.html.mozilla) {
					var node = this.getSelectedNode();
					while (node.parentNode && node.nodeName != "A") { node = node.parentNode; }
					return node.nodeName == "A";
				} else if (command == "inserttable" && dojo.render.html.mozilla) {
					return true;
				}

				// return this.document.queryCommandEnabled(command);
				var elem = (dojo.render.html.ie) ? this.document.selection.createRange() : this.document;
				return elem.queryCommandEnabled(command);
			}
		},

		queryCommandState: function (command, argument) {
			if (this.object) {
				if (command == "forecolor") { command = "setforecolor"; }
				else if (command == "backcolor") { command = "setbackcolor"; }

				if (typeof this._activeX.command[command] == "undefined") { return null; }
				var status = this.object.QueryStatus(this._activeX.command[command]);
				return (status == this._activeX.status.enabled ||
					status == this._activeX.status.ninched);
			} else {
				return this.document.queryCommandState(command);
			}
		},

		queryCommandValue: function (command, argument) {
			if (this.object) {
				switch (command) {
					case "forecolor":
					case "backcolor":
					case "fontsize":
					case "fontname":
					case "blockformat":
						command = "get" + command;
						return this.object.execCommand(
							this._activeX.command[command],
							this._activeX.ui.noprompt);
				}			
			
				//var status = this.object.QueryStatus(this._activeX.command[command]);
			} else {
				return this.document.queryCommandValue(command);
			}
		},
		
		
	/* Misc.
	 ********/

		getSelectedNode: function (){
			if(!this.isLoaded){ return; }
			if(this.document.selection){
				return this.document.selection.createRange().parentElement();
			}else if(dojo.render.html.mozilla){
				return this.window.getSelection().getRangeAt(0).commonAncestorContainer;
			}
			return this.editNode;
		},
		
		placeCursorAtStart: function(){
			if(!this.isLoaded){
				dojo.event.connect(this, "onLoad", this, "placeCursorAtEnd");
				return;
			}
			dojo.event.disconnect(this, "onLoad", this, "placeCursorAtEnd");
			if(this.window.getSelection){
				var selection = this.window.getSelection;
				if (selection.removeAllRanges) { // Mozilla			
					var range = this.document.createRange();
					range.selectNode(this.editNode.firstChild);
					range.collapse(true);
					var selection = this.window.getSelection();
					selection.removeAllRanges();
					selection.addRange(range);
				} else { // Safari
					// not a great deal we can do
				}
			} else if (this.document.selection) { // IE
				var range = this.document.body.createTextRange();
				range.moveToElementText(this.editNode);
				range.collapse(true);
				range.select();
			}
		},

		replaceEditorContent: function(html){
			if(this.window.getSelection){
				var selection = this.window.getSelection;
				// if(selection.removeAllRanges){ // Mozilla			
				if(dojo.render.html.moz){ // Mozilla			
					var range = this.document.createRange();
					range.selectNodeContents(this.editNode);
					var selection = this.window.getSelection();
					selection.removeAllRanges();
					selection.addRange(range);
					this.execCommand("inserthtml", html);
				}else{ // Safari
					// look ma! it's a totally f'd browser!
					this.editNode.innerHTML = html;
				}
			}else if(this.document.selection){ // IE
				var range = this.document.body.createTextRange();
				range.moveToElementText(this.editNode);
				range.select();
				this.execCommand("inserthtml", html);
			}
		},
		
		placeCursorAtEnd: function () {
			if(!this.isLoaded){
				dojo.event.connect(this, "onLoad", this, "placeCursorAtEnd");
				return;
			}
			dojo.event.disconnect(this, "onLoad", this, "placeCursorAtEnd");
			if (this.window.getSelection) {
				var selection = this.window.getSelection;
				if (selection.removeAllRanges) { // Mozilla			
					var range = this.document.createRange();
					range.selectNode(this.editNode.lastChild);
					range.collapse(false);
					var selection = this.window.getSelection();
					selection.removeAllRanges();
					selection.addRange(range);
				} else { // Safari
					// not a great deal we can do
				}
			} else if (this.document.selection) { // IE
				var range = this.document.body.createTextRange();
				range.moveToElementText(this.editNode);
				range.collapse(true);
				range.select();
			}
		},

		_lastHeight: 0,

		/** Updates the height of the iframe to fit the contents. */
		_updateHeight: function () {
			if(!this.isLoaded){ return; }
			if(this.height){ return; }
			if(this.iframe){
				/*
				if(!this.document.body["offsetHeight"]){
					return;
				}
				*/
				// The height includes the padding, borders and margins so these
				// need to be added on
				var heights = ["margin-top", "margin-bottom",
					"padding-bottom", "padding-top",
					"border-width-bottom", "border-width-top"];
				for (var i = 0, chromeheight = 0; i < heights.length; i++) {
					var height = dojo.style.getStyle(this.iframe, heights[i]);
					// Safari doesn't have all the heights so we have to test
					if (height) {
						chromeheight += Number(height.replace(/[^0-9]/g, ""));
					}
				}

				if(this.document.body["offsetHeight"]){
					this._lastHeight = Math.max(this.document.body.scrollHeight, this.document.body.offsetHeight) + chromeheight;
					this.iframe.height = this._lastHeight + "px";
					this.window.scrollTo(0, 0);
				}
				// dojo.debug(this.iframe.height);
			}else if(this.object){
				this.object.style.height = dojo.style.getInnerHeight(this.editNode)+"px";
			}
		},
		
		/**
		 * Saves the content in an onunload event if the editor has not been closed
		 */
		_saveContent: function(e){
			var saveTextarea = document.getElementById("dojo.widget.RichText.savedContent");
			saveTextarea.value += this._SEPARATOR + this.saveName + ":" + this.getEditorContent();
		},

		getEditorContent: function(){
			var ec = "";
			try{
				ec = (this._content.length > 0) ? this._content : this.editNode.innerHTML;
				if(dojo.string.trim(ec) == "&nbsp;"){ ec = ""; }
			}catch(e){ /* squelch */ }

			dojo.lang.forEach(this.contentFilters, function(ef){
				ec = ef(ec);
			});

			if (this.relativeImageUrls) {
				// why use a regexp instead of dom? because IE is stupid 
				// and won't let us set img.src to a relative URL
				// this comes after contentFilters because once content
				// gets innerHTML'd img urls will be fully qualified
				var siteBase = window.location.protocol + "//" + window.location.host;
				var pathBase = window.location.pathname;
				if (pathBase.match(/\/$/)) {
					// ends with slash, match full path
				} else {
					// match parent path to find siblings
					var pathParts = pathBase.split("/");
					if (pathParts.length) {
						pathParts.pop();
					}
					pathBase = pathParts.join("/") + "/";

				}
				
				var sameSite = new RegExp("(<img[^>]*\ src=[\"'])("+siteBase+"("+pathBase+")?)", "ig");
				ec = ec.replace(sameSite, "$1");
			}
			return ec;
		},
		
		/**
		 * Kills the editor and optionally writes back the modified contents to the 
		 * element from which it originated.
		 *
		 * @param save Whether or not to save the changes. If false, the changes are
		 *             discarded.
		 * @return true if the contents has been modified, false otherwise
		 */
		close: function(save, force){
			if(this.isClosed){return false; }

			if (arguments.length == 0) { save = true; }
			this._content = this.editNode.innerHTML;
			var changed = (this.savedContent.innerHTML != this._content);
			
			// line height is squashed for iframes
			// FIXME: why was this here? if (this.iframe){ this.domNode.style.lineHeight = null; }

			if(this.interval){ clearInterval(this.interval); }
			
			if(dojo.render.html.ie && !this.object){
				dojo.event.browser.clean(this.editNode);
			}
			
			if (this.iframe) {
				// FIXME: should keep iframe around for later re-use
				delete this.iframe;
			}
			this.domNode.innerHTML = "";

			if(save){
				// kill listeners on the saved content
				dojo.event.browser.clean(this.savedContent);
				if(dojo.render.html.moz){
					var nc = document.createElement("span");
					this.domNode.appendChild(nc);
					nc.innerHTML = this.editNode.innerHTML;
				}else{
					this.domNode.innerHTML = this._content;
				}
			} else {
				while (this.savedContent.hasChildNodes()) {
					this.domNode.appendChild(this.savedContent.firstChild);
				}
			}
			delete this.savedContent;
			
			dojo.html.removeClass(this.domNode, "RichTextEditable");
			this.isClosed = true;
			this.isLoaded = false;
			// FIXME: is this always the right thing to do?
			delete this.editNode;

			return changed;
		},

		destroyRendering: function(){}, // stub!
		
		destroy: function (){
			this.destroyRendering();
			if(!this.isClosed){ this.close(false); }
		
			// disconnect those listeners.
			while(this._connected.length){
				this.disconnect(this._connected[0],
					this._connected[1], this._connected[2]);
			}
		},

		_connected: [],
		connect: function (targetObj, targetFunc, thisFunc) {
			dojo.event.connect(targetObj, targetFunc, this, thisFunc);
			// this._connected.push([targetObj, targetFunc, thisFunc]);	
		},
		
		// FIXME: below two functions do not work with the above line commented out
		disconnect: function (targetObj, targetFunc, thisFunc) {
			for (var i = 0; i < this._connected.length; i++) {
				if (this._connected[0] == targetObj &&
					this._connected[1] == targetFunc &&
					this._connected[2] == thisFunc) {
					dojo.event.disconnect(targetObj, targetFunc, this, thisFunc);
					this._connected.splice(i, 1);
					break;
				}
			}
		},
		
		disconnectAllWithRoot: function (targetObj) {
			for (var i = 0; i < this._connected.length; i++) {
				if (this._connected[0] == targetObj) {
					dojo.event.disconnect(targetObj,
						this._connected[1], this, this._connected[2]);
					this._connected.splice(i, 1);
				}
			}	
		}
		
	},
	"html",
	function(){
		this.contentFilters = [];
		// this.contentFilters.push(this.defaultContentCleaner);
		
		this._keyHandlers = {};
	}
);

__CPAN_FILE__ src/widget/Rounded.js
dojo.provide("dojo.widget.Rounded");
dojo.widget.tags.addParseTreeHandler("dojo:rounded");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.html.ContentPane");
dojo.require("dojo.html");
dojo.require("dojo.style");

	/***************************************************************
	* The following script is derived (with permission) from		 *
	* curvyCorners (attribution below) and was adapted to			 *
	* Dojo Toolkit by Brian Lucas	(brian.lucas <at> gmail.com)	 *
	****************************************************************
	*                                                              *
	*  curvyCorners                                                *
	*  ------------                                                *
	*  This script generates rounded corners for your divs.        *
	*                                                              *
	*  Version 1.00 beta                                           *
	*  Copyright (c) 2006 Cameron Cooke                            *
	*  By: Cameron Cooke and Tim Hutchison.                        *
	*                                                              *
	*  Website: http://www.curvycorners.net                        *
	*  Email:   info@totalinfinity.com                             *
	*                                                              *
	*  This library is free software; you can redistribute         *
	*  it and/or modify it under the terms of the GNU              *
	*  Lesser General Public License as published by the           *
	*  Free Software Foundation; either version 2.1 of the         *
	*  License, or (at your option) any later version.             *
	*                                                              *
	*  (...standard GPL disclaimer follows, snipped for space...)  *
	****************************************************************/

dojo.widget.Rounded = function() {
	dojo.widget.html.ContentPane.call(this);
}

dojo.inherits(dojo.widget.Rounded, dojo.widget.html.ContentPane);

dojo.lang.extend(dojo.widget.Rounded, {
	isSafari: dojo.render.html.safari,
	widgetType: "Rounded",
	boxMargin: "50px", // margin outside rounded corner box
	radius: 14, // radius of corners
	domNode: "",
	corners: "TR,TL,BR,BL", // corner string to render
	antiAlias: true, // false to disable anti-aliasing

	fillInTemplate: function(args, frag) {
		dojo.widget.Rounded.superclass.fillInTemplate.call(this, args, frag);

		dojo.style.insertCssFile(this.templateCssPath);

		// Magic to automatically calculate the box height/width if not supplied
		if (this.domNode.style.height<=0) {
			minHeight = (this.radius*1)+this.domNode.clientHeight;
			this.domNode.style.height = minHeight+"px";
		}

		if (this.domNode.style.width<=0) {
			minWidth = (this.radius*1)+this.domNode.clientWidth;
			this.domNode.style.width = minWidth+"px";
		}

		cornersAvailable = ["TR", "TL", "BR", "BL"];
		cornersPassed = this.corners.split(",");

		this.settings = {
			antiAlias: this.antiAlias
		};

		setCorner = function(currentCorner, cornersAvailable, radius, settings) {
			this.settings = settings;
			val = currentCorner.toLowerCase(); 
			if(dojo.lang.inArray(cornersAvailable, currentCorner)) {
				this.settings[val] = { radius: radius, enabled: true };
			} else { 
				this.settings[val] = { radius: 0 }
			}
		}

		dojo.lang.map(cornersAvailable, this, function(currentCorner){setCorner(currentCorner, cornersPassed, this.radius, this.settings); } );
		this.domNode.style.margin = this.boxMargin;
		this.curvyCorners(this.settings);
		this.applyCorners();

	},

	// ------------- curvyCorners OBJECT

	curvyCorners: function(settings){	

		// Setup Globals
		this.box             = this.domNode;
		this.topContainer    = null;
		this.bottomContainer = null;
		this.masterCorners   = [];

		// Get box formatting details
		var boxHeight       = dojo.style.getStyle(this.box, "height");
		if(boxHeight=="") boxHeight="0px";
		var boxWidth        = dojo.style.getStyle(this.box, "width");
		var borderWidth     = dojo.style.getStyle(this.box, "borderTopWidth");
		if(borderWidth=="") borderWidth="0px";
		//alert(borderWidth);

		var borderColour    = dojo.style.getStyle(this.box, "borderTopColor");
		// Set to true if we have a border
		if(borderWidth>0) this.antiAlias=true;

		var boxColour       = dojo.style.getStyle(this.box, "backgroundColor");
		var backgroundImage = dojo.style.getStyle(this.box, "backgroundImage");
		var boxPosition     = dojo.style.getStyle(this.box, "position");

		// Set formatting propertes
		this.boxHeight       = parseInt(((boxHeight != "" && boxHeight != "auto" && boxHeight.indexOf("%") == -1)? boxHeight.substring(0, boxHeight.indexOf("px")) : this.box.scrollHeight));
		this.boxWidth        = parseInt(((boxWidth != "" && boxWidth != "auto" && boxWidth.indexOf("%") == -1)? boxWidth.substring(0, boxWidth.indexOf("px")) : this.box.scrollWidth));
		this.borderWidth     = parseInt(((borderWidth != "" && borderWidth.indexOf("px") !== -1)? borderWidth.slice(0, borderWidth.indexOf("px")) : 0));

		// DEBUG ME?

		//dojo.debug(this.rgb2Hex(boxColour));
		test  = new dojo.graphics.color.Color(boxColour);
		//dojo.debug(test.toHex()); 

		this.boxColour       = ((boxColour != "" && boxColour != "transparent")? ((boxColour.substr(0, 3) == "rgb")? this.rgb2Hex(boxColour) : boxColour) : "#ffffff");
		this.borderColour    = ((borderColour != "" && borderColour != "transparent" && this.borderWidth > 0)? ((borderColour.substr(0, 3) == "rgb")? this.rgb2Hex(borderColour)  : borderColour) : this.boxColour);
		this.borderString    = this.borderWidth + "px" + " solid " + this.borderColour;
		this.backgroundImage = ((backgroundImage != "none")? backgroundImage : "");

		// Make box relative if not already absolute
		if(boxPosition != "absolute") this.box.style.position = "relative";

		//This method creates the corners and
		//applies them to the div element.

		this.applyCorners = function() {
			// Create top and bottom containers.
			// These will be used as a parent for the corners and bars.
			for(var t = 0; t < 2; t++) {
			    switch(t) {
			        // Top
			        case 0:
						// Only build top bar if a top corner is to be draw
						if(this.settings.tl.enabled || this.settings.tr.enabled ) {
							var newMainContainer = document.createElement("DIV");
			
							with(newMainContainer.style){
								width    = "100%";
								fontSize = "1px";
								overflow = "hidden";
								position = "absolute";
								//backgroundColor = "#FFFFC4";
								paddingLeft  = this.borderWidth + "px";
								paddingRight = this.borderWidth + "px";
								var topMaxRadius = Math.max(this.settings.tl ? this.settings.tl.radius : 0, this.settings.tr ? this.settings.tr.radius : 0);
								height = topMaxRadius + "px";
								top    = 0 - topMaxRadius + "px";
								left   = 0 - this.borderWidth + "px";
							}
							
							this.topContainer = this.box.appendChild(newMainContainer);
						}
			            break;
	
			        // Bottom
			        case 1:      
			            // Only build bottom bar if a top corner is to be draw
			            if(this.settings.bl.enabled || this.settings.br.enabled) {
							var newMainContainer = document.createElement("DIV");
							with(newMainContainer.style){
								width    = "100%";
								fontSize = "1px";
								overflow = "hidden";
								position = "absolute";
								//backgroundColor = "#FFFFC4";
								paddingLeft  = this.borderWidth + "px";
								paddingRight = this.borderWidth + "px";
								var botMaxRadius = Math.max(this.settings.bl ? this.settings.bl.radius : 0, this.settings.br ? this.settings.br.radius : 0);
								height  = botMaxRadius + "px";
								bottom  =  0 - botMaxRadius + "px";
								left    =  0 - this.borderWidth + "px";
							}
						this.bottomContainer = this.box.appendChild(newMainContainer);
			            }
		            break;
			    }
			}
	
			// Turn off current borders
			if(this.topContainer) this.box.style.borderTopWidth = "0px";
			if(this.bottomContainer) this.box.style.borderBottomWidth = "0px";
	
			// Create array of available corners
			var corners = ["tr", "tl", "br", "bl"];
		
			//Loop for each corner
	
			for(var i in corners) {
			    // Get current corner type from array
			    var cc = corners[i];

			    // Has the user requested the currentCorner be round?
			    if(!this.settings[cc]) {
			        // No
			        if(((cc == "tr" || cc == "tl") && this.topContainer != null) || ((cc == "br" || cc == "bl") && this.bottomContainer != null)) {
						// We need to create a filler div to fill the space upto the next horzontal corner.
						var newCorner = document.createElement("DIV");
		
						// Setup corners properties
						newCorner.style.position = "relative";
						newCorner.style.fontSize = "1px";
						newCorner.style.overflow = "hidden";
		
						// Add background image?
						if(this.backgroundImage == "") {
							newCorner.style.backgroundColor = this.boxColour;
						} else {
							newCorner.style.backgroundImage = this.backgroundImage;
						}

			            switch(cc) {
							case "tl":
								with(newCorner.style){
									height      = topMaxRadius - this.borderWidth + "px";
									marginRight = this.settings.tr.radius - (this.borderWidth*2) + "px";
									borderLeft  = this.borderString;
									borderTop   = this.borderString;
									left         = -this.borderWidth + "px";
								}
							break;
			
							case "tr":
								with(newCorner.style){
									height      = topMaxRadius - this.borderWidth + "px";
									marginLeft  = this.settings.tl.radius - (this.borderWidth*2) + "px";
									borderRight = this.borderString;
									borderTop   = this.borderString;
									backgroundPosition  = "-" + this.boxWidth + "px 0px";
									left         = this.borderWidth + "px";
								}
							break;
	
							case "bl":
								with(newCorner.style){
									height       = botMaxRadius - this.borderWidth + "px";
									marginRight  = this.settings.br.radius - (this.borderWidth*2) + "px";
									borderLeft   = this.borderString;
									borderBottom = this.borderString;
									left         = -this.borderWidth + "px";
								}
							break;
			
							case "br":
								with(newCorner.style){
									height       = botMaxRadius - this.borderWidth + "px";
									marginLeft   = this.settings.bl.radius - (this.borderWidth*2) + "px";
									borderRight  = this.borderString;
									borderBottom = this.borderString;
									left         = this.borderWidth + "px"
								}
							break;
			            }
			        }
			    } else {
			        /*
			        PERFORMANCE NOTE:

			        If more than one corner is requested and a corner has been already
			        created for the same radius then that corner will be used as a master and cloned.
			        The pixel bars will then be repositioned to form the new corner type.
			        All new corners start as a bottom right corner.
			        */
			        if(this.masterCorners[this.settings[cc].radius]) {
			            // Create clone of the master corner
			            var newCorner = this.masterCorners[this.settings[cc].radius].cloneNode(true);
			        } else {
			            // Yes, we need to create a new corner
			            var newCorner = document.createElement("DIV");
						with(newCorner.style){
							height = this.settings[cc].radius + "px";
							width  = this.settings[cc].radius + "px";
							position = "absolute";
							fontSize = "1px";
							overflow = "hidden";
						}
						// THE FOLLOWING BLOCK OF CODE CREATES A ROUNDED CORNER
						// ---------------------------------------------------- TOP
			
						// Get border radius
						var borderRadius = parseInt(this.settings[cc].radius - this.borderWidth);
			
						// Cycle the x-axis
						for(var intx = 0, j = this.settings[cc].radius; intx < j; intx++) {
							// Calculate the value of y1 which identifies the pixels inside the border
							if((intx +1) >= borderRadius) {
								var y1 = -1;
							} else {
								var y1 = (Math.floor(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow((intx+1), 2))) - 1);
							}
			
							// Only calculate y2 and y3 if there is a border defined
							if(borderRadius != j) {
								if((intx) >= borderRadius) {
									var y2 = -1;
								} else {
									var y2 = Math.ceil(Math.sqrt(Math.pow(borderRadius,2) - Math.pow(intx, 2)));
								}
			
								if((intx+1) >= j) {
									var y3 = -1;
								} else {
									var y3 = (Math.floor(Math.sqrt(Math.pow(j ,2) - Math.pow((intx+1), 2))) - 1);
								}
							}

							// Calculate y4
							if((intx) >= j) {
								var y4 = -1;
							} else {
								var y4 = Math.ceil(Math.sqrt(Math.pow(j ,2) - Math.pow(intx, 2)));
							}

							// Draw bar on inside of the border with foreground colour
							if(y1 > -1) this.drawPixel(intx, 0, this.boxColour, 100, (y1+1), newCorner, -1, this.settings[cc].radius);
	
							// Only draw border/foreground antialiased pixels and border if there is a border defined
							if(borderRadius != j) {
								// Draw aa pixels?
								if(this.antiAlias) {
									// Cycle the y-axis
									for(var inty = (y1 + 1); inty < y2; inty++) {
										// For each of the pixels that need anti aliasing between the foreground and border colour draw single pixel divs
										if(this.backgroundImage != "") {					
											var borderFract = (this.pixelFraction(intx, inty, borderRadius) * 100);
					
											if (borderFract < 30) {
												this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, 0, this.settings[cc].radius);
											} else {
												this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, -1, this.settings[cc].radius);
											}
										} else {
											var pixelcolour = dojo.graphics.color.blend(this.boxColour, this.borderColour, this.pixelFraction(intx, inty, borderRadius));
											this.drawPixel(intx, inty, pixelcolour, 100, 1, newCorner, 0, this.settings[cc].radius);
										}
									}
								}

								// Draw bar for the border
								if(y3 >= y2) {
									if (y1 == -1) {
										y1 = 0;
									}
									this.drawPixel(intx, y2, this.borderColour, 100, (y3 - y2 + 1), newCorner, 0, this.settings[cc].radius);
								}	
								// Set the colour for the outside curve
								var outsideColour = this.borderColour;
							} else {
								// Set the coour for the outside curve
								var outsideColour = this.boxColour;
								var y3 = y1;
							}
			
							// Draw aa pixels?
							if(this.antiAlias) {		
								// Cycle the y-axis and draw the anti aliased pixels on the
								// outside of the curve
								for(var inty = (y3 + 1); inty < y4; inty++) {
									// For each of the pixels that need anti aliasing between 
									//the foreground/border colour & background draw single pixel divs
									this.drawPixel(intx, inty, outsideColour, (this.pixelFraction(intx, inty , j) * 100), 1, newCorner, ((this.borderWidth > 0)? 0 : -1), this.settings[cc].radius);
								}
							}
			            }

			            // END OF CORNER CREATION
			            // ---------------------------------------------------- END

			            // We now need to store the current corner in the masterConers array
			            this.masterCorners[this.settings[cc].radius] = newCorner.cloneNode(true);
			        }
			
					//Now we have a new corner we need to reposition all the pixels unless
					//the current corner is the bottom right.
			        if(cc != "br") {	
						// Loop through all children (pixel bars)
						for(var t = 0, k = newCorner.childNodes.length; t < k; t++) {
							// Get current pixel bar
							var pixelBar = newCorner.childNodes[t];
	
							// Get current top and left properties
							var pixelBarTop    = parseInt(pixelBar.style.top.substring(0, pixelBar.style.top.indexOf("px")));
							var pixelBarLeft   = parseInt(pixelBar.style.left.substring(0, pixelBar.style.left.indexOf("px")));
							var pixelBarHeight = parseInt(pixelBar.style.height.substring(0, pixelBar.style.height.indexOf("px")));
							
							// Reposition pixels
							if(cc == "tl" || cc == "bl") {
								pixelBar.style.left = this.settings[cc].radius -pixelBarLeft -1 + "px"; // Left
							}
							if(cc == "tr" || cc == "tl") {
								pixelBar.style.top =  this.settings[cc].radius -pixelBarHeight -pixelBarTop + "px"; // Top
							}
					
							switch(cc) {
								case "tr":
									value = (-1 *( Math.abs((this.boxWidth - this.settings[cc].radius + this.borderWidth) + pixelBarLeft) - (Math.abs(this.settings[cc].radius -pixelBarHeight -pixelBarTop - this.borderWidth))));
									pixelBar.style.backgroundPosition  = value + "px";
									
								break;
				
								case "tl":
									value = (-1 *( Math.abs((this.settings[cc].radius -pixelBarLeft -1)  - this.borderWidth) - (Math.abs(this.settings[cc].radius -pixelBarHeight -pixelBarTop - this.borderWidth))));
									pixelBar.style.backgroundPosition  = value + "px";

								break;
				
								case "bl":
									value = (-1 *( Math.abs((this.settings[cc].radius -pixelBarLeft -1) - this.borderWidth) - (Math.abs((this.boxHeight + this.settings[cc].radius + pixelBarTop) -this.borderWidth))));
									pixelBar.style.backgroundPosition  = value + "px";

								break;
							}
						}
					}
				}
				if(newCorner) {
					// Position the container
					switch(cc) {
						case "tl":
							if(newCorner.style.position == "absolute") newCorner.style.top  = "0px";
							if(newCorner.style.position == "absolute") newCorner.style.left = "0px";
							if(this.topContainer) this.topContainer.appendChild(newCorner);
						break;

						case "tr":
							if(newCorner.style.position == "absolute") newCorner.style.top  = "0px";
							if(newCorner.style.position == "absolute") newCorner.style.right = "0px";
							if(this.topContainer) this.topContainer.appendChild(newCorner);
						break;
		
						case "bl":
							if(newCorner.style.position == "absolute") newCorner.style.bottom  = "0px";
							if(newCorner.style.position == "absolute") newCorner.style.left = "0px";
							if(this.bottomContainer) this.bottomContainer.appendChild(newCorner);
						break;
						
						case "br":
							if(newCorner.style.position == "absolute") newCorner.style.bottom = "0px";
							if(newCorner.style.position == "absolute") newCorner.style.right = "0px";
							if(this.bottomContainer) this.bottomContainer.appendChild(newCorner);
						break;
					}
				}
			}
			//The last thing to do is draw the rest of the filler DIVs.
			//We only need to create a filler DIVs when two corners have
			//diffrent radiuses in either the top or bottom container.
	
			// Find out which corner has the biiger radius and get the difference amount
			var radiusDiff = [];
			radiusDiff["t"] = this.settings.tl.enabled && this.settings.tr.enabled ? Math.abs(this.settings.tl.radius - this.settings.tr.radius) : 0;
			radiusDiff["b"] = this.settings.bl.enabled && this.settings.br.enabled ? Math.abs(this.settings.bl.radius - this.settings.br.radius) : 0;

			for(z in radiusDiff) {
				if(radiusDiff[z]) {
					// Get the type of corner that is the smaller one
					var smallerCornerType = ((this.settings[z + "l"].radius < this.settings[z + "r"].radius)? z +"l" : z +"r");

					// First we need to create a DIV for the space under the smaller corner
					var newFiller = document.createElement("DIV");
					with(newFiller.style) {
						height = radiusDiff[z] + "px";
						width  =  this.settings[smallerCornerType].radius+ "px"
						position = "absolute";
						fontSize = "1px";
						overflow = "hidden";
						backgroundColor = this.boxColour;
					}

					// Position filler
					switch(smallerCornerType) {
						case "tl":
							with(newFiller.style) {
								bottom = "0px";
								left   = "0px";
								borderLeft = this.borderString;
							}
							this.topContainer.appendChild(newFiller);
						break;
	
						case "tr":
							with(newFiller.style) {
								bottom = "0px";
								right  = "0px";
								borderRight = this.borderString;
							}
							this.topContainer.appendChild(newFiller);
						break;

						case "bl":
							with(newFiller.style) {
								top    = "0px";
								left   = "0px";
								borderLeft = this.borderString;
							}
							this.bottomContainer.appendChild(newFiller);
						break;

						case "br":
							with(newFiller.style) {
								top    = "0px";
								right  = "0px";
								borderRight = this.borderString;
							}
							this.bottomContainer.appendChild(newFiller);
						break;
					}
			    }

				// Create the bar to fill the gap between each corner horizontally
				var newFillerBar = document.createElement("DIV");
				with(newFillerBar.style) {
					position = "relative";
					fontSize = "1px";
					overflow = "hidden";
					backgroundColor = this.boxColour;
				}

				switch(z) {
					case "t":
						// Top Bar
						if(this.topContainer) {
							with(newFillerBar.style) {
								height      = topMaxRadius - this.borderWidth + "px";
								marginLeft  = this.settings.tl.radius - this.borderWidth + "px";
								marginRight = this.settings.tr.radius - this.borderWidth + "px";
								borderTop   = this.borderString;
							}
						this.topContainer.appendChild(newFillerBar);
						}
					break;

					case "b":
						if(this.bottomContainer) {
						// Bottom Bar
						with(newFillerBar.style) {
							height       = botMaxRadius - this.borderWidth + "px";
							marginLeft   = this.settings.bl.radius - this.borderWidth + "px";
							marginRight  = this.settings.br.radius - this.borderWidth + "px";
							borderBottom = this.borderString;
						}
						this.bottomContainer.appendChild(newFillerBar);
					}
					break;
				}
			}
		}

		// This function draws the pixles
		this.drawPixel = function(intx, inty, colour, transAmount, height, newCorner, image, cornerRadius) {
			// Create pixel
			var pixel = document.createElement("DIV");

			
			// Section doesn't like with (pixel.style) { DEBUG?
			pixel.style.height   = height + "px";
			pixel.style.width    = "1px";
			pixel.style.position = "absolute";
			pixel.style.fontSize = "1px";
			pixel.style.overflow = "hidden";
			
			// Dont apply background image to border pixels
			if(image == -1 && this.backgroundImage != "") {
				pixel.style.backgroundImage = this.backgroundImage;
				pixel.style.backgroundPosition  = "-" + (this.boxWidth - (cornerRadius - intx) + this.borderWidth) + "px -" + ((this.boxHeight + cornerRadius + inty) -this.borderWidth) + "px";
			} else {
				pixel.style.backgroundColor = colour;
			}
			
			// Set opacity if the transparency is anything other than 100
			if (transAmount != 100) {
				dojo.style.setOpacity(pixel, transAmount);
			}
			// Set the pixels position
			pixel.style.top = inty + "px";
			pixel.style.left = intx + "px";
		
			newCorner.appendChild(pixel);
		}
	},

	//For a pixel cut by the line determines the fraction of the pixel on the 'inside' of the
	//line.  Returns a number between 0 and 1
	pixelFraction: function(x, y, r) {
		var pixelfraction = 0;
		
		//determine the co-ordinates of the two points on the perimeter of the pixel that the
		//circle crosses
		
		var xvalues = [];
		var yvalues = [];
		var point = 0;
		var whatsides = "";

		// x + 0 = Left
		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(x,2)));

		if ((intersect >= y) && (intersect < (y+1))) {
			whatsides = "Left";
			xvalues[point] = 0;
			yvalues[point] = intersect - y;
			point =  point + 1;
		}

		// y + 1 = Top
		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(y+1,2)));
		
		if ((intersect >= x) && (intersect < (x+1))) {
			whatsides = whatsides + "Top";
			xvalues[point] = intersect - x;
			yvalues[point] = 1;
			point = point + 1;
		}
		// x + 1 = Right
		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(x+1,2)));

		if ((intersect >= y) && (intersect < (y+1))) {
			whatsides = whatsides + "Right";
			xvalues[point] = 1;
			yvalues[point] = intersect - y;
			point =  point + 1;
		}
		// y + 0 = Bottom
		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(y,2)));

		if ((intersect >= x) && (intersect < (x+1))) {
			whatsides = whatsides + "Bottom";
			xvalues[point] = intersect - x;
			yvalues[point] = 0;
		}

	    //depending on which sides of the perimeter of the pixel the circle crosses calculate the
	    //fraction of the pixel inside the circle

		switch (whatsides) {
			case "LeftRight":
				pixelfraction = Math.min(yvalues[0],yvalues[1]) + ((Math.max(yvalues[0],yvalues[1]) - Math.min(yvalues[0],yvalues[1]))/2);
			break;
			
			case "TopRight":
				pixelfraction = 1-(((1-xvalues[0])*(1-yvalues[1]))/2);
			break;
			
			case "TopBottom":
				pixelfraction = Math.min(xvalues[0],xvalues[1]) + ((Math.max(xvalues[0],xvalues[1]) - Math.min(xvalues[0],xvalues[1]))/2);
			break;
			
			case "LeftBottom":
				pixelfraction = (yvalues[0]*xvalues[1])/2;
			break;
			
			default:
				pixelfraction = 1;
	    }
	    return pixelfraction;
	},

	// This function converts CSS rgb(x, x, x) to hexadecimal
	rgb2Hex: function (rgbColour) {
		try{	
			// Get array of RGB values
			var rgbArray = this.rgb2Array(rgbColour);
			
			// Get RGB values
			var red   = parseInt(rgbArray[0]);
			var green = parseInt(rgbArray[1]);
			var blue  = parseInt(rgbArray[2]);
			
			// Build hex colour code
			var hexColour = "#" + this.intToHex(red) + this.intToHex(green) + this.intToHex(blue);
		}
		catch(e){ alert("There was an error converting the RGB value to Hexadecimal in function rgb2Hex");
		}
		return hexColour;
	},

	//Converts a number to hexadecimal format

	intToHex: function (strNum) {
		base = strNum / 16;
		rem = strNum % 16;
		base = base - (rem / 16);
		baseS = this.makeHex(base);
		remS = this.makeHex(rem);
		return baseS + '' + remS;
	},
	//gets the hex bits of a number

	makeHex: function(x) {
		if((x >= 0) && (x <= 9)) {
			return x;
		} else {
			switch(x) {
				case 10: return "A";
				case 11: return "B";
				case 12: return "C";
				case 13: return "D";
				case 14: return "E";
				case 15: return "F";
			}
		}
	},

	// Returns an array of rbg values
	rgb2Array: function(rgbColour) {
		// Remove rgb()
		var rgbValues = rgbColour.substring(4, rgbColour.indexOf(")"));
	
		// Split RGB into array
		var rgbArray = rgbValues.split(", ");
		return rgbArray;
	}
}); // end function

__CPAN_FILE__ src/widget/SimpleDropdownButtons.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/* TODO:
 * - make the dropdowns "smart" so they can't get cutoff on bottom of page, sides of page, etc.
 * - unify menus with the MenuItem and Menu classes so we can add stuff to all menus at once
 * - allow buttons to be enabled/disabled at runtime
 *     - this probably means creating all menus upfront and then triggering a disable action
 *       for disabled buttons in the constructor loop. we'll need a disable and enable action anyway
 * - should each button with menu be a widget object of it's own?
 */
dojo.provide("dojo.widget.SimpleDropdownButtons");
dojo.provide("dojo.widget.HtmlSimpleDropdownButtons");

dojo.deprecated("dojo.widget.SimpleDropdownButtons",  "use dojo.widget.DropDownButton", "0.4");

dojo.require("dojo.event.*");
dojo.require("dojo.widget.*");
dojo.require("dojo.uri.Uri");
dojo.require("dojo.dom");
dojo.require("dojo.style");
dojo.require("dojo.html");

dojo.widget.tags.addParseTreeHandler("dojo:simpledropdownbuttons");

dojo.widget.HtmlSimpleDropdownButtons = function() {
	dojo.widget.HtmlWidget.call(this);

	this.widgetType = "SimpleDropdownButtons";
	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlSimpleDropdownButtons.css");

	this.menuTriggerClass = "dojoSimpleDropdownButtons";
	this.menuClass = "dojoSimpleDropdownButtonsMenu";

	// overwrite buildRendering so we don't clobber our list
	this.buildRendering = function(args, frag) {
		if(this.templateCssPath) {
			dojo.style.insertCssFile(this.templateCssPath, null, true);
		}
		this.domNode = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];

		var menu = this.domNode;
		if( !dojo.html.hasClass(menu, this.menuTriggerClass) ) {
			dojo.html.addClass(menu, this.menuTriggerClass);
		}
		var li = dojo.dom.getFirstChildElement(menu);
		var menuIDs = [];
		var arrowIDs = [];

		while(li) {
			if(li.getElementsByTagName("ul").length > 0) {
				var a = dojo.dom.getFirstChildElement(li);
				var arrow = document.createElement("a");
				arrow.href = "javascript:;";
				arrow.innerHTML = "&nbsp;";
				dojo.html.setClass(arrow, "downArrow");
				if(!arrow.id) {
					arrow.id = dojo.dom.getUniqueId();
				}
				arrowIDs.push(arrow.id);
				var submenu = dojo.dom.getNextSiblingElement(a);
				if(!submenu.id) {
					submenu.id = dojo.dom.getUniqueId();
				}
				menuIDs.push(submenu.id);

				if( dojo.html.hasClass(a, "disabled") ) {
					dojo.html.addClass(arrow, "disabled");
					dojo.html.disableSelection(li);
					arrow.onfocus = function(){ this.blur(); }
				} else {
					dojo.html.addClass(submenu, this.menuClass);
					document.body.appendChild(submenu);
					dojo.event.connect(arrow, "onmousedown", (function() {
						var ar = arrow;
						return function(e) {
							dojo.html.addClass(ar, "pressed");
						}
					})());
					dojo.event.connect(arrow, "onclick", (function() {
						var aa = a;
						var ar = arrow;
						var sm = submenu;
						var setWidth = false;

						return function(e) {
							hideAll(sm, ar);
							sm.style.left = (dojo.html.getScrollLeft()
								+ e.clientX - e.layerX + aa.offsetLeft) + "px";
							sm.style.top = (dojo.html.getScrollTop() + e.clientY
								- e.layerY + aa.offsetTop + aa.offsetHeight) + "px";
							sm.style.display = sm.style.display == "block" ? "none" : "block";
							if(sm.style.display == "none") {
								dojo.html.removeClass(ar, "pressed");
								e.target.blur()
							}
							if(!setWidth && sm.style.display == "block"
								&& sm.offsetWidth < aa.offsetWidth + ar.offsetWidth) {
								sm.style.width = aa.offsetWidth + ar.offsetWidth + "px";
								setWidth = true;
							}
							e.preventDefault();
						}
					})());
				}

				dojo.event.connect(a, "onclick", function(e) {
					if(e && e.target && e.target.blur) {
						e.target.blur();
					}
				});

				if(a.nextSibling) {
					li.insertBefore(arrow, a.nextSibling);
				} else {
					li.appendChild(arrow);
				}

			}
			li = dojo.dom.getNextSiblingElement(li);
		}

		function hideAll(excludeMenu, excludeArrow) {
			// hide menus
			for(var i = 0; i < menuIDs.length; i++) {
				var m = document.getElementById(menuIDs[i]);
				if(!excludeMenu || m != excludeMenu) {
					document.getElementById(menuIDs[i]).style.display = "none";
				}
			}
			// restore arrows to non-pressed state
			for(var i = 0; i < arrowIDs.length; i++) {
				var m = document.getElementById(arrowIDs[i]);
				if(!excludeArrow || m != excludeArrow) {
					dojo.html.removeClass(m, "pressed");
				}
			}
		}

		dojo.event.connect(document.documentElement, "onmousedown", function(e) {
			if( dojo.html.hasClass(e.target, "downArrow") ) { return };
			for(var i = 0; i < menuIDs.length; i++) {
				if( dojo.dom.isDescendantOf(e.target, document.getElementById(menuIDs[i])) ) {
					return;
				}
			}
			hideAll();
		});
	}
}
dojo.inherits(dojo.widget.HtmlSimpleDropdownButtons, dojo.widget.HtmlWidget);

__CPAN_FILE__ src/widget/SlideShow.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.SlideShow");
dojo.provide("dojo.widget.html.SlideShow");

dojo.require("dojo.event");
dojo.require("dojo.widget.*");
dojo.require("dojo.lfx.*");
dojo.require("dojo.style");

dojo.widget.html.SlideShow = function(){
	dojo.widget.HtmlWidget.call(this);

	this.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlSlideShow.html");
	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlSlideShow.css");

	// over-ride some defaults
	this.isContainer = false;
	this.widgetType = "SlideShow";

	// useful properties
	this.imgUrls = [];		// the images we'll go through
	this.imgUrlBase = "";
	this.urlsIdx = 0;		// where in the images we are
	this.delay = 4000; 		// give it 4 seconds
	this.transitionInterval = 2000; // 2 seconds
	this.imgWidth = 800;	// img width
	this.imgHeight = 600;	// img height
	this.background = "img2"; // what's in the bg
	this.foreground = "img1"; // what's in the fg
	this.stopped = false;	// should I stay or should I go?
	this.fadeAnim = null; // references our animation

	// our DOM nodes:
	this.imagesContainer = null;
	this.startStopButton = null;
	this.controlsContainer = null;
	this.img1 = null;
	this.img2 = null;

	this.fillInTemplate = function(){
		dojo.style.setOpacity(this.img1, 0.9999);
		dojo.style.setOpacity(this.img2, 0.9999);
		with(this.imagesContainer.style){
			width = this.imgWidth+"px";
			height = this.imgHeight+"px";
		}
		with(this.img1.style){
			width = this.imgWidth+"px";
			height = this.imgHeight+"px";
		}
		with(this.img2.style){
			width = this.imgWidth+"px";
			height = this.imgHeight+"px";
		}
		if(this.imgUrls.length>1){
			this.img2.src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
			this.endTransition();
		}else{
			this.img1.src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
		}
	}

	this.togglePaused = function(){
		if(this.stopped){
			this.stopped = false;
			this.endTransition();
			this.startStopButton.value= "pause";
		}else{
			this.stopped = true;
			this.startStopButton.value= "play";
		}
	}

	this.backgroundImageLoaded = function(){
		// start fading out the foreground image
		if(this.stopped){ return; }
		// closure magic for callback
		var _this = this; 
		var callback = function(){ _this.endTransition(); };

		// actually start the fadeOut effect
		// NOTE: if we wanted to use other transition types, we'd set them up
		// 		 here as well
		if(this.fadeAnim) {
			this.fadeAnim.stop();
		}
		this.fadeAnim = dojo.lfx.fadeOut(this[this.foreground], 
			this.transitionInterval, null, callback);
		this.fadeAnim.play();
	}

	this.endTransition = function(){
		// move the foreground image to the background 
		with(this[this.background].style){ zIndex = parseInt(zIndex)+1; }
		with(this[this.foreground].style){ zIndex = parseInt(zIndex)-1; }

		// fg/bg book-keeping
		var tmp = this.foreground;
		this.foreground = this.background;
		this.background = tmp;

		// keep on truckin
		this.loadNextImage();
	}

	this.loadNextImage = function(){
		// load a new image in that container, and make sure it informs
		// us when it finishes loading
		dojo.event.kwConnect({
			srcObj: this[this.background],
			srcFunc: "onload",
			adviceObj: this,
			adviceFunc: "backgroundImageLoaded",
			once: true, // make sure we only ever hear about it once
			delay: this.delay
		});
		dojo.style.setOpacity(this[this.background], 1.0);
		this[this.background].src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
		if(this.urlsIdx>(this.imgUrls.length-1)){
			this.urlsIdx = 0;
		}
	}
}
dojo.inherits(dojo.widget.html.SlideShow, dojo.widget.HtmlWidget);
dojo.widget.tags.addParseTreeHandler("dojo:slideshow");

__CPAN_FILE__ src/widget/SortableTable.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.SortableTable");
dojo.require("dojo.widget.*");
dojo.requireAfterIf("html", "dojo.widget.html.SortableTable");
dojo.widget.tags.addParseTreeHandler("dojo:sortableTable");

//	set up the general widget
dojo.widget.SortableTable=function(){
	//	summary
	//	base class for the SortableTable
	dojo.widget.Widget.call(this);
	this.widgetType="SortableTable";
	this.isContainer=false;

	//	custom properties
	this.enableMultipleSelect=false;
	this.maximumNumberOfSelections=0;	//	0 for unlimited, is the default.
	this.enableAlternateRows=false;
	this.minRows=0;	//	0 means ignore.
	this.defaultDateFormat="%D";
	this.data=[];
	this.selected=[];		//	always an array to handle multiple selections.
	this.columns=[];
	this.sortIndex=0;		//	index of the column sorted on, first is the default.
	this.sortDirection=0;	//	0==asc, 1==desc
	this.valueField="Id";	//	if a JSON structure is parsed and there is a field of this name,
							//	a value attribute will be added to the row (tr value="{Id}")
};
dojo.inherits(dojo.widget.SortableTable, dojo.widget.Widget);

__CPAN_FILE__ src/widget/SplitContainer.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.SplitContainer");
dojo.provide("dojo.widget.SplitContainerPanel");
dojo.provide("dojo.widget.html.SplitContainer");
dojo.provide("dojo.widget.html.SplitContainerPanel");

//
// TODO
// make it prettier
// active dragging upwards doesn't always shift other bars (direction calculation is wrong in this case)
//

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.LayoutContainer");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.html");
dojo.require("dojo.style");
dojo.require("dojo.dom");
dojo.require("dojo.io");	// workaround dojo bug. dojo.io.cookie requires dojo.io but it still doesn't get pulled in
dojo.require("dojo.io.cookie");

dojo.widget.html.SplitContainer = function(){

	dojo.widget.HtmlWidget.call(this);

	this.sizers = [];
}

dojo.inherits(dojo.widget.html.SplitContainer, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.SplitContainer, {
	widgetType: "SplitContainer",
	isContainer: true,

	virtualSizer: null,
	isHorizontal: 0,
	paneBefore: null,
	paneAfter: null,
	isSizing: false,
	dragOffset: null,
	startPoint: null,
	lastPoint: null,
	sizingSplitter: null,
	isActiveResize: 0,
	offsetX: 0,
	offsetY: 0,
	isDraggingLeft: 0,
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlSplitContainer.css"),
	originPos: null,
	persist: true,		// save splitter positions in a cookie

	activeSizing: '',
	sizerWidth: 15,
	orientation: 'horizontal',

	debugName: '',

	fillInTemplate: function(){

		dojo.style.insertCssFile(this.templateCssPath, null, true);
		dojo.html.addClass(this.domNode, "dojoSplitContainer");
		this.domNode.style.overflow='hidden';	// workaround firefox bug

		this.paneWidth = dojo.style.getContentWidth(this.domNode);
		this.paneHeight = dojo.style.getContentHeight(this.domNode);

		this.isHorizontal = (this.orientation == 'horizontal') ? 1 : 0;
		this.isActiveResize = (this.activeSizing == '1') ? 1 : 0;

		//dojo.debug("fillInTemplate for "+this.debugName);
	},

	onResized: function(e){
		this.paneWidth = dojo.style.getContentWidth(this.domNode);
		this.paneHeight = dojo.style.getContentHeight(this.domNode);
		this.layoutPanels();
	},

	postCreate: function(args, fragment, parentComp){

		// dojo.debug("post create for "+this.debugName);

		// attach the children and create the draggers
		for(var i=0; i<this.children.length; i++){
            with(this.children[i].domNode.style){
                position = "absolute";
            }
            dojo.html.addClass(this.children[i].domNode,
                "dojoSplitPane");

            if(i == this.children.length-1){
                break;
            }

            this._addSizer();
		}

		// create the fake dragger
		this.virtualSizer = document.createElement('div');
		this.virtualSizer.style.position = 'absolute';
		this.virtualSizer.style.display = 'none';
		//this.virtualSizer.style.backgroundColor = 'lime';
		this.virtualSizer.style.zIndex = 10;
		this.virtualSizer.className = this.isHorizontal ? 'dojoSplitContainerVirtualSizerH' : 'dojoSplitContainerVirtualSizerV';
		this.domNode.appendChild(this.virtualSizer);

		dojo.html.disableSelection(this.virtualSizer);

		if(this.persist){
			this.restoreState();
		}

		// size the panels once the browser has caught up
		this.resizeSoon();
	},

    _injectChild: function(child) {
        with(child.domNode.style){
            position = "absolute";
        }
        dojo.html.addClass(child.domNode,
            "dojoSplitPane");
    },

    _addSizer: function() {
        var i = this.sizers.length;

        this.sizers[i] = document.createElement('div');
        this.sizers[i].style.position = 'absolute';
        this.sizers[i].className = this.isHorizontal ? 'dojoSplitContainerSizerH' : 'dojoSplitContainerSizerV';

        var self = this;
        var handler = (function(){ var sizer_i = i; return function(e){ self.beginSizing(e, sizer_i); } })();
        dojo.event.connect(this.sizers[i], "onmousedown", handler);

        this.domNode.appendChild(this.sizers[i]);
        dojo.html.disableSelection(this.sizers[i]);
    },

    removeChild: function(widget){
        // Remove sizer, but only if widget is really our child and
        // we have at least one sizer to throw away
        if (this.sizers.length > 0) {
            for(var x=0; x<this.children.length; x++){
                if(this.children[x] === widget){
                    var i = this.sizers.length - 1;
                    this.domNode.removeChild(this.sizers[i]);
                    this.sizers.length = i;
                    break;
                }
            }
        }

        // Remove widget and repaint
        dojo.widget.html.SplitContainer.superclass.removeChild.call(this, widget, arguments);
        this.onResized();
    },

    addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
        dojo.widget.html.SplitContainer.superclass.addChild.call(this, widget, overrideContainerNode, pos, ref, insertIndex);
        this._injectChild(widget);

        if (this.children.length > 1) {
            this._addSizer();
        }

        this.layoutPanels();
    },

    layoutPanels: function(){
        if (this.children.length == 0){ return; }

		//
		// calculate space
		//

		var space = this.isHorizontal ? this.paneWidth : this.paneHeight;

		if (this.children.length > 1){

			space -= this.sizerWidth * (this.children.length - 1);
		}


		//
		// calculate total of SizeShare values
		//

		var out_of = 0;

		for(var i=0; i<this.children.length; i++){

			out_of += this.children[i].sizeShare;
		}


		//
		// work out actual pixels per sizeshare unit
		//

		var pix_per_unit = space / out_of;


		//
		// set the SizeActual member of each pane
		//

		var total_size = 0;

		for(var i=0; i<this.children.length-1; i++){

			var size = Math.round(pix_per_unit * this.children[i].sizeShare);
			this.children[i].sizeActual = size;
			total_size += size;
		}
		this.children[this.children.length-1].sizeActual = space - total_size;

		//
		// make sure the sizes are ok
		//

		this.checkSizes();


		//
		// now loop, positioning each pane and letting children resize themselves
		//

		var pos = 0;
		var size = this.children[0].sizeActual;
		this.movePanel(this.children[0].domNode, pos, size);
		this.children[0].position = pos;
        this.children[0].onParentResized();
		pos += size;

		for(var i=1; i<this.children.length; i++){

			// first we position the sizing handle before this pane
			this.movePanel(this.sizers[i-1], pos, this.sizerWidth);
			this.sizers[i-1].position = pos;
			pos += this.sizerWidth;

			size = this.children[i].sizeActual;
			this.movePanel(this.children[i].domNode, pos, size);
			this.children[i].position = pos;
            this.children[i].onParentResized();
			pos += size;
		}
	},

	movePanel: function(panel, pos, size){
		if (this.isHorizontal){
			panel.style.left = pos + 'px';
			panel.style.top = 0;

			dojo.style.setOuterWidth(panel, size);
			dojo.style.setOuterHeight(panel, this.paneHeight);
		}else{
			panel.style.left = 0;
			panel.style.top = pos + 'px';

			dojo.style.setOuterWidth(panel, this.paneWidth);
			dojo.style.setOuterHeight(panel, size);
		}
	},

	growPane: function(growth, pane){

		if (growth > 0){
			if (pane.sizeActual > pane.sizeMin){
				if ((pane.sizeActual - pane.sizeMin) > growth){

					// stick all the growth in this pane
					pane.sizeActual = pane.sizeActual - growth;
					growth = 0;
				}else{
					// put as much growth in here as we can
					growth -= pane.sizeActual - pane.sizeMin;
					pane.sizeActual = pane.sizeMin;
				}
			}
		}
		return growth;
	},

	checkSizes: function(){

		var total_min_size = 0;
		var total_size = 0;

		for(var i=0; i<this.children.length; i++){

			total_size += this.children[i].sizeActual;
			total_min_size += this.children[i].sizeMin;
		}

		// only make adjustments if we have enough space for all the minimums

		if (total_min_size <= total_size){

			var growth = 0;

			for(var i=0; i<this.children.length; i++){

				if (this.children[i].sizeActual < this.children[i].sizeMin){

					growth += this.children[i].sizeMin - this.children[i].sizeActual;
					this.children[i].sizeActual = this.children[i].sizeMin;
				}
			}

			if (growth > 0){
				if (this.isDraggingLeft){
					for(var i=this.children.length-1; i>=0; i--){
						growth = this.growPane(growth, this.children[i]);
					}
				}else{
					for(var i=0; i<this.children.length; i++){
						growth = this.growPane(growth, this.children[i]);
					}
				}
			}
		}else{

			for(var i=0; i<this.children.length; i++){
				this.children[i].sizeActual = Math.round(total_size * (this.children[i].sizeMin / total_min_size));
			}
		}
	},

	beginSizing: function(e, i){
		var clientX = e.layerX;
		var clientY = e.layerY;
		var screenX = e.pageX;
		var screenY = e.pageY;

		this.paneBefore = this.children[i];
		this.paneAfter = this.children[i+1];

		this.isSizing = true;
		this.sizingSplitter = this.sizers[i];
		this.originPos = dojo.style.getAbsolutePosition(this.domNode, true);
		this.dragOffset = {'x':clientX, 'y':clientY};
		this.startPoint  = {'x':screenX, 'y':screenY};
		this.lastPoint  = {'x':screenX, 'y':screenY};

		this.offsetX = screenX - clientX;
		this.offsetY = screenY - clientY;

		if (!this.isActiveResize){
			this.showSizingLine();
		}

		//
		// attach mouse events
		//

		dojo.event.connect(document.documentElement, "onmousemove", this, "changeSizing");
		dojo.event.connect(document.documentElement, "onmouseup", this, "endSizing");
	},

	changeSizing: function(e){
		var screenX = e.pageX;
		var screenY = e.pageY;

		if (this.isActiveResize){
			this.lastPoint = {'x':screenX, 'y':screenY};
			this.movePoint();
			this.updateSize();
		}else{
			this.lastPoint = {'x':screenX, 'y':screenY};
			this.movePoint();
			this.moveSizingLine();
		}
	},

	endSizing: function(e){

		if (!this.isActiveResize){
			this.hideSizingLine();
		}

		this.updateSize();

		this.isSizing = false;

		dojo.event.disconnect(document.documentElement, "onmousemove", this, "changeSizing");
		dojo.event.disconnect(document.documentElement, "onmouseup", this, "endSizing");
		
		if(this.persist){
			this.saveState(this);
		}
	},

	movePoint: function(){

		// make sure FLastPoint is a legal point to drag to
		p = this.screenToMainClient(this.lastPoint);

		if (this.isHorizontal){

			var a = p.x - this.dragOffset.x;
			a = this.legaliseSplitPoint(a);
			p.x = a + this.dragOffset.x;
		}else{
			var a = p.y - this.dragOffset.y;
			a = this.legaliseSplitPoint(a);
			p.y = a + this.dragOffset.y;
		}

		this.lastPoint = this.mainClientToScreen(p);
	},

	screenToClient: function(pt){

		pt.x -= (this.offsetX + this.sizingSplitter.position);
		pt.y -= (this.offsetY + this.sizingSplitter.position);

		return pt;
	},

	clientToScreen: function(pt){

		pt.x += (this.offsetX + this.sizingSplitter.position);
		pt.y += (this.offsetY + this.sizingSplitter.position);

		return pt;
	},

	screenToMainClient: function(pt){

		pt.x -= this.offsetX;
		pt.y -= this.offsetY;

		return pt;
	},

	mainClientToScreen: function(pt){

		pt.x += this.offsetX;
		pt.y += this.offsetY;

		return pt;
	},

	legaliseSplitPoint: function(a){

		a += this.sizingSplitter.position;

		this.isDraggingLeft = (a > 0) ? 1 : 0;

		if (!this.isActiveResize){

			if (a < this.paneBefore.position + this.paneBefore.sizeMin){

				a = this.paneBefore.position + this.paneBefore.sizeMin;
			}

			if (a > this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin))){

				a = this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin));
			}
		}

		a -= this.sizingSplitter.position;

		this.checkSizes();

		return a;
	},

	updateSize: function(){

		var p = this.clientToScreen(this.lastPoint);
		var p = this.screenToClient(this.lastPoint);

		var pos = this.isHorizontal ? p.x - (this.dragOffset.x + this.originPos.x) : p.y - (this.dragOffset.y + this.originPos.y);

		var start_region = this.paneBefore.position;
		var end_region   = this.paneAfter.position + this.paneAfter.sizeActual;

		this.paneBefore.sizeActual = pos - start_region;
		this.paneAfter.position    = pos + this.sizerWidth;
		this.paneAfter.sizeActual  = end_region - this.paneAfter.position;

		for(var i=0; i<this.children.length; i++){

			this.children[i].sizeShare = this.children[i].sizeActual;
		}

		this.layoutPanels();
	},

	showSizingLine: function(){

		this.moveSizingLine();

		if (this.isHorizontal){
			dojo.style.setOuterWidth(this.virtualSizer, this.sizerWidth);
			dojo.style.setOuterHeight(this.virtualSizer, this.paneHeight);
		}else{
			dojo.style.setOuterWidth(this.virtualSizer, this.paneWidth);
			dojo.style.setOuterHeight(this.virtualSizer, this.sizerWidth);
		}

		this.virtualSizer.style.display = 'block';
	},

	hideSizingLine: function(){

		this.virtualSizer.style.display = 'none';
	},

	moveSizingLine: function(){

		var origin = {'x':0, 'y':0};

		if (this.isHorizontal){
			origin.x += (this.lastPoint.x - this.startPoint.x) + this.sizingSplitter.position;
		}else{
			origin.y += (this.lastPoint.y - this.startPoint.y) + this.sizingSplitter.position;
		}

		this.virtualSizer.style.left = origin.x + 'px';
		this.virtualSizer.style.top = origin.y + 'px';
	},
	
	_getCookieName: function(i) {
		return this.widgetId + "_" + i;
	},

	restoreState: function () {
		for(var i=0; i<this.children.length; i++) {
			var cookieName = this._getCookieName(i);
			var cookieValue = dojo.io.cookie.getCookie(cookieName);
			if (cookieValue != null) {
				var pos = parseInt(cookieValue);
				this.children[i].sizeShare=pos;
			}
		}
	},

	saveState: function (){
		for(var i=0; i<this.children.length; i++) {
			var cookieName = this._getCookieName(i);
			dojo.io.cookie.setCookie(cookieName, this.children[i].sizeShare, null, null, null, null);
		}
	}
});

// These arguments can be specified for the children of a SplitContainer.
// Since any widget can be specified as a SplitContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.lang.extend(dojo.widget.Widget, {
	sizeMin: 10,
	sizeShare: 10
});

// Deprecated class for split pane children.
// Actually any widget can be the child of a split pane
dojo.widget.html.SplitContainerPanel = function(){
	dojo.widget.html.LayoutContainer.call(this);
}
dojo.inherits(dojo.widget.html.SplitContainerPanel, dojo.widget.html.LayoutContainer);
dojo.lang.extend(dojo.widget.html.SplitContainerPanel, {
	widgetType: "SplitContainerPanel"
});

dojo.widget.tags.addParseTreeHandler("dojo:SplitContainer");
dojo.widget.tags.addParseTreeHandler("dojo:SplitContainerPanel");

__CPAN_FILE__ src/widget/SvgButton.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

// FIXME: not yet functional

dojo.provide("dojo.widget.SvgButton");

dojo.require("dojo.widget.Button");

dojo.widget.SvgButton = function(){
	// FIXME: this is incomplete and doesn't work yet
	// if DOMButton turns into a mixin, we should subclass Button instead and
	// just mix in the DOMButton properties.

	dojo.widget.DomButton.call(this);
	dojo.widget.SvgWidget.call(this);

	// FIXME: freaking implement this already!
	this.onFoo = function(){ alert("bar"); }

	this.label = "huzzah!";

	this.setLabel = function(x, y, textSize, label, shape){
		//var labelNode = this.domNode.ownerDocument.createTextNode(this.label);
		//var textNode = this.domNode.ownerDocument.createElement("text");
		var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape);
		var textString = "";
		switch(shape) {
			case "ellipse":
				textString = "<text x='"+ coords[6] + "' y='"+ coords[7] + "'>"+ label + "</text>";
				//textNode.setAttribute("x", coords[6]);
				//textNode.setAttribute("y", coords[7]);
				break;
			case "rectangle":
				//FIXME: implement
				textString = "";
				//textNode.setAttribute("x", coords[6]);
				//textNode.setAttribute("y", coords[7]);
				break;
			case "circle":
				//FIXME: implement
				textString = "";
				//textNode.setAttribute("x", coords[6]);
				//textNode.setAttribute("y", coords[7]);
				break;
		}
		//textNode.appendChild(labelNode);
		//this.domNode.appendChild(textNode);
		return textString;
		alert(textNode.getComputedTextLength());
	}

	this.fillInTemplate = function(x, y, textSize, label, shape){
		// the idea is to set the text to the appropriate place given its length
		// and the template shape
		
		// FIXME: For now, assuming text sizes are integers in SVG units
		this.textSize = textSize || 12;
		this.label = label;
		// FIXEME: for now, I'm going to fake this... need to come up with a real way to 
		// determine the actual width of the text, such as computedStyle
		var textWidth = this.label.length*this.textSize ;
		//this.setLabel();
	}
}

dojo.inherits(dojo.widget.SvgButton, dojo.widget.DomButton);

// FIXME
dojo.widget.SvgButton.prototype.shapeString = function(x, y, textSize, label, shape) {
	switch(shape) {
		case "ellipse":
			var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape)
			return "<ellipse cx='"+ coords[4]+"' cy='"+ coords[5]+"' rx='"+ coords[2]+"' ry='"+ coords[3]+"'/>";
			break;
		case "rect":
			//FIXME: implement
			return "";
			//return "<rect x='110' y='45' width='70' height='30'/>";
			break;
		case "circle":
			//FIXME: implement
			return "";
			//return "<circle cx='210' cy='60' r='23'/>";
			break;
	}
}

dojo.widget.SvgButton.prototype.coordinates = function(x, y, textSize, label, shape) {
	switch(shape) {
		case "ellipse":
			var buttonWidth = label.length*textSize;
			var buttonHeight = textSize*2.5
			var rx = buttonWidth/2;
			var ry = buttonHeight/2;
			var cx = rx + x;
			var cy = ry + y;
			var textX = cx - rx*textSize/25;
			var textY = cy*1.1;
			return [buttonWidth, buttonHeight, rx, ry, cx, cy, textX, textY];
			break;
		case "rectangle":
			//FIXME: implement
			return "";
			break;
		case "circle":
			//FIXME: implement
			return "";
			break;
	}
}

dojo.widget.SvgButton.prototype.labelString = function(x, y, textSize, label, shape){
	var textString = "";
	var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape);
	switch(shape) {
		case "ellipse":
			textString = "<text x='"+ coords[6] + "' y='"+ coords[7] + "'>"+ label + "</text>";
			break;
		case "rectangle":
			//FIXME: implement
			textString = "";
			break;
		case "circle":
			//FIXME: implement
			textString = "";
			break;
	}
	return textString;
}

dojo.widget.SvgButton.prototype.templateString = function(x, y, textSize, label, shape) {
	return "<g class='dojoButton' dojoAttachEvent='onClick; onMouseMove: onFoo;' dojoAttachPoint='labelNode'>"+ dojo.widgets.SVGButton.prototype.shapeString(x, y, textSize, label, shape) + dojo.widget.SVGButton.prototype.labelString(x, y, textSize, label, shape) + "</g>";
}

__CPAN_FILE__ src/widget/SvgWidget.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.widget.DomWidget");
dojo.provide("dojo.widget.SvgWidget");
dojo.provide("dojo.widget.SVGWidget"); // back compat

dojo.require("dojo.dom");

// SVGWidget is a mixin ONLY
dojo.widget.SvgWidget = function(args){
	// mix in the parent type
	// dojo.widget.DomWidget.call(this);
}
dojo.inherits(dojo.widget.SvgWidget, dojo.widget.DomWidget);

dojo.lang.extend(dojo.widget.SvgWidget, {
	getContainerHeight: function(){
		// NOTE: container height must be returned as the INNER height
		dojo.unimplemented("dojo.widget.SvgWidget.getContainerHeight");
	},

	getContainerWidth: function(){
		// return this.parent.domNode.offsetWidth;
		dojo.unimplemented("dojo.widget.SvgWidget.getContainerWidth");
	},

	setNativeHeight: function(height){
		// var ch = this.getContainerHeight();
		dojo.unimplemented("dojo.widget.SVGWidget.setNativeHeight");
	},

	createNodesFromText: function(txt, wrap){
		return dojo.dom.createNodesFromText(txt, wrap);
	}
});

dojo.widget.SVGWidget = dojo.widget.SvgWidget;

try{
(function(){
	var tf = function(){
		// FIXME: fill this in!!!
		var rw = new function(){
			dojo.widget.SvgWidget.call(this);
			this.buildRendering = function(){ return; }
			this.destroyRendering = function(){ return; }
			this.postInitialize = function(){ return; }
			this.cleanUp = function(){ return; }
			this.widgetType = "SVGRootWidget";
			this.domNode = document.documentElement;
		}
		var wm = dojo.widget.manager;
		wm.root = rw;
		wm.add(rw);

		// extend the widgetManager with a getWidgetFromNode method
		wm.getWidgetFromNode = function(node){
			var filter = function(x){
				if(x.domNode == node){
					return true;
				}
			}
			var widgets = [];
			while((node)&&(widgets.length < 1)){
				widgets = this.getWidgetsByFilter(filter);
				node = node.parentNode;
			}
			if(widgets.length > 0){
				return widgets[0];
			}else{
				return null;
			}
		}

		wm.getWidgetFromEvent = function(domEvt){
			return this.getWidgetFromNode(domEvt.target);
		}

		wm.getWidgetFromPrimitive = wm.getWidgetFromNode;
	}
	// make sure we get called when the time is right
	dojo.event.connect(dojo.hostenv, "loaded", tf);
})();
}catch(e){ alert(e); }

__CPAN_FILE__ src/widget/TabContainer.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.TabContainer");
dojo.provide("dojo.widget.html.TabContainer");
dojo.provide("dojo.widget.Tab");

dojo.require("dojo.lang.func");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.event.*");
dojo.require("dojo.html");
dojo.require("dojo.style");
dojo.require("dojo.html.layout");

//////////////////////////////////////////
// TabContainer -- a set of Tabs
//////////////////////////////////////////
dojo.widget.html.TabContainer = function() {
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.html.TabContainer, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.TabContainer, {
	widgetType: "TabContainer",
    isContainer: true,

	// Constructor arguments
	labelPosition: "top",
	closeButton: "none",

	useVisibility: false,		// true-->use visibility:hidden instead of display:none
	doLayout: true,

	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlTabContainer.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlTabContainer.css"),

	selectedTab: "",		// initially selected tab (widgetId)

	fillInTemplate: function(args, frag) {
		// Copy style info and id from input node to output node
		var source = this.getFragNodeRef(frag);
		// get around opera wich doesnt have cssText, and IE wich bugs on setAttribute 
		if(dojo.lang.isUndefined(source.style.cssText)){ 
			this.domNode.setAttribute("style", source.getAttribute("style")); 
		}else{
			this.domNode.style.cssText = source.style.cssText; 
		}
		dojo.html.addClass(this.domNode, dojo.html.getClass(source));
		dojo.widget.html.TabContainer.superclass.fillInTemplate.call(this, args, frag);
	},

	postCreate: function(args, frag) {
		// Load all the tabs, creating a label for each one
		for(var i=0; i<this.children.length; i++){
			this._setupTab(this.children[i]);
		}

		if (this.closeButton=="pane") {
			var div = document.createElement("div");
			dojo.html.addClass(div, "dojoTabPanePaneClose");
			var self = this;
			dojo.event.connect(div, "onclick", function(){ self._runOnCloseTab(self.selectedTabWidget); });
			dojo.event.connect(div, "onmouseover", function(){ dojo.html.addClass(div, "dojoTabPanePaneCloseHover"); });
			dojo.event.connect(div, "onmouseout", function(){ dojo.html.removeClass(div, "dojoTabPanePaneCloseHover"); });
			this.dojoTabLabels.appendChild(div);
		}

		dojo.html.addClass(this.dojoTabLabels, "dojoTabLabels-"+this.labelPosition);

        this._doSizing();

		// Display the selected tab
		if(this.selectedTabWidget){
			this.selectTab(this.selectedTabWidget, true);
		}
	},

	addChild: function(child, overrideContainerNode, pos, ref, insertIndex){
		this._setupTab(child);
		dojo.widget.html.TabContainer.superclass.addChild.call(this,child, overrideContainerNode, pos, ref, insertIndex);

		// in case the tab labels have overflowed from one line to two lines
		this._doSizing();
	},

	_setupTab: function(tab){
		tab.domNode.style.display="none";

		// Create label
		tab.div = document.createElement("div");
		dojo.html.addClass(tab.div, "dojoTabPaneTab");
		var span = document.createElement("span");
		span.innerHTML = tab.label;
		dojo.html.disableSelection(span);
		if (this.closeButton=="tab") {
			var img = document.createElement("div");
			dojo.html.addClass(img, "dojoTabPaneTabClose");
			var self = this;
			dojo.event.connect(img, "onclick", function(evt){ self._runOnCloseTab(tab); dojo.event.browser.stopEvent(evt); });
			dojo.event.connect(img, "onmouseover", function(){ dojo.html.addClass(img,"dojoTabPaneTabCloseHover"); });
			dojo.event.connect(img, "onmouseout", function(){ dojo.html.removeClass(img,"dojoTabPaneTabCloseHover"); });
			span.appendChild(img);
		}
		tab.div.appendChild(span);
		this.dojoTabLabels.appendChild(tab.div);
		
		var self = this;
		dojo.event.connect(tab.div, "onclick", function(){ self.selectTab(tab); });

		if(!this.selectedTabWidget || this.selectedTab==tab.widgetId || tab.selected){
    		this.selectedTabWidget = tab;
        } else {
            this._hideTab(tab);
        }
	},

	// Configure the content pane to take up all the space except for where the tab labels are
	_doSizing: function(){
		// position the labels and the container node
		var labelAlign=this.labelPosition.replace(/-h/,"");
		var children = [
			{domNode: this.dojoTabLabels, layoutAlign: labelAlign},
			{domNode: this.containerNode, layoutAlign: "client"}
		];


		if (this.doLayout) {
			dojo.html.layout(this.domNode, children);
		} 
			
		// size the current tab
		// TODO: should have ptr to current tab rather than searching
		var cw=dojo.style.getContentWidth(this.containerNode);
		var ch=dojo.style.getContentHeight(this.containerNode);
		dojo.lang.forEach(this.children, function(child){
			//if (this.doLayout) {
				if(child.selected){
					child.resizeTo(cw, ch);
				} 
			//} else {
			//	child.onResized();
			//}
		});
		
	},

    removeChild: function(tab) {

		// remove tab event handlers
		dojo.event.disconnect(tab.div, "onclick", function () { });
		if (this.closeButton=="tab") {
			var img = tab.div.lastChild.lastChild;
			if (img) {
				dojo.html.removeClass(img, "dojoTabPaneTabClose", function () { });
				dojo.event.disconnect(img, "onclick", function () { });
				dojo.event.disconnect(img, "onmouseover", function () { });
				dojo.event.disconnect(img, "onmouseout", function () { });
			}
		}

        dojo.widget.html.TabContainer.superclass.removeChild.call(this, tab);

        dojo.html.removeClass(tab.domNode, "dojoTabPane");
        this.dojoTabLabels.removeChild(tab.div);
        delete(tab.div);

        if (this.selectedTabWidget === tab) {
            this.selectedTabWidget = undefined;
            if (this.children.length > 0) {
                this.selectTab(this.children[0], true);
            }
        }

		// in case the tab labels have overflowed from one line to two lines
		this._doSizing();
    },

    selectTab: function(tab, _noRefresh) {
		// Deselect old tab and select new one
		if (this.selectedTabWidget) {
			this._hideTab(this.selectedTabWidget);
		}
		this.selectedTabWidget = tab;
		this._showTab(tab, _noRefresh);
	},

	_showTab: function(tab, _noRefresh) {
		dojo.html.addClass(tab.div, "current");
		tab.selected=true;
		if ( this.useVisibility && !dojo.render.html.ie ) {
			tab.domNode.style.visibility="visible";
		} else {
			// make sure we dont refresh onClose and on postCreate
			// speeds up things a bit when using refreshOnShow and fixes #646
			if(_noRefresh && tab.refreshOnShow){
				var tmp = tab.refreshOnShow;
				tab.refreshOnShow = false;
				tab.show();
				tab.refreshOnShow = tmp;
			}else{
				tab.show();
			}

			tab.resizeTo(
				dojo.style.getContentWidth(this.containerNode),
				dojo.style.getContentHeight(this.containerNode)
			);
		}
	},

	_hideTab: function(tab) {
		dojo.html.removeClass(tab.div, "current");
		tab.selected=false;
		if( this.useVisibility ){
			tab.domNode.style.visibility="hidden";
		}else{
			tab.hide();
		}
	},

	_runOnCloseTab: function(tab) {
		var onc = tab.extraArgs.onClose || tab.extraArgs.onclose;
		var fcn = dojo.lang.isFunction(onc) ? onc : window[onc];
		if(dojo.lang.isFunction(fcn)) {
			if(fcn(this,tab)) {
				this.removeChild(tab);
			}
		} else {
			this.removeChild(tab);
		}
		// makes sure we can clean up executeScripts in ContentPane onUnLoad
		tab.destroy();
	},

	onResized: function() {
		this._doSizing();
	}
});
dojo.widget.tags.addParseTreeHandler("dojo:TabContainer");

// These arguments can be specified for the children of a TabContainer.
// Since any widget can be specified as a TabContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.lang.extend(dojo.widget.Widget, {
	label: "",
	selected: false	// is this tab currently selected?
});

__CPAN_FILE__ src/widget/TaskBar.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.TaskBar");
dojo.provide("dojo.widget.TaskBarItem");
dojo.require("dojo.widget.Widget");

dojo.widget.TaskBar = function(){
	dojo.widget.Widget.call(this);

	this.widgetType = "TaskBar";
	this.isContainer = true;
}
dojo.inherits(dojo.widget.TaskBar, dojo.widget.Widget);
dojo.widget.tags.addParseTreeHandler("dojo:taskbar");

dojo.widget.TaskBarItem = function(){
	dojo.widget.Widget.call(this);

	this.widgetType = "TaskBarItem";
}
dojo.inherits(dojo.widget.TaskBarItem, dojo.widget.Widget);
dojo.widget.tags.addParseTreeHandler("dojo:taskbaritem");

dojo.requireAfterIf("html", "dojo.widget.html.TaskBar");

__CPAN_FILE__ src/widget/TimePicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.TimePicker");
dojo.provide("dojo.widget.TimePicker.util");
dojo.require("dojo.widget.DomWidget");
dojo.require("dojo.date");

dojo.widget.TimePicker = function(){
	dojo.widget.Widget.call(this);
	this.widgetType = "TimePicker";
	this.isContainer = false;
	// the following aliases prevent breaking people using 0.2.x
	this.toRfcDateTime = dojo.widget.TimePicker.util.toRfcDateTime;
	this.fromRfcDateTime = dojo.widget.TimePicker.util.fromRfcDateTime;
	this.toAmPmHour = dojo.widget.TimePicker.util.toAmPmHour;
	this.fromAmPmHour = dojo.widget.TimePicker.util.fromAmPmHour;
}

dojo.inherits(dojo.widget.TimePicker, dojo.widget.Widget);
dojo.widget.tags.addParseTreeHandler("dojo:timepicker");

dojo.requireAfterIf("html", "dojo.widget.html.TimePicker");

dojo.widget.TimePicker.util = new function() {
	// utility functions
	this.toRfcDateTime = function(jsDate) {
		if(!jsDate) {
			jsDate = new Date();
		}
		return dojo.date.format(jsDate, "%Y-%m-%dT%H:%M:00%z");
	}

	this.fromRfcDateTime = function(rfcDate, useDefaultMinutes, isAnyTime) {
		var tempDate = new Date();
		if(!rfcDate || rfcDate.indexOf("T")==-1) {
			if(useDefaultMinutes) {
				tempDate.setMinutes(Math.floor(tempDate.getMinutes()/5)*5);
			} else {
				tempDate.setMinutes(0);
			}
		} else {
			var tempTime = rfcDate.split("T")[1].split(":");
			// fullYear, month, date
			var tempDate = new Date();
			tempDate.setHours(tempTime[0]);
			tempDate.setMinutes(tempTime[1]);
		}
		return tempDate;
	}

	this.toAmPmHour = function(hour) {
		var amPmHour = hour;
		var isAm = true;
		if (amPmHour == 0) {
			amPmHour = 12;
		} else if (amPmHour>12) {
			amPmHour = amPmHour - 12;
			isAm = false;
		} else if (amPmHour == 12) {
			isAm = false;
		}
		return [amPmHour, isAm];
	}

	this.fromAmPmHour = function(amPmHour, isAm) {
		var hour = parseInt(amPmHour, 10);
		if(isAm && hour == 12) {
			hour = 0;
		} else if (!isAm && hour<12) {
			hour = hour + 12;
		}
		return hour;
	}
}

__CPAN_FILE__ src/widget/TitlePane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.TitlePane");
dojo.requireAfterIf("html", "dojo.widget.html.TitlePane");

__CPAN_FILE__ src/widget/Toggler.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Toggler");
dojo.require("dojo.widget.*");
dojo.require("dojo.event.*");

// clicking on this node shows/hides another widget

dojo.widget.Toggler = function(){
	dojo.widget.DomWidget.call(this);
}

dojo.inherits(dojo.widget.Toggler, dojo.widget.DomWidget);

dojo.lang.extend(dojo.widget.Toggler, {
	widgetType: "Toggler",
	
	// Associated widget 
	targetId: '',
	
	fillInTemplate: function() {
		dojo.event.connect(this.domNode, "onclick", this, "onClick");
	},
	
	onClick: function() {
		var pane = dojo.widget.byId(this.targetId);
		if(!pane){ return; }
		pane.explodeSrc = this.domNode;
		pane.toggleShowing();
	}
});
dojo.widget.tags.addParseTreeHandler("dojo:toggler");

__CPAN_FILE__ src/widget/Toolbar.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.ToolbarContainer");
dojo.provide("dojo.widget.html.ToolbarContainer");
dojo.provide("dojo.widget.Toolbar");
dojo.provide("dojo.widget.html.Toolbar");
dojo.provide("dojo.widget.ToolbarItem");
dojo.provide("dojo.widget.html.ToolbarButtonGroup");
dojo.provide("dojo.widget.html.ToolbarButton");
dojo.provide("dojo.widget.html.ToolbarDialog");
dojo.provide("dojo.widget.html.ToolbarMenu");
dojo.provide("dojo.widget.html.ToolbarSeparator");
dojo.provide("dojo.widget.html.ToolbarSpace");
dojo.provide("dojo.widget.Icon");

dojo.require("dojo.widget.*");
dojo.require("dojo.html");

/* ToolbarContainer
 *******************/
dojo.widget.tags.addParseTreeHandler("dojo:toolbarContainer");
dojo.widget.html.ToolbarContainer = function() {
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.html.ToolbarContainer, dojo.widget.HtmlWidget);
dojo.lang.extend(dojo.widget.html.ToolbarContainer, {
	widgetType: "ToolbarContainer",
	isContainer: true,

	templateString: '<div class="toolbarContainer" dojoAttachPoint="containerNode"></div>',
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlToolbar.css"),

	getItem: function(name) {
		if(name instanceof dojo.widget.ToolbarItem) { return name; }
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				var item = child.getItem(name);
				if(item) { return item; }
			}
		}
		return null;
	},

	getItems: function() {
		var items = [];
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				items = items.concat(child.getItems());
			}
		}
		return items;
	},

	enable: function() {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				child.enable.apply(child, arguments);
			}
		}
	},

	disable: function() {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				child.disable.apply(child, arguments);
			}
		}
	},

	select: function(name) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				child.select(arguments);
			}
		}
	},

	deselect: function(name) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				child.deselect(arguments);
			}
		}
	},

	getItemsState: function() {
		var values = {};
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				dojo.lang.mixin(values, child.getItemsState());
			}
		}
		return values;
	},

	getItemsActiveState: function() {
		var values = {};
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				dojo.lang.mixin(values, child.getItemsActiveState());
			}
		}
		return values;
	},

	getItemsSelectedState: function() {
		var values = {};
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.html.Toolbar) {
				dojo.lang.mixin(values, child.getItemsSelectedState());
			}
		}
		return values;
	}
});

/* Toolbar
 **********/
dojo.widget.tags.addParseTreeHandler("dojo:toolbar");
dojo.widget.html.Toolbar = function() {
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.html.Toolbar, dojo.widget.HtmlWidget);
dojo.lang.extend(dojo.widget.html.Toolbar, {
	widgetType: "Toolbar",
	isContainer: true,

	templateString: '<div class="toolbar" dojoAttachPoint="containerNode" unselectable="on" dojoOnMouseover="_onmouseover" dojoOnMouseout="_onmouseout" dojoOnClick="_onclick" dojoOnMousedown="_onmousedown" dojoOnMouseup="_onmouseup"></div>',
	//templateString: '<div class="toolbar" dojoAttachPoint="containerNode" unselectable="on"></div>',

	// given a node, tries to find it's toolbar item
	_getItem: function(node) {
		var start = new Date();
		var widget = null;
		while(node && node != this.domNode) {
			if(dojo.html.hasClass(node, "toolbarItem")) {
				var widgets = dojo.widget.manager.getWidgetsByFilter(function(w) { return w.domNode == node; });
				if(widgets.length == 1) {
					widget = widgets[0];
					break;
				} else if(widgets.length > 1) {
					dojo.raise("Toolbar._getItem: More than one widget matches the node");
				}
			}
			node = node.parentNode;
		}
		return widget;
	},

	_onmouseover: function(e) {
		var widget = this._getItem(e.target);
		if(widget && widget._onmouseover) { widget._onmouseover(e); }
	},

	_onmouseout: function(e) {
		var widget = this._getItem(e.target);
		if(widget && widget._onmouseout) { widget._onmouseout(e); }
	},

	_onclick: function(e) {
		var widget = this._getItem(e.target);
		if(widget && widget._onclick){ 
			widget._onclick(e);
		}
	},

	_onmousedown: function(e) {
		var widget = this._getItem(e.target);
		if(widget && widget._onmousedown) { widget._onmousedown(e); }
	},

	_onmouseup: function(e) {
		var widget = this._getItem(e.target);
		if(widget && widget._onmouseup) { widget._onmouseup(e); }
	},

	addChild: function(item, pos, props) {
		var widget = dojo.widget.ToolbarItem.make(item, null, props);
		var ret = dojo.widget.html.Toolbar.superclass.addChild.call(this, widget, null, pos, null);
		return ret;
	},

	push: function() {
		for(var i = 0; i < arguments.length; i++) {
			this.addChild(arguments[i]);
		}
	},

	getItem: function(name) {
		if(name instanceof dojo.widget.ToolbarItem) { return name; }
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem
				&& child._name == name) { return child; }
		}
		return null;
	},

	getItems: function() {
		var items = [];
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem) {
				items.push(child);
			}
		}
		return items;
	},

	getItemsState: function() {
		var values = {};
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem) {
				values[child._name] = {
					selected: child._selected,
					enabled: child._enabled
				};
			}
		}
		return values;
	},

	getItemsActiveState: function() {
		var values = this.getItemsState();
		for(var item in values) {
			values[item] = values[item].enabled;
		}
		return values;
	},

	getItemsSelectedState: function() {
		var values = this.getItemsState();
		for(var item in values) {
			values[item] = values[item].selected;
		}
		return values;
	},

	enable: function() {
		var items = arguments.length ? arguments : this.children;
		for(var i = 0; i < items.length; i++) {
			var child = this.getItem(items[i]);
			if(child instanceof dojo.widget.ToolbarItem) {
				child.enable(false, true);
			}
		}
	},

	disable: function() {
		var items = arguments.length ? arguments : this.children;
		for(var i = 0; i < items.length; i++) {
			var child = this.getItem(items[i]);
			if(child instanceof dojo.widget.ToolbarItem) {
				child.disable();
			}
		}
	},

	select: function() {
		for(var i = 0; i < arguments.length; i++) {
			var name = arguments[i];
			var item = this.getItem(name);
			if(item) { item.select(); }
		}
	},

	deselect: function() {
		for(var i = 0; i < arguments.length; i++) {
			var name = arguments[i];
			var item = this.getItem(name);
			if(item) { item.disable(); }
		}
	},

	setValue: function() {
		for(var i = 0; i < arguments.length; i += 2) {
			var name = arguments[i], value = arguments[i+1];
			var item = this.getItem(name);
			if(item) {
				if(item instanceof dojo.widget.ToolbarItem) {
					item.setValue(value);
				}
			}
		}
	}
});

/* ToolbarItem hierarchy:
	- ToolbarItem
		- ToolbarButton
		- ToolbarDialog
			- ToolbarMenu
		- ToolbarSeparator
			- ToolbarSpace
				- ToolbarFlexibleSpace
*/


/* ToolbarItem
 **************/
dojo.widget.ToolbarItem = function() {
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.ToolbarItem, dojo.widget.HtmlWidget);
dojo.lang.extend(dojo.widget.ToolbarItem, {
	templateString: '<span unselectable="on" class="toolbarItem"></span>',

	_name: null,
	getName: function() { return this._name; },
	setName: function(value) { return this._name = value; },
	getValue: function() { return this.getName(); },
	setValue: function(value) { return this.setName(value); },

	_selected: false,
	isSelected: function() { return this._selected; },
	setSelected: function(is, force, preventEvent) {
		if(!this._toggleItem && !force) { return; }
		is = Boolean(is);
		if(force || this._enabled && this._selected != is) {
			this._selected = is;
			this.update();
			if(!preventEvent) {
				this._fireEvent(is ? "onSelect" : "onDeselect");
				this._fireEvent("onChangeSelect");
			}
		}
	},
	select: function(force, preventEvent) {
		return this.setSelected(true, force, preventEvent);
	},
	deselect: function(force, preventEvent) {
		return this.setSelected(false, force, preventEvent);
	},

	_toggleItem: false,
	isToggleItem: function() { return this._toggleItem; },
	setToggleItem: function(value) { this._toggleItem = Boolean(value); },

	toggleSelected: function(force) {
		return this.setSelected(!this._selected, force);
	},

	_enabled: true,
	isEnabled: function() { return this._enabled; },
	setEnabled: function(is, force, preventEvent) {
		is = Boolean(is);
		if(force || this._enabled != is) {
			this._enabled = is;
			this.update();
			if(!preventEvent) {
				this._fireEvent(this._enabled ? "onEnable" : "onDisable");
				this._fireEvent("onChangeEnabled");
			}
		}
		return this._enabled;
	},
	enable: function(force, preventEvent) {
		return this.setEnabled(true, force, preventEvent);
	},
	disable: function(force, preventEvent) {
		return this.setEnabled(false, force, preventEvent);
	},
	toggleEnabled: function(force, preventEvent) {
		return this.setEnabled(!this._enabled, force, preventEvent);
	},

	_icon: null,
	getIcon: function() { return this._icon; },
	setIcon: function(value) {
		var icon = dojo.widget.Icon.make(value);
		if(this._icon) {
			this._icon.setIcon(icon);
		} else {
			this._icon = icon;
		}
		var iconNode = this._icon.getNode();
		if(iconNode.parentNode != this.domNode) {
			if(this.domNode.hasChildNodes()) {
				this.domNode.insertBefore(iconNode, this.domNode.firstChild);
			} else {
				this.domNode.appendChild(iconNode);
			}
		}
		return this._icon;
	},

	// TODO: update the label node (this.labelNode?)
	_label: "",
	getLabel: function() { return this._label; },
	setLabel: function(value) {
		var ret = this._label = value;
		if(!this.labelNode) {
			this.labelNode = document.createElement("span");
			this.domNode.appendChild(this.labelNode);
		}
		this.labelNode.innerHTML = "";
		this.labelNode.appendChild(document.createTextNode(this._label));
		this.update();
		return ret;
	},

	// fired from: setSelected, setEnabled, setLabel
	update: function() {
		if(this._enabled) {
			dojo.html.removeClass(this.domNode, "disabled");
			if(this._selected) {
				dojo.html.addClass(this.domNode, "selected");
			} else {
				dojo.html.removeClass(this.domNode, "selected");
			}
		} else {
			this._selected = false;
			dojo.html.addClass(this.domNode, "disabled");
			dojo.html.removeClass(this.domNode, "down");
			dojo.html.removeClass(this.domNode, "hover");
		}
		this._updateIcon();
	},

	_updateIcon: function() {
		if(this._icon) {
			if(this._enabled) {
				if(this._cssHover) {
					this._icon.hover();
				} else if(this._selected) {
					this._icon.select();
				} else {
					this._icon.enable();
				}
			} else {
				this._icon.disable();
			}
		}
	},

	_fireEvent: function(evt) {
		if(typeof this[evt] == "function") {
			var args = [this];
			for(var i = 1; i < arguments.length; i++) {
				args.push(arguments[i]);
			}
			this[evt].apply(this, args);
		}
	},

	_onmouseover: function(e) {
		if(!this._enabled) { return };
		dojo.html.addClass(this.domNode, "hover");
	},

	_onmouseout: function(e) {
		dojo.html.removeClass(this.domNode, "hover");
		dojo.html.removeClass(this.domNode, "down");
		if(!this._selected) {
			dojo.html.removeClass(this.domNode, "selected");
		}
	},

	_onclick: function(e) {
		// FIXME: buttons never seem to have this._enabled set to true on Opera 9
		// dojo.debug("widget:", this.widgetType, ":", this.getName(), ", enabled:", this._enabled);
		if(this._enabled && !this._toggleItem) {
			this._fireEvent("onClick");
		}
	},

	_onmousedown: function(e) {
		if(e.preventDefault) { e.preventDefault(); }
		if(!this._enabled) { return };
		dojo.html.addClass(this.domNode, "down");
		if(this._toggleItem) {
			if(this.parent.preventDeselect && this._selected) {
				return;
			}
			this.toggleSelected();
		}
	},

	_onmouseup: function(e) {
		dojo.html.removeClass(this.domNode, "down");
	},

	fillInTemplate: function(args, frag) {
		if(args.name) { this._name = args.name; }
		if(args.selected) { this.select(); }
		if(args.disabled) { this.disable(); }
		if(args.label) { this.setLabel(args.label); }
		if(args.icon) { this.setIcon(args.icon); }
		if(args.toggleitem||args.toggleItem) { this.setToggleItem(true); }
	}
});

dojo.widget.ToolbarItem.make = function(wh, whIsType, props) {
	var item = null;

	if(wh instanceof Array) {
		item = dojo.widget.createWidget("ToolbarButtonGroup", props);
		item.setName(wh[0]);
		for(var i = 1; i < wh.length; i++) {
			item.addChild(wh[i]);
		}
	} else if(wh instanceof dojo.widget.ToolbarItem) {
		item = wh;
	} else if(wh instanceof dojo.uri.Uri) {
		item = dojo.widget.createWidget("ToolbarButton",
			dojo.lang.mixin(props||{}, {icon: new dojo.widget.Icon(wh.toString())}));
	} else if(whIsType) {
		item = dojo.widget.createWidget(wh, props)
	} else if(typeof wh == "string" || wh instanceof String) {
		switch(wh.charAt(0)) {
			case "|":
			case "-":
			case "/":
				item = dojo.widget.createWidget("ToolbarSeparator", props);
				break;
			case " ":
				if(wh.length == 1) {
					item = dojo.widget.createWidget("ToolbarSpace", props);
				} else {
					item = dojo.widget.createWidget("ToolbarFlexibleSpace", props);
				}
				break;
			default:
				if(/\.(gif|jpg|jpeg|png)$/i.test(wh)) {
					item = dojo.widget.createWidget("ToolbarButton",
						dojo.lang.mixin(props||{}, {icon: new dojo.widget.Icon(wh.toString())}));
				} else {
					item = dojo.widget.createWidget("ToolbarButton",
						dojo.lang.mixin(props||{}, {label: wh.toString()}));
				}
		}
	} else if(wh && wh.tagName && /^img$/i.test(wh.tagName)) {
		item = dojo.widget.createWidget("ToolbarButton",
			dojo.lang.mixin(props||{}, {icon: wh}));
	} else {
		item = dojo.widget.createWidget("ToolbarButton",
			dojo.lang.mixin(props||{}, {label: wh.toString()}));
	}
	return item;
}

/* ToolbarButtonGroup
 *********************/
dojo.widget.tags.addParseTreeHandler("dojo:toolbarButtonGroup");
dojo.widget.html.ToolbarButtonGroup = function() {
	dojo.widget.ToolbarItem.call(this);
}
dojo.inherits(dojo.widget.html.ToolbarButtonGroup, dojo.widget.ToolbarItem);
dojo.lang.extend(dojo.widget.html.ToolbarButtonGroup, {
	widgetType: "ToolbarButtonGroup",
	isContainer: true,

	templateString: '<span unselectable="on" class="toolbarButtonGroup" dojoAttachPoint="containerNode"></span>',

	// if a button has the same name, it will be selected
	// if this is set to a number, the button at that index will be selected
	defaultButton: "",

    postCreate: function() {
        for (var i = 0; i < this.children.length; i++) {
            this._injectChild(this.children[i]);
        }
    },

	addChild: function(item, pos, props) {
		var widget = dojo.widget.ToolbarItem.make(item, null, dojo.lang.mixin(props||{}, {toggleItem:true}));
		var ret = dojo.widget.html.ToolbarButtonGroup.superclass.addChild.call(this, widget, null, pos, null);
        this._injectChild(widget);
        return ret;
    },

    _injectChild: function(widget) {
        dojo.event.connect(widget, "onSelect", this, "onChildSelected");
        dojo.event.connect(widget, "onDeselect", this, "onChildDeSelected");
        if(widget._name == this.defaultButton
			|| (typeof this.defaultButton == "number"
			&& this.children.length-1 == this.defaultButton)) {
			widget.select(false, true);
		}
	},

	getItem: function(name) {
		if(name instanceof dojo.widget.ToolbarItem) { return name; }
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem
				&& child._name == name) { return child; }
		}
		return null;
	},

	getItems: function() {
		var items = [];
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem) {
				items.push(child);
			}
		}
		return items;
	},

	onChildSelected: function(e) {
		this.select(e._name);
	},

	onChildDeSelected: function(e) {
		this._fireEvent("onChangeSelect", this._value);
	},

	enable: function(force, preventEvent) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem) {
				child.enable(force, preventEvent);
				if(child._name == this._value) {
					child.select(force, preventEvent);
				}
			}
		}
	},

	disable: function(force, preventEvent) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem) {
				child.disable(force, preventEvent);
			}
		}
	},

	_value: "",
	getValue: function() { return this._value; },

	select: function(name, force, preventEvent) {
		for(var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if(child instanceof dojo.widget.ToolbarItem) {
				if(child._name == name) {
					child.select(force, preventEvent);
					this._value = name;
				} else {
					child.deselect(true, true);
				}
			}
		}
		if(!preventEvent) {
			this._fireEvent("onSelect", this._value);
			this._fireEvent("onChangeSelect", this._value);
		}
	},
	setValue: this.select,

	preventDeselect: false // if true, once you select one, you can't have none selected
});

/* ToolbarButton
 ***********************/
dojo.widget.tags.addParseTreeHandler("dojo:toolbarButton");
dojo.widget.html.ToolbarButton = function() {
	dojo.widget.ToolbarItem.call(this);
}
dojo.inherits(dojo.widget.html.ToolbarButton, dojo.widget.ToolbarItem);
dojo.lang.extend(dojo.widget.html.ToolbarButton, {
	widgetType: "ToolbarButton",

	fillInTemplate: function(args, frag) {
		dojo.widget.html.ToolbarButton.superclass.fillInTemplate.call(this, args, frag);
		dojo.html.addClass(this.domNode, "toolbarButton");
		if(this._icon) {
			this.setIcon(this._icon);
		}
		if(this._label) {
			this.setLabel(this._label);
		}

		if(!this._name) {
			if(this._label) {
				this.setName(this._label);
			} else if(this._icon) {
				var src = this._icon.getSrc("enabled").match(/[\/^]([^\.\/]+)\.(gif|jpg|jpeg|png)$/i);
				if(src) { this.setName(src[1]); }
			} else {
				this._name = this._widgetId;
			}
		}
	}
});

/* ToolbarDialog
 **********************/
dojo.widget.tags.addParseTreeHandler("dojo:toolbarDialog");
dojo.widget.html.ToolbarDialog = function() {
	dojo.widget.html.ToolbarButton.call(this);
}
dojo.inherits(dojo.widget.html.ToolbarDialog, dojo.widget.html.ToolbarButton);
dojo.lang.extend(dojo.widget.html.ToolbarDialog, {
	widgetType: "ToolbarDialog",
	
	fillInTemplate: function (args, frag) {
		dojo.widget.html.ToolbarDialog.superclass.fillInTemplate.call(this, args, frag);
		dojo.event.connect(this, "onSelect", this, "showDialog");
		dojo.event.connect(this, "onDeselect", this, "hideDialog");
	},
	
	showDialog: function (e) {
		dojo.lang.setTimeout(dojo.event.connect, 1, document, "onmousedown", this, "deselect");
	},
	
	hideDialog: function (e) {
		dojo.event.disconnect(document, "onmousedown", this, "deselect");
	}

});

/* ToolbarMenu
 **********************/
dojo.widget.tags.addParseTreeHandler("dojo:toolbarMenu");
dojo.widget.html.ToolbarMenu = function() {
	dojo.widget.html.ToolbarDialog.call(this);

	this.widgetType = "ToolbarMenu";
}
dojo.inherits(dojo.widget.html.ToolbarMenu, dojo.widget.html.ToolbarDialog);

/* ToolbarMenuItem
 ******************/
dojo.widget.ToolbarMenuItem = function() {
}

/* ToolbarSeparator
 **********************/
dojo.widget.tags.addParseTreeHandler("dojo:toolbarSeparator");
dojo.widget.html.ToolbarSeparator = function() {
    dojo.widget.ToolbarItem.call(this);
}
dojo.inherits(dojo.widget.html.ToolbarSeparator, dojo.widget.ToolbarItem);
dojo.lang.extend(dojo.widget.html.ToolbarSeparator, {
	widgetType: "ToolbarSeparator",
	templateString: '<span unselectable="on" class="toolbarItem toolbarSeparator"></span>',

	defaultIconPath: new dojo.uri.dojoUri("src/widget/templates/buttons/-.gif"),

	fillInTemplate: function(args, frag, skip) {
		dojo.widget.html.ToolbarSeparator.superclass.fillInTemplate.call(this, args, frag);
		this._name = this.widgetId;
		if(!skip) {
			if(!this._icon) {
				this.setIcon(this.defaultIconPath);
			}
			this.domNode.appendChild(this._icon.getNode());
		}
	},

	// don't want events!
	_onmouseover: null, 
    _onmouseout: null, 
    _onclick: null, 
    _onmousedown: null, 
    _onmouseup: null 
});

/* ToolbarSpace
 **********************/
dojo.widget.tags.addParseTreeHandler("dojo:toolbarSpace");
dojo.widget.html.ToolbarSpace = function() {
	dojo.widget.html.ToolbarSeparator.call(this);
}
dojo.inherits(dojo.widget.html.ToolbarSpace, dojo.widget.html.ToolbarSeparator);
dojo.lang.extend(dojo.widget.html.ToolbarSpace, {
    widgetType: "ToolbarSpace",

	fillInTemplate: function(args, frag, skip) {
		dojo.widget.html.ToolbarSpace.superclass.fillInTemplate.call(this, args, frag, true);
		if(!skip) {
			dojo.html.addClass(this.domNode, "toolbarSpace");
		}
	}
});

/* ToolbarSelect
 ******************/ 

dojo.widget.tags.addParseTreeHandler("dojo:toolbarSelect");
dojo.widget.html.ToolbarSelect = function() {
	dojo.widget.ToolbarItem.call(this);
}
dojo.inherits(dojo.widget.html.ToolbarSelect, dojo.widget.ToolbarItem);
dojo.lang.extend(dojo.widget.html.ToolbarSelect, {
    widgetType: "ToolbarSelect",
	templateString: '<span class="toolbarItem toolbarSelect" unselectable="on"><select dojoAttachPoint="selectBox" dojoOnChange="changed"></select></span>',

	fillInTemplate: function(args, frag) {
		dojo.widget.html.ToolbarSelect.superclass.fillInTemplate.call(this, args, frag, true);
		var keys = args.values;
		var i = 0;
		for(var val in keys) {
			var opt = document.createElement("option");
			opt.setAttribute("value", keys[val]);
			opt.innerHTML = val;
			this.selectBox.appendChild(opt);
		}
	},

	changed: function(e) {
		this._fireEvent("onSetValue", this.selectBox.value);
	},

	setEnabled: function(is, force, preventEvent) {
		var ret = dojo.widget.html.ToolbarSelect.superclass.setEnabled.call(this, is, force, preventEvent);
		this.selectBox.disabled = !this._enabled;
		return ret;
	},

	// don't want events!
	_onmouseover: null,
    _onmouseout: null,
    _onclick: null,
    _onmousedown: null,
    _onmouseup: null
});

/* Icon
 *********/
// arguments can be IMG nodes, Image() instances or URLs -- enabled is the only one required
dojo.widget.Icon = function(enabled, disabled, hover, selected) {
	if(arguments.length == 0) {
		throw new Error("Icon must have at least an enabled state");
	}
	var states = ["enabled", "disabled", "hover", "selected"];
	var currentState = "enabled";
	var domNode = document.createElement("img");

	this.getState = function() { return currentState; }
	this.setState = function(value) {
		if(dojo.lang.inArray(value, states)) {
			if(this[value]) {
				currentState = value;
				domNode.setAttribute("src", this[currentState].src);
			}
		} else {
			throw new Error("Invalid state set on Icon (state: " + value + ")");
		}
	}

	this.setSrc = function(state, value) {
		if(/^img$/i.test(value.tagName)) {
			this[state] = value;
		} else if(typeof value == "string" || value instanceof String
			|| value instanceof dojo.uri.Uri) {
			this[state] = new Image();
			this[state].src = value.toString();
		}
		return this[state];
	}

	this.setIcon = function(icon) {
		for(var i = 0; i < states.length; i++) {
			if(icon[states[i]]) {
				this.setSrc(states[i], icon[states[i]]);
			}
		}
		this.update();
	}

	this.enable = function() { this.setState("enabled"); }
	this.disable = function() { this.setState("disabled"); }
	this.hover = function() { this.setState("hover"); }
	this.select = function() { this.setState("selected"); }

	this.getSize = function() {
		return {
			width: domNode.width||domNode.offsetWidth,
			height: domNode.height||domNode.offsetHeight
		};
	}

	this.setSize = function(w, h) {
		domNode.width = w;
		domNode.height = h;
		return { width: w, height: h };
	}

	this.getNode = function() {
		return domNode;
	}

	this.getSrc = function(state) {
		if(state) { return this[state].src; }
		return domNode.src||"";
	}

	this.update = function() {
		this.setState(currentState);
	}

	for(var i = 0; i < states.length; i++) {
		var arg = arguments[i];
		var state = states[i];
		this[state] = null;
		if(!arg) { continue; }
		this.setSrc(state, arg);
	}

	this.enable();
}

dojo.widget.Icon.make = function(a,b,c,d) {
	for(var i = 0; i < arguments.length; i++) {
		if(arguments[i] instanceof dojo.widget.Icon) {
			return arguments[i];
		} else if(!arguments[i]) {
			nullArgs++;
		}
	}

	return new dojo.widget.Icon(a,b,c,d);
}

__CPAN_FILE__ src/widget/Tooltip.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Tooltip");
dojo.require("dojo.widget.Widget");

dojo.widget.tags.addParseTreeHandler("dojo:tooltip");

dojo.widget.Tooltip = function(){
	dojo.widget.Widget.call(this);

	this.widgetType = "Tooltip";
	this.isContainer = true;
}
dojo.inherits(dojo.widget.Tooltip, dojo.widget.Widget);

dojo.requireAfterIf("html", "dojo.widget.html.Tooltip");

__CPAN_FILE__ src/widget/Tree.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/**
 * Tree model does all the drawing, visual node management etc.
 * Throws events about clicks on it, so someone may catch them and process
 * Tree knows nothing about DnD stuff, covered in TreeDragAndDrop and (if enabled) attached by controller
*/

/**
 * TODO: use domNode.cloneNode instead of createElement for grid
 * Should be faster (lyxsus)
 */
dojo.provide("dojo.widget.Tree");

dojo.require("dojo.event.*");
dojo.require("dojo.io.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.TreeNode");



// make it a tag
dojo.widget.tags.addParseTreeHandler("dojo:Tree");


dojo.widget.Tree = function() {
	dojo.widget.HtmlWidget.call(this);

	this.eventNames = {};

	this.tree = this;
	this.DNDAcceptTypes = [];
	this.actionsDisabled = [];

}
dojo.inherits(dojo.widget.Tree, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.Tree, {
	widgetType: "Tree",

	eventNamesDefault: {
		// new child does not get domNode filled in (only template draft)
		// until addChild->createDOMNode is called(program way) OR createDOMNode (html-way)
		// hook events to operate on new DOMNode, create dropTargets etc
		createDOMNode: "createDOMNode",
		// tree created.. Perform tree-wide actions if needed
		treeCreate: "treeCreate",
		treeDestroy: "treeDestroy",
		// expand icon clicked
		treeClick: "treeClick",
		// node icon clicked
		iconClick: "iconClick",
		// node title clicked
		titleClick: "titleClick",

		moveFrom: "moveFrom",
		moveTo: "moveTo",
		addChild: "addChild",
		removeNode: "removeNode",
		expand: "expand",
		collapse: "collapse"
	},

	isContainer: true,

	DNDMode: "off",

	lockLevel: 0, // lock ++ unlock --, so nested locking works fine

	strictFolders: true,

	DNDModes: {
		BETWEEN: 1,
		ONTO: 2
	},

	DNDAcceptTypes: "",

	templateCssPath: dojo.uri.dojoUri("src/widget/templates/images/Tree/Tree.css"),

	templateString: '<div class="dojoTree"></div>',

	isExpanded: true, // consider this "root node" to be always expanded

	isTree: true,

	objectId: "",

	// autoCreate if not "off"
	// used to get the autocreated controller ONLY.
	// generally, tree DOES NOT KNOW about its CONTROLLER, it just doesn't care
	// controller gets messages via dojo.event
	controller: "",

	// autoCreate if not "off"
	// used to get the autocreated selector ONLY.
	// generally, tree DOES NOT KNOW its SELECTOR
	// binding is made with dojo.event
	selector: "",

	// used ONLY at initialization time
	menu: "", // autobind menu if menu's widgetId is set here

	expandLevel: "", // expand to level automatically

	//
	// these icons control the grid and expando buttons for the whole tree
	//

	blankIconSrc: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_blank.gif"),

	gridIconSrcT: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_t.gif"), // for non-last child grid
	gridIconSrcL: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_l.gif"), // for last child grid
	gridIconSrcV: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_v.gif"), // vertical line
	gridIconSrcP: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_p.gif"), // for under parent item child icons
	gridIconSrcC: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_c.gif"), // for under child item child icons
	gridIconSrcX: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_x.gif"), // grid for sole root item
	gridIconSrcY: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_y.gif"), // grid for last rrot item
	gridIconSrcZ: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_z.gif"), // for under root parent item child icon

	expandIconSrcPlus: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_expand_plus.gif"),
	expandIconSrcMinus: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_expand_minus.gif"),
	expandIconSrcLoading: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_loading.gif"),


	iconWidth: 18,
	iconHeight: 18,


	//
	// tree options
	//

	showGrid: true,
	showRootGrid: true,

	actionIsDisabled: function(action) {
		var _this = this;
		return dojo.lang.inArray(_this.actionsDisabled, action)
	},


	actions: {
    	ADDCHILD: "ADDCHILD"
	},


	getInfo: function() {
		var info = {
			widgetId: this.widgetId,
			objectId: this.objectId
		}

		return info;
	},

	initializeController: function() {
		if (this.controller != "off") {
			if (this.controller) {
				this.controller = dojo.widget.byId(this.controller);
			}
			else {
				// create default controller here
				dojo.require("dojo.widget.TreeBasicController");
				this.controller = dojo.widget.createWidget("TreeBasicController",
					{ DNDController: (this.DNDMode ? "create" : ""), dieWithTree: true }
				 );

			}
			this.controller.listenTree(this); // controller listens to my events

		} else {
			this.controller = null;
		}
	},

	initializeSelector: function() {

		if (this.selector != "off") {
			if (this.selector) {
				this.selector = dojo.widget.byId(this.selector);
			}
			else {
				// create default controller here
				dojo.require("dojo.widget.TreeSelector");
				this.selector = dojo.widget.createWidget("TreeSelector", {dieWithTree: true});
			}

			this.selector.listenTree(this);

		} else {
			this.selector = null;
		}
	},

	initialize: function(args, frag){

		var _this = this;

		for(name in this.eventNamesDefault) {
			if (dojo.lang.isUndefined(this.eventNames[name])) {
				this.eventNames[name] = this.widgetId+"/"+this.eventNamesDefault[name];
			}
		}

		for(var i=0; i<this.actionsDisabled.length; i++) {
			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
		}

		if (this.DNDMode == "off") {
			this.DNDMode = 0;
		} else if (this.DNDMode == "between") {
			this.DNDMode = this.DNDModes.ONTO | this.DNDModes.BETWEEN;
		} else if (this.DNDMode == "onto") {
			this.DNDMode = this.DNDModes.ONTO;
		}

		this.expandLevel = parseInt(this.expandLevel);

		this.initializeSelector();
		this.initializeController();

		if (this.menu) {
			this.menu = dojo.widget.byId(this.menu);
			this.menu.listenTree(this);
		}


		this.containerNode = this.domNode;

	},


	postCreate: function() {
		this.createDOMNode();
	},


	createDOMNode: function() {

		dojo.html.disableSelection(this.domNode);

		for(var i=0; i<this.children.length; i++){
			this.children[i].parent = this; // root nodes have tree as parent

			var node = this.children[i].createDOMNode(this, 0);


			this.domNode.appendChild(node);
		}


		if (!this.showRootGrid){
			for(var i=0; i<this.children.length; i++){
				this.children[i].expand();
			}
		}

		dojo.event.topic.publish(this.eventNames.treeCreate, { source: this } );

	},


	destroy: function() {
		dojo.event.topic.publish(this.tree.eventNames.treeDestroy, { source: this } );

		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
	},


	addChild: function(child, index) {

//		dojo.debug("doAddChild "+index+" called for "+child);

		var message = {
			child: child,
			index: index,
			parent: this,
			// remember if dom was already initialized
			// initialized => no createDOMNode => no createDOMNode event
			domNodeInitialized: child.domNodeInitialized
		}

		this.doAddChild.apply(this, arguments);

		dojo.event.topic.publish(this.tree.eventNames.addChild, message);
	},


	// not called for initial tree building. See createDOMNode instead.
	// builds child html node if needed
	// index is "last node" by default
	/**
	 * FIXME: Is it possible that removeNode from the tree will cause leaks cause of attached events ?
	 * if yes, then only attach events in addChild and detach in remove.. Seems all ok yet.
	*/
	doAddChild: function(child, index){

		if (dojo.lang.isUndefined(index)) {
			index = this.children.length;
		}

		if (!child.isTreeNode){
			dojo.raise("You can only add TreeNode widgets to a "+this.widgetType+" widget!");
			return;
		}

		// usually it is impossible to change "isFolder" state, but if anyone wants to add a child to leaf,
		// it is possible program-way.
		if (this.isTreeNode){
			if (!this.isFolder) { // just became a folder.
				//dojo.debug("becoming folder "+this);
				this.setFolder();
			}
		}

		// adjust tree
		var _this = this;
		dojo.lang.forEach(child.getDescendants(), function(elem) { elem.tree = _this.tree; });

		// fix parent
		child.parent = this;


		// no dynamic loading for those who become parents
		if (this.isTreeNode) {
			this.state = this.loadStates.LOADED;
		}

		// add new child into DOM after it was added into children
		if (index < this.children.length) { // children[] already has child
			//dojo.debug("Inserting before "+this.children[index].title);
			dojo.dom.insertBefore(child.domNode, this.children[index].domNode);
		} else {
			this.containerNode.appendChild(child.domNode);
			if (this.isExpanded && this.isTreeNode) {
				/* When I add children to hidden containerNode => show container w/ them */
				this.showChildren();
			}
		}


		this.children.splice(index, 0, child);

		//dojo.debugShallow(this.children);


		// if node exists - adjust its depth, otherwise build it
		if (child.domNodeInitialized) {
			var d = this.isTreeNode ? this.depth : -1;
			child.adjustDepth( d - child.depth + 1 );


			// update icons to link generated dom with Tree => updateParentGrid
			// if I moved child from LastNode inside the tree => need to link it up'n'down =>
			// updateExpandGridColumn
			// if I change depth => need to update all grid..
			child.updateIconTree();
		} else {
			//dojo.debug("Create domnode ");
			child.depth = this.isTreeNode ? this.depth+1 : 0;
			child.createDOMNode(child.tree, child.depth);
		}



		// Use-case:
		// When previous sibling was created => it was last, no children after it
		// so it did not create link down => let's add it for all descendants
		// Use-case:
		// a child was moved down under the last node so last node should be updated
		var prevSibling = child.getPreviousSibling();
		if (child.isLastNode() && prevSibling) {
			prevSibling.updateExpandGridColumn();
		}


		//dojo.debug("Added child "+child);



	},




	makeBlankImg: function() {
		var img = document.createElement('img');

		img.style.width = this.iconWidth + 'px';
		img.style.height = this.iconHeight + 'px';
		img.src = this.blankIconSrc;
		img.style.verticalAlign = 'middle';

		return img;
	},


	updateIconTree: function(){

		//dojo.debug("Update icons for "+this)
		if (!this.isTree) {
			this.updateIcons();
		}

		for(var i=0; i<this.children.length; i++){
			this.children[i].updateIconTree();
		}

	},

	toString: function() {
		return "["+this.widgetType+" ID:"+this.widgetId+"]"
	},




	/**
	 * Move child to newParent as last child
	 * redraw tree and update icons.
	 *
	 * Called by target, saves source in event.
	 * events are published for BOTH trees AFTER update.
	*/
	move: function(child, newParent, index) {

		//dojo.debug(child+" "+newParent+" at "+index);

		var oldParent = child.parent;
		var oldTree = child.tree;

		this.doMove.apply(this, arguments);

		var newParent = child.parent;
		var newTree = child.tree;

		var message = {
				oldParent: oldParent, oldTree: oldTree,
				newParent: newParent, newTree: newTree,
				child: child
		};

		/* publish events here about structural changes for both source and target trees */
		dojo.event.topic.publish(oldTree.eventNames.moveFrom, message);
		dojo.event.topic.publish(newTree.eventNames.moveTo, message);

	},


	/* do actual parent change here. Write remove child first */
	doMove: function(child, newParent, index) {
		//var parent = child.parent;
		child.parent.doRemoveNode(child);

		newParent.doAddChild(child, index);
	},



// ================================ removeNode ===================================

	removeNode: function(child) {
		if (!child.parent) return;

		var oldTree = child.tree;
		var oldParent = child.parent;

		var removedChild = this.doRemoveNode.apply(this, arguments);


		dojo.event.topic.publish(this.tree.eventNames.removeNode,
			{ child: removedChild, tree: oldTree, parent: oldParent }
		);

		return removedChild;
	},


	doRemoveNode: function(child) {
		if (!child.parent) return;

		var parent = child.parent;

		var children = parent.children;


		var index = child.getParentIndex();
		if (index < 0) {
			dojo.raise("Couldn't find node "+child+" for removal");
		}


		children.splice(index,1);
		dojo.dom.removeNode(child.domNode);

		if (parent.children.length == 0) {
			parent.containerNode.style.display = "none";
		}

		// if WAS last node (children.length decreased already) and has prevSibling
		if (index == children.length && index>0) {
			children[index-1].updateExpandGridColumn();
		}
		// if it WAS first node in WHOLE TREE -
		// update link up of its former lower neighbour(if exists still)
		if (parent instanceof dojo.widget.Tree && index == 0 && children.length>0) {
			children[0].updateExpandGrid();
		}

		//parent.updateIconTree();


		child.parent = child.tree = null;

		return child;
	},

	markLoading: function() {
		// no way to mark tree loading
	},

	unMarkLoading: function() {
		// no way to show that tree finished loading
	},


	lock: function() {
		!this.lockLevel && this.markLoading();
		this.lockLevel++;
	},
	unlock: function() {
		if (!this.lockLevel) {
			dojo.raise("unlock: not locked");
		}
		this.lockLevel--;
		!this.lockLevel && this.unMarkLoading();
	},

	isLocked: function() {
		var node = this;
		while (true) {
			if (node.lockLevel) {
				return true;
			}
			if (node instanceof dojo.widget.Tree) {
				break;
			}
			node = node.parent;
		}

		return false;
	},

	flushLock: function() {
		this.lockLevel = 0;
		this.unMarkLoading();
	}
});



__CPAN_FILE__ src/widget/TreeBasicController.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/


dojo.provide("dojo.widget.TreeBasicController");

dojo.require("dojo.event.*");
dojo.require("dojo.json")
dojo.require("dojo.io.*");


dojo.widget.tags.addParseTreeHandler("dojo:TreeBasicController");


dojo.widget.TreeBasicController = function() {
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.TreeBasicController, dojo.widget.HtmlWidget);


dojo.lang.extend(dojo.widget.TreeBasicController, {
	widgetType: "TreeBasicController",

	DNDController: "",

	dieWithTree: false,

	initialize: function(args, frag){

		/* no DND by default for compatibility */
		if (this.DNDController == "create") {
			dojo.require("dojo.dnd.TreeDragAndDrop");
			this.DNDController = new dojo.dnd.TreeDNDController(this);
		}



	},


	/**
	 * Binds controller to all tree events
	*/
	listenTree: function(tree) {
		//dojo.debug("Event "+tree.eventNames.treeClick);
		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
		dojo.event.topic.subscribe(tree.eventNames.treeClick, this, "onTreeClick");
		dojo.event.topic.subscribe(tree.eventNames.treeCreate, this, "onTreeCreate");
		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");

		if (this.DNDController) {
			this.DNDController.listenTree(tree);
		}
	},

	unlistenTree: function(tree) {
		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
		dojo.event.topic.unsubscribe(tree.eventNames.treeClick, this, "onTreeClick");
		dojo.event.topic.unsubscribe(tree.eventNames.treeCreate, this, "onTreeCreate");
		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
	},

	onTreeDestroy: function(message) {
		var tree = message.source;

		this.unlistenTree(tree);

		if (this.dieWithTree) {
			//alert("Killing myself "+this.widgetId);
			this.destroy();
			//dojo.debug("done");
		}
	},

	onCreateDOMNode: function(message) {

		var node = message.source;


		if (node.expandLevel > 0) {
			this.expandToLevel(node, node.expandLevel);
		}
	},

	// perform actions-initializers for tree
	onTreeCreate: function(message) {
		var tree = message.source;
		var _this = this;
		if (tree.expandLevel) {
			dojo.lang.forEach(tree.children,
				function(child) {
					_this.expandToLevel(child, tree.expandLevel-1)
				}
			);
		}
	},

	expandToLevel: function(node, level) {
		if (level == 0) return;

		var children = node.children;
		var _this = this;

		var handler = function(node, expandLevel) {
			this.node = node;
			this.expandLevel = expandLevel;
			// recursively expand opened node
			this.process = function() {
				//dojo.debug("Process "+node+" level "+level);
				for(var i=0; i<this.node.children.length; i++) {
					var child = node.children[i];

					_this.expandToLevel(child, this.expandLevel);
				}
			};
		}

		var h = new handler(node, level-1);


		this.expand(node, false, h, h.process);

	},




	onTreeClick: function(message){
		var node = message.source;

		if(node.isLocked()) {
			return false;
		}

		if (node.isExpanded){
			this.collapse(node);
		} else {
			this.expand(node);
		}
	},

	expand: function(node, sync, callObj, callFunc) {
		node.expand();
		if (callFunc) callFunc.apply(callObj, [node]);
	},

	collapse: function(node) {

		node.collapse();
	},

// =============================== move ============================

	/**
	 * Checks whether it is ok to change parent of child to newParent
	 * May incur type checks etc
	 *
	 * It should check only hierarchical possibility w/o index, etc
	 * because in onDragOver event for Between DND mode we can't calculate index at once on onDragOVer.
	 * index changes as client moves mouse up-down over the node
	 */
	canMove: function(child, newParent){

		if (child.actionIsDisabled(child.actions.MOVE)) {
			return false;
		}

		// if we move under same parent then no matter if ADDCHILD disabled for him
		// but if we move to NEW parent then check if action is disabled for him
		// also covers case for newParent being a non-folder in strict mode etc
		if (child.parent !== newParent && newParent.actionIsDisabled(newParent.actions.ADDCHILD)) {
			return false;
		}

		// Can't move parent under child. check whether new parent is child of "child".
		var node = newParent;
		while(node.isTreeNode) {
			//dojo.debugShallow(node.title)
			if (node === child) {
				// parent of newParent is child
				return false;
			}
			node = node.parent;
		}

		return true;
	},


	move: function(child, newParent, index) {

		/* move sourceTreeNode to new parent */
		if (!this.canMove(child, newParent)) {
			return false;
		}

		var result = this.doMove(child, newParent, index);

		if (!result) return result;

		if (newParent.isTreeNode) {
			this.expand(newParent);
		}

		return result;
	},

	doMove: function(child, newParent, index) {
		child.tree.move(child, newParent, index);

		return true;
	},

// =============================== removeNode ============================


	canRemoveNode: function(child) {
		if (child.actionIsDisabled(child.actions.REMOVE)) {
			return false;
		}

		return true;
	},


	removeNode: function(node, callObj, callFunc) {
		if (!this.canRemoveNode(node)) {
			return false;
		}

		return this.doRemoveNode(node, callObj, callFunc);
	},


	doRemoveNode: function(node, callObj, callFunc) {
		node.tree.removeNode(node);

		if (callFunc) {
			callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node]);
		}
	},


	// -----------------------------------------------------------------------------
	//                             Create node stuff
	// -----------------------------------------------------------------------------


	canCreateChild: function(parent, index, data) {
		if (parent.actionIsDisabled(parent.actions.ADDCHILD)) return false;

		return true;
	},


	/* send data to server and add child from server */
	/* data may contain an almost ready child, or anything else, suggested to server */
	/*in RPC controllers server responds with child data to be inserted */
	createChild: function(parent, index, data, callObj, callFunc) {
		if (!this.canCreateChild(parent, index, data)) {
			return false;
		}

		return this.doCreateChild.apply(this, arguments);
	},

	doCreateChild: function(parent, index, data, callObj, callFunc) {

		var widgetType = data.widgetType ? data.widgetType : "TreeNode";

		var newChild = dojo.widget.createWidget(widgetType, data);

		parent.addChild(newChild, index);

		this.expand(parent);

		if (callFunc) {
			callFunc.apply(callObj, [newChild]);
		}

		return newChild;
	}



});

__CPAN_FILE__ src/widget/TreeContextMenu.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/



dojo.provide("dojo.widget.TreeContextMenu");
dojo.provide("dojo.widget.TreeMenuItem");

dojo.require("dojo.event.*");
dojo.require("dojo.io.*");
dojo.require("dojo.widget.Menu2");


dojo.widget.tags.addParseTreeHandler("dojo:TreeContextMenu");
dojo.widget.tags.addParseTreeHandler("dojo:TreeMenuItem");



dojo.widget.TreeContextMenu = function() {
	dojo.widget.PopupMenu2.call(this);

	this.listenedTrees = [];

}


dojo.inherits(dojo.widget.TreeContextMenu, dojo.widget.PopupMenu2);

dojo.lang.extend(dojo.widget.TreeContextMenu, {

	widgetType: "TreeContextMenu",

	open: function(x, y, parentMenu, explodeSrc){

		var result = dojo.widget.PopupMenu2.prototype.open.apply(this, arguments);

		/* publish many events here about structural changes */
		dojo.event.topic.publish(this.eventNames.open, { menu:this });

		return result;
	},

	listenTree: function(tree) {
		/* add context menu to all nodes that exist already */
		var nodes = tree.getDescendants();

		for(var i=0; i<nodes.length; i++) {
			if (!nodes[i].isTreeNode) continue;
			this.bindDomNode(nodes[i].labelNode);
		}


		/* bind context menu to all nodes that will be created in the future (e.g loaded from server)*/
		var _this = this;
		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
		dojo.event.topic.subscribe(tree.eventNames.moveTo, this, "onMoveTo");
		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
		dojo.event.topic.subscribe(tree.eventNames.addChild, this, "onAddChild");
		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");

		this.listenedTrees.push(tree);

	},

	unlistenTree: function(tree) {
		/* clear event listeners */

		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
		dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, "onMoveTo");
		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
		dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, "onAddChild");
		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");

		for(var i=0; i<this.listenedTrees.length; i++){
           if(this.listenedTrees[i] === tree){
                   this.listenedTrees.splice(i, 1);
                   break;
           }
		}
	},

	onTreeDestroy: function(message) {
		this.unlistenTree(message.source);
	},

	bindTreeNode: function(node) {
		var _this = this;
		//dojo.debug("bind to "+node);
		dojo.lang.forEach(node.getDescendants(),
			function(e) {_this.bindDomNode(e.labelNode); }
		);
	},


	unBindTreeNode: function(node) {
		var _this = this;
		//dojo.debug("Unbind from "+node);
		dojo.lang.forEach(node.getDescendants(),
			function(e) {_this.unBindDomNode(e.labelNode); }
		);
	},

	onCreateDOMNode: function(message) {
		this.bindTreeNode(message.source);
	},


	onMoveFrom: function(message) {
		if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
			this.unBindTreeNode(message.child);
		}
	},

	onMoveTo: function(message) {
		if (dojo.lang.inArray(this.listenedTrees, message.newTree)) {
			this.bindTreeNode(message.child);
		}
	},

	onRemoveNode: function(message) {
		this.unBindTreeNode(message.child);
	},

	onAddChild: function(message) {
		if (message.domNodeInitialized) {
			// dom node was there already => I did not process onNodeDomCreate
			this.bindTreeNode(message.child);
		}
	}


});






dojo.widget.TreeMenuItem = function() {
	dojo.widget.MenuItem2.call(this);

}


dojo.inherits(dojo.widget.TreeMenuItem, dojo.widget.MenuItem2);


dojo.lang.extend(dojo.widget.TreeMenuItem, {

	widgetType: "TreeMenuItem",

	// treeActions menu item performs following actions (to be checked for permissions)
	treeActions: "",

	initialize: function(args, frag) {

		this.treeActions = this.treeActions.split(",");
		for(var i=0; i<this.treeActions.length; i++) {
			this.treeActions[i] = this.treeActions[i].toUpperCase();
		}

	},

	getTreeNode: function() {
		var menu = this;

		while (! (menu instanceof dojo.widget.TreeContextMenu) ) {
			menu = menu.parent;
		}

		var source = menu.getTopOpenEvent().target;

		while (!source.getAttribute('treeNode') && source.tagName != 'body') {
			source = source.parentNode;
		}
		if (source.tagName == 'body') {
			dojo.raise("treeNode not detected");
		}
		var treeNode = dojo.widget.manager.getWidgetById(source.getAttribute('treeNode'));

		return treeNode;
	},


	menuOpen: function(message) {
		var treeNode = this.getTreeNode();

		this.setDisabled(false); // enable by default

		var _this = this;
		dojo.lang.forEach(_this.treeActions,
			function(action) {
				_this.setDisabled( treeNode.actionIsDisabled(action) );
			}
		);

	},

	toString: function() {
		return "["+this.widgetType+" node "+this.getTreeNode()+"]";
	}

});



__CPAN_FILE__ src/widget/TreeControllerExtension.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/**
 * Additional tree utils
 *
 */
dojo.provide("dojo.widget.TreeControllerExtension");


dojo.widget.TreeControllerExtension = function() { }

dojo.lang.extend(dojo.widget.TreeControllerExtension, {

	saveExpandedIndices: function(node, field) {
		var obj = {};

		for(var i=0; i<node.children.length; i++) {
			if (node.children[i].isExpanded) {
				var key = dojo.lang.isUndefined(field) ? i : node.children[i][field];
				obj[key] = this.saveExpandedIndices(node.children[i], field);
			}
		}

		return obj;
	},


	restoreExpandedIndices: function(node, savedIndices, field) {
		var _this = this;

		var handler = function(node, savedIndices) {
			this.node = node; //.children[i];
			this.savedIndices = savedIndices; //[i];
			// recursively read next savedIndices level and apply to opened node
			this.process = function() {
				//dojo.debug("Callback applied for "+this.node);
				_this.restoreExpandedIndices(this.node, this.savedIndices, field);
			};
		}


		for(var i=0; i<node.children.length; i++) {
			var child = node.children[i];

			var found = false;
			var key = -1;

			//dojo.debug("Check "+child)
			// process field set case
			if (dojo.lang.isUndefined(field) && savedIndices[i]) {
				found = true;
				key = i;
			}

			// process case when field is not set
			if (field) {
				for(var key in savedIndices) {
					//dojo.debug("Compare "+key+" "+child[field])
					if (key == child[field]) {
						found = true;
						break;
					}
				}
			}

			// if we found anything - expand it
			if (found) {
				//dojo.debug("Found at "+key)
				var h = new handler(child, savedIndices[key]);
				_this.expand(child, false, h, h.process);
			} else if (child.isExpanded) { // not found, so collapse
				//dojo.debug("Collapsing all descendants "+node.children[i])
				dojo.lang.forEach(child.getDescendants(), function(elem) { _this.collapse(elem); });
				//this.collapse(node.children[i]);
			}

		}


	}

});






__CPAN_FILE__ src/widget/TreeLoadingController.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/


dojo.provide("dojo.widget.TreeLoadingController");

dojo.require("dojo.widget.TreeBasicController");
dojo.require("dojo.event.*");
dojo.require("dojo.json")
dojo.require("dojo.io.*");


dojo.widget.tags.addParseTreeHandler("dojo:TreeLoadingController");


dojo.widget.TreeLoadingController = function() {
	dojo.widget.TreeBasicController.call(this);
}

dojo.inherits(dojo.widget.TreeLoadingController, dojo.widget.TreeBasicController);


dojo.lang.extend(dojo.widget.TreeLoadingController, {
	widgetType: "TreeLoadingController",

	RPCUrl: "",

	RPCActionParam: "action", // used for GET for RPCUrl


	/**
	 * Common RPC error handler (dies)
	*/
	RPCErrorHandler: function(type, obj, evt) {
		alert( "RPC Error: " + (obj.message||"no message"));
	},



	getRPCUrl: function(action) {

		// RPCUrl=local meant SOLELY for DEMO and LOCAL TESTS.
		// May lead to widgetId collisions
		if (this.RPCUrl == "local") {
			var dir = document.location.href.substr(0, document.location.href.lastIndexOf('/'));
			var localUrl = dir+"/"+action;
			//dojo.debug(localUrl);
			return localUrl;
		}

		if (!this.RPCUrl) {
			dojo.raise("Empty RPCUrl: can't load");
		}

		return this.RPCUrl + ( this.RPCUrl.indexOf("?") > -1 ? "&" : "?") + this.RPCActionParam+"="+action;
	},


	/**
	 * Add all loaded nodes from array obj as node children and expand it
	*/
	loadProcessResponse: function(node, result, callObj, callFunc) {

		if (!dojo.lang.isUndefined(result.error)) {
			this.RPCErrorHandler("server", result.error);
			return false;
		}

		//dojo.debugShallow(result);

		var newChildren = result;

		if (!dojo.lang.isArray(newChildren)) {
			dojo.raise('loadProcessResponse: Not array loaded: '+newChildren);
		}

		for(var i=0; i<newChildren.length; i++) {
			// looks like dojo.widget.manager needs no special "add" command
			newChildren[i] = dojo.widget.createWidget(node.widgetType, newChildren[i]);
			node.addChild(newChildren[i]);
		}


		//node.addAllChildren(newChildren);

		node.state = node.loadStates.LOADED;

		//dojo.debug(callFunc);

		if (dojo.lang.isFunction(callFunc)) {
			callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node, newChildren]);
		}
		//this.expand(node);
	},

	getInfo: function(obj) {
		return obj.getInfo();
	},

	runRPC: function(kw) {
		var _this = this;

		var handle = function(type, data, evt) {
			// unlock BEFORE any processing is done
			// so errorHandler may apply locking
			if (kw.lock) {
				dojo.lang.forEach(kw.lock,
					function(t) { t.unlock() }
				);
			}

			if(type == "load"){
				kw.load.call(this, data);
			}else{
				this.RPCErrorHandler(type, data, evt);
			}

		}

		if (kw.lock) {
			dojo.lang.forEach(kw.lock,
				function(t) { t.lock() }
			);
		}


		dojo.io.bind({
			url: kw.url,
			/* I hitch to get this.loadOkHandler */
			handle: dojo.lang.hitch(this, handle),
			mimetype: "text/json",
			preventCache: true,
			sync: kw.sync,
			content: { data: dojo.json.serialize(kw.params) }
		});
	},



	/**
	 * Load children of the node from server
	 * Synchroneous loading doesn't break control flow
	 * I need sync mode for DnD
	*/
	loadRemote: function(node, sync, callObj, callFunc){
		var _this = this;

		var params = {
			node: this.getInfo(node),
			tree: this.getInfo(node.tree)
		};

		//dojo.debug(callFunc)

		this.runRPC({
			url: this.getRPCUrl('getChildren'),
			load: function(result) {
				_this.loadProcessResponse(node, result, callObj, callFunc) ;
			},
			sync: sync,
			lock: [node],
			params: params
		});

	},


	expand: function(node, sync, callObj, callFunc) {

		if (node.state == node.loadStates.UNCHECKED && node.isFolder) {

			this.loadRemote(node, sync,
				this,
				function(node, newChildren) {
					this.expand(node, sync, callObj, callFunc);
				}
			);

			return;
		}

		dojo.widget.TreeBasicController.prototype.expand.apply(this, arguments);

	},



	doMove: function(child, newParent, index) {
		/* load nodes into newParent in sync mode, if needed, first */
		if (newParent.isTreeNode && newParent.state == newParent.loadStates.UNCHECKED) {
			this.loadRemote(newParent, true);
		}

		return dojo.widget.TreeBasicController.prototype.doMove.apply(this, arguments);
	},


	doCreateChild: function(parent, index, data, callObj, callFunc) {

		/* load nodes into newParent in sync mode, if needed, first */
		if (parent.state == parent.loadStates.UNCHECKED) {
			this.loadRemote(parent, true);
		}

		return dojo.widget.TreeBasicController.prototype.doCreateChild.apply(this, arguments);
	}



});

__CPAN_FILE__ src/widget/TreeNode.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/


dojo.provide("dojo.widget.TreeNode");

dojo.require("dojo.event.*");
dojo.require("dojo.io.*");

// make it a tag
dojo.widget.tags.addParseTreeHandler("dojo:TreeNode");


// # //////////

dojo.widget.TreeNode = function() {
	dojo.widget.HtmlWidget.call(this);

	this.actionsDisabled = [];
}

dojo.inherits(dojo.widget.TreeNode, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.TreeNode, {
	widgetType: "TreeNode",

	loadStates: {
		UNCHECKED: "UNCHECKED",
    	LOADING: "LOADING",
    	LOADED: "LOADED"
	},


	actions: {
		MOVE: "MOVE",
    	REMOVE: "REMOVE",
    	EDIT: "EDIT",
    	ADDCHILD: "ADDCHILD"
	},

	isContainer: true,

	lockLevel: 0, // lock ++ unlock --, so nested locking works fine


	templateString: ('<div class="dojoTreeNode"> '
		+ '<span treeNode="${this.widgetId}" class="dojoTreeNodeLabel" dojoAttachPoint="labelNode"> '
		+ '		<span dojoAttachPoint="titleNode" dojoAttachEvent="onClick: onTitleClick" class="dojoTreeNodeLabelTitle">${this.title}</span> '
		+ '</span> '
		+ '<span class="dojoTreeNodeAfterLabel" dojoAttachPoint="afterLabelNode">${this.afterLabel}</span> '
		+ '<div dojoAttachPoint="containerNode" style="display:none"></div> '
		+ '</div>').replace(/(>|<)\s+/g, '$1'), // strip whitespaces between nodes


	childIconSrc: "",
	childIconFolderSrc: dojo.uri.dojoUri("src/widget/templates/images/Tree/closed.gif"), // for under root parent item child icon,
	childIconDocumentSrc: dojo.uri.dojoUri("src/widget/templates/images/Tree/document.gif"), // for under root parent item child icon,

	childIcon: null,
	isTreeNode: true,

	objectId: "", // the widget represents an object

	afterLabel: "",
	afterLabelNode: null, // node to the left of labelNode

	// an icon left from childIcon: imgs[-2].
	// if +/- for folders, blank for leaves
	expandIcon: null,

	title: "",
	object: "", // node may have object attached, settable from HTML
	isFolder: false,

	labelNode: null, // the item label
	titleNode: null, // the item title
	imgs: null, // an array of icons imgs

	expandLevel: "", // expand to level

	tree: null,

	depth: 0,

	isExpanded: false,

	state: null,  // after creation will change to loadStates: "loaded/loading/unchecked"
	domNodeInitialized: false,  // domnode is initialized with icons etc


	isFirstNode: function() {
		return this.getParentIndex() == 0 ? true: false;
	},

	isLastNode: function() {
		return this.getParentIndex() == this.parent.children.length-1 ? true : false;
	},

	lock: function(){ return this.tree.lock.apply(this, arguments) },
	unlock: function(){ return this.tree.unlock.apply(this, arguments) },
	isLocked: function(){ return this.tree.isLocked.apply(this, arguments) },
	cleanLock: function(){ return this.tree.cleanLock.apply(this, arguments) },

	actionIsDisabled: function(action) {
		var _this = this;

		var disabled = false;

		if (this.tree.strictFolders && action == this.actions.ADDCHILD && !this.isFolder) {
			disabled = true;
		}

		if (dojo.lang.inArray(_this.actionsDisabled, action)) {
			disabled = true;
		}

		if (this.isLocked()) {
			disabled = true;
		}

		return disabled;
	},

	getInfo: function() {
		// No title here (title may be widget)
		var info = {
			widgetId: this.widgetId,
			objectId: this.objectId,
			index: this.getParentIndex(),
			isFolder: this.isFolder
		}

		return info;
	},

	initialize: function(args, frag){

		//dojo.debug(this.title)

		this.state = this.loadStates.UNCHECKED;

		for(var i=0; i<this.actionsDisabled.length; i++) {
			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
		}

		this.expandLevel = parseInt(this.expandLevel);

	},


	/**
	 * Change visible node depth by appending/prepending with blankImgs
	 * @param depthDiff Integer positive => move right, negative => move left
	*/
	adjustDepth: function(depthDiff) {

		for(var i=0; i<this.children.length; i++) {
			this.children[i].adjustDepth(depthDiff);
		}

		this.depth += depthDiff;

		if (depthDiff>0) {
			for(var i=0; i<depthDiff; i++) {
				var img = this.tree.makeBlankImg();
				this.imgs.unshift(img);
				//dojo.debugShallow(this.domNode);
				dojo.dom.insertBefore(this.imgs[0], this.domNode.firstChild);

			}
		}
		if (depthDiff<0) {
			for(var i=0; i<-depthDiff;i++) {
				this.imgs.shift();
				dojo.dom.removeNode(this.domNode.firstChild);
			}
		}

	},


	markLoading: function() {
		this._markLoadingSavedIcon = this.expandIcon.src;
		this.expandIcon.src = this.tree.expandIconSrcLoading;
	},

	// if icon is "Loading" then
	unMarkLoading: function() {
		if (!this._markLoadingSavedIcon) return;

		var im = new Image();
		im.src = this.tree.expandIconSrcLoading;

		//dojo.debug("Unmark "+this.expandIcon.src+" : "+im.src);
		if (this.expandIcon.src == im.src) {
			this.expandIcon.src = this._markLoadingSavedIcon;
		}
		this._markLoadingSavedIcon = null;
	},


	setFolder: function() {
		dojo.event.connect(this.expandIcon, 'onclick', this, 'onTreeClick');
		this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
		this.isFolder = true;
	},


	createDOMNode: function(tree, depth){

		this.tree = tree;
		this.depth = depth;


		//
		// add the tree icons
		//

		this.imgs = [];

		for(var i=0; i<this.depth+1; i++){

			var img = this.tree.makeBlankImg();

			this.domNode.insertBefore(img, this.labelNode);

			this.imgs.push(img);
		}


		this.expandIcon = this.imgs[this.imgs.length-1];


		this.childIcon = this.tree.makeBlankImg();

		// add to images before the title
		this.imgs.push(this.childIcon);

		dojo.dom.insertBefore(this.childIcon, this.titleNode);

		// node with children(from source html) becomes folder on build stage.
		if (this.children.length || this.isFolder) {
			this.setFolder();
		}
		else {
			// leaves are always loaded
			//dojo.debug("Set "+this+" state to loaded");
			this.state = this.loadStates.LOADED;
		}

		dojo.event.connect(this.childIcon, 'onclick', this, 'onIconClick');


		//
		// create the child rows
		//


		for(var i=0; i<this.children.length; i++){
			this.children[i].parent = this;

			var node = this.children[i].createDOMNode(this.tree, this.depth+1);

			this.containerNode.appendChild(node);
		}


		if (this.children.length) {
			this.state = this.loadStates.LOADED;
		}

		this.updateIcons();

		this.domNodeInitialized = true;

		dojo.event.topic.publish(this.tree.eventNames.createDOMNode, { source: this } );

		return this.domNode;
	},

	onTreeClick: function(e){
		dojo.event.topic.publish(this.tree.eventNames.treeClick, { source: this, event: e });
	},

	onIconClick: function(e){
		dojo.event.topic.publish(this.tree.eventNames.iconClick, { source: this, event: e });
	},

	onTitleClick: function(e){
		dojo.event.topic.publish(this.tree.eventNames.titleClick, { source: this, event: e });
	},

	markSelected: function() {
		dojo.html.addClass(this.titleNode, 'dojoTreeNodeLabelSelected');
	},


	unMarkSelected: function() {
		//dojo.debug('unmark')
		dojo.html.removeClass(this.titleNode, 'dojoTreeNodeLabelSelected');
	},

	updateExpandIcon: function() {
		if (this.isFolder){
			this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
		} else {
			this.expandIcon.src = this.tree.blankIconSrc;
		}
	},

	/* set the grid under the expand icon */
	updateExpandGrid: function() {

		if (this.tree.showGrid){
			if (this.depth){
				this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
			}else{
				if (this.isFirstNode()){
					this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcX : this.tree.gridIconSrcY);
				}else{
					this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
				}
			}
		}else{
			this.setGridImage(-2, this.tree.blankIconSrc);
		}

	},

	/* set the grid under the child icon */
	updateChildGrid: function() {

		if ((this.depth || this.tree.showRootGrid) && this.tree.showGrid){
			this.setGridImage(-1, (this.children.length && this.isExpanded) ? this.tree.gridIconSrcP : this.tree.gridIconSrcC);
		}else{
			if (this.tree.showGrid && !this.tree.showRootGrid){
				this.setGridImage(-1, (this.children.length && this.isExpanded) ? this.tree.gridIconSrcZ : this.tree.blankIconSrc);
			}else{
				this.setGridImage(-1, this.tree.blankIconSrc);
			}
		}


	},

	updateParentGrid: function() {
		var parent = this.parent;

		//dojo.debug("updateParentGrid "+this);

		for(var i=0; i<this.depth; i++){

			//dojo.debug("Parent "+parent);

			var idx = this.imgs.length-(3+i);
			var img = (this.tree.showGrid && !parent.isLastNode()) ? this.tree.gridIconSrcV : this.tree.blankIconSrc;

			//dojo.debug("Image "+img+" for "+idx);

			this.setGridImage(idx, img);

			parent = parent.parent;
		}
	},

	updateExpandGridColumn: function() {
		if (!this.tree.showGrid) return;

		var _this = this;

		var icon = this.isLastNode() ? this.tree.blankIconSrc : this.tree.gridIconSrcV;

		dojo.lang.forEach(_this.getDescendants(),
			function(node) { node.setGridImage(_this.depth, icon); }
		);

		this.updateExpandGrid();
	},

	updateIcons: function(){


		//dojo.profile.start("updateIcons")

		//dojo.debug("Update icons for "+this)
		//dojo.debug(this.isFolder)

		this.imgs[0].style.display = this.tree.showRootGrid ? 'inline' : 'none';


		//
		// set the expand icon
		//


		//
		// set the child icon
		//
		this.buildChildIcon();

		this.updateExpandGrid();
		this.updateChildGrid();
		this.updateParentGrid();



		dojo.profile.stop("updateIcons")

	},

	buildChildIcon: function() {
		// IE (others?) tries to download whatever is on src attribute so setting "url()" like before isnt a good idea
		// Only results in a 404
		if(this.childIconSrc){
			this.childIcon.src = this.childIconSrc;
		}
		this.childIcon.style.display = this.childIconSrc ? 'inline' : 'none';
	},

	setGridImage: function(idx, src){

		if (idx < 0){
			idx = this.imgs.length + idx;
		}

		//if (idx >= this.imgs.length-2) return;
		this.imgs[idx].style.backgroundImage = 'url(' + src + ')';
	},


	updateIconTree: function(){
		this.tree.updateIconTree.call(this);
	},




	expand: function(){
		if (this.isExpanded) return;

		if (this.children.length) {
			this.showChildren();
		}

		this.isExpanded = true;

		this.updateExpandIcon();

		dojo.event.topic.publish(this.tree.eventNames.expand, {source: this} );
	},

	collapse: function(){
		if (!this.isExpanded) return;

		this.hideChildren();
		this.isExpanded = false;

		this.updateExpandIcon();

		dojo.event.topic.publish(this.tree.eventNames.collapse, {source: this} );
	},

	hideChildren: function(){
		var _this = this;
		this.tree.toggleObj.hide(
			_this.containerNode, _this.toggleDuration, _this.explodeSrc, _this.onHide
		);

		/* if dnd is in action, recalculate changed coordinates */
		if(dojo.exists(dojo, 'dnd.dragManager.dragObjects') && dojo.dnd.dragManager.dragObjects.length) {
			dojo.dnd.dragManager.cacheTargetLocations();
		}
	},

	showChildren: function(){
		var _this = this;
		this.tree.toggleObj.show(
			_this.containerNode, _this.toggleDuration,	_this.explodeSrc, _this.onShow
		);

		/* if dnd is in action, recalculate changed coordinates */
		if(dojo.exists(dojo, 'dnd.dragManager.dragObjects') && dojo.dnd.dragManager.dragObjects.length) {
			dojo.dnd.dragManager.cacheTargetLocations();
		}
	},

	addChild: function(){
		return this.tree.addChild.apply(this, arguments);
	},

	doAddChild: function(){
		return this.tree.doAddChild.apply(this, arguments);
	},



	/* Edit current node : change properties and update contents */
	edit: function(props) {
		dojo.lang.mixin(this, props);
		if (props.title) {
			this.titleNode.innerHTML = this.title;
		}

		if (props.afterLabel) {
			this.afterLabelNode.innerHTML = this.afterLabel;
		}

		if (props.childIconSrc) {
			this.buildChildIcon();
		}


	},


	removeNode: function(){ return this.tree.removeNode.apply(this, arguments) },
	doRemoveNode: function(){ return this.tree.doRemoveNode.apply(this, arguments) },


	toString: function() {
		return "["+this.widgetType+" Tree:"+this.tree+" ID:"+this.widgetId+" Title:"+this.title+"]";

	}

});





__CPAN_FILE__ src/widget/TreeRPCController.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/


dojo.provide("dojo.widget.TreeRPCController");

dojo.require("dojo.event.*");
dojo.require("dojo.json")
dojo.require("dojo.io.*");
dojo.require("dojo.widget.TreeLoadingController");


dojo.widget.tags.addParseTreeHandler("dojo:TreeRPCController");


dojo.widget.TreeRPCController = function() {
	dojo.widget.TreeLoadingController.call(this);
}

dojo.inherits(dojo.widget.TreeRPCController, dojo.widget.TreeLoadingController);


dojo.lang.extend(dojo.widget.TreeRPCController, {
	widgetType: "TreeRPCController",

	/**
	 * Make request to server about moving children.
	 *
	 * Request returns "true" if move succeeded,
	 * object with error field if failed
	 *
	 * I can't leave DragObject floating until async request returns, need to return false/true
	 * so making it sync way...
	 *
	 * Also, "loading" icon is not shown until function finishes execution, so no indication for remote request.
	*/
	doMove: function(child, newParent, index) {

		//if (newParent.isTreeNode) newParent.markLoading();

		var params = {
			// where from
			child: this.getInfo(child),
			childTree: this.getInfo(child.tree),
			// where to
			newParent: this.getInfo(newParent),
			newParentTree: this.getInfo(newParent.tree),
			newIndex: index
		};

		var success;

		this.runRPC({		
			url: this.getRPCUrl('move'),
			/* I hitch to get this.loadOkHandler */
			load: function(response) {
				success = this.doMoveProcessResponse(response, child, newParent, index) ;
			},
			sync: true,
			lock: [child, newParent],
			params: params
		});


		return success;
	},

	doMoveProcessResponse: function(response, child, newParent, index) {

		if (!dojo.lang.isUndefined(response.error)) {
			this.RPCErrorHandler("server", response.error);
			return false;
		}

		var args = [child, newParent, index];
		return dojo.widget.TreeLoadingController.prototype.doMove.apply(this, args);

	},


	doRemoveNode: function(node, callObj, callFunc) {

		var params = {
			node: this.getInfo(node),
			tree: this.getInfo(node.tree)
		}

		this.runRPC({
				url: this.getRPCUrl('removeNode'),
				/* I hitch to get this.loadOkHandler */
				load: function(response) {
					this.doRemoveNodeProcessResponse(response, node, callObj, callFunc) 
				},
				params: params,
				lock: [node]
		});

	},


	doRemoveNodeProcessResponse: function(response, node, callObj, callFunc) {
		if (!dojo.lang.isUndefined(response.error)) {
			this.RPCErrorHandler("server", response.error);
			return false;
		}

		if (!response) return false;

		if (response == true) {
			/* change parent succeeded */
			var args = [ node, callObj, callFunc ];
			dojo.widget.TreeLoadingController.prototype.doRemoveNode.apply(this, args);

			return;
		} else if (dojo.lang.isObject(response)) {
			dojo.raise(response.error);
		} else {
			dojo.raise("Invalid response "+obj)
		}


	},



	// -----------------------------------------------------------------------------
	//                             Create node stuff
	// -----------------------------------------------------------------------------


	doCreateChild: function(parent, index, output, callObj, callFunc) {

			var params = {
				tree: this.getInfo(parent.tree),
				parent: this.getInfo(parent),
				index: index,
				data: output
			}

			this.runRPC({
				url: this.getRPCUrl('createChild'),
				load: function(response) {
					// suggested data is dead, fresh data from server is used
					this.doCreateChildProcessResponse( response, parent, index, callObj, callFunc) 
				},
				params: params,
				lock: [parent]
			});

	},

	doCreateChildProcessResponse: function(response, parent, index, callObj, callFunc) {

		if (!dojo.lang.isUndefined(response.error)) {
			this.RPCErrorHandler("server",response.error);
			return false;
		}

		if (!dojo.lang.isObject(response)) {
			dojo.raise("Invalid result "+response)
		}

		var args = [parent, index, response, callObj, callFunc];
		
		dojo.widget.TreeLoadingController.prototype.doCreateChild.apply(this, args);

	}

});

__CPAN_FILE__ src/widget/TreeSelector.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/


dojo.provide("dojo.widget.TreeSelector");

dojo.require("dojo.widget.HtmlWidget");


dojo.widget.tags.addParseTreeHandler("dojo:TreeSelector");


dojo.widget.TreeSelector = function() {
	dojo.widget.HtmlWidget.call(this);


	this.eventNames = {};

	this.listenedTrees = [];

}

dojo.inherits(dojo.widget.TreeSelector, dojo.widget.HtmlWidget);


dojo.lang.extend(dojo.widget.TreeSelector, {
	widgetType: "TreeSelector",
	selectedNode: null,

	dieWithTree: false,

	eventNamesDefault: {
		select : "select",
		destroy : "destroy",
		deselect : "deselect",
		dblselect: "dblselect" // select already selected node.. Edit or whatever
	},

	initialize: function() {

		for(name in this.eventNamesDefault) {
			if (dojo.lang.isUndefined(this.eventNames[name])) {
				this.eventNames[name] = this.widgetId+"/"+this.eventNamesDefault[name];
			}
		}

	},


	destroy: function() {
		dojo.event.topic.publish(this.eventNames.destroy, { source: this } );

		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
	},


	listenTree: function(tree) {
		dojo.event.topic.subscribe(tree.eventNames.titleClick, this, "select");
		dojo.event.topic.subscribe(tree.eventNames.iconClick, this, "select");
		dojo.event.topic.subscribe(tree.eventNames.collapse, this, "onCollapse");
		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");

		/* remember all my trees to deselect when element is movedFrom them */
		this.listenedTrees.push(tree);
	},


	unlistenTree: function(tree) {

		dojo.event.topic.unsubscribe(tree.eventNames.titleClick, this, "select");
		dojo.event.topic.unsubscribe(tree.eventNames.iconClick, this, "select");
		dojo.event.topic.unsubscribe(tree.eventNames.collapse, this, "onCollapse");
		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");


		for(var i=0; i<this.listenedTrees.length; i++){
           if(this.listenedTrees[i] === tree){
                   this.listenedTrees.splice(i, 1);
                   break;
           }
		}
	},


	onTreeDestroy: function(message) {

		this.unlistenTree(message.source);

		if (this.dieWithTree) {
			//dojo.debug("Killing myself "+this.widgetId);
			this.destroy();
			//dojo.debug("done");
		}
	},


	// deselect node if parent is collapsed
	onCollapse: function(message) {
		if (!this.selectedNode) return;

		var node = message.source;
		var parent = this.selectedNode.parent;
		while (parent !== node && parent.isTreeNode) {
			parent = parent.parent;
		}
		if (parent.isTreeNode) {
			this.deselect();
		}
	},



	select: function(message) {
		var node = message.source;
		var e = message.event;

		if (this.selectedNode === node) {
			dojo.event.topic.publish(this.eventNames.dblselect, { node: node });
			return;
		}

		if (this.selectedNode) {
			this.deselect();
		}

		this.doSelect(node);

		dojo.event.topic.publish(this.eventNames.select, {node: node} );
	},

	/**
	 * Deselect node if target tree is out of our concern
	 */
	onMoveFrom: function(message) {
		if (message.child !== this.selectedNode) {
			return;
		}

		if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
			this.deselect();
		}
	},

	onRemoveNode: function(message) {
		if (message.child !== this.selectedNode) {
			return;
		}

		this.deselect();
	},

	doSelect: function(node){

		node.markSelected();

		this.selectedNode = node;
	},

	deselect: function(){

		var node = this.selectedNode;

		this.selectedNode = null;
		node.unMarkSelected();
		dojo.event.topic.publish(this.eventNames.deselect, {node: node} );

	}

});




__CPAN_FILE__ src/widget/validate.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.validate");

dojo.provide("dojo.widget.validate.Textbox");
dojo.provide("dojo.widget.validate.ValidationTextbox");
dojo.provide("dojo.widget.validate.IntegerTextbox");
dojo.provide("dojo.widget.validate.RealNumberTextbox");
dojo.provide("dojo.widget.validate.CurrencyTextbox");
dojo.provide("dojo.widget.validate.IpAddressTextbox");
dojo.provide("dojo.widget.validate.UrlTextbox");
dojo.provide("dojo.widget.validate.EmailTextbox");
dojo.provide("dojo.widget.validate.EmailListTextbox");
dojo.provide("dojo.widget.validate.DateTextbox");
dojo.provide("dojo.widget.validate.TimeTextbox");
dojo.provide("dojo.widget.validate.UsStateTextbox");
dojo.provide("dojo.widget.validate.UsZipTextbox");
dojo.provide("dojo.widget.validate.UsPhoneNumberTextbox");
dojo.provide("dojo.widget.validate.FloatValidationTextbox");
dojo.provide("dojo.widget.validate.FloatIntegerTextbox");
dojo.provide("dojo.widget.validate.FloatDateTextbox");

dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.Manager");
dojo.require("dojo.widget.Parse");
dojo.require("dojo.xml.Parse");
dojo.require("dojo.lang");
dojo.require("dojo.validate");

dojo.widget.manager.registerWidgetPackage("dojo.widget.validate");


/*
  ****** Textbox ******

  This widget is a generic textbox field.
  Serves as a base class to derive more specialized functionality in subclasses.
  Has the following properties that can be specified as attributes in the markup.

  @attr id         The textbox id attribute.
  @attr className  The textbox class attribute.
  @attr name       The textbox name attribute.
  @attr value      The textbox value attribute.
  @attr trim       Removes leading and trailing whitespace if true.  Default is false.
  @attr uppercase  Converts all characters to uppercase if true.  Default is false.
  @attr lowercase  Converts all characters to lowercase if true.  Default is false.
  @attr ucFirst    Converts the first character of each word to uppercase if true.
  @attr lowercase  Removes all characters that are not digits if true.  Default is false.
*/
dojo.widget.validate.Textbox = function() {  }

dojo.inherits(dojo.widget.validate.Textbox, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.validate.Textbox, {
	// default values for new subclass properties
	widgetId: "", 
	widgetType: "Textbox", 
	id: "",
	className: "",
	name: "",
	value: "",
	trim: false,
	uppercase: false,
	lowercase: false,
	ucFirst: false,
	digit: false,
	
	templateString: "<input dojoAttachPoint='textbox' dojoAttachEvent='onblur;onfocus'"
					+ " id='${this.widgetId}' name='${this.name}' "
					+ " value='${this.value}' class='${this.className}'></input>",

	// our DOM nodes
	textbox: null,

	// Apply various filters to textbox value
	filter: function() { 
		if (this.trim) {
			this.textbox.value = this.textbox.value.replace(/(^\s*|\s*$)/g, "");
		} 
		if (this.uppercase) {
			this.textbox.value = this.textbox.value.toUpperCase();
		} 
		if (this.lowercase) {
			this.textbox.value = this.textbox.value.toLowerCase();
		} 
		if (this.ucFirst) {
			this.textbox.value = this.textbox.value.replace(/\b\w+\b/g, 
				function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });
		} 
		if (this.digit) {
			this.textbox.value = this.textbox.value.replace(/\D/g, "");
		} 
	},

	// event handlers, you can over-ride these in your own subclasses
	onfocus: function() {},
	onblur: function() { this.filter(); },

	// All functions below are called by create from dojo.widget.Widget
	mixInProperties: function(localProperties, frag) {
		dojo.widget.validate.Textbox.superclass.mixInProperties.apply(this, arguments);
		if ( localProperties["class"] ) { 
			this.className = localProperties["class"];
		}
	},

	fillInTemplate: function() {
		// apply any filters to initial value
		this.filter();
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:Textbox");


/*
  ****** ValidationTextbox ******

  A subclass of Textbox.
  Over-ride isValid in subclasses to perform specific kinds of validation.
  Has several new properties that can be specified as attributes in the markup.

	@attr type          		Basic input tag type declaration.
	@attr size          		Basic input tag size declaration.
	@attr type          		Basic input tag maxlength declaration.	
  @attr required          Can be true or false, default is false.
  @attr validColor        The color textbox is highlighted for valid input. Default is #cfc.
  @attr invalidColor      The color textbox is highlighted for invalid input. Default is #fcc.
  @attr invalidClass			Class used to format displayed text in page if necessary to override default class
  @attr invalidMessage    The message to display if value is invalid.
  @attr missingMessage    The message to display if value is missing.
  @attr missingClass		  Override default class used for missing input data
  @attr listenOnKeyPress  Updates messages on each key press.  Default is true.
  @attr promptMessage			Will not issue invalid message if field is populated with default user-prompt text
*/
dojo.widget.validate.ValidationTextbox = function() {}

dojo.inherits(dojo.widget.validate.ValidationTextbox, dojo.widget.validate.Textbox);

dojo.lang.extend(dojo.widget.validate.ValidationTextbox, {
	// default values for new subclass properties
	widgetType: "ValidationTextbox", 
	type: "",
	required: false,
	validColor: "#cfc",
	invalidColor: "#fcc",
	invalidClass: "invalid",
	missingClass: "missing",
	size: "",
	maxlength: "",
	promptMessage: "",
	invalidMessage: "* The value entered is not valid.",
	missingMessage: "* This value is required.",
	listenOnKeyPress: true,

	templateString:   "<div>"
					+   "<input dojoAttachPoint='textbox' type='${this.type}' dojoAttachEvent='onblur;onfocus;onkeyup'"
					+     " id='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'"
					+     " value='${this.value}' class='${this.className}'></input>"
					+   "<span dojoAttachPoint='invalidSpan' class='${this.invalidClass}'>${this.invalidMessage}</span>"
					+   "<span dojoAttachPoint='missingSpan' class='${this.missingClass}'>${this.missingMessage}</span>"
					+ "</div>",

	// new DOM nodes
	invalidSpan: null,
	missingSpan: null,

	// Need to over-ride with your own validation code in subclasses
	isValid: function() { return true; },

	// Returns true if value is all whitespace
	isEmpty: function() { 
		return ( /^\s*$/.test(this.textbox.value) );
	},

	// Returns true if value is required and it is all whitespace.
	isMissing: function() { 
		return ( this.required && this.isEmpty() );
	},

	// Called oninit, onblur, and onkeypress.
	// Show missing or invalid messages if appropriate, and highlight textbox field.
	update: function() {
		this.missingSpan.style.display = "none";
		this.invalidSpan.style.display = "none";

		var empty = this.isEmpty();
		var valid = true;
		if(this.promptMessage != this.textbox.value) { 
				valid = this.isValid(); 
		}
		var missing = this.isMissing();

		// Display at most one error message
		if ( missing ){
			this.missingSpan.style.display = "";
		}
		else if ( !empty && !valid ){
			this.invalidSpan.style.display = "";
		}
	},

	// Called oninit, and onblur.
	highlight: function() {
		// highlight textbox background 
		if ( this.isEmpty() ) {
			this.textbox.style.backgroundColor = "";
		}
		else if ( this.isValid() ) {
			this.textbox.style.backgroundColor = this.validColor;
		}
		else {
			if(this.textbox.value != this.promptMessage) { 
				this.textbox.style.backgroundColor = this.invalidColor;
			}
		}
	},

	onfocus: function() {
		// Put the textbox background back to normal
		this.textbox.style.backgroundColor = "";
	},

	onblur: function() { 
		this.filter();
		this.update(); 
		this.highlight(); 
	},

	onkeyup: function() { 
		if ( this.listenOnKeyPress ) { 
			//this.filter();  trim is problem if you have to type two words
			this.update(); 
		} 
	},

	fillInTemplate: function() {
		// Attach isMissing and isValid methods to the textbox.
		// We may use them later in connection with a submit button widget.
		// TODO: this is unorthodox; it seems better to do it another way -- Bill
		this.textbox.isValid = function() { _this.isValid.call(_this); };
		this.textbox.isMissing = function() { _this.isMissing.call(_this); };
	},

	fillInTemplate: function() {
		// apply any filters to initial value
		this.filter();

		// highlight textbox as valid or invalid
		this.highlight(); 

		// show missing or invalid messages on init
		this.update(); 
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:ValidationTextbox");


/*
  ****** IntegerTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test for integer input.
  Has two new properties that can be specified as attributes in the markup.

  @attr signed     The leading plus-or-minus sign. Can be true or false, default is either.
  @attr separator  The character used as the thousands separator.  Default is no separator.
*/
dojo.widget.validate.IntegerTextbox = function(node) {
	// this property isn't a primitive and needs to be created on a per-item basis.
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.IntegerTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.IntegerTextbox, {
	// new subclass properties
	widgetType: "IntegerTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.IntegerTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.signed ) { 
			this.flags.signed = ( localProperties.signed == "true" );
		}
		if ( localProperties.separator ) { 
			this.flags.separator = localProperties.separator;
		}
	},

	// Over-ride for integer validation
	isValid: function() { 
		return dojo.validate.isInteger(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:IntegerTextbox");


/*
  ****** RealNumberTextbox ******

  A subclass that extends IntegerTextbox.
  Over-rides isValid to test for real number input.
  Has three new properties that can be specified as attributes in the markup.

  @attr places    The exact number of decimal places.  If omitted, it's unlimited and optional.
  @attr exponent  Can be true or false.  If omitted the exponential part is optional.
  @attr eSigned   Is the exponent signed?  Can be true or false, if omitted the sign is optional.
*/
dojo.widget.validate.RealNumberTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.RealNumberTextbox, dojo.widget.validate.IntegerTextbox);

dojo.lang.extend(dojo.widget.validate.RealNumberTextbox, {
	// new subclass properties
	widgetType: "RealNumberTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.RealNumberTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.places ) { 
			this.flags.places = Number( localProperties.places );
		}
		if ( localProperties.exponent ) { 
			this.flags.exponent = ( localProperties.exponent == "true" );
		}
		if ( localProperties.esigned ) { 
			this.flags.eSigned = ( localProperties.esigned == "true" );
		}
	},

	// Over-ride for real number validation
	isValid: function() { 
		return dojo.validate.isRealNumber(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:RealNumberTextbox");


/*
  ****** CurrencyTextbox ******

  A subclass that extends IntegerTextbox.
  Over-rides isValid to test if input denotes a monetary value .
  Has 2 new properties that can be specified as attributes in the markup.

  @attr cents      The two decimal places for cents.  Can be true or false, optional if omitted.
  @attr symbol     A currency symbol such as Yen "???", Pound "???", or the Euro "???". Default is "$".
  @attr separator  Default is "," instead of no separator as in IntegerTextbox.
*/
dojo.widget.validate.CurrencyTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.CurrencyTextbox, dojo.widget.validate.IntegerTextbox);

dojo.lang.extend(dojo.widget.validate.CurrencyTextbox, {
	// new subclass properties
	widgetType: "CurrencyTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.CurrencyTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.cents ) { 
			this.flags.cents = ( localProperties.cents == "true" );
		}
		if ( localProperties.symbol ) { 
			this.flags.symbol = localProperties.symbol;
		}
	},

	// Over-ride for currency validation
	isValid: function() { 
		return dojo.validate.isCurrency(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:CurrencyTextbox");


/*
  ****** IpAddressTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test for IP addresses.
  Can specify formats for ipv4 or ipv6 as attributes in the markup.

  @attr allowDottedDecimal  true or false, default is true.
  @attr allowDottedHex      true or false, default is true.
  @attr allowDottedOctal    true or false, default is true.
  @attr allowDecimal        true or false, default is true.
  @attr allowHex            true or false, default is true.
  @attr allowIPv6           true or false, default is true.
  @attr allowHybrid         true or false, default is true.
*/
dojo.widget.validate.IpAddressTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.IpAddressTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.IpAddressTextbox, {
	// new subclass properties
	widgetType: "IpAddressTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.IpAddressTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.allowdotteddecimal ) { 
			this.flags.allowDottedDecimal = ( localProperties.allowdotteddecimal == "true" );
		}
		if ( localProperties.allowdottedhex ) { 
			this.flags.allowDottedHex = ( localProperties.allowdottedhex == "true" );
		}
		if ( localProperties.allowdottedoctal ) { 
			this.flags.allowDottedOctal = ( localProperties.allowdottedoctal == "true" );
		}
		if ( localProperties.allowdecimal ) { 
			this.flags.allowDecimal = ( localProperties.allowdecimal == "true" );
		}
		if ( localProperties.allowhex ) { 
			this.flags.allowHex = ( localProperties.allowhex == "true" );
		}
		if ( localProperties.allowipv6 ) { 
			this.flags.allowIPv6 = ( localProperties.allowipv6 == "true" );
		}
		if ( localProperties.allowhybrid ) { 
			this.flags.allowHybrid = ( localProperties.allowhybrid == "true" );
		}
	},

	// Over-ride for IP address validation
	isValid: function() { 
		return dojo.validate.isIpAddress(this.textbox.value, this.flags);
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:IpAddressTextbox");


/*
  ****** UrlTextbox ******

  A subclass of IpAddressTextbox.
  Over-rides isValid to test for URL's.
  Can specify 5 additional attributes in the markup.

  @attr scheme        Can be true or false.  If omitted the scheme is optional.
  @attr allowIP       Allow an IP address for hostname.  Default is true.
  @attr allowLocal    Allow the host to be "localhost".  Default is false.
  @attr allowCC       Allow 2 letter country code domains.  Default is true.
  @attr allowGeneric  Allow generic domains.  Can be true or false, default is true.
*/
dojo.widget.validate.UrlTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.UrlTextbox, dojo.widget.validate.IpAddressTextbox);

dojo.lang.extend(dojo.widget.validate.UrlTextbox, {
	// new subclass properties
	widgetType: "UrlTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.UrlTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.scheme ) { 
			this.flags.scheme = ( localProperties.scheme == "true" );
		}
		if ( localProperties.allowip ) { 
			this.flags.allowIP = ( localProperties.allowip == "true" );
		}
		if ( localProperties.allowlocal ) { 
			this.flags.allowLocal = ( localProperties.allowlocal == "true" );
		}
		if ( localProperties.allowcc ) { 
			this.flags.allowCC = ( localProperties.allowcc == "true" );
		}
		if ( localProperties.allowgeneric ) { 
			this.flags.allowGeneric = ( localProperties.allowgeneric == "true" );
		}
	},

	// Over-ride for URL validation
	isValid: function() { 
		return dojo.validate.isUrl(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:UrlTextbox");


/*
  ****** EmailTextbox ******

  A subclass of UrlTextbox.
  Over-rides isValid to test for email addresses.
  Can use all markup attributes/properties of UrlTextbox except scheme.
  One new attribute available in the markup.

  @attr allowCruft  Allow address like <mailto:foo@yahoo.com>.  Default is false.
*/
dojo.widget.validate.EmailTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.EmailTextbox, dojo.widget.validate.UrlTextbox);

dojo.lang.extend(dojo.widget.validate.EmailTextbox, {
	// new subclass properties
	widgetType: "EmailTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.EmailTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.allowcruft ) { 
			this.flags.allowCruft = ( localProperties.allowcruft == "true" );
		}
	},

	// Over-ride for email address validation
	isValid: function() { 
		return dojo.validate.isEmailAddress(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:EmailTextbox");


/*
  ****** EmailListTextbox ******

  A subclass of EmailTextbox.
  Over-rides isValid to test for a list of email addresses.
  Can use all markup attributes/properties of EmailTextbox and ...

  @attr listSeparator  The character used to separate email addresses.  
    Default is ";", ",", "\n" or " ".
*/
dojo.widget.validate.EmailListTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.EmailListTextbox, dojo.widget.validate.EmailTextbox);

dojo.lang.extend(dojo.widget.validate.EmailListTextbox, {
	// new subclass properties
	widgetType: "EmailListTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.EmailListTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.listseparator ) { 
			this.flags.listSeparator = localProperties.listseparator;
		}
	},

	// Over-ride for email address list validation
	isValid: function() { 
		return dojo.validate.isEmailAddressList(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:EmailListTextbox");


/*
  ****** DateTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test if input is in a valid date format.

  @attr format  Described in dojo.validate.js.  Default is  "MM/DD/YYYY".
*/
dojo.widget.validate.DateTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.DateTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.DateTextbox, {
	// new subclass properties
	widgetType: "DateTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.DateTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.format ) { 
			this.flags.format = localProperties.format;
		}
	},

	// Over-ride for date validation
	isValid: function() { 
		return dojo.validate.isValidDate(this.textbox.value, this.flags.format);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:DateTextbox");


/*
  ****** TimeTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test if input is in a valid time format.

  @attr format    Described in dojo.validate.js.  Default is  "h:mm:ss t".
  @attr amSymbol  The symbol used for AM.  Default is "AM" or "am".
  @attr pmSymbol  The symbol used for PM.  Default is "PM" or "pm".
*/
dojo.widget.validate.TimeTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.TimeTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.TimeTextbox, {
	// new subclass properties
	widgetType: "TimeTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.TimeTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.format ) { 
			this.flags.format = localProperties.format;
		}
		if ( localProperties.amsymbol ) { 
			this.flags.amSymbol = localProperties.amsymbol;
		}
		if ( localProperties.pmsymbol ) { 
			this.flags.pmSymbol = localProperties.pmsymbol;
		}
	},

	// Over-ride for time validation
	isValid: function() { 
		return dojo.validate.isValidTime(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:TimeTextbox");


/*
  ****** UsStateTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test if input is a US state abbr.

  @attr allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
  @attr allowMilitary     Allow military 'states', e.g. Armed Forces Europe (AE). Default is true.
*/
dojo.widget.validate.UsStateTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.UsStateTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.UsStateTextbox, {
	// new subclass properties
	widgetType: "UsStateTextbox", 

	mixInProperties: function(localProperties, frag) {
		// Initialize properties in super-class.
		dojo.widget.validate.UsStateTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.allowterritories ) { 
			this.flags.allowTerritories = ( localProperties.allowterritories == "true" );
		}
		if ( localProperties.allowmilitary ) { 
			this.flags.allowMilitary = ( localProperties.allowmilitary == "true" );
		}
	},

	isValid: function() { 
		return dojo.validate.us.isState(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:UsStateTextbox");


/*
  ****** UsZipTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test if input is a US zip code.
  Validates zip-5 and zip-5 plus 4.
*/
dojo.widget.validate.UsZipTextbox = function(node) {}

dojo.inherits(dojo.widget.validate.UsZipTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.UsZipTextbox, {
	// new subclass properties
	widgetType: "UsZipTextbox", 

	isValid: function() { 
		return dojo.validate.us.isZipCode(this.textbox.value);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:UsZipTextbox");


/*
  ****** UsSocialSecurityNumberTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test if input is a US Social Security Number.
*/
dojo.widget.validate.UsSocialSecurityNumberTextbox = function(node) {}

dojo.inherits(dojo.widget.validate.UsSocialSecurityNumberTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.UsSocialSecurityNumberTextbox, {
	// new subclass properties
	widgetType: "UsSocialSecurityNumberTextbox", 

	isValid: function() { 
		return dojo.validate.us.isSocialSecurityNumber(this.textbox.value);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:UsSocialSecurityNumberTextbox");


/*
  ****** UsPhoneNumberTextbox ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test if input is a 10-digit US phone number, an extension is optional.
*/
dojo.widget.validate.UsPhoneNumberTextbox = function(node) {}

dojo.inherits(dojo.widget.validate.UsPhoneNumberTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.UsPhoneNumberTextbox, {
	// new subclass properties
	widgetType: "UsPhoneNumberTextbox", 

	isValid: function() { 
		return dojo.validate.us.isPhoneNumber(this.textbox.value);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:UsPhoneNumberTextbox");


/*
  ****** FloatValidationTextbox, ******

  A subclass of ValidationTextbox.
  Over-rides isValid to test if input is a 10-digit US phone number, an extension is optional.
*/
dojo.widget.validate.FloatValidationTextbox = function(node) {}

dojo.inherits(dojo.widget.validate.FloatValidationTextbox, dojo.widget.validate.ValidationTextbox);

dojo.lang.extend(dojo.widget.validate.FloatValidationTextbox, {
	// new subclass properties
	widgetType: "FloatValidationTextbox", 
	size: "",
	maxlength: "",

	templateString:   "<div style='float: left; display: inline'>"
					+   "<input dojoAttachPoint='textbox' dojoAttachEvent='onblur;onfocus;onkeyup'"
					+     " id='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'"
					+     " value='${this.value}' class='${this.className}'></input>"
					+   "<span dojoAttachPoint='invalidSpan' class='invalid'>${this.invalidMessage}</span>"
					+   "<span dojoAttachPoint='missingSpan' class='missing'>${this.missingMessage}</span>"
					+ "</div>"
					
});

dojo.widget.tags.addParseTreeHandler("dojo:FloatValidationTextbox");

/*
  ****** FloatIntegerTextbox ******

  A subclass of FloatValidationTextbox.
  Over-rides isValid to test for integer input.
  Has two new properties that can be specified as attributes in the markup.

  @attr signed     The leading plus-or-minus sign. Can be true or false, default is either.
  @attr separator  The character used as the thousands separator.  Default is no separator.
*/
dojo.widget.validate.FloatIntegerTextbox = function(node) {
	// this property isn't a primitive and needs to be created on a per-item basis.
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.FloatIntegerTextbox, dojo.widget.validate.FloatValidationTextbox);

dojo.lang.extend(dojo.widget.validate.FloatIntegerTextbox, {
	// new subclass properties
	widgetType: "FloatIntegerTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.FloatIntegerTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.signed ) { 
			this.flags.signed = ( localProperties.signed == "true" );
		}
		if ( localProperties.separator ) { 
			this.flags.separator = localProperties.separator;
		}
	},

	// Over-ride for integer validation
	isValid: function() { 
		return dojo.validate.isInteger(this.textbox.value, this.flags);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:FloatIntegerTextbox");

/*
  ****** FloatDateTextbox ******

  A subclass of FloatValidationTextbox.
  Over-rides isValid to test if input is in a valid date format.

  @attr format  Described in dojo.validate.js.  Default is  "MM/DD/YYYY".
*/
dojo.widget.validate.FloatDateTextbox = function(node) {
	this.flags = {};
}

dojo.inherits(dojo.widget.validate.FloatDateTextbox, dojo.widget.validate.FloatValidationTextbox);

dojo.lang.extend(dojo.widget.validate.FloatDateTextbox, {
	// new subclass properties
	widgetType: "FloatDateTextbox", 

	mixInProperties: function(localProperties, frag) {
		// First initialize properties in super-class.
		dojo.widget.validate.FloatDateTextbox.superclass.mixInProperties.apply(this, arguments);

		// Get properties from markup attibutes, and assign to flags object.
		if ( localProperties.format ) { 
			this.flags.format = localProperties.format;
		}
	},

	// Over-ride for date validation
	isValid: function() { 
		return dojo.validate.isValidDate(this.textbox.value, this.flags.format);
	}

});

dojo.widget.tags.addParseTreeHandler("dojo:FloatDateTextbox");

__CPAN_FILE__ src/widget/Widget.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Widget");
dojo.provide("dojo.widget.tags");

dojo.require("dojo.lang.func");
dojo.require("dojo.lang.array");
dojo.require("dojo.lang.extras");
dojo.require("dojo.lang.declare");
dojo.require("dojo.widget.Manager");
dojo.require("dojo.event.*");

dojo.declare("dojo.widget.Widget", null, {
	initializer: function() {								 
		// these properties aren't primitives and need to be created on a per-item
		// basis.
		this.children = [];
		// this.selection = new dojo.widget.Selection();
		// FIXME: need to replace this with context menu stuff
		this.extraArgs = {};
	},
	// FIXME: need to be able to disambiguate what our rendering context is
	//        here!
	//
	// needs to be a string with the end classname. Every subclass MUST
	// over-ride.
	//
	// base widget properties
	parent: null,
	// obviously, top-level and modal widgets should set these appropriately
	isTopLevel:  false,
	isModal: false,

	isEnabled: true,
	isHidden: false,
	isContainer: false, // can we contain other widgets?
	widgetId: "",
	widgetType: "Widget", // used for building generic widgets

	toString: function() {
		return '[Widget ' + this.widgetType + ', ' + (this.widgetId || 'NO ID') + ']';
	},

	repr: function(){
		return this.toString();
	},

	enable: function(){
		// should be over-ridden
		this.isEnabled = true;
	},

	disable: function(){
		// should be over-ridden
		this.isEnabled = false;
	},

	hide: function(){
		// should be over-ridden
		this.isHidden = true;
	},

	show: function(){
		// should be over-ridden
		this.isHidden = false;
	},

	onResized: function(){
		// Clients should override this function to do special processing,
		// then call this.notifyChildrenOfResize() to notify children of resize
		this.notifyChildrenOfResize();
	},
	
	notifyChildrenOfResize: function(){
		for(var i=0; i<this.children.length; i++){
			var child = this.children[i];
			//dojo.debug(this.widgetId + " resizing child " + child.widgetId);
			if( child.onResized ){
				child.onResized();
			}
		}
	},

	create: function(args, fragment, parentComp){
		// dojo.debug(this.widgetType, "create");
		this.satisfyPropertySets(args, fragment, parentComp);
		// dojo.debug(this.widgetType, "-> mixInProperties");
		this.mixInProperties(args, fragment, parentComp);
		// dojo.debug(this.widgetType, "-> postMixInProperties");
		this.postMixInProperties(args, fragment, parentComp);
		// dojo.debug(this.widgetType, "-> dojo.widget.manager.add");
		dojo.widget.manager.add(this);
		// dojo.debug(this.widgetType, "-> buildRendering");
		this.buildRendering(args, fragment, parentComp);
		// dojo.debug(this.widgetType, "-> initialize");
		this.initialize(args, fragment, parentComp);
		// dojo.debug(this.widgetType, "-> postInitialize");
		this.postInitialize(args, fragment, parentComp);
		// dojo.debug(this.widgetType, "-> postCreate");
		this.postCreate(args, fragment, parentComp);
		// dojo.debug(this.widgetType, "done!");
		return this;
	},

	// Destroy this widget and it's descendants
	destroy: function(finalize){
		// FIXME: this is woefully incomplete
		this.destroyChildren();
		this.uninitialize();
		this.destroyRendering(finalize);
		dojo.widget.manager.removeById(this.widgetId);
	},

	// Destroy the children of this widget, and their descendents
	destroyChildren: function(){
		while(this.children.length > 0){
			var tc = this.children[0];
			this.removeChild(tc);
			tc.destroy();
		}
	},

	getChildrenOfType: function(type, recurse){
		var ret = [];
		var isFunc = dojo.lang.isFunction(type);
		if(!isFunc){
			type = type.toLowerCase();
		}
		for(var x=0; x<this.children.length; x++){
			if(isFunc){
				if(this.children[x] instanceof type){
					ret.push(this.children[x]);
				}
			}else{
				if(this.children[x].widgetType.toLowerCase() == type){
					ret.push(this.children[x]);
				}
			}
			if(recurse){
				ret = ret.concat(this.children[x].getChildrenOfType(type, recurse));
			}
		}
		return ret;
	},

	getDescendants: function(){
		var result = [];
		var stack = [this];
		var elem;
		while (elem = stack.pop()){
			result.push(elem);
			dojo.lang.forEach(elem.children, function(elem) { stack.push(elem); });
		}
		return result;
	},

	satisfyPropertySets: function(args){
		// dojo.profile.start("satisfyPropertySets");
		// get the default propsets for our component type
		/*
		var typePropSets = []; // FIXME: need to pull these from somewhere!
		var localPropSets = []; // pull out propsets from the parser's return structure

		// for(var x=0; x<args.length; x++){
		// }

		for(var x=0; x<typePropSets.length; x++){
		}

		for(var x=0; x<localPropSets.length; x++){
		}
		*/
		// dojo.profile.end("satisfyPropertySets");
		
		return args;
	},

	mixInProperties: function(args, frag){
		if((args["fastMixIn"])||(frag["fastMixIn"])){
			// dojo.profile.start("mixInProperties_fastMixIn");
			// fast mix in assumes case sensitivity, no type casting, etc...
			// dojo.lang.mixin(this, args);
			for(var x in args){
				this[x] = args[x];
			}
			// dojo.profile.end("mixInProperties_fastMixIn");
			return;
		}
		// dojo.profile.start("mixInProperties");
		/*
		 * the actual mix-in code attempts to do some type-assignment based on
		 * PRE-EXISTING properties of the "this" object. When a named property
		 * of a propset is located, it is first tested to make sure that the
		 * current object already "has one". Properties which are undefined in
		 * the base widget are NOT settable here. The next step is to try to
		 * determine type of the pre-existing property. If it's a string, the
		 * property value is simply assigned. If a function, the property is
		 * replaced with a "new Function()" declaration. If an Array, the
		 * system attempts to split the string value on ";" chars, and no
		 * further processing is attempted (conversion of array elements to a
		 * integers, for instance). If the property value is an Object
		 * (testObj.constructor === Object), the property is split first on ";"
		 * chars, secondly on ":" chars, and the resulting key/value pairs are
		 * assigned to an object in a map style. The onus is on the property
		 * user to ensure that all property values are converted to the
		 * expected type before usage.
		 */

		var undef;

		// NOTE: we cannot assume that the passed properties are case-correct
		// (esp due to some browser bugs). Therefore, we attempt to locate
		// properties for assignment regardless of case. This may cause
		// problematic assignments and bugs in the future and will need to be
		// documented with big bright neon lights.

		// FIXME: fails miserably if a mixin property has a default value of null in 
		// a widget

		// NOTE: caching lower-cased args in the prototype is only 
		// acceptable if the properties are invariant.
		// if we have a name-cache, get it
		var lcArgs = dojo.widget.lcArgsCache[this.widgetType];
		if ( lcArgs == null ){
			// build a lower-case property name cache if we don't have one
			lcArgs = {};
			for(var y in this){
				lcArgs[((new String(y)).toLowerCase())] = y;
			}
			dojo.widget.lcArgsCache[this.widgetType] = lcArgs;
		}
		var visited = {};
		for(var x in args){
			if(!this[x]){ // check the cache for properties
				var y = lcArgs[(new String(x)).toLowerCase()];
				if(y){
					args[y] = args[x];
					x = y; 
				}
			}
			if(visited[x]){ continue; }
			visited[x] = true;
			if((typeof this[x]) != (typeof undef)){
				if(typeof args[x] != "string"){
					this[x] = args[x];
				}else{
					if(dojo.lang.isString(this[x])){
						this[x] = args[x];
					}else if(dojo.lang.isNumber(this[x])){
						this[x] = new Number(args[x]); // FIXME: what if NaN is the result?
					}else if(dojo.lang.isBoolean(this[x])){
						this[x] = (args[x].toLowerCase()=="false") ? false : true;
					}else if(dojo.lang.isFunction(this[x])){

						// FIXME: need to determine if always over-writing instead
						// of attaching here is appropriate. I suspect that we
						// might want to only allow attaching w/ action items.
						
						// RAR, 1/19/05: I'm going to attach instead of
						// over-write here. Perhaps function objects could have
						// some sort of flag set on them? Or mixed-into objects
						// could have some list of non-mutable properties
						// (although I'm not sure how that would alleviate this
						// particular problem)? 

						// this[x] = new Function(args[x]);

						// after an IRC discussion last week, it was decided
						// that these event handlers should execute in the
						// context of the widget, so that the "this" pointer
						// takes correctly.
						
						// argument that contains no punctuation other than . is 
						// considered a function spec, not code
						if(args[x].search(/[^\w\.]+/i) == -1){
							this[x] = dojo.evalObjPath(args[x], false);
						}else{
							var tn = dojo.lang.nameAnonFunc(new Function(args[x]), this);
							dojo.event.connect(this, x, this, tn);
						}
					}else if(dojo.lang.isArray(this[x])){ // typeof [] == "object"
						this[x] = args[x].split(";");
					} else if (this[x] instanceof Date) {
						this[x] = new Date(Number(args[x])); // assume timestamp
					}else if(typeof this[x] == "object"){ 
						// FIXME: should we be allowing extension here to handle
						// other object types intelligently?

						// if we defined a URI, we probablt want to allow plain strings
						// to override it
						if (this[x] instanceof dojo.uri.Uri){

							this[x] = args[x];
						}else{

							// FIXME: unlike all other types, we do not replace the
							// object with a new one here. Should we change that?
							var pairs = args[x].split(";");
							for(var y=0; y<pairs.length; y++){
								var si = pairs[y].indexOf(":");
								if((si != -1)&&(pairs[y].length>si)){
									this[x][pairs[y].substr(0, si).replace(/^\s+|\s+$/g, "")] = pairs[y].substr(si+1);
								}
							}
						}
					}else{
						// the default is straight-up string assignment. When would
						// we ever hit this?
						this[x] = args[x];
					}
				}
			}else{
				// collect any extra 'non mixed in' args
				this.extraArgs[x.toLowerCase()] = args[x];
			}
		}
		// dojo.profile.end("mixInProperties");
	},
	
	postMixInProperties: function(){
	},

	initialize: function(args, frag){
		// dojo.unimplemented("dojo.widget.Widget.initialize");
		return false;
	},

	postInitialize: function(args, frag){
		return false;
	},

	postCreate: function(args, frag){
		return false;
	},

	uninitialize: function(){
		// dojo.unimplemented("dojo.widget.Widget.uninitialize");
		return false;
	},

	buildRendering: function(){
		// SUBCLASSES MUST IMPLEMENT
		dojo.unimplemented("dojo.widget.Widget.buildRendering, on "+this.toString()+", ");
		return false;
	},

	destroyRendering: function(){
		// SUBCLASSES MUST IMPLEMENT
		dojo.unimplemented("dojo.widget.Widget.destroyRendering");
		return false;
	},

	cleanUp: function(){
		// SUBCLASSES MUST IMPLEMENT
		dojo.unimplemented("dojo.widget.Widget.cleanUp");
		return false;
	},

	addedTo: function(parent){
		// this is just a signal that can be caught
	},

	addChild: function(child){
		// SUBCLASSES MUST IMPLEMENT
		dojo.unimplemented("dojo.widget.Widget.addChild");
		return false;
	},

	// Detach the given child widget from me, but don't destroy it
	removeChild: function(widget){
		for(var x=0; x<this.children.length; x++){
			if(this.children[x] === widget){
				this.children.splice(x, 1);
				break;
			}
		}
		return widget;
	},

	resize: function(width, height){
		// both width and height may be set as percentages. The setWidth and
		// setHeight  functions attempt to determine if the passed param is
		// specified in percentage or native units. Integers without a
		// measurement are assumed to be in the native unit of measure.
		this.setWidth(width);
		this.setHeight(height);
	},

	setWidth: function(width){
		if((typeof width == "string")&&(width.substr(-1) == "%")){
			this.setPercentageWidth(width);
		}else{
			this.setNativeWidth(width);
		}
	},

	setHeight: function(height){
		if((typeof height == "string")&&(height.substr(-1) == "%")){
			this.setPercentageHeight(height);
		}else{
			this.setNativeHeight(height);
		}
	},

	setPercentageHeight: function(height){
		// SUBCLASSES MUST IMPLEMENT
		return false;
	},

	setNativeHeight: function(height){
		// SUBCLASSES MUST IMPLEMENT
		return false;
	},

	setPercentageWidth: function(width){
		// SUBCLASSES MUST IMPLEMENT
		return false;
	},

	setNativeWidth: function(width){
		// SUBCLASSES MUST IMPLEMENT
		return false;
	},

	getPreviousSibling: function() {
		var idx = this.getParentIndex();
 
		 // first node is idx=0 not found is idx<0
		if (idx<=0) return null;
 
		return this.getSiblings()[idx-1];
	},
 
	getSiblings: function() {
		return this.parent.children;
	},
 
	getParentIndex: function() {
		return dojo.lang.indexOf( this.getSiblings(), this, true);
	},
 
	getNextSibling: function() {
 
		var idx = this.getParentIndex();
 
		if (idx == this.getSiblings().length-1) return null; // last node
		if (idx < 0) return null; // not found
 
		return this.getSiblings()[idx+1];
 
	}
});

// Lower case name cache: listing of the lower case elements in each widget.
// We can't store the lcArgs in the widget itself because if B subclasses A,
// then B.prototype.lcArgs might return A.prototype.lcArgs, which is not what we
// want
dojo.widget.lcArgsCache = {};

// TODO: should have a more general way to add tags or tag libraries?
// TODO: need a default tags class to inherit from for things like getting propertySets
// TODO: parse properties/propertySets into component attributes
// TODO: parse subcomponents
// TODO: copy/clone raw markup fragments/nodes as appropriate
dojo.widget.tags = {};
dojo.widget.tags.addParseTreeHandler = function(type){
	var ltype = type.toLowerCase();
	this[ltype] = function(fragment, widgetParser, parentComp, insertionIndex, localProps){ 
		return dojo.widget.buildWidgetFromParseTree(ltype, fragment, widgetParser, parentComp, insertionIndex, localProps);
	}
}
dojo.widget.tags.addParseTreeHandler("dojo:widget");

dojo.widget.tags["dojo:propertyset"] = function(fragment, widgetParser, parentComp){
	// FIXME: Is this needed?
	// FIXME: Not sure that this parses into the structure that I want it to parse into...
	// FIXME: add support for nested propertySets
	var properties = widgetParser.parseProperties(fragment["dojo:propertyset"]);
}

// FIXME: need to add the <dojo:connect />
dojo.widget.tags["dojo:connect"] = function(fragment, widgetParser, parentComp){
	var properties = widgetParser.parseProperties(fragment["dojo:connect"]);
}

// FIXME: if we know the insertion point (to a reasonable location), why then do we:
//	- create a template node
//	- clone the template node
//	- render the clone and set properties
//	- remove the clone from the render tree
//	- place the clone
// this is quite dumb
dojo.widget.buildWidgetFromParseTree = function(type, frag, 
												parser, parentComp, 
												insertionIndex, localProps){
	var stype = type.split(":");
	stype = (stype.length == 2) ? stype[1] : type;
	// FIXME: we don't seem to be doing anything with this!
	// var propertySets = parser.getPropertySets(frag);
	var localProperties = localProps || parser.parseProperties(frag["dojo:"+stype]);
	// var tic = new Date();
	var twidget = dojo.widget.manager.getImplementation(stype);
	if(!twidget){
		throw new Error("cannot find \"" + stype + "\" widget");
	}else if (!twidget.create){
		throw new Error("\"" + stype + "\" widget object does not appear to implement *Widget");
	}
	localProperties["dojoinsertionindex"] = insertionIndex;
	// FIXME: we loose no less than 5ms in construction!
	var ret = twidget.create(localProperties, frag, parentComp);
	// dojo.debug(new Date() - tic);
	return ret;
}

/*
 * it would be best to be able to call defineWidget for any widget namespace
 */
dojo.widget.defineWidget = function(widgetClass /*string*/, superclass /*function*/, props /*object*/, renderer /*string*/, ctor /*function*/){
	// widgetClass takes the form foo.bar.baz<.renderer>.WidgetName (e.g. foo.bar.baz.WidgetName or foo.bar.baz.html.WidgetName)
	var namespace = widgetClass.split(".");
	var type = namespace.pop(); // type <= WidgetName, namespace <= foo.bar.baz<.renderer>
	if(renderer){
		// FIXME: could just be namespace.pop(), unless there can be foo.bar.baz.html.zot.WidgetName
		while ((namespace.length)&&(namespace.pop() != renderer)); // namespace <= foo.bar.baz
	}
	namespace = namespace.join(".");

	dojo.widget.manager.registerWidgetPackage(namespace);
	dojo.widget.tags.addParseTreeHandler("dojo:"+type.toLowerCase());

	if(!props){ props = {}; }
	props.widgetType = type;

	if((!ctor)&&(props["classConstructor"])){
		ctor = props.classConstructor;
		delete props.classConstructor;
	}
	dojo.declare(widgetClass, superclass, props, ctor);
}

__CPAN_FILE__ src/widget/Wizard.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.Wizard");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.LayoutContainer");
dojo.require("dojo.widget.ContentPane");
dojo.require("dojo.event.*");
dojo.require("dojo.html");
dojo.require("dojo.style");

//////////////////////////////////////////
// WizardContainer -- a set of panels
//////////////////////////////////////////
dojo.widget.WizardContainer = function() {
	dojo.widget.html.LayoutContainer.call(this);
}
dojo.inherits(dojo.widget.WizardContainer, dojo.widget.html.LayoutContainer);

dojo.lang.extend(dojo.widget.WizardContainer, {

	widgetType: "WizardContainer",

	labelPosition: "top",

	templatePath: dojo.uri.dojoUri("src/widget/templates/Wizard.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/Wizard.css"),

	selected: null,		// currently selected panel
	wizardNode: null, // the outer wizard node
	wizardPanelContainerNode: null, // the container for the panels
	wizardControlContainerNode: null, // the container for the wizard controls
	previousButton: null, // the previous button
	nextButton: null, // the next button
	cancelButton: null, // the cancel button
	doneButton: null, // the done button
	nextButtonLabel: "next",
	previousButtonLabel: "previous",
	cancelButtonLabel: "cancel",
	doneButtonLabel: "done",
	cancelFunction : "",

	hideDisabledButtons: false,

	fillInTemplate: function(args, frag){
		dojo.event.connect(this.nextButton, "onclick", this, "nextPanel");
		dojo.event.connect(this.previousButton, "onclick", this, "previousPanel");
		if (this.cancelFunction){
			dojo.event.connect(this.cancelButton, "onclick", this.cancelFunction);
		}else{
			this.cancelButton.style.display = "none";
		}
		dojo.event.connect(this.doneButton, "onclick", this, "done");
		this.nextButton.value = this.nextButtonLabel;
		this.previousButton.value = this.previousButtonLabel;
		this.cancelButton.value = this.cancelButtonLabel;
		this.doneButton.value = this.doneButtonLabel;
	},

	checkButtons: function(){
		var lastStep = !this.hasNextPanel();
		this.nextButton.disabled = lastStep;
		this.setButtonClass(this.nextButton);
		if(this.selected.doneFunction){
			this.doneButton.style.display = "";
			// hide the next button if this is the last one and we have a done function
			if(lastStep){
				this.nextButton.style.display = "none";
			}
		}else{
			this.doneButton.style.display = "none";
		}
		this.previousButton.disabled = ((!this.hasPreviousPanel()) || (!this.selected.canGoBack));
		this.setButtonClass(this.previousButton);
	},

	setButtonClass: function(button){
		if(!this.hideDisabledButtons){
			button.style.display = "";
			dojo.html.setClass(button, button.disabled ? "WizardButtonDisabled" : "WizardButton");
		}else{
			button.style.display = button.disabled ? "none" : "";
		}
	},

	registerChild: function(panel, insertionIndex){
		dojo.widget.WizardContainer.superclass.registerChild.call(this, panel, insertionIndex);
		this.wizardPanelContainerNode.appendChild(panel.domNode);
		panel.hide();

		if(!this.selected){
			this.onSelected(panel);
		}
		this.checkButtons();
	},

	onSelected: function(panel){
		// Deselect old panel and select new one
		if(this.selected ){
			if (this.selected.checkPass()) {
				this.selected.hide();
			} else {
				return;
			}
		}
		panel.show();
		this.selected = panel;
	},

	getPanels: function() {
		return this.getChildrenOfType("WizardPane", false);
	},

	selectedIndex: function() {
		if (this.selected) {
			return dojo.lang.indexOf(this.getPanels(), this.selected);
		}
		return -1;
	},

	nextPanel: function() {
		var selectedIndex = this.selectedIndex();
		if ( selectedIndex > -1 ) {
			var childPanels = this.getPanels();
			if (childPanels[selectedIndex + 1]) {
				this.onSelected(childPanels[selectedIndex + 1]);
			}
		}
		this.checkButtons();
	},

	previousPanel: function() {
		var selectedIndex = this.selectedIndex();
		if ( selectedIndex > -1 ) {
			var childPanels = this.getPanels();
			if (childPanels[selectedIndex - 1]) {
				this.onSelected(childPanels[selectedIndex - 1]);
			}
		}
		this.checkButtons();
	},

	hasNextPanel: function() {
		var selectedIndex = this.selectedIndex();
		return (selectedIndex < (this.getPanels().length - 1));
	},

	hasPreviousPanel: function() {
		var selectedIndex = this.selectedIndex();
		return (selectedIndex > 0);
	},

	done: function() {
		this.selected.done();
	}
});
dojo.widget.tags.addParseTreeHandler("dojo:WizardContainer");

//////////////////////////////////////////
// WizardPane -- a panel in a wizard
//////////////////////////////////////////
dojo.widget.WizardPane = function() {
	dojo.widget.html.ContentPane.call(this);
}
dojo.inherits(dojo.widget.WizardPane, dojo.widget.html.ContentPane);

dojo.lang.extend(dojo.widget.WizardPane, {
	widgetType: "WizardPane",

	canGoBack: true,

	passFunction: "",
	doneFunction: "",

	fillInTemplate: function(args, frag) {
		if (this.passFunction) {
			this.passFunction = dj_global[this.passFunction];
		}
		if (this.doneFunction) {
			this.doneFunction = dj_global[this.doneFunction];
		}
	},

	checkPass: function() {
		if (this.passFunction && dojo.lang.isFunction(this.passFunction)) {
			var failMessage = this.passFunction();
			if (failMessage) {
				alert(failMessage);
				return false;
			}
		}
		return true;
	},

	done: function() {
		if (this.doneFunction && dojo.lang.isFunction(this.doneFunction)) {
			this.doneFunction();
		}
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:WizardPane");

__CPAN_FILE__ src/widget/YahooMap.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.YahooMap");
dojo.provide("dojo.widget.YahooMap.Controls");
dojo.require("dojo.widget.*");

dojo.widget.defineWidget(
	"dojo.widget.YahooMap",
	dojo.widget.Widget,
	{ isContainer: false }
);

dojo.widget.YahooMap.Controls={
	MapType:"maptype",
	Pan:"pan",
	ZoomLong:"zoomlong",
	ZoomShort:"zoomshort"
};
dojo.requireAfterIf("html", "dojo.widget.html.YahooMap");

__CPAN_FILE__ src/widget/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.kwCompoundRequire({
	common: ["dojo.xml.Parse", 
			 "dojo.widget.Widget", 
			 "dojo.widget.Parse", 
			 "dojo.widget.Manager"],
	browser: ["dojo.widget.DomWidget",
			  "dojo.widget.HtmlWidget"],
	dashboard: ["dojo.widget.DomWidget",
			  "dojo.widget.HtmlWidget"],
	svg: 	 ["dojo.widget.SvgWidget"]
});
dojo.provide("dojo.widget.*");

__CPAN_DIR__ src/widget/html
__CPAN_FILE__ src/widget/html/AccordionPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.AccordionPane");
dojo.require("dojo.widget.TitlePane");

dojo.widget.html.AccordionPane = function(){

	dojo.widget.html.TitlePane.call(this);
	this.widgetType = "AccordionPane";

	this.open=false;
	this.allowCollapse=true;
	this.label="";
	this.open=false;

	this.labelNodeClass="";
	this.containerNodeClass="";
}

dojo.inherits(dojo.widget.html.AccordionPane, dojo.widget.html.TitlePane);

dojo.lang.extend(dojo.widget.html.AccordionPane, {
        postCreate: function() {
                dojo.widget.html.AccordionPane.superclass.postCreate.call(this);
		this.domNode.widgetType=this.widgetType;
		this.setSizes();
		dojo.html.addClass(this.labelNode, this.labelNodeClass);
		dojo.html.disableSelection(this.labelNode);
		dojo.html.addClass(this.containerNode, this.containerNodeClass);
        },

	collapse: function() {
		//dojo.fx.html.wipeOut(this.containerNode,250);
		//var anim = dojo.fx.html.wipe(this.containerNode, 1000, this.containerNode.offsetHeight, 0, null, true);
		this.containerNode.style.display="none";
		this.open=false;
	},

	expand: function() {
		//dojo.fx.html.wipeIn(this.containerNode,250);
		this.containerNode.style.display="block";
		//var anim = dojo.fx.html.wipe(this.containerNode, 1000, 0, this.containerNode.scrollHeight, null, true);
		this.open=true;
	},

	getCollapsedHeight: function() {
		return dojo.style.getOuterHeight(this.labelNode)+1;
	},

	setSizes: function() {
		var siblings = this.domNode.parentNode.childNodes;
		var height=dojo.style.getInnerHeight(this.domNode.parentNode)-this.getCollapsedHeight();

		this.siblingWidgets = [];
	
		for (var x=0; x<siblings.length; x++) {
			if (siblings[x].widgetType==this.widgetType) {
				if (this.domNode != siblings[x]) {
					var ap = dojo.widget.byNode(siblings[x]);
					this.siblingWidgets.push(ap);
					height -= ap.getCollapsedHeight();
				}
			}
		}
	
		for (var x=0; x<this.siblingWidgets.length; x++) {
			dojo.style.setOuterHeight(this.siblingWidgets[x].containerNode,height);
		}

		dojo.style.setOuterHeight(this.containerNode,height);
	},

	onLabelClick: function() {
		this.setSizes();
		if (!this.open) { 
			for (var x=0; x<this.siblingWidgets.length;x++) {
				if (this.siblingWidgets[x].open) {
					this.siblingWidgets[x].collapse();
				}
			}
			this.expand();
		} else {
			if (this.allowCollapse) {
				this.collapse();
			}
		}
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:AccordionPane");

__CPAN_FILE__ src/widget/html/Button.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.Button");
dojo.require("dojo.lang.extras");
dojo.require("dojo.html");
dojo.require("dojo.style");

dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.Button");

dojo.widget.html.Button = function(){
	// call superclass constructors
	dojo.widget.HtmlWidget.call(this);
	dojo.widget.Button.call(this);
}
dojo.inherits(dojo.widget.html.Button, dojo.widget.HtmlWidget);
dojo.lang.extend(dojo.widget.html.Button, dojo.widget.Button.prototype);
dojo.lang.extend(dojo.widget.html.Button, {

	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlButtonTemplate.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlButtonTemplate.css"),
	
	// button images
	inactiveImg: "src/widget/templates/images/soriaButton-",
	activeImg: "src/widget/templates/images/soriaActive-",
	pressedImg: "src/widget/templates/images/soriaPressed-",
	disabledImg: "src/widget/templates/images/soriaDisabled-",
	width2height: 1.0/3.0,

	// attach points
	containerNode: null,
	leftImage: null,
	centerImage: null,
	rightImage: null,

	fillInTemplate: function(args, frag){
		if(this.caption != ""){
			this.containerNode.appendChild(document.createTextNode(this.caption));
		}
		dojo.html.disableSelection(this.containerNode);
		if ( this.disabled ) {
			dojo.html.prependClass(this.domNode, "dojoButtonDisabled");
		}
		
		// after the browser has had a little time to calculate the size needed
		// for the button contents, size the button
		dojo.lang.setTimeout(this, this.sizeMyself, 0);
	},

	sizeMyself: function(e){
		this.height = dojo.style.getOuterHeight(this.containerNode);
		this.containerWidth = dojo.style.getOuterWidth(this.containerNode);
		var endWidth= this.height * this.width2height;

		this.containerNode.style.left=endWidth+"px";

		this.leftImage.height = this.rightImage.height = this.centerImage.height = this.height;
		this.leftImage.width = this.rightImage.width = endWidth+1;
		this.centerImage.width = this.containerWidth;
		this.centerImage.style.left=endWidth+"px";
		this._setImage(this.disabled ? this.disabledImg : this.inactiveImg);
			
		this.domNode.style.height=this.height + "px";
		this.domNode.style.width= (this.containerWidth+2*endWidth) + "px";
	},

	onMouseOver: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.domNode, "dojoButtonHover");
		this._setImage(this.activeImg);
	},

	onMouseDown: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.domNode, "dojoButtonDepressed");
		dojo.html.removeClass(this.domNode, "dojoButtonHover");
		this._setImage(this.pressedImg);
	},
	onMouseUp: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.domNode, "dojoButtonHover");
		dojo.html.removeClass(this.domNode, "dojoButtonDepressed");
		this._setImage(this.activeImg);
	},

	onMouseOut: function(e){
		if( this.disabled ){ return; }
		dojo.html.removeClass(this.domNode, "dojoButtonHover");
		this._setImage(this.inactiveImg);
	},

	buttonClick: function(e){
		if( !this.disabled && this.onClick ) { this.onClick(e); }
	},

	_setImage: function(prefix){
		this.leftImage.src=dojo.uri.dojoUri(prefix + "l.gif");
		this.centerImage.src=dojo.uri.dojoUri(prefix + "c.gif");
		this.rightImage.src=dojo.uri.dojoUri(prefix + "r.gif");
	},
	
	_toggleMenu: function(menuId){
		var menu = dojo.widget.getWidgetById(menuId);
		if ( !menu ) { return; }

		if ( menu.open && !menu.isShowingNow) {
			var pos = dojo.style.getAbsolutePosition(this.domNode, false);
			menu.open(pos.x, pos.y+this.height, this);
		} else if ( menu.close && menu.isShowingNow ){
			menu.close();
		} else {
			menu.toggle();
		}
	},
	
	onParentResized: function(){
		// Not sure why this is necessary; but if button is inside a hidden floating
		// pane (see Mail.html demo).  Revisit when buttons are redesigned
		this.sizeMyself();
	}
});

/**** DropDownButton - push the button and a menu shows up *****/
dojo.widget.html.DropDownButton = function(){
	// call constructors of superclasses
	dojo.widget.DropDownButton.call(this);
	dojo.widget.html.Button.call(this);
}
dojo.inherits(dojo.widget.html.DropDownButton, dojo.widget.html.Button);
dojo.lang.extend(dojo.widget.html.DropDownButton, dojo.widget.DropDownButton.prototype);

dojo.lang.extend(dojo.widget.html.DropDownButton, {

	downArrow: "src/widget/templates/images/whiteDownArrow.gif",
	disabledDownArrow: "src/widget/templates/images/whiteDownArrow.gif",

	fillInTemplate: function(args, frag){
		dojo.widget.html.DropDownButton.superclass.fillInTemplate.call(this, args, frag);

		// draw the arrow
		var arrow = document.createElement("img");
		arrow.src = dojo.uri.dojoUri(this.disabled ? this.disabledDownArrow : this.downArrow);
		dojo.html.setClass(arrow, "downArrow");
		this.containerNode.appendChild(arrow);
	},

	onClick: function (e){
		if( this.disabled ){ return; }
		this._toggleMenu(this.menuId);
	}
});

/**** ComboButton - left side is normal button, right side shows menu *****/
dojo.widget.html.ComboButton = function(){
	// call constructors of superclasses
	dojo.widget.html.Button.call(this);
	dojo.widget.ComboButton.call(this);
}
dojo.inherits(dojo.widget.html.ComboButton, dojo.widget.html.Button);
dojo.lang.extend(dojo.widget.html.ComboButton, dojo.widget.ComboButton.prototype);
dojo.lang.extend(dojo.widget.html.ComboButton, {

	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlComboButtonTemplate.html"),

	// attach points
	leftPart: null,
	rightPart: null,
	arrowBackgroundImage: null,

	// constants
	splitWidth: 2,		// pixels between left&right part of button
	arrowWidth: 5,		// width of segment holding down arrow

	sizeMyself: function(e){
		this.height = dojo.style.getOuterHeight(this.containerNode);
		this.containerWidth = dojo.style.getOuterWidth(this.containerNode);
		var endWidth= this.height/3;

		// left part
		this.leftImage.height = this.rightImage.height = this.centerImage.height = 
			this.arrowBackgroundImage.height = this.height;
		this.leftImage.width = endWidth+1;
		this.centerImage.width = this.containerWidth;
		this.leftPart.style.height = this.height + "px";
		this.leftPart.style.width = endWidth + this.containerWidth + "px";
		this._setImageL(this.disabled ? this.disabledImg : this.inactiveImg);

		// right part
		this.arrowBackgroundImage.width=this.arrowWidth;
		this.rightImage.width = endWidth+1;
		this.rightPart.style.height = this.height + "px";
		this.rightPart.style.width = this.arrowWidth + endWidth + "px";
		this._setImageR(this.disabled ? this.disabledImg : this.inactiveImg);

		// outer container
		this.domNode.style.height=this.height + "px";
		var totalWidth = this.containerWidth+this.splitWidth+this.arrowWidth+2*endWidth;
		this.domNode.style.width= totalWidth + "px";
	},

	/** functions on left part of button**/
	leftOver: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.leftPart, "dojoButtonHover");
		this._setImageL(this.activeImg);
	},

	leftDown: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.leftPart, "dojoButtonDepressed");
		dojo.html.removeClass(this.leftPart, "dojoButtonHover");
		this._setImageL(this.pressedImg);
	},
	leftUp: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.leftPart, "dojoButtonHover");
		dojo.html.removeClass(this.leftPart, "dojoButtonDepressed");
		this._setImageL(this.activeImg);
	},

	leftOut: function(e){
		if( this.disabled ){ return; }
		dojo.html.removeClass(this.leftPart, "dojoButtonHover");
		this._setImageL(this.inactiveImg);
	},

	leftClick: function(e){
		if ( !this.disabled && this.onClick ) {
			this.onClick(e);
		}
	},

	_setImageL: function(prefix){
		this.leftImage.src=dojo.uri.dojoUri(prefix + "l.gif");
		this.centerImage.src=dojo.uri.dojoUri(prefix + "c.gif");
	},

	/*** functions on right part of button ***/
	rightOver: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.rightPart, "dojoButtonHover");
		this._setImageR(this.activeImg);
	},

	rightDown: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.rightPart, "dojoButtonDepressed");
		dojo.html.removeClass(this.rightPart, "dojoButtonHover");
		this._setImageR(this.pressedImg);
	},
	rightUp: function(e){
		if( this.disabled ){ return; }
		dojo.html.prependClass(this.rightPart, "dojoButtonHover");
		dojo.html.removeClass(this.rightPart, "dojoButtonDepressed");
		this._setImageR(this.activeImg);
	},

	rightOut: function(e){
		if( this.disabled ){ return; }
		dojo.html.removeClass(this.rightPart, "dojoButtonHover");
		this._setImageR(this.inactiveImg);
	},

	rightClick: function(e){
		if( this.disabled ){ return; }
		this._toggleMenu(this.menuId);
	},

	_setImageR: function(prefix){
		this.arrowBackgroundImage.src=dojo.uri.dojoUri(prefix + "c.gif");
		this.rightImage.src=dojo.uri.dojoUri(prefix + "r.gif");
	}
});

__CPAN_FILE__ src/widget/html/Button2.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

// this is a stub that will be removed in 0.4, see ../Button2.html for details

dojo.provide("dojo.widget.html.Button2");

dojo.widget.html.Button2 = function(){}
dojo.inherits(dojo.widget.html.Button2, dojo.widget.html.Button);
dojo.lang.extend(dojo.widget.html.Button2, { widgetType: "Button2" });

dojo.widget.html.DropDownButton2 = function(){}
dojo.inherits(dojo.widget.html.DropDownButton2, dojo.widget.html.DropDownButton);
dojo.lang.extend(dojo.widget.html.DropDownButton2, { widgetType: "DropDownButton2" });

dojo.widget.html.ComboButton2 = function(){}
dojo.inherits(dojo.widget.html.ComboButton2, dojo.widget.html.ComboButton);
dojo.lang.extend(dojo.widget.html.ComboButton2, { widgetType: "ComboButton2" });
__CPAN_FILE__ src/widget/html/Checkbox.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.widget.Checkbox");
dojo.provide("dojo.widget.html.Checkbox");

// FIXME: the input doesn't get taken out of the tab list (i think)
// FIXME: the image doesn't get into the tab list (needs to steal the tabindex value from the input)

dojo.widget.html.Checkbox = function(){
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.html.Checkbox, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.Checkbox, {
	widgetType: "Checkbox",

	_testImg: null,

	_events: [
		"onclick",
		"onfocus",
		"onblur",
		"onselect",
		"onchange",
		"onclick",
		"ondblclick",
		"onmousedown",
		"onmouseup",
		"onmouseover",
		"onmousemove",
		"onmouseout",
		"onkeypress",
		"onkeydown",
		"onkeyup"
	],

	srcOn: dojo.uri.dojoUri('src/widget/templates/check_on.gif'),
	srcOff: dojo.uri.dojoUri('src/widget/templates/check_off.gif'),

	fillInTemplate: function(){

		// FIXME: if images are disabled, we DON'T want to swap out the element
		// we can use the usual 'load image to check' trick
		// i don't know what image we can check yet, so we'll skip this for now...

		// this._testImg = document.createElement("img");
		// document.body.appendChild(this._testImg);
		// this._testImg.src = "spacer.gif?cachebust=" + new Date().valueOf();
		// dojo.connect(this._testImg, 'onload', this, 'onImagesLoaded');

		this.onImagesLoaded();
	},

	onImagesLoaded: function(){

		// FIXME: if we actually check for loading images, remove the thing here
		// document.body.removeChild(this._testImg);

		// 'hide' the checkbox
		this.domNode.style.position = "absolute";
		this.domNode.style.left = "-9000px";

		// create a replacement image
		this.imgNode = document.createElement("img");
		dojo.html.addClass(this.imgNode, "dojoHtmlCheckbox");
		this.updateImgSrc();
		dojo.event.connect(this.imgNode, 'onclick', this, 'onClick');
		dojo.event.connect(this.domNode, 'onchange', this, 'onChange');
		this.domNode.parentNode.insertBefore(this.imgNode, this.domNode.nextSibling)

		// real ugly - make sure the image has all the events that the checkbox did
		for(var i=0; i<this._events.length; i++){
			if(this.domNode[this._events[i]]){
				dojo.event.connect(	this.imgNode, this._events[i], 
									this.domNode[this._events[i]]);
			}
		}
	},

	onClick: function(){

		this.domNode.checked = !this.domNode.checked ? true : false;
		this.updateImgSrc();
	},

	onChange: function(){

		this.updateImgSrc();
	},

	updateImgSrc: function(){

		this.imgNode.src = this.domNode.checked ? this.srcOn : this.srcOff;
	}
});


__CPAN_FILE__ src/widget/html/ComboBox.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.ComboBox");
dojo.require("dojo.widget.ComboBox");
dojo.require("dojo.widget.*");
dojo.require("dojo.io.*");
dojo.require("dojo.lfx.*");
dojo.require("dojo.dom");
dojo.require("dojo.html");
dojo.require("dojo.string");
dojo.require("dojo.widget.html.stabile");

dojo.widget.html.ComboBox = function(){
	dojo.widget.ComboBox.call(this);
	dojo.widget.HtmlWidget.call(this);

	this.autoComplete = true;
	this.formInputName = "";
	this.name = ""; // clone in the name from the DOM node
	this.textInputNode = null;
	this.comboBoxValue = null;
	this.comboBoxSelectionValue = null;
	this.optionsListWrapper = null;
	this.optionsListNode = null;
	this.downArrowNode = null;
	this.cbTableNode = null;
	this.searchTimer = null;
	this.searchDelay = 100;
	this.dataUrl = "";
	// maxListLength limits list to X visible rows, scroll on rest 
	this.maxListLength = 8; 
	// mode can also be "remote" for JSON-returning live search or "html" for
	// dumber live search
	this.mode = "local"; 
	this.selectedResult = null;
	this._highlighted_option = null;
	this._prev_key_backspace = false;
	this._prev_key_esc = false;
	this._result_list_open = false;
	this._gotFocus = false;
	this._mouseover_list = false;

}

dojo.inherits(dojo.widget.html.ComboBox, dojo.widget.HtmlWidget);

// copied from superclass since we can't really over-ride via prototype
dojo.lang.extend(dojo.widget.html.ComboBox, dojo.widget.ComboBox.defaults);

dojo.lang.extend(dojo.widget.html.ComboBox, {


	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlComboBox.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlComboBox.css"),

	setValue: function(value) {
		this.comboBoxValue.value = value;
		if (this.textInputNode.value != value) { // prevent mucking up of selection
			this.textInputNode.value = value;
		}
		dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
	},

	getValue: function() {
		return this.comboBoxValue.value;
	},

	getState: function() {
		return {value: this.getValue()};
	},

	setState: function(state) {
		this.setValue(state.value);
	},

	getCaretPos: function(element){
		// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
		if(dojo.lang.isNumber(element.selectionStart)){
			// FIXME: this is totally borked on Moz < 1.3. Any recourse?
			return element.selectionStart;
		}else if(dojo.render.html.ie){
			// in the case of a mouse click in a popup being handled,
			// then the document.selection is not the textarea, but the popup
			// var r = document.selection.createRange();
			// hack to get IE 6 to play nice. What a POS browser.
			var tr = document.selection.createRange().duplicate();
			var ntr = element.createTextRange();
			tr.move("character",0);
			ntr.move("character",0);
			try {
				// If control doesnt have focus, you get an exception.
				// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
				// There appears to be no workaround for this - googled for quite a while.
				ntr.setEndPoint("EndToEnd", tr);
				return String(ntr.text).replace(/\r/g,"").length;
			} catch (e) {
				return 0; // If focus has shifted, 0 is fine for caret pos.
			}
			
		}
	},

	setCaretPos: function(element, location){
		location = parseInt(location);
		this.setSelectedRange(element, location, location);
	},

	setSelectedRange: function(element, start, end){
		if(!end){ end = element.value.length; }  // NOTE: Strange - should be able to put caret at start of text?
		// Mozilla
		// parts borrowed from http://www.faqts.com/knowledge_base/view.phtml/aid/13562/fid/130
		if(element.setSelectionRange){
			element.focus();
			element.setSelectionRange(start, end);
		}else if(element.createTextRange){ // IE
			var range = element.createTextRange();
			with(range){
				collapse(true);
				moveEnd('character', end);
				moveStart('character', start);
				select();
			}
		}else{ //otherwise try the event-creation hack (our own invention)
			// do we need these?
			element.value = element.value;
			element.blur();
			element.focus();
			// figure out how far back to go
			var dist = parseInt(element.value.length)-end;
			var tchar = String.fromCharCode(37);
			var tcc = tchar.charCodeAt(0);
			for(var x = 0; x < dist; x++){
				var te = document.createEvent("KeyEvents");
				te.initKeyEvent("keypress", true, true, null, false, false, false, false, tcc, tcc);
				twe.dispatchEvent(te);
			}
		}
	},

	// does the keyboard related stuff
	_handleKeyEvents: function(evt){
		if(evt.ctrlKey || evt.altKey){ return; }

		// reset these
		this._prev_key_backspace = false;
		this._prev_key_esc = false;

		var k = dojo.event.browser.keys;
		var doSearch = true;

		// mozilla quirk 
		// space has no keyCode in mozilla
		var keyCode = evt.keyCode;
		if(keyCode==0 && evt.charCode==k.KEY_SPACE){
			keyCode = k.KEY_SPACE;
		}
		switch(keyCode){
 			case k.KEY_DOWN_ARROW:
				if(!this._result_list_open){
					this.startSearchFromInput();
				}
				this.highlightNextOption();
				dojo.event.browser.stopEvent(evt);
				return;
			case k.KEY_UP_ARROW:
				this.highlightPrevOption();
				dojo.event.browser.stopEvent(evt);
				return;
			case k.KEY_ENTER:
				// prevent to send form if we press enter with list open
				if(this._result_list_open){
					dojo.event.browser.stopEvent(evt);
				}
				// falltrough
			case k.KEY_TAB:
				// using linux alike tab for autocomplete
				if(!this.autoComplete && this._result_list_open && this._highlighted_option){
					dojo.event.browser.stopEvent(evt);
					this.selectOption({ 'target': this._highlighted_option, 'noHide': true });

					// put caret last
					this.setSelectedRange(this.textInputNode, this.textInputNode.value.length, null);
				}else{
					this.selectOption();
					return;
				}
				break;
			case k.KEY_SPACE:
				if(this._result_list_open && this._highlighted_option){
					dojo.event.browser.stopEvent(evt);
					this.selectOption();
					this.hideResultList();
					return;
				}
				break;
			case k.KEY_ESCAPE:
				this.hideResultList();
				this._prev_key_esc = true;
				return;
			case k.KEY_BACKSPACE:
				this._prev_key_backspace = true;
				if(!this.textInputNode.value.length){
					this.hideResultList();
					doSearch = false;
				}
				break;
			case k.KEY_RIGHT_ARROW: // falltrough
			case k.KEY_LEFT_ARROW: // falltrough
			case k.KEY_SHIFT:
				doSearch = false;
				break;
			default:// non char keys (F1-F12 etc..)  shouldnt open list
				if(evt.charCode==0){
					doSearch = false;
				}
		}

// 		this.setValue(this.textInputNode.value);
		if(this.searchTimer){
			clearTimeout(this.searchTimer);
		}
		if(doSearch){
			// if we have gotten this far we dont want to keep our highlight
			this.blurOptionNode();

			// need to wait a tad before start search so that the event bubbels through DOM and we have value visible
			this.searchTimer = setTimeout(dojo.lang.hitch(this, this.startSearchFromInput), this.searchDelay);
		}
	},

	onKeyDown: function(evt){
		// IE needs to stop keyDown others need to stop keyPress
		if(!document.createEvent){ // only IE
			this._handleKeyEvents(evt);
		}
		// FIXME: What about ESC ??
	},

	onKeyPress: function(evt){
		if(document.createEvent){ // never IE
			this._handleKeyEvents(evt);
		}
	},

	onKeyUp: function(evt){
		this.setValue(this.textInputNode.value);
	},

	setSelectedValue: function(value){
		// FIXME, not sure what to do here!
		this.comboBoxSelectionValue.value = value;
		this.hideResultList();
	},

	// opera, khtml, safari doesnt support node.scrollIntoView(), workaround
	scrollIntoView: function(){
		var node = this._highlighted_option;
		var parent = this.optionsListNode;
		// dont rely on that node.scrollIntoView works just because the function is there
		// it doesnt work in Konqueror or Opera even though the function is there and probably
		// not safari either
		// dont like browser sniffs implementations but sometimes you have to use it
		if(dojo.render.html.ie || dojo.render.html.mozilla){
			// IE, mozilla
			node.scrollIntoView(false);	
		}else{
			var parentBottom = parent.scrollTop + dojo.style.getInnerHeight(parent);
			var nodeBottom = node.offsetTop + dojo.style.getOuterHeight(node);
			if(parentBottom < nodeBottom){
				parent.scrollTop += (nodeBottom - parentBottom);
			}else if(parent.scrollTop > node.offsetTop){
				parent.scrollTop -= (parent.scrollTop - node.offsetTop);
			}
		}
	},

	// does the actual highlight
	focusOptionNode: function(node){
		if(this._highlighted_option != node){
			this.blurOptionNode();
			this._highlighted_option = node;
			dojo.html.addClass(this._highlighted_option, "dojoComboBoxItemHighlight");
		}
	},

	// removes highlight on highlighted
	blurOptionNode: function(){
		if(this._highlighted_option){
			dojo.html.removeClass(this._highlighted_option, "dojoComboBoxItemHighlight");
			this._highlighted_option = null;
		}
	},

	highlightNextOption: function(){
		if((!this._highlighted_option) || !this._highlighted_option.parentNode){
			this.focusOptionNode(this.optionsListNode.firstChild);
		}else if(this._highlighted_option.nextSibling){
			this.focusOptionNode(this._highlighted_option.nextSibling);
		}
		this.scrollIntoView();
	},

	highlightPrevOption: function(){
		if(this._highlighted_option && this._highlighted_option.previousSibling){
			this.focusOptionNode(this._highlighted_option.previousSibling);
		}else{
			this._highlighted_option = null;
			this.hideResultList();
			return;
		}
		this.scrollIntoView();
	},

	itemMouseOver: function(evt){
		this.focusOptionNode(evt.target);
		dojo.html.addClass(this._highlighted_option, "dojoComboBoxItemHighlight");
	},

	itemMouseOut: function(evt){
		this.blurOptionNode();
	},

	fillInTemplate: function(args, frag){
		// FIXME: need to get/assign DOM node names for form participation here.
		this.comboBoxValue.name = this.name;
		this.comboBoxSelectionValue.name = this.name+"_selected";

		// NOTE: this doesn't copy style info inherited from classes;
		// it's just primitive support for direct style setting
		var source = this.getFragNodeRef(frag);
		if ( source.style ){
			// get around opera wich doesnt have cssText, and IE wich bugs on setAttribute 
			if(dojo.lang.isUndefined(source.style.cssText)){ 
				this.domNode.setAttribute("style", source.getAttribute("style")); 
			}else{
				this.domNode.style.cssText = source.style.cssText; 
			}
		}

		// FIXME: add logic
		this.dataProvider = new dojo.widget.ComboBoxDataProvider();

		if(!dojo.string.isBlank(this.dataUrl)){
			if("local" == this.mode){
				var _this = this;
				dojo.io.bind({
					url: this.dataUrl,
					load: function(type, data, evt){ 
						if(type=="load"){
							if(!dojo.lang.isArray(data)){
								var arrData = [];
								for(var key in data){
									arrData.push([data[key], key]);
								}
								data = arrData;
							}
							_this.dataProvider.setData(data);
						}
					},
					mimetype: "text/json"
				});
			}else if("remote" == this.mode){
				this.dataProvider = new dojo.widget.incrementalComboBoxDataProvider(this.dataUrl);
			}
		}else{
			// check to see if we can populate the list from <option> elements
			var node = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
			if((node)&&(node.nodeName.toLowerCase() == "select")){
				// NOTE: we're not handling <optgroup> here yet
				var opts = node.getElementsByTagName("option");
				var ol = opts.length;
				var data = [];
				for(var x=0; x<ol; x++){
					var keyValArr = [new String(opts[x].innerHTML), new String(opts[x].value)];
					data.push(keyValArr);
					if(opts[x].selected){ 
						this.setValue(keyValArr[0]); 
						this.comboBoxSelectionValue.value = keyValArr[1];
					}
				}
				this.dataProvider.setData(data);
			}
		}

		// Prevent IE bleed-through problem
		this.optionsIframe = new dojo.html.BackgroundIframe(this.optionsListWrapper);
		this.optionsIframe.size([0,0,0,0]);
	},


	focus: function(){
		// summary
		//	set focus to input node from code
		this.tryFocus();
	},

	openResultList: function(results){
		this.clearResultList();
		if(!results.length){
			this.hideResultList();
		}

		if(	(this.autoComplete)&&
			(results.length)&&
			(!this._prev_key_backspace)&&
			(this.textInputNode.value.length > 0)){
			var cpos = this.getCaretPos(this.textInputNode);
			// only try to extend if we added the last charachter at the end of the input
			if((cpos+1) > this.textInputNode.value.length){
				// only add to input node as we would overwrite Capitalisation of chars
				this.textInputNode.value += results[0][0].substr(cpos);
				// build a new range that has the distance from the earlier
				// caret position to the end of the first string selected
				this.setSelectedRange(this.textInputNode, cpos, this.textInputNode.value.length);
			}
		}

		var even = true;
		while(results.length){
			var tr = results.shift();
			if(tr){
				var td = document.createElement("div");
				td.appendChild(document.createTextNode(tr[0]));
				td.setAttribute("resultName", tr[0]);
				td.setAttribute("resultValue", tr[1]);
				td.className = "dojoComboBoxItem "+((even) ? "dojoComboBoxItemEven" : "dojoComboBoxItemOdd");
				even = (!even);
				this.optionsListNode.appendChild(td);
				dojo.event.connect(td, "onmouseover", this, "itemMouseOver");
				dojo.event.connect(td, "onmouseout", this, "itemMouseOut");
			}
		}

		// show our list (only if we have content, else nothing)
		this.showResultList();
	},

	onFocusInput: function(){
		this._hasFocus = true;
	},

	onBlurInput: function(){
		this._hasFocus = false;
		this._handleBlurTimer(true, 100);
	},

	// collect all blur timers issues here
	_handleBlurTimer: function(/*Boolean*/clear, /*Number*/ millisec){
		if(this.blurTimer && (clear || millisec)){
			clearTimeout(this.blurTimer);
		}
		if(millisec){ // we ignore that zero is false and never sets as that never happens in this widget
			this.blurTimer = dojo.lang.setTimeout(this, "checkBlurred", millisec);
		}
	},

	// these 2 are needed in IE and Safari as inputTextNode looses focus when scrolling optionslist
	_onMouseOver: function(evt){
		if(!this._mouseover_list){
			this._handleBlurTimer(true, 0);
			this._mouseover_list = true;
		}
	},

	_onMouseOut:function(evt){
		var relTarget = evt.relatedTarget;
		if(!relTarget || relTarget.parentNode!=this.optionsListNode){
			this._mouseover_list = false;
			this._handleBlurTimer(true, 100);
			this.tryFocus();
		}
	},

	checkBlurred: function(){
		if(!this._hasFocus && !this._mouseover_list){
			this.hideResultList();
		}
	},

	sizeBackgroundIframe: function(){
		var w = dojo.style.getOuterWidth(this.optionsListNode);
		var h = dojo.style.getOuterHeight(this.optionsListNode);
		if( w==0 || h==0 ){
			// need more time to calculate size
			dojo.lang.setTimeout(this, "sizeBackgroundIframe", 100);
			return;
		}
		if(this._result_list_open){
			this.optionsIframe.size([0,0,w,h]);
		}
	},

	selectOption: function(evt){
		if(!evt){
			evt = { target: this._highlighted_option };
		}

		if(!dojo.dom.isDescendantOf(evt.target, this.optionsListNode)){
			return;
		}

		var tgt = evt.target;
		while((tgt.nodeType!=1)||(!tgt.getAttribute("resultName"))){
			tgt = tgt.parentNode;
			if(tgt === document.body){
				return false;
			}
		}

		this.textInputNode.value = tgt.getAttribute("resultName");
		this.selectedResult = [tgt.getAttribute("resultName"), tgt.getAttribute("resultValue")];
		this.setValue(tgt.getAttribute("resultName"));
		this.comboBoxSelectionValue.value = tgt.getAttribute("resultValue");
		if(!evt.noHide){
			this.hideResultList();
			this.setSelectedRange(this.textInputNode, 0, null);
		}
		this.tryFocus();
	},

	clearResultList: function(){
		var oln = this.optionsListNode;
		while(oln.firstChild){
			dojo.event.disconnect(oln.firstChild, "onmouseover", this, "itemMouseOver");
			dojo.event.disconnect(oln.firstChild, "onmouseout", this, "itemMouseOut");
			oln.removeChild(oln.firstChild);
		}
	},

	hideResultList: function(){
		if(this._result_list_open){
			this._result_list_open = false;
			this.optionsIframe.size([0,0,0,0]);
			dojo.lfx.fadeHide(this.optionsListNode, 200).play();
		}
	},

	showResultList: function(){
		// Our dear friend IE doesnt take max-height so we need to calculate that on our own every time
		var childs = this.optionsListNode.childNodes;
		if(childs.length){
			var visibleCount = this.maxListLength;
			if(childs.length < visibleCount){
				visibleCount = childs.length;
			}

			with(this.optionsListNode.style){
				display = "";
				height = ((visibleCount) ? (dojo.style.getOuterHeight(childs[0]) * visibleCount) : 0)+"px";
				width = dojo.html.getOuterWidth(this.cbTableNode)+"px";
			}
			// only fadein once (flicker)
			if(!this._result_list_open){
				dojo.html.setOpacity(this.optionsListNode, 0);
				dojo.lfx.fadeIn(this.optionsListNode, 200).play();
			}
			
			// prevent IE bleed through
			this._iframeTimer = dojo.lang.setTimeout(this, "sizeBackgroundIframe", 200);
			this._result_list_open = true;
		}else{
			this.hideResultList();
		}
	},

	handleArrowClick: function(){
		this._handleBlurTimer(true, 0);
		this.tryFocus();
		if(this._result_list_open){
			this.hideResultList();
		}else{
			this.startSearchFromInput();
		}
	},

	tryFocus: function(){
		try {    
			this.textInputNode.focus();
		} catch (e) {
			// element isnt focusable if disabled, or not visible etc - not easy to test for.
 		};
	},
	
	startSearchFromInput: function(){
		this.startSearch(this.textInputNode.value);
	},

	postCreate: function(){
		dojo.event.connect(this, "startSearch", this.dataProvider, "startSearch");
		dojo.event.connect(this.dataProvider, "provideSearchResults", this, "openResultList");
		dojo.event.connect(this.textInputNode, "onblur", this, "onBlurInput");
		dojo.event.connect(this.textInputNode, "onfocus", this, "onFocusInput");

		var s = dojo.widget.html.stabile.getState(this.widgetId);
		if (s) {
			this.setState(s);
		}
	}
});

__CPAN_FILE__ src/widget/html/ContentPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.ContentPane");

dojo.require("dojo.widget.*");
dojo.require("dojo.io.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.ContentPane");
dojo.require("dojo.string");
dojo.require("dojo.string.extras");
dojo.require("dojo.style");

dojo.widget.html.ContentPane = function(){
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.html.ContentPane, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.ContentPane, {
	widgetType: "ContentPane",
	isContainer: true,

	// remote loading options
	href: "",
	extractContent: true,
	parseContent: true,
	cacheContent: true,
	preload: false,			// force load of data even if pane is hidden
	refreshOnShow: false,
	handler: "",			// generate pane content from a java function
	executeScripts: false,	// if true scripts in content will be evaled after content is set and parsed
	scriptScope: null,		// scopeContainer for downloaded scripts

		// If the user want a global in the remote script he/she just omitts the var
		// examples:
		//--------------------------
		// these gets collected by scriptScope and is reached by dojo.widget.byId('..').scriptScope.myCustomproperty
		//	this.myString = "dojo is a great javascript toolkit!";
		//
		//	this.alertMyString = function(){
		//		alert(myString);
		//	}
		// -------------------------
		// these go into the global namespace (window) notice lack of var, equiv to window.myString
		//	myString = "dojo is a javascript toolkit!";
		//
		//	alertMyString = function(){
		//		alert(myString);
		// }


	// private
	_remoteStyles: null,	// array of stylenodes inserted to document head
							// by remote content, used when we clean up for new content

	_callOnUnLoad: false,		// used by setContent and _handleDefults, makes sure onUnLoad is only called once


	postCreate: function(args, frag, parentComp){
		if ( this.handler != "" ){
			this.setHandler(this.handler);
		}
		if(this.isShowing()||this.preload){ this.loadContents(); }
	},

	show: function(){
		// if refreshOnShow is true, reload the contents every time; otherwise, load only the first time
		if(this.refreshOnShow){
			this.refresh();
		}else{
			this.loadContents();
		}
		dojo.widget.html.ContentPane.superclass.show.call(this);
	},

	refresh: function(){
		this.isLoaded=false;
		this.loadContents();
	},

	loadContents: function() {
		if ( this.isLoaded ){
			return;
		}
		this.isLoaded=true;
		if ( dojo.lang.isFunction(this.handler)) {
			this._runHandler();
		} else if ( this.href != "" ) {
			this._downloadExternalContent(this.href, this.cacheContent);
		}
	},

	
	setUrl: function(/*String*/ url) {
		// summary:
		// 	Reset the (external defined) content of this pane and replace with new url
		this.href = url;
		this.isLoaded = false;
		if ( this.preload || this.isShowing() ){
			this.loadContents();
		}
	},

	_downloadExternalContent: function(url, useCache) {
		this._handleDefaults("Loading...", "onDownloadStart");
		var self = this;
		dojo.io.bind({
			url: url,
			useCache: useCache,
			preventCache: !useCache,
			mimetype: "text/html",
			handler: function(type, data, e) {
				if(type == "load") {
					self.onDownloadEnd.call(self, url, data);
				} else {
					// works best when from a live serveer instead of from file system
					self._handleDefaults.call(self, "Error loading '" + url + "' (" + e.status + " "+  e.statusText + ")", "onDownloadError");
					self.onLoad();
				}
			}
		});
	},

	// called when setContent is finished
	onLoad: function(e){ /*stub*/ },

	// called before old content is cleared
	onUnLoad: function(e){ 
			this.scriptScope = null;
	},

	destroy: function(){
		// make sure we call onUnLoad
		this.onUnLoad();
		dojo.widget.html.ContentPane.superclass.destroy.call(this);
	},

	// called when content script eval error or Java error occurs, preventDefault-able
	onExecError: function(e){ /*stub*/ },

	// called on DOM faults, require fault etc in content, preventDefault-able
	onContentError: function(e){ /*stub*/ },

	// called when download error occurs, preventDefault-able
	onDownloadError: function(e){ /*stub*/ },

	// called before download starts, preventDefault-able
	onDownloadStart: function(e){ /*stub*/ },

	// called when download is finished
	onDownloadEnd: function(url, data){
		data = this.splitAndFixPaths(data, url);
		this.setContent(data);
	},

	// usefull if user wants to prevent default behaviour ie: _setContent("Error...")
	_handleDefaults: function(e, handler, useAlert){
		if(!handler){ handler = "onContentError"; }
		if(dojo.lang.isString(e)){
			e = {
				"text": e,
				"toString": function(){ return this.text; }
			}
		}
		if(typeof e.returnValue != "boolean"){
			e.returnValue = true; 
		}
		if(typeof e.preventDefault != "function"){
			e.preventDefault = function(){
				this.returnValue = false;
			}
		}
		// call our handler
		this[handler](e);
		if(e.returnValue){
			if(useAlert){
				alert(e.toString());
			}else{
				if(this._callOnUnLoad){
					this.onUnLoad(); // makes sure scripts can clean up after themselves, before we setContent
				}
				this._callOnUnLoad = false; // makes sure we dont try to call onUnLoad again on this event,
											// ie onUnLoad before 'Loading...' but not before clearing 'Loading...'
				this._setContent(e.toString());
			}
		}
	},

	
	splitAndFixPaths: function(/*String*/s, /*dojo.uri.Uri?*/url){
		// summary:
		// 	fixes all remote paths in (hopefully) all cases for example images, remote scripts, links etc.
		// 	splits up content in different pieces, scripts, title, style, link and whats left becomes .xml

		if(!url) { url = "./"; } // point to this page if not set
		if(!s) { return ""; }

		// fix up paths in data
		var titles = []; var scripts = []; var linkStyles = [];
		var styles = []; var remoteScripts = []; var requires = [];

		// khtml is much more picky about dom faults, you can't for example attach a style node under body of document
		// must go into head, as does a title node, so we need to cut out those tags
		// cut out title tags
		var match = [];
		while(match){
			match = s.match(/<title[^>]*>([\s\S]*?)<\/title>/i); // can't match with dot as that 
			if(!match){ break;}					//doesnt match newline in js
			titles.push(match[1]);
			s = s.replace(/<title[^>]*>[\s\S]*?<\/title>/i, "");
		}

		// cut out <style> url(...) </style>, as that bails out in khtml
		var match = [];
		while(match){
			match = s.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
			if(!match){ break; }
			styles.push(dojo.style.fixPathsInCssText(match[1], url));
			s = s.replace(/<style[^>]*?>[\s\S]*?<\/style>/i, "");
		}

		// attributepaths one tag can have multiple paths example:
		// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
		// strip out the tag and run fix on that.
		// this guarantees that we won't run replace another tag's attribute + it was easier do
		var pos = 0; var pos2 = 0; var stop = 0 ;var str = ""; var fixedPath = "";
		var attr = []; var fix = ""; var tagFix = ""; var tag = ""; var regex = ""; 
		while(pos>-1){
			pos = s.search(/<[a-z][a-z0-9]*[^>]*\s(?:(?:src|href|style)=[^>])+[^>]*>/i);
			if(pos==-1){ break; }
			str += s.substring(0, pos);
			s = s.substring(pos, s.length);
			tag = s.match(/^<[a-z][a-z0-9]*[^>]*>/i)[0];
			s = s.substring(tag.length, s.length);

			// loop through attributes
			pos2 = 0; tagFix = ""; fix = ""; regex = ""; var regexlen = 0;
			while(pos2!=-1){
				// slices up before next attribute check, values from previous loop
				tagFix += tag.substring(0, pos2) + fix;
				tag = tag.substring(pos2+regexlen, tag.length);

				// fix next attribute or bail out when done
				// hopefully this charclass covers most urls
				attr = tag.match(/ (src|href|style)=(['"]?)([\w()\[\]\/.,\\'"-:;#=&?\s@]+?)\2/i);
				if(!attr){ break; }

				switch(attr[1].toLowerCase()){
					case "src":// falltrough
					case "href":
						// this hopefully covers most common protocols
						if(attr[3].search(/^(?:[#]|(?:(?:https?|ftps?|file|javascript|mailto|news):))/)==-1){
							fixedPath = (new dojo.uri.Uri(url, attr[3]).toString());
						} else {
							pos2 = pos2 + attr[3].length;
							continue;
						}
						break;
					case "style":// style
						fixedPath = dojo.style.fixPathsInCssText(attr[3], url);
						break;
					default:
						pos2 = pos2 + attr[3].length;
						continue;
				}

				regex = " " + attr[1] + "=" + attr[2] + attr[3] + attr[2];
				regexlen = regex.length;
				fix = " " + attr[1] + "=" + attr[2] + fixedPath + attr[2];
				pos2 = tag.search(new RegExp(dojo.string.escapeRegExp(regex)));
			}
			str += tagFix + tag;
			pos = 0; // reset for next mainloop
		}
		s = str+s;

		// cut out all script tags, push them into scripts array
		match = []; var tmp = [];
		while(match){
			match = s.match(/<script([^>]*)>([\s\S]*?)<\/script>/i);
			if(!match){ break; }
			if(match[1]){
				attr = match[1].match(/src=(['"]?)([^"']*)\1/i);
				if(attr){
					// remove a dojo.js or dojo.js.uncompressed.js from remoteScripts
					// we declare all files with dojo.js as bad, regardless of folder
					var tmp = attr[2].search(/.*(\bdojo\b(?:\.uncompressed)?\.js)$/);
					if(tmp > -1){
						dojo.debug("Security note! inhibit:"+attr[2]+" from  beeing loaded again.");
					}else{
						remoteScripts.push(attr[2]);
					}
				}
			}
			if(match[2]){
				// strip out all djConfig variables from script tags nodeValue
				// this is ABSOLUTLY needed as reinitialize djConfig after dojo is initialised
				// makes a dissaster greater than Titanic, update remove writeIncludes() to
				var sc = match[2].replace(/(?:var )?\bdjConfig\b(?:[\s]*=[\s]*\{[^}]+\}|\.[\w]*[\s]*=[\s]*[^;\n]*)?;?|dojo\.hostenv\.writeIncludes\(\s*\);?/g, "");
				if(!sc){ continue; }

				// cut out all dojo.require (...) calls, if we have execute 
				// scripts false widgets dont get there require calls
				// does suck out possible widgetpackage registration as well
				tmp = [];
				while(tmp && requires.length<100){
					tmp = sc.match(/dojo\.(?:(?:require(?:After)?(?:If)?)|(?:widget\.(?:manager\.)?registerWidgetPackage)|(?:(?:hostenv\.)?setModulePrefix))\((['"]).*?\1\)\s*;?/);
					if(!tmp){ break;}
					requires.push(tmp[0]);
					sc = sc.replace(tmp[0], "");
				}
				scripts.push(sc);
			}
			s = s.replace(/<script[^>]*>[\s\S]*?<\/script>/i, "");
		}

		// scan for scriptScope in html eventHandlers and replace with link to this pane
		if(this.executeScripts){
			var regex = /(<[a-zA-Z][a-zA-Z0-9]*\s[^>]*\S=(['"])[^>]*[^\.\]])scriptScope([^>]*>)/;
			var pos = 0;var str = "";match = [];var cit = "";
			while(pos > -1){
				pos = s.search(regex);
				if(pos > -1){
					cit = ((RegExp.$2=="'") ? '"': "'");
					str += s.substring(0, pos);
					s = s.substr(pos).replace(regex, "$1dojo.widget.byId("+ cit + this.widgetId + cit + ").scriptScope$3");
				}
			}
			s = str + s;
		}

		// cut out all <link rel="stylesheet" href="..">
		match = [];
		while(match){
			match = s.match(/<link ([^>]*rel=['"]?stylesheet['"]?[^>]*)>/i);
			if(!match){ break; }
			attr = match[1].match(/href=(['"]?)([^'">]*)\1/i);
			if(attr){
				linkStyles.push(attr[2]);
			}
			s = s.replace(new RegExp(match[0]), "");
		}

		return {"xml": s, // Object
			"styles": styles,
			"linkStyles": linkStyles,
			"titles": titles,
			"requires": 	requires,
			"scripts": scripts,
			"remoteScripts": remoteScripts,
			"url": url};
	},

	
	_setContent: function(/*String*/ xml){
		// summary: 
		//		private internal function without path regExpCheck and no onLoad calls aftervards

		// remove old children from current content
		this.destroyChildren();

		// remove old stylenodes from HEAD
		if(this._remoteStyles){
			for(var i = 0; i < this._remoteStyles.length; i++){
				if(this._remoteStyles[i] && this._remoteStyles.parentNode){
					this._remoteStyles[i].parentNode.removeChild(this._remoteStyles[i]);
				}
			}
			this._remoteStyles = null;
		}

		var node = this.containerNode || this.domNode;
		try{
			if(typeof xml != "string"){
				node.innerHTML = "";
				node.appendChild(xml);
			}else{
				node.innerHTML = xml;
			}
		} catch(e){
			e = "Could'nt load html:"+e;
			this._handleDefaults(e, "onContentError");
		}
	},

	setContent: function(/*String*/ data){
		// summary:
		// 	Destroys old content and setting new content, and possibly initialize any widgets within 'data'

		if(this._callOnUnLoad){ // this tells a remote script clean up after itself
			this.onUnLoad();
		}
		this._callOnUnLoad = true;

		if(!data || dojo.dom.isNode(data)){
			// if we do a clean using setContent(""); or setContent(#node) bypass all parseing, extractContent etc
			this._setContent(data);
		}else{
			// need to run splitAndFixPaths? ie. manually setting content
			 if(!data.xml){
				data = this.splitAndFixPaths(data);
			}
			if(this.extractContent) {
				var matches = data.xml.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches) { data.xml = matches[1]; }
			}
			// insert styleNodes, from <style>....
			for(var i = 0; i < data.styles.length; i++){
				if(i==0){ 
					this._remoteStyles = []; 
				}
				this._remoteStyles.push(dojo.style.insertCssText(data.styles[i]));
			}
			// insert styleNodes, from <link href="...">
			for(var i = 0; i < data.linkStyles.length; i++){
				if(i==0){ 
					this._remoteStyles = []; 
				}
				this._remoteStyles.push(dojo.style.insertCssFile(data.linkStyles[i]));
			}
			this._setContent(data.xml);

			if(this.parseContent){
				for(var i = 0; i < data.requires.length; i++){
					try{ 
						eval(data.requires[i]);
					} catch(e){
						this._handleDefaults(e, "onContentError", true);
					}
				}
				var node = this.containerNode || this.domNode;
				var parser = new dojo.xml.Parse();
				var frag = parser.parseElement(node, null, true);
				// createSubComponents not createComponents because frag has already been created
				dojo.widget.getParser().createSubComponents(frag, this);
			}

			if(this.executeScripts){
				this._executeScripts(data);
			}
		}
		this.onResized(); // move this here so that resize is called when we set "" to reset sizing code
		this.onLoad(); // tell system that we have finished
	},

	// Generate pane content from given java function
	setHandler: function(handler) {
		var fcn = dojo.lang.isFunction(handler) ? handler : window[handler];
		if(!dojo.lang.isFunction(fcn)) {
			// FIXME: needs testing! somebody with java knowledge needs to try this
			this._handleDefaults("Unable to set handler, '" + handler + "' not a function.", "onExecError", true);
			return;
		}
		this.handler = function() {
			return fcn.apply(this, arguments);
		}
	},

	_runHandler: function() {
		if(dojo.lang.isFunction(this.handler)) {
			this.handler(this, this.domNode);
			return false;
		}
		return true;
	},

	_executeScripts: function(data) {
		// do remoteScripts first
		var self = this;
		for(var i = 0; i < data.remoteScripts.length; i++){
			dojo.io.bind({
				"url": data.remoteScripts[i],
				"useCash":	this.cacheContent,
				"load":     function(type, scriptStr){
						dojo.lang.hitch(self, data.scripts.push(scriptStr));
				},
				"error":    function(type, error){
						self._handleDefaults.call(self, type + " downloading remote script", "onExecError", true);
				},
				"mimetype": "text/plain",
				"sync":     true
			});
		}

		var scripts = "";
		for(var i = 0; i < data.scripts.length; i++){
			scripts += data.scripts[i];
		}

			// initialize a new anonymous container for our script, dont make it part of this widgets scope chain
			// instead send in a variable that points to this widget, usefull to connect events to onLoad, onUnLoad etc..
			this.scriptScope = null;
			this.scriptScope = new (new Function('_container_', scripts+'; return this;'))(self);
	try{
		}catch(e){
			this._handleDefaults("Error running scripts from content:\n"+e, "onExecError", true);
		}
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:ContentPane");

__CPAN_FILE__ src/widget/html/ContextMenu.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.ContextMenu");
dojo.require("dojo.html");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.ContextMenu");
dojo.require("dojo.lang");

dojo.widget.html.ContextMenu = function(){
	dojo.widget.ContextMenu.call(this);
	dojo.widget.HtmlWidget.call(this);

	this.isShowing = 0;
	this.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlContextMenuTemplate.html");
	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/Menu.css");

	this.targetNodeIds = []; // fill this with nodeIds upon widget creation and it only responds to those nodes

	// default event detection method 
	var eventType = "oncontextmenu"; 

	var doc = document.documentElement  || document.body; 

	var _blockHide = false; 

	this.fillInTemplate = function(args, frag){

		var func = "onOpen";
		var attached = false;

		// connect with rightclick if oncontextmenu is not around
		// NOTE: It would be very nice to have a dojo.event.browser.supportsEvent here
		// NOTE: Opera does not have rightclick events, it is listed here only because
		//     it bails out when connecting with oncontextmenu event

		if((dojo.render.html.khtml && !dojo.render.html.safari) || (dojo.render.html.opera)){
			eventType = "onmousedown";
			func = "_checkRightClick";
		}

		// attach event listeners to our selected nodes
		for(var i=0; i<this.targetNodeIds.length; i++){
			var node = document.getElementById(this.targetNodeIds[i]);
			if(node){
				dojo.event.connect(node, eventType, this, func);
				attached = true;
			}else{
				// remove this nodeId
				dojo.debug("Couldent find "+this.targetNodeIds[i]+", cant do ContextMenu on this node");
				this.targetNodeIds.splice(i,1);
			}
		}

		// if we got attached to a node, hide on all non node contextevents
		if(attached){ func = "_canHide"; }

		dojo.event.connect(doc, eventType, this, func);
	}

	this.onOpen = function(evt){
		// if (this.isShowing){ this.onHide(evt); } // propably not needed
		this.isShowing = 1;

		// if I do this, I cant preventDefault in khtml
		//evt = dojo.event.browser.fixEvent(evt);
 
		// stop default contextmenu, needed in khtml
		if (evt.preventDefault){ evt.preventDefault(); }

		// need to light up this one before we check width and height
		this.domNode.style.left = "-9999px";
		this.domNode.style.top  = "-9999px";
		this.domNode.style.display = "block";

		// calculate if menu is going to apear within window
		// or if its partially out of visable area
		with(dojo.html){

			var menuW = getInnerWidth(this.domNode);
			var menuH = getInnerHeight(this.domNode);

			var viewport = getViewportSize();
			var scrolloffset = getScrollOffset();
		}

		var minX = viewport[0];
		var minY = viewport[1];

		var maxX = (viewport[0] + scrolloffset[0]) - menuW;
		var maxY = (viewport[1] + scrolloffset[1]) - menuH;

		var posX = evt.clientX + scrolloffset[0];
		var posY = evt.clientY + scrolloffset[1];

		if (posX > maxX){ posX = posX - menuW; }
		if (posY > maxY){ posY = posY - menuH; }

		this.domNode.style.left = posX + "px";
		this.domNode.style.top = posY + "px";


		// block the onclick that follows this particular right click
		// not if the eventtrigger is documentElement and always when
		// we use onmousedown hack
		_blockHide = (evt.currentTarget!=doc || eventType=='onmousedown');

		//return false; // we propably doesnt need to return false as we dont stop the event as we did before
	}

	/*
	* _canHide is meant to block the onHide call that follows the event that triggered
	* onOpen. This is (hopefully) faster that event.connect and event.disconnect every
	* time the code executes and it makes connecting with onmousedown event possible
	* and we dont have to stop the event from bubbling further.
	*
	* this code is moved into a separete function because it makes it possible for the
	* user to connect to a onHide event, if anyone would like that.
	*/

	this._canHide = function(evt){
		// block the onclick that follows the same event that turn on contextmenu
		if(_blockHide){
			// the onclick check is needed to prevent displaying multiple
			// menus when we have 2 or more contextmenus loaded and are using
			// the onmousedown hack
			if(evt.type=='click' || eventType=='oncontextmenu'){
				_blockHide = false;
				return;
			}else{
				return;
			}
		}

		this.onHide(evt);
	}
	
	this.onHide = function(evt){
		// FIXME: use whatever we use to do more general style setting?
		this.domNode.style.display = "none";
		//dojo.event.disconnect(doc, "onclick", this, "onHide");
		this.isShowing = 0;
	}

	// callback for rightclicks, needed for browsers that doesnt implement oncontextmenu, konqueror and more? 
	this._checkRightClick = function(evt){ 

		// for some reason konq comes here even when we are not clicking on the attached nodes 
		// added check for targetnode 
		if (evt.button==2 && (this.targetNodeIds.length==0 || (evt.currentTarget.id!="" && dojo.lang.inArray(this.targetNodeIds, evt.currentTarget.id)))){

			return this.onOpen(evt);
		}
	}

	dojo.event.connect(doc, "onclick", this, "_canHide");
}

dojo.inherits(dojo.widget.html.ContextMenu, dojo.widget.HtmlWidget);

__CPAN_FILE__ src/widget/html/DatePicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.DatePicker");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.DatePicker");
dojo.require("dojo.event.*");
dojo.require("dojo.html");
dojo.require("dojo.date");

/*
	Some assumptions:
	- I'm planning on always showing 42 days at a time, and we can scroll by week,
	not just by month or year
	- To get a sense of what month to highlight, I basically initialize on the 
	first Saturday of each month, since that will be either the first of two or 
	the second of three months being partially displayed, and then I work forwards 
	and backwards from that point.
	Currently, I assume that dates are stored in the RFC 3339 format,
	because I find it to be most human readable and easy to parse
	http://www.faqs.org/rfcs/rfc3339.html: 		2005-06-30T08:05:00-07:00
	FIXME: scroll by week not yet implemented
*/


dojo.widget.html.DatePicker = function(){
	dojo.widget.DatePicker.call(this);
	dojo.widget.HtmlWidget.call(this);

	var _this = this;
	// today's date, JS Date object
	this.today = "";
	// selected date, JS Date object
	this.date = "";
	// rfc 3339 date
	this.storedDate = "";
	// date currently selected in the UI, stored in year, month, date in the format that will be actually displayed
	this.currentDate = {};
	// stored in year, month, date in the format that will be actually displayed
	this.firstSaturday = {};
	this.classNames = {
		previous: "previousMonth",
		current: "currentMonth",
		next: "nextMonth",
		currentDate: "currentDate",
		selectedDate: "selectedItem"
	}

	this.templatePath =  dojo.uri.dojoUri("src/widget/templates/HtmlDatePicker.html");
	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlDatePicker.css");
	
	this.fillInTemplate = function(){
		this.initData();
		this.initUI();
	}
	
	this.initData = function() {
		this.today = new Date();
		if(this.storedDate && (this.storedDate.split("-").length > 2)) {
			this.date = dojo.widget.DatePicker.util.fromRfcDate(this.storedDate);
		} else {
			this.date = this.today;
		}
		// calendar math is simplified if time is set to 0
		this.today.setHours(0);
		this.date.setHours(0);
		var month = this.date.getMonth();
		var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(this.date.getMonth().toString(), this.date.getFullYear());
		this.firstSaturday.year = tempSaturday.year;
		this.firstSaturday.month = tempSaturday.month;
		this.firstSaturday.date = tempSaturday.date;
	}
	
	this.setDate = function(rfcDate) {
		this.storedDate = rfcDate;
	}
	
	
	this.initUI = function() {
		this.selectedIsUsed = false;
		this.currentIsUsed = false;
		var currentClassName = "";
		var previousDate = new Date();
		var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName("td");
		var currentCalendarNode;
		// set hours of date such that there is no chance of rounding error due to 
		// time change in local time zones
		previousDate.setHours(8);
		var nextDate = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date, 8);
		
		if(this.firstSaturday.date < 7) {
			// this means there are days to show from the previous month
			var dayInWeek = 6;
			for (var i=this.firstSaturday.date; i>0; i--) {
				currentCalendarNode = calendarNodes.item(dayInWeek);
				currentCalendarNode.innerHTML = nextDate.getDate();
				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
				dayInWeek--;
				previousDate = nextDate;
				nextDate = this.incrementDate(nextDate, false);
			}
			for(var i=dayInWeek; i>-1; i--) {
				currentCalendarNode = calendarNodes.item(i);
				currentCalendarNode.innerHTML = nextDate.getDate();
				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "previous"));
				previousDate = nextDate;
				nextDate = this.incrementDate(nextDate, false);				
			}
		} else {
			nextDate.setDate(this.firstSaturday.date-6);
			for(var i=0; i<7; i++) {
				currentCalendarNode = calendarNodes.item(i);
				currentCalendarNode.innerHTML = nextDate.getDate();
				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
				previousDate = nextDate;
				nextDate = this.incrementDate(nextDate, true);				
			}
		}
		previousDate.setDate(this.firstSaturday.date);
		previousDate.setMonth(this.firstSaturday.month);
		previousDate.setFullYear(this.firstSaturday.year);
		nextDate = this.incrementDate(previousDate, true);
		var count = 7;
		currentCalendarNode = calendarNodes.item(count);
		while((nextDate.getMonth() == previousDate.getMonth()) && (count<42)) {
			currentCalendarNode.innerHTML = nextDate.getDate();
			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
			currentCalendarNode = calendarNodes.item(++count);
			previousDate = nextDate;
			nextDate = this.incrementDate(nextDate, true);
		}
		
		while(count < 42) {
			currentCalendarNode.innerHTML = nextDate.getDate();
			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "next"));
			currentCalendarNode = calendarNodes.item(++count);
			previousDate = nextDate;
			nextDate = this.incrementDate(nextDate, true);
		}
		this.setMonthLabel(this.firstSaturday.month);
		this.setYearLabels(this.firstSaturday.year);
	}
	
	this.incrementDate = function(date, bool) {
		// bool: true to increase, false to decrease
		var time = date.getTime();
		var increment = 1000 * 60 * 60 * 24;
		time = (bool) ? (time + increment) : (time - increment);
		var returnDate = new Date();
		returnDate.setTime(time);
		return returnDate;
	}
	
	this.incrementWeek = function(date, bool) {
		dojo.unimplemented('dojo.widget.html.DatePicker.incrementWeek');
	}

	this.incrementMonth = function(date, bool) {
		dojo.unimplemented('dojo.widget.html.DatePicker.incrementMonth');
	}

	this.incrementYear = function(date, bool) {
		dojo.unimplemented('dojo.widget.html.DatePicker.incrementYear');
	}

	this.onIncrementDate = function(evt) {
		dojo.unimplemented('dojo.widget.html.DatePicker.onIncrementDate');
	}

	this._daysIn = function(month,year) {
		var daysIn = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; 
		
		if (month==1) {
			return (year%400 == 0) ? 29: (year%100 == 0) ? 28: (year%4 == 0) ? 29: 28;
		} else {
			return daysIn[month];
		}
	}	

	this.onIncrementWeek = function(evt) {
		// FIXME: should make a call to incrementWeek when that is implemented
		evt.stopPropagation();
		var date = this.firstSaturday.date;
		var month = this.firstSaturday.month;
		var year = this.firstSaturday.year;
		switch(evt.target) {
			case this.increaseWeekNode.getElementsByTagName("img").item(0): 
			case this.increaseWeekNode:
				date = date + 7;
				if (date>this._daysIn(month,year)) {
					date = date - this._daysIn(month,year);
					if (month < 11) {
						month++;	
					} else {
						month=0;
						year++;
					}
				}
				break;
			case this.decreaseWeekNode.getElementsByTagName("img").item(0):
			case this.decreaseWeekNode:
				if (date > 7) {
					date = date - 7;
				} else {
					var diff = 7 - date;
					if (month > 0) {
						month--;
						date = this._daysIn(month,year) - diff;
					}else {
						year--;
						month=11;
						date = 31 - diff;
					}
				}
				break;

		}

		this.firstSaturday.date=date;
		this.firstSaturday.month=month;
		this.firstSaturday.year=year;
		this.initUI();
	}

	this.onIncrementMonth = function(evt) {
		// FIXME: should make a call to incrementMonth when that is implemented
		evt.stopPropagation();
		var month = this.firstSaturday.month;
		var year = this.firstSaturday.year;
		switch(evt.currentTarget) {
			case this.increaseMonthNode:
				if(month < 11) {
					month++;
				} else {
					month = 0;
					year++;
					
					this.setYearLabels(year);
				}
				break;
			case this.decreaseMonthNode:
				if(month > 0) {
					month--;
				} else {
					month = 11;
					year--;
					this.setYearLabels(year);
				}
				break;
			case this.increaseMonthNode.getElementsByTagName("img").item(0):
				if(month < 11) {
					month++;
				} else {
					month = 0;
					year++;
					this.setYearLabels(year);
				}
				break;
			case this.decreaseMonthNode.getElementsByTagName("img").item(0):
				if(month > 0) {
					month--;
				} else {
					month = 11;
					year--;
					this.setYearLabels(year);
				}
				break;
		}
		var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(month.toString(), year);
		this.firstSaturday.year = tempSaturday.year;
		this.firstSaturday.month = tempSaturday.month;
		this.firstSaturday.date = tempSaturday.date;
		this.initUI();
	}
	
	this.onIncrementYear = function(evt) {
		// FIXME: should make a call to incrementYear when that is implemented
		evt.stopPropagation();
		var year = this.firstSaturday.year;
		switch(evt.target) {
			case this.nextYearLabelNode:
				year++;
				break;
			case this.previousYearLabelNode:
				year--;
				break;
		}
		var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(this.firstSaturday.month.toString(), year);
		this.firstSaturday.year = tempSaturday.year;
		this.firstSaturday.month = tempSaturday.month;
		this.firstSaturday.date = tempSaturday.date;
		this.initUI();
	}

	this.setMonthLabel = function(monthIndex) {
		this.monthLabelNode.innerHTML = this.months[monthIndex];
	}
	
	this.setYearLabels = function(year) {
		this.previousYearLabelNode.innerHTML = year - 1;
		this.currentYearLabelNode.innerHTML = year;
		this.nextYearLabelNode.innerHTML = year + 1;
	}
	
	this.getDateClassName = function(date, monthState) {
		var currentClassName = this.classNames[monthState];
		if ((!this.selectedIsUsed) && (date.getDate() == this.date.getDate()) && (date.getMonth() == this.date.getMonth()) && (date.getFullYear() == this.date.getFullYear())) {
			currentClassName = this.classNames.selectedDate + " " + currentClassName;
			this.selectedIsUsed = 1;
		}
		if((!this.currentIsUsed) && (date.getDate() == this.today.getDate()) && (date.getMonth() == this.today.getMonth()) && (date.getFullYear() == this.today.getFullYear())) {
			currentClassName = currentClassName + " "  + this.classNames.currentDate;
			this.currentIsUsed = 1;
		}
		return currentClassName;
	}

	this.onClick = function(evt) {
		dojo.event.browser.stopEvent(evt)
	}
	
	this.onSetDate = function(evt) {
		dojo.event.browser.stopEvent(evt);
		this.selectedIsUsed = 0;
		this.todayIsUsed = 0;
		var month = this.firstSaturday.month;
		var year = this.firstSaturday.year;
		if (dojo.html.hasClass(evt.target, this.classNames["next"])) {
			month = ++month % 12;
			// if month is now == 0, add a year
			year = (month==0) ? ++year : year;
		} else if (dojo.html.hasClass(evt.target, this.classNames["previous"])) {
			month = --month % 12;
			// if month is now == 0, add a year
			year = (month==11) ? --year : year;
		}
		this.date = new Date(year, month, evt.target.innerHTML);
		this.setDate(dojo.widget.DatePicker.util.toRfcDate(this.date));
		this.initUI();
	}
}
dojo.inherits(dojo.widget.html.DatePicker, dojo.widget.HtmlWidget);

__CPAN_FILE__ src/widget/html/DebugConsole.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.DebugConsole");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.FloatingPane");

dojo.widget.html.DebugConsole= function(){

	dojo.widget.html.FloatingPane.call(this);
	dojo.widget.DebugConsole.call(this);
}

dojo.inherits(dojo.widget.html.DebugConsole, dojo.widget.html.FloatingPane);

dojo.lang.extend(dojo.widget.html.DebugConsole, {
	fillInTemplate: function() {
		dojo.widget.html.DebugConsole.superclass.fillInTemplate.apply(this, arguments);
		this.containerNode.id = "debugConsoleClientPane";
		djConfig.isDebug = true;
		djConfig.debugContainerId = this.containerNode.id;
	}
});

__CPAN_FILE__ src/widget/html/DemoEngine.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.DemoEngine");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.lfx.*");
dojo.require("dojo.style");
dojo.require("dojo.io.*");
dojo.require("dojo.widget.Button");
dojo.require("dojo.widget.TabContainer");
dojo.require("dojo.widget.ContentPane");

dojo.widget.html.DemoEngine = function(){
	dojo.widget.HtmlWidget.call(this);
	this.widgetType = "DemoEngine";

	this.templatePath = dojo.uri.dojoUri("src/widget/templates/DemoEngine.html");

	this.demoEngineClass="demoEngine";

	this.navigationNode="";
	this.navigationClass="demoEngineNavigation";

	this.collapseToNode="";
	this.collapseToClass="collapseTo";

	this.menuNavigationNode="";
	this.menuNavigationClass="demoEngineMenuNavigation";

	this.demoNavigationNode="";
	this.demoNavigationClass="demoEngineDemoNavigation";

	this.demoListWrapperClass="demoListWrapper";
	this.demoListContainerClass="demoListContainer";
	this.demoSummaryClass = "demoSummary";
	this.demoSummaryBoxClass="demoSummaryBox";
	this.demoListScreenshotClass="screenshot";
	this.demoListSummaryContainerClass="summaryContainer";
	this.demoSummaryClass="summary";
	this.demoViewLinkClass="view";	

	this.demoContainerNode="";
	this.demoContainerClass="demoEngineDemoContainer";

	this.demoHeaderNode="";
	this.demoHeaderClass="demoEngineDemoHeader";

	this.collapsedMenuNode="";
	this.collapsedMenuClass="demoEngineCollapsedMenu";
	this.collapsedMenuButton="";

	this.aboutNode="";
	this.aboutClass="demoEngineAbout";

	this.demoPaneNode="";	
	this.demoTabContainer="";

	this.viewLinkImage="viewDemo.png";
	this.dojoDemosImage = "dojoDemos.gif";
	this.dojoDemosImageNode="";

	this.registry = function() {};	
}

dojo.inherits(dojo.widget.html.DemoEngine, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.DemoEngine, {
	postCreate: function() {
		dojo.html.addClass(this.domNode, this.demoEngineClass);
		dojo.html.addClass(this.navigationNode, this.navigationClass);
		dojo.html.addClass(this.collapseToNode, this.collapseToClass);
		dojo.html.addClass(this.menuNavigationNode, this.menuNavigationClass);
		dojo.html.addClass(this.demoNavigationNode, this.demoListWrapperClass);
		dojo.html.addClass(this.collapsedMenuNode, this.collapsedMenuClass);
		dojo.html.addClass(this.demoHeaderNode, this.demoHeaderClass);
		dojo.html.addClass(this.demoContainerNode, this.demoContainerClass);

		// Make sure navigation node is hidden and opaque
		//dojo.style.hide(this.navigationNode);
		//dojo.style.setOpacity(this.navigationNode, 0);

		//Make sure demoNavigationNode is hidden and opaque;
		dojo.style.hide(this.demoNavigationNode);
		dojo.style.setOpacity(this.demoNavigationNode,0);

		//Make sure demoContainerNode is hidden and opaque
		dojo.style.hide(this.demoContainerNode);
		dojo.style.setOpacity(this.demoContainerNode,0);

		//Populate the menu
		this.buildMenu();

		//show navigationNode
		//dojo.lfx.html.fadeShow(this.navigationNode, 500).play();

		//turn demoPaneNode into a tabset
		this.demoTabContainer = dojo.widget.createWidget("TabContainer",{},this.demoPaneNode);	

	},

	buildMenu: function() {
		dojo.html.removeChildren(this.menuNavigationNode);

		dojo.io.bind({
			url: "demoRegistry.json",
			load: dojo.lang.hitch(this, "_buildMenu"),
			mimetype: "text/json"
		});
	},

	_buildMenu: function(type, data) {
		this.registry = data;
		dojo.debug("_buildMenu");

		dojo.lang.forEach(this.registry.navigation, dojo.lang.hitch(this,function(category) {
			this._addMenuItem(category);
		}));
	},

	_addMenuItem: function(category) {
		dojo.debug("Adding button for " + category.name);
		var newCat = dojo.widget.createWidget("Button");
		newCat.containerNode.innerHTML=category.name;
		this.menuNavigationNode.appendChild(newCat.domNode);
		dojo.event.connect(newCat,"onClick", this, "selectCategory");
	},

	selectCategory: function(e) {
		dojo.debug("Selecting: " + e.target.innerHTML);
		var showDemoNav = dojo.lfx.html.fadeShow(this.demoNavigationNode, 600);
		var moveMenuNav = dojo.lfx.html.slideTo(this.menuNavigationNode,[0,0], 250);

		dojo.html.removeChildren(this.demoNavigationNode);
	
		dojo.lfx.combine(showDemoNav, moveMenuNav).play()	

		for (var x = 0 ; x< this.registry.navigation.length; x++) {
			if (this.registry.navigation[x].name == e.target.innerHTML) {
				for (var y=0; y< this.registry.navigation[x].demos.length; y++) {
					dojo.debug("demo: " + this.registry.navigation[x].demos[y]);
					var d = this.registry.definitions[this.registry.navigation[x].demos[y]];

					//var demoListWrapper = document.createElement("div");
					//dojo.html.addClass(demoListWrapper,this.demoListWrapperClass);
					//this.demoNavigationNode.appendChild(demoListWrapper);

					var demoListContainer=document.createElement("div");
					dojo.html.addClass(demoListContainer, this.demoListContainerClass);
					this.demoNavigationNode.appendChild(demoListContainer);

					var demoSummary = document.createElement("div");
					dojo.html.addClass(demoSummary,this.demoSummaryClass);
					demoListContainer.appendChild(demoSummary);

					var demoSummaryBox = document.createElement("div");
					dojo.html.addClass(demoSummaryBox, this.demoSummaryBoxClass);
					demoSummary.appendChild(demoSummaryBox);

					var table = document.createElement("table");
					table.width="100%";
					table.cellSpacing="0";
					table.cellPadding="0";
					table.border="0";
					demoSummaryBox.appendChild(table);

					var tbody = document.createElement("tbody");
					table.appendChild(tbody);

					var tr= document.createElement("tr");
					tbody.appendChild(tr);

					var screenshotTd = document.createElement("td");
					dojo.html.addClass(screenshotTd,this.demoListScreenshotClass);
					screenshotTd.valign="top";
					screenshotTd.demoName = this.registry.navigation[x].demos[y];
					tr.appendChild(screenshotTd);

					var ss = document.createElement("img");
					ss.src=d.thumbnail;
					screenshotTd.appendChild(ss);

					var summaryTd = document.createElement("td");
					dojo.html.addClass(summaryTd,this.demoListSummaryContainerClass);
					summaryTd.vAlign="top";
					tr.appendChild(summaryTd);

					var name = document.createElement("h1");
					name.appendChild(document.createTextNode(this.registry.navigation[x].demos[y]));
					summaryTd.appendChild(name);

					var summary = document.createElement("div");
					dojo.html.addClass(summary, this.demoSummaryClass);		
					summaryTd.appendChild(summary);

					var desc = document.createElement("p");
					desc.appendChild(document.createTextNode(d.description));
					summary.appendChild(desc);
					
					var viewDiv = document.createElement("div");
					dojo.html.addClass(viewDiv, this.demoViewLinkClass);
					summary.appendChild(viewDiv);
				
					var viewLink = document.createElement("img");
					viewLink.src = this.viewLinkImage;
					viewLink.demoName = this.registry.navigation[x].demos[y];
					viewDiv.appendChild(viewLink);	
							
					dojo.event.connect(viewLink, "onclick", this, "launchDemo");
					dojo.event.connect(screenshotTd, "onclick", this, "launchDemo");
				}
			}
		}
	},

	showIframe: function(e) {
		dojo.lfx.html.fadeShow(e.currentTarget,250).play();
	},

	launchDemo: function(e) {
		dojo.debug("Launching Demo: " + e.currentTarget.parentNode.parentNode.parentNode.firstChild.innerHTML);
		var demo = e.currentTarget.demoName;

		//implode = dojo.lfx.html.implode(this.navigationNode, this.collapsedMenuNode,1500);
		//show = dojo.lfx.html.fadeShow(this.demoContainerNode,1500);
		dojo.style.setOpacity(this.demoContainerNode, 0);
		hide = dojo.lfx.html.fadeHide(this.navigationNode, 500);
		show = dojo.lfx.html.fadeShow(this.demoContainerNode,500);
		//dojo.style.setOpacity(this.demoContainerNode, 0);
		//dojo.style.show(this.demoContainerNode);
		dojo.lfx.combine(hide,show).play();

		this.demoTabContainer.destroyChildren();

		demoIframe = document.createElement("iframe");
		demoIframe.src=this.registry.definitions[demo].url;

		dojo.html.removeChildren(this.aboutNode);
		var name = document.createElement("h1");
		var about= document.createElement("h2");
		name.appendChild(document.createTextNode(demo));
		about.appendChild(document.createTextNode(this.registry.definitions[demo].description));
		this.aboutNode.appendChild(name);
		this.aboutNode.appendChild(about);

		liveDemo = dojo.widget.createWidget("ContentPane",{label: "Live Demo"});
		liveDemo.domNode.appendChild(demoIframe);

		this.demoTabContainer.addChild(liveDemo);
		demoIframe.parentNode.style.display="inline";
		demoIframe.parentNode.parentNode.style.overflow="hidden";
		dojo.io.bind({
			url: this.registry.definitions[demo].url,
			mimetype: "text/plain",
			load: dojo.lang.hitch(this, function(type,data,e) {
				source = document.createElement("textarea");
				source.appendChild(document.createTextNode(data));
				var sourcePane = dojo.widget.createWidget("ContentPane",{label: "Source"});
				source.rows="20";
				sourcePane.domNode.appendChild(source);
				this.demoTabContainer.addChild(sourcePane);
				dojo.style.show(sourcePane.domNode);

				//let the text area take care of the scrolling 
				sourcePane.domNode.style.overflow="hidden";
				
			})
		});

		this.demoTabContainer.selectTab(liveDemo);
	},

	expandDemoNavigation: function(e) {
		dojo.debug("re expanding navigation");
		//dojo.style.hide(this.demoContainerNode);
		//explode = dojo.lfx.html.explode(this.navigationNode,this.collapseToNode,1000);
		//dojo.style.show(this.navigationNode);
		//hide = dojo.lfx.html.fadeHide(this.demoContainerNode,250);

		show = dojo.lfx.html.fadeShow(this.navigationNode, 1000);
		hide = dojo.lfx.html.fadeHide(this.demoContainerNode, 1000);
		dojo.lfx.combine(show,hide).play();
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:DemoEngine");

__CPAN_FILE__ src/widget/html/DocPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.DocPane");

dojo.require("dojo.widget.*");
dojo.require("dojo.io.*");
dojo.require("dojo.event.*");
dojo.require("dojo.widget.HtmlWidget");

dojo.widget.html.DocPane = function(){
	dojo.widget.HtmlWidget.call(this);

	this.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlDocPane.html");
	this.templateCSSPath = dojo.uri.dojoUri("src/widget/templates/HtmlDocPane.css");
	this.widgetType = "DocPane";
	this.isContainer = true;

	this.select;
	this.result;
	this.fn;
	this.fnLink;
	this.count;
	this.row;
	this.summary;
	this.description;
	this.variables;
	this.vRow;
	this.vLink;
	this.vDesc;
	this.parameters;
	this.pRow;
	this.pLink;
	this.pDesc;
	this.pOpt;
	this.pType;
	this.source;

	dojo.event.topic.subscribe("docResults", this, "onDocResults");
	dojo.event.topic.subscribe("docFunctionDetail", this, "onDocSelectFunction");
}

dojo.inherits(dojo.widget.html.DocPane, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.DocPane, {
	fillInTemplate: function(){
		this.homeSave = this.containerNode.cloneNode(true);
		this.selectSave = dojo.dom.removeNode(this.select);
		this.resultSave = dojo.dom.removeNode(this.result);
		this.rowParent = this.row.parentNode;
		this.rowSave = dojo.dom.removeNode(this.row);
		this.vParent = this.vRow.parentNode;
		this.vSave = dojo.dom.removeNode(this.vRow);
		this.pParent = this.pRow.parentNode;
		this.pSave = dojo.dom.removeNode(this.pRow);
	},

	onDocSelectFunction: function(message){
		var appends = [];
		dojo.dom.removeChildren(this.domNode);
		this.fn.innerHTML = message.name;
		this.description.innerHTML = message.doc.description;

		this.variables.style.display = "block";
		var all = [];
		if(message.meta){
			if(message.meta.variables){
				all = message.meta.variables;
			}
			if(message.meta.this_variables){
				all = all.concat(message.meta.this_variables);
			}
			if(message.meta.child_variables){
				all = all.concat(message.meta.child_variables);
			}
		}
		if(!all.length){
			this.variables.style.display = "none";
		}else{
			for(var i = 0, one; one = all[i]; i++){
				this.vLink.innerHTML = one;
				this.vDesc.parentNode.style.display = "none";
				appends.push(this.vParent.appendChild(this.vSave.cloneNode(true)));
			}
		}
		
		this.parameters.style.display = "none";
		for(var param in message.meta.params){
			this.parameters.style.display = "block";		
			this.pLink.innerHTML = param;
			this.pOpt.style.display = "none";
			if(message.meta.params[param].opt){
				this.pOpt.style.display = "inline";				
			}
			this.pType.parentNode.style.display = "none";
			if(message.meta.params[param].type){
				this.pType.parentNode.style.display = "inline";
				this.pType.innerHTML = message.meta.params[param].type;
			}
			this.pDesc.parentNode.style.display = "none";			
			if(message.doc.parameters[param] && message.doc.parameters[param].description){
				this.pDesc.parentNode.style.display = "inline";
				this.pDesc.innerHTML = message.doc.parameters[param].description;
			}
			appends.push(this.pParent.appendChild(this.pSave.cloneNode(true)));
		}

		dojo.dom.removeChildren(this.source);
		this.source.appendChild(document.createTextNode(message.meta.sig + "{\r\n\t" + message.src.replace(/\n/g, "\r\n\t") + "\r\n}"));
		
		this.domNode.appendChild(this.selectSave.cloneNode(true));

		for(var i = 0, append; append = appends[i]; i++){
			dojo.dom.removeNode(append);
		}
	},

	onDocResults: function(message){
		dojo.dom.removeChildren(this.domNode);

		this.count.innerHTML = message.docResults.length;
		var appends = [];
		for(var i = 0, row; row = message.docResults[i]; i++){
			this.fnLink.innerHTML = row.name;
			this.fnLink.href = "#" + row.name;
			if(row.id){
				this.fnLink.href = this.fnLink.href + "," + row.id;	
			}
			this.summary.parentNode.style.display = "none";
			if(row.summary){
				this.summary.parentNode.style.display = "inline";				
				this.summary.innerHTML = row.summary;
			}
			appends.push(this.rowParent.appendChild(this.rowSave.cloneNode(true)));
		}
		
		function makeSelect(x){
			return function(e) {
				dojo.event.topic.publish("docSelectFunction", x);
			}
		}

		this.domNode.appendChild(this.resultSave.cloneNode(true));
		var as = this.domNode.getElementsByTagName("a");
		for(var i = 0, a; a = as[i]; i++){
			dojo.event.connect(a, "onclick", makeSelect(message.docResults[i]));
		}
		
		for(var i = 0, append; append = appends[i]; i++){
			this.rowParent.removeChild(append);
		}
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:DocPane");

__CPAN_FILE__ src/widget/html/DropdownButton.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

/* TODO:
 * - make the dropdown "smart" so it can't get cutoff on bottom of page, sides of page, etc.
 */

dojo.provide("dojo.widget.html.DropdownButton");

dojo.require("dojo.event.*");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.uri.Uri");
dojo.require("dojo.dom");
dojo.require("dojo.style");
dojo.require("dojo.html");

dojo.widget.html.DropdownButton = function() {
	// mix in the button properties
	dojo.widget.DropdownButton.call(this);
	dojo.widget.HtmlWidget.call(this);
}

dojo.inherits(dojo.widget.html.DropdownButton, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.DropdownButton, {
	
	// In IE, event handlers on objects inside buttons don't work correctly, so
	// we just set onClick on the button itself.
	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlDropDownButtonTemplate.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlButtonTemplate.css"),

	// attach points
	button: null,
	table: null,
	labelCell: null,
	borderCell: null,
	arrowCell: null,
	arrow: null,

	fillInTemplate: function(args, frag) {
		// input data (containing the anchor for the button itself, plus the
		// thing to display when you push the down arrow)
		var input = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];

		// Recursively expand widgets inside of the <dojo:dropdownButton>
		var parser = new dojo.xml.Parse();
		var frag = parser.parseElement(input, null, true);
		var ary = dojo.widget.getParser().createComponents(frag);

		this.a = dojo.dom.getFirstChildElement(input);	// the button contents
		this.menu = dojo.dom.getNextSiblingElement(this.a);	// the menu under the button
		
		this.disabled = dojo.html.hasClass(this.a, "disabled");
		if( this.disabled ) {
			dojo.html.addClass(this.button, "dojoDisabled");
			this.domNode.setAttribute("disabled", "true");
		}

		dojo.html.disableSelection(this.a);
		this.a.style["text-decoration"]="none";
		this.labelCell.appendChild(this.a);

		this.arrow.src =
			dojo.uri.dojoUri("src/widget/templates/images/dropdownButtonsArrow" +
			(this.disabled ? "-disabled" : "") + ".gif");

		// Attach menu to body so that it appears above other buttons
		this.menu.style.position="absolute";
		this.menu.style.display="none";
		this.menu.style["z-index"] = 99;
		document.body.appendChild(this.menu);
	},

	postCreate: function() {
		if ( dojo.render.html.ie ) {
			// Compensate for IE's weird padding of button content, which seems to be relative
			// to the length of the content
			var contentWidth = dojo.style.getOuterWidth(this.table);
			this.labelCell.style["left"] = "-" + (contentWidth / 10) + "px";
			this.arrowCell.style["left"] = (contentWidth / 10) + "px";
		}

		// Make menu at least as wide as the button
		var buttonWidth = dojo.style.getOuterWidth(this.button);
		var menuWidth = dojo.style.getOuterWidth(this.menu);
		if ( buttonWidth > menuWidth ) {
			dojo.style.setOuterWidth(this.menu, buttonWidth);
		}
	},

	// If someone clicks anywhere else on the screen (including another menu),
	// then close this menu.
	onCanvasMouseDown: function(e) {
		if( !dojo.dom.isDescendantOf(e.target, this.button) &&
			!dojo.dom.isDescendantOf(e.target, this.menu) ) {
			this.hideMenu();
		}
	},

	eventWasOverArrow: function(e) {
		// want to use dojo.html.overElement() but also need to detect clicks
		// on the area between the arrow and the edge of the button
		var eventX = e.clientX;
		var borderX = dojo.style.totalOffsetLeft(this.borderCell);
		return (eventX > borderX );
	},

	onMouseOver: function(e) {
		dojo.html.addClass(this.button, "dojoButtonHover");
		dojo.html.removeClass(this.button, "dojoButtonNoHover");
	},
	
	onMouseOut: function(e) {
		dojo.html.removeClass(this.button, "dojoButtonHover");
		dojo.html.addClass(this.button, "dojoButtonNoHover");
	},

	onClick: function(e) {
		if ( this.eventWasOverArrow(e) ) {
			this._onClickArrow();
		} else {
			this._onClickButton();
		}
	},

	// Action when the user presses the button
	_onClickButton: function(e) {
		if ( this.a ) {
			if ( this.a.click ) {
				this.a.click();
			} else if ( this.a.href ) {
				location.href = this.a.href;
			}
		}
	},

	// Action when user presses the arrow
	_onClickArrow: function() {
		if ( this.menu.style.display == "none" ) {
			this.showMenu();
		} else {
			this.hideMenu();
		}
	},
	
	showMenu: function() {
		if ( this.disabled )
			return;

		// Position it accordingly, relative to screen root (since
		// it's attached to document.body)
		this.menu.style.left = dojo.style.totalOffsetLeft(this.button) + "px";
		this.menu.style.top = dojo.style.totalOffsetTop(this.button) + dojo.style.getOuterHeight(this.button) + "px";

		// Display the menu; do this funky code below to stop the menu from extending
		// all the way to the right edge of the screen.
		// TODO: retest simple display="" to confirm that it doesn't work.
		try {
			this.menu.style.display="table";	// mozilla
		} catch(e) {
			this.menu.style.display="block";	// IE
		}

		// If someone clicks somewhere else on the screen then close the menu
		dojo.event.connect(document.documentElement, "onmousedown", this, "onCanvasMouseDown");
		
		// When someone clicks the menu, after the menu handles the event,
		// close the menu (be careful not to close the menu too early or else
		// the menu will never receive the event.)
		dojo.event.connect(this.menu, "onclick", this, "hideMenu");
	},

	hideMenu: function() {
		this.menu.style.display = "none";
		dojo.event.disconnect(document.documentElement, "onmousedown", this, "onCanvasMouseDown");
		dojo.event.disconnect(this.menu, "onclick", this, "hideMenu");
	}
});



__CPAN_FILE__ src/widget/html/GoogleMap.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.GoogleMap");
dojo.require("dojo.event.*");
dojo.require("dojo.html");
dojo.require("dojo.math");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.GoogleMap");

(function(){
	var gkey = djConfig["gMapKey"]||djConfig["googleMapKey"];
	if(!dojo.hostenv.post_load_){
		var tag = "<scr"+"ipt src='http://maps.google.com/maps?file=api&amp;v=2&amp;key="+gkey+"'></scri"+"pt>";
		if(!dj_global["GMap2"]){ // prevent multi-inclusion
			document.write(tag);
		}
	}else{
		dojo.debug("cannot initialize map system after the page has been loaded! Please either manually include the script block provided by Google in your page or require() the GoogleMap widget before onload has fired");
	}
})();

dojo.widget.html.GoogleMap=function(){
	dojo.widget.HtmlWidget.call(this);
	dojo.widget.GoogleMap.call(this);

	var gm=dojo.widget.GoogleMap;

	this.map=null;
	this.data=[];
	this.datasrc="";
	// FIXME: this is pehraps the stupidest way to specify this enum I can think of
	this.controls=[gm.Controls.LargeMap,gm.Controls.Scale,gm.Controls.MapType];
};
dojo.inherits(dojo.widget.html.GoogleMap, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.GoogleMap, {
	templatePath:null,
	templateCssPath:null,

	setControls:function(){
		var c=dojo.widget.GoogleMap.Controls;
		for(var i=0; i<this.controls.length; i++){
			var type=this.controls[i];
			switch(type){
				case c.LargeMap:{
					this.map.addControl(new GLargeMapControl());
					break;
				}
				case c.SmallMap:{
					this.map.addControl(new GSmallMapControl());
					break;
				}
				case c.SmallZoom:{
					this.map.addControl(new GSmallZoomControl());
					break;
				}
				case c.Scale:{
					this.map.addControl(new GScaleControl());
					break;
				}
				case c.MapType:{
					this.map.addControl(new GMapTypeControl());
					break;
				}
				case c.Overview:{
					this.map.addControl(new GOverviewMapControl());
					break;
				}
				default:{
					break;
				}
			}
		}
	},
	
	findCenter:function(bounds){
		var clat=(bounds.getNorthEast().lat()+bounds.getSouthWest().lat())/2;
		var clng=(bounds.getNorthEast().lng()+bounds.getSouthWest().lng())/2;
		return (new GLatLng(clat,clng));
	},

	createPinpoint:function(pt,overlay){
		var m=new GMarker(pt);
		if(overlay){
			GEvent.addListener(m,"click",function(){
				m.openInfoWindowHtml("<div>"+overlay+"</div>");
			});
		}
		return m;
	},

	parse:function(table){
		this.data=[];

		//	get the column indices
		var h=table.getElementsByTagName("thead")[0];
		if(!h){
			return;
		}

		var a=[];
		var cols=h.getElementsByTagName("td");
		if(cols.length==0){
			cols=h.getElementsByTagName("th");
		}
		for(var i=0; i<cols.length; i++){
			var c=cols[i].innerHTML.toLowerCase();
			if(c=="long") c="lng";
			a.push(c);
		}
		
		//	parse the data
		var b=table.getElementsByTagName("tbody")[0];
		if(!b){
			return;
		}
		for(var i=0; i<b.childNodes.length; i++){
			if(!(b.childNodes[i].nodeName&&b.childNodes[i].nodeName.toLowerCase()=="tr")){
				continue;
			}
			var cells=b.childNodes[i].getElementsByTagName("td");
			var o={};
			for(var j=0; j<a.length; j++){
				var col=a[j];
				if(col=="lat"||col=="lng"){
					o[col]=parseFloat(cells[j].innerHTML);					
				}else{
					o[col]=cells[j].innerHTML;
				}
			}
			this.data.push(o);
		}
	},
	render:function(){
		var bounds=new GLatLngBounds();
		var d=this.data;
		var pts=[];
		for(var i=0; i<d.length; i++){
			bounds.extend(new GLatLng(d[i].lat,d[i].lng));
		}

		this.map.setCenter(this.findCenter(bounds), this.map.getBoundsZoomLevel(bounds));

		for(var i=0; i<this.data.length; i++){
			var p=new GLatLng(this.data[i].lat,this.data[i].lng);
			var d=this.data[i].description||null;
			var m=this.createPinpoint(p,d);
			this.map.addOverlay(m);
		}
	},
	

	initialize:function(args, frag){
		if(!GMap2){
			dojo.raise("dojo.widget.GoogleMap: The Google Map script must be included (with a proper API key) in order to use this widget.");
		}
		if(this.datasrc){
			this.parse(dojo.byId(this.datasrc));
		}
		else if(this.domNode.getElementsByTagName("table")[0]){
			this.parse(this.domNode.getElementsByTagName("table")[0]);
		}
	},
	postCreate:function(){
		//	clean the domNode before creating the map.
		while(this.domNode.childNodes.length>0){
			this.domNode.removeChild(this.domNode.childNodes[0]);
		}
		this.map=new GMap2(this.domNode);
		this.render();
		this.setControls();
	}
});

__CPAN_FILE__ src/widget/html/LinkPane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.LinkPane");
dojo.provide("dojo.widget.html.LinkPane");

//
// a div that loads from a URL.  (Similar to an iframe, but
// it's in the same environment as the main window)
//

dojo.require("dojo.widget.LinkPane");
dojo.require("dojo.widget.*");
dojo.require("dojo.event.*");
dojo.require("dojo.io.*");
dojo.require("dojo.widget.ContentPane");
dojo.require("dojo.html");
dojo.require("dojo.style");
dojo.require("dojo.dom");
dojo.require("dojo.string");


dojo.widget.html.LinkPane = function(){
	dojo.widget.html.ContentPane.call(this);
}

dojo.inherits(dojo.widget.html.LinkPane, dojo.widget.html.ContentPane);

dojo.lang.extend(dojo.widget.html.LinkPane, {
	widgetType: "LinkPane",

	// I'm using a template because the user may specify the input as
	// <a href="foo.html">label</a>, in which case we need to get rid of the
	// <a> because we don't want a link.
	templateString: '<div class="dojoLinkPane"></div>',

	fillInTemplate: function(args, frag){
		var source = this.getFragNodeRef(frag);

		// If user has specified node contents, they become the label
		// (the link must be plain text)
		this.label += source.innerHTML;

		// Copy style info from input node to output node
		// get around opera wich doesnt have cssText, and IE wich bugs on setAttribute
		if(dojo.lang.isUndefined(source.style.cssText)){
			this.domNode.setAttribute("style", source.getAttribute("style"));
		}else{
			this.domNode.style.cssText = source.style.cssText;
		}
		dojo.html.addClass(this.domNode, dojo.html.getClass(source));
	}
});

__CPAN_FILE__ src/widget/html/Menu.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.widget.Menu");
dojo.provide("dojo.widget.html.Menu");

/* HtmlMenu
 ***********/
 
dojo.widget.html.Menu = function(){
	dojo.widget.html.Menu.superclass.constructor.call(this);
	this.items = [];
}
dojo.inherits(dojo.widget.html.Menu, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.Menu, {
	widgetType: "Menu",
	isContainer: true,

	// copy children widgets output directly to parent (this node), to avoid
	// errors trying to insert an <li> under a <div>
	snarfChildDomOutput: true,

	templateString: '<ul></ul>',
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/Menu.css"),
	
	fillInTemplate: function (args, frag){
		//dojo.widget.HtmlMenu.superclass.fillInTemplate.apply(this, arguments);
		this.domNode.className = "dojoMenu";
	},
	
 
	_register: function (item ) {
		dojo.event.connect(item, "onSelect", this, "onSelect");
		this.items.push(item);
	},

	push: function (item) {
		this.domNode.appendChild(item.domNode);
		this._register(item);
	}

});


__CPAN_FILE__ src/widget/html/MenuItem.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.MenuItem");

/* HtmlMenuItem
 ***************/

dojo.widget.html.MenuItem = function(){
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.html.MenuItem, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.MenuItem, {
	widgetType: "MenuItem",
	templateString: '<li class="dojoMenuItem" dojoAttachEvent="onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick;"></li>',
	title: "",

	fillInTemplate: function(args, frag){
		dojo.html.disableSelection(this.domNode);

		if(!dojo.string.isBlank(this.title)){
			this.domNode.appendChild(document.createTextNode(this.title));
		}else{
			this.domNode.appendChild(frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"]);
		}
	},
	
	onMouseOver: function(e){
		dojo.html.addClass(this.domNode, "dojoMenuItemHover");
	},
	
	onMouseOut: function(e){
		dojo.html.removeClass(this.domNode, "dojoMenuItemHover");
	},
	
	onClick: function(e){ this.onSelect(this, e); },
	onMouseDown: function(e){},
	onMouseUp: function(e){},
	
	// By default, when I am clicked, click the item inside of me
	onSelect: function (item, e) {
		var child = dojo.dom.getFirstChildElement(this.domNode);
		if(child){
			if(child.click){
				child.click();
			}else if(child.href){
				location.href = child.href;
			}
		}
	}
});


__CPAN_FILE__ src/widget/html/MonthlyCalendar.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.MonthlyCalendar");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.html.DatePicker");
dojo.require("dojo.widget.MonthlyCalendar");
//dojo.require("dojo.widget.MonthlyCalendar.util");
dojo.require("dojo.event.*");
dojo.require("dojo.html");

dojo.widget.html.MonthlyCalendar= function(){
	dojo.widget.MonthlyCalendar.call(this);
	//dojo.widget.html.DatePicker.call(this);
	this.widgetType = "MonthlyCalendar";
	this.templatePath =  dojo.uri.dojoUri("src/widget/templates/HtmlMonthlyCalendar.html");
	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlMonthlyCalendar.css");

	this.iCalendars = [];
}

dojo.inherits(dojo.widget.html.MonthlyCalendar, dojo.widget.html.DatePicker);

dojo.lang.extend(dojo.widget.html.MonthlyCalendar, {
	cache: function() {
	},

	addCalendar: function(/* dojo.iCalendar */ cal) {
		dojo.debug("Adding Calendar");
		this.iCalendars.push(cal);
		dojo.debug("Starting init");
		this.initUI()
		dojo.debug("done init");
	},

	createDayContents: function(node,mydate) {
		dojo.dom.removeChildren(node);
		node.appendChild(document.createTextNode(mydate.getDate()));	
			for(var x=0; x<this.iCalendars.length; x++) {
				evts = this.iCalendars[x].getEvents(mydate);
				if ((dojo.lang.isArray(evts)) && (evts.length>0)) {
				for(var y=0;y<evts.length;y++) {
					var el = document.createElement("div");
					dojo.html.addClass(el, "dojoMonthlyCalendarEvent");          
					el.appendChild(document.createTextNode(evts[y].summary.value));
					el.width = dojo.style.getContentWidth(node);
					node.appendChild(el);
				}
			}
		}
	},

	initUI: function() {
		this.selectedIsUsed = false;
		this.currentIsUsed = false;
		var currentClassName = "";
		var previousDate = new Date();
		var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName("td");
		var currentCalendarNode;
		// set hours of date such that there is no chance of rounding error due to 
		// time change in local time zones
		previousDate.setHours(8);
		var nextDate = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date, 8);
		var lastDay = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date + 42, 8);
		
		if (this.iCalendars.length > 0) {
			for (var x=0; x<this.iCalendars.length;x++) {
				this.iCalendars[x].preComputeRecurringEvents(lastDay);
			}
		}

		if(this.firstSaturday.date < 7) {
			// this means there are days to show from the previous month
			var dayInWeek = 6;
			for (var i=this.firstSaturday.date; i>0; i--) {
				currentCalendarNode = calendarNodes.item(dayInWeek);
				this.createDayContents(currentCalendarNode, nextDate);
				
				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
				dayInWeek--;
				previousDate = nextDate;
				nextDate = this.incrementDate(nextDate, false);
			}
			for(var i=dayInWeek; i>-1; i--) {
				currentCalendarNode = calendarNodes.item(i);

				this.createDayContents(currentCalendarNode, nextDate);

				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "previous"));
				previousDate = nextDate;
				nextDate = this.incrementDate(nextDate, false);				
			}
		} else {
			nextDate.setDate(1);
			for(var i=0; i<7; i++) {
				currentCalendarNode = calendarNodes.item(i);
				this.createDayContents(currentCalendarNode, nextDate);
				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
				previousDate = nextDate;
				nextDate = this.incrementDate(nextDate, true);				
			}
		}
		previousDate.setDate(this.firstSaturday.date);
		previousDate.setMonth(this.firstSaturday.month);
		previousDate.setFullYear(this.firstSaturday.year);
		nextDate = this.incrementDate(previousDate, true);
		var count = 7;
		currentCalendarNode = calendarNodes.item(count);
		while((nextDate.getMonth() == previousDate.getMonth()) && (count<42)) {
			this.createDayContents(currentCalendarNode, nextDate);
			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
			currentCalendarNode = calendarNodes.item(++count);
			previousDate = nextDate;
			nextDate = this.incrementDate(nextDate, true);
		}
		
		while(count < 42) {
			this.createDayContents(currentCalendarNode, nextDate);
			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "next"));
			currentCalendarNode = calendarNodes.item(++count);
			previousDate = nextDate;
			nextDate = this.incrementDate(nextDate, true);
		}
		this.setMonthLabel(this.firstSaturday.month);
		this.setYearLabels(this.firstSaturday.year);
	}	
});

__CPAN_FILE__ src/widget/html/SortableTable.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.SortableTable");
dojo.require("dojo.lang");
dojo.require("dojo.date");
dojo.require("dojo.html");
dojo.require("dojo.event.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.SortableTable");

dojo.widget.html.SortableTable=function(){
	//	summary
	//	Constructor for the SortableTable widget
	dojo.widget.SortableTable.call(this);
	dojo.widget.HtmlWidget.call(this);

	this.headClass="";
	this.tbodyClass="";
	this.headerClass="";
	this.headerSortUpClass="selected";
	this.headerSortDownClass="selected";
	this.rowClass="";
	this.rowAlternateClass="alt";
	this.rowSelectedClass="selected";
	this.columnSelected="sorted-column";
};
dojo.inherits(dojo.widget.html.SortableTable, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.SortableTable, {
	templatePath:null,
	templateCssPath:null,

	getTypeFromString:function(/* string */ s){
		//	summary
		//	Find the constructor that matches param s by searching through the entire object tree.
		var parts=s.split("."),i=0,obj=dj_global; 
		do{obj=obj[parts[i++]];}while(i<parts.length&&obj); 
		return(obj!=dj_global)?obj:null;	//	function
	},
	compare:function(/* object */ o1, /* object */ o2){
		//	summary
		//	Compare two objects using a shallow property compare
		for(var p in o1){
			if(!o2[p]) return false;	//	boolean
			if(o1[p].valueOf()!=o2[p].valueOf()) return false;	//	boolean
		}
		return true;	// boolean
	},
	isSelected:function(/* object */ o){
		//	summary
		//	checked to see if the passed object is in the current selection.
		for(var i=0;i<this.selected.length;i++){
			if(this.compare(this.selected[i],o)){
				return true; // boolean
			}
		}
		return false;	// boolean
	},
	removeFromSelected:function(/* object */ o){
		//	summary
		//	remove the passed object from the current selection.
		var idx=-1;
		for(var i=0;i<this.selected.length;i++){
			if(this.compare(this.selected[i],o)){
				idx=i;
				break;
			}
		}
		if(idx>=0){
			this.selected.splice(idx,1);
		}
	},
	getSelection:function(){
		//	summary
		//	return the array of currently selected objects (JSON format)
		return this.selected;	//	array
	},
	getValue:function(){
		//	summary
		//	return a comma-delimited list of selected valueFields.
		var a=[];
		for(var i=0;i<this.selected.length;i++){
			if (this.selected[i][this.valueField]){
				a.push(this.selected[i][this.valueField]);
			}
		}
		return a.join();	//	string
	},
	reset:function(){
		//	summary
		//	completely resets the internal representations.
		this.columns=[];
		this.data=[];
		this.resetSelections(this.domNode.getElementsByTagName("tbody")[0]);
	},
	resetSelections:function(/* HTMLTableBodyElement */ body){
		this.selected=[];
		var idx=0;
		var rows=body.getElementsByTagName("tr");
		for(var i=0; i<rows.length; i++){
			if(rows[i].parentNode==body){
				rows[i].removeAttribute("selected");
				if(this.enableAlternateRows&&idx%2==1){
					rows[i].className=this.rowAlternateClass;
				}else{
					rows[i].className="";
				}
				idx++;
			}
		}
	},

	getObjectFromRow:function(/* HTMLTableRowElement */ row){
		//	summary
		//	creates a JSON object based on the passed row
		var cells=row.getElementsByTagName("td");
		var o={};
		for(var i=0; i<this.columns.length;i++){
			if(this.columns[i].sortType=="__markup__"){
				//	FIXME: should we parse this instead?  Because if the user may not get back the markup they put in...
				o[this.columns[i].getField()]=cells[i].innerHTML;
			}else{
				var text=dojo.html.renderedTextContent(cells[i]);
				var val=new (this.columns[i].getType())(text);
				o[this.columns[i].getField()]=val;
			}
		}
		if(dojo.html.hasAttribute(row,"value")){
			o[this.valueField]=dojo.html.getAttribute(row,"value");
		}
		return o;	//	object
	},
	setSelectionByRow:function(/* HTMLTableElementRow */ row){
		//	summary
		//	create the selection object based on the passed row, makes sure it's unique.
		//	note that you need to call render manually (because of multi-select operations)
		var o=this.getObjectFromRow(row);
		var b=false;
		for(var i=0;i<this.selected.length;i++){
			if(this.compare(this.selected[i], o)){
				b=true;
				break;
			}
		}
		if(!b){
			this.selected.push(o);
		}
	},

	parseColumns:function(/* HTMLTableHeadElement */ node){
		//	summary
		//	parses the passed element to create column objects
		this.reset();
		var row=node.getElementsByTagName("tr")[0];
		var cells=row.getElementsByTagName("td");
		if (cells.length==0) cells=row.getElementsByTagName("th");
		for(var i=0; i<cells.length; i++){
			var o={
				field:null,
				format:null,
				noSort:false,
				sortType:"String",
				dataType:String,
				sortFunction:null,
				label:null,
				align:"left",
				valign:"middle",
				getField:function(){ return this.field||this.label; },
				getType:function(){ return this.dataType; }
			};
			//	presentation attributes
			if(dojo.html.hasAttribute(cells[i], "align")){
				o.align=dojo.html.getAttribute(cells[i],"align");
			}
			if(dojo.html.hasAttribute(cells[i], "valign")){
				o.valign=dojo.html.getAttribute(cells[i],"valign");
			}

			//	sorting features.
			if(dojo.html.hasAttribute(cells[i], "nosort")){
				o.noSort=dojo.html.getAttribute(cells[i],"nosort")=="true";
			}
			if(dojo.html.hasAttribute(cells[i], "sortusing")){
				var trans=dojo.html.getAttribute(cells[i],"sortusing");
				var f=this.getTypeFromString(trans);
				if (f!=null && f!=window && typeof(f)=="function") 
					o.sortFunction=f;
			}

			if(dojo.html.hasAttribute(cells[i], "field")){
				o.field=dojo.html.getAttribute(cells[i],"field");
			}
			if(dojo.html.hasAttribute(cells[i], "format")){
				o.format=dojo.html.getAttribute(cells[i],"format");
			}
			if(dojo.html.hasAttribute(cells[i], "dataType")){
				var sortType=dojo.html.getAttribute(cells[i],"dataType");
				if(sortType.toLowerCase()=="html"||sortType.toLowerCase()=="markup"){
					o.sortType="__markup__";	//	always convert to "__markup__"
					o.noSort=true;
				}else{
					var type=this.getTypeFromString(sortType);
					if(type){
						o.sortType=sortType;
						o.dataType=type;
					}
				}
			}
			o.label=dojo.html.renderedTextContent(cells[i]);
			this.columns.push(o);

			//	check to see if there's a default sort, and set the properties necessary
			if(dojo.html.hasAttribute(cells[i], "sort")){
				this.sortIndex=i;
				var dir=dojo.html.getAttribute(cells[i], "sort");
				if(!isNaN(parseInt(dir))){
					dir=parseInt(dir);
					this.sortDirection=(dir!=0)?1:0;
				}else{
					this.sortDirection=(dir.toLowerCase()=="desc")?1:0;
				}
			}
		}
	},

	parseData:function(/* array */ data){
		//	summary
		//	Parse the passed JSON data structure, and cast based on columns.
		this.data=[];
		this.selected=[];
		for(var i=0; i<data.length; i++){
			var o={};	//	new data object.
			for(var j=0; j<this.columns.length; j++){
				var field=this.columns[j].getField();
				if(this.columns[j].sortType=="__markup__"){
					o[field]=String(data[i][field]);
				}else{
					var type=this.columns[j].getType();
					var val=data[i][field];
					var t=this.columns[j].sortType.toLowerCase();
					if(val){
						o[field]=new type(val);
					}else{
						o[field]=new type();	//	let it use the default.
					}
				}
			}
			//	check for the valueField if not already parsed.
			if(data[i][this.valueField]&&!o[this.valueField]){
				o[this.valueField]=data[i][this.valueField];
			}
			this.data.push(o);
		}
	}, 

	parseDataFromTable:function(/* HTMLTableBodyElement */ tbody){
		//	summary
		//	parses the data in the tbody of a table to create a set of objects.
		//	Will add objects to this.selected if an attribute 'selected="true"' is present on the row.
		this.data=[];
		this.selected=[];
		var rows=tbody.getElementsByTagName("tr");
		for(var i=0; i<rows.length; i++){
			if(dojo.html.getAttribute(rows[i],"ignoreIfParsed")=="true"){
				continue;
			}
			var o={};	//	new data object.
			var cells=rows[i].getElementsByTagName("td");
			for(var j=0; j<this.columns.length; j++){
				var field=this.columns[j].getField();
				if(this.columns[j].sortType=="__markup__"){
					//	FIXME: parse this?
					o[field]=cells[j].innerHTML;
				}else{
					var type=this.columns[j].getType();
					var val=dojo.html.renderedTextContent(cells[j]); //	should be the same index as the column.
					if (val) o[field]=new type(val);
					else o[field]=new type();	//	let it use the default.
				}
			}
			if(dojo.html.hasAttribute(rows[i],"value")&&!o[this.valueField]){
				o[this.valueField]=dojo.html.getAttribute(rows[i],"value");
			}
			//	FIXME: add code to preserve row attributes in __metadata__ field?
			this.data.push(o);
			
			//	add it to the selections if selected="true" is present.
			if(dojo.html.getAttribute(rows[i],"selected")=="true"){
				this.selected.push(o);
			}
		}
	},
	
	showSelections:function(){
		var body=this.domNode.getElementsByTagName("tbody")[0];
		var rows=body.getElementsByTagName("tr");
		var idx=0;
		for(var i=0; i<rows.length; i++){
			if(rows[i].parentNode==body){
				if(dojo.html.getAttribute(rows[i],"selected")=="true"){
					rows[i].className=this.rowSelectedClass;
				} else {
					if(this.enableAlternateRows&&idx%2==1){
						rows[i].className=this.rowAlternateClass;
					}else{
						rows[i].className="";
					}
				}
				idx++;
			}
		}
	},
	render:function(bDontPreserve){
		//	summary
		//	renders the table to the browser
		var data=[];
		var body=this.domNode.getElementsByTagName("tbody")[0];

		if(!bDontPreserve){
			//	rebuild data and selection
			this.parseDataFromTable(body);
		}

		//	clone this.data for sorting purposes.
		for(var i=0; i<this.data.length; i++){
			data.push(this.data[i]);
		}
		
		var col=this.columns[this.sortIndex];
		if(!col.noSort){
			var field=col.getField();
			if(col.sortFunction){
				var sort=col.sortFunction;
			}else{
				var sort=function(a,b){
					if (a[field]>b[field]) return 1;
					if (a[field]<b[field]) return -1;
					return 0;
				}
			}
			data.sort(sort);
			if(this.sortDirection!=0) data.reverse();
		}

		//	build the table and pop it in.
		while(body.childNodes.length>0) body.removeChild(body.childNodes[0]);
		for(var i=0; i<data.length;i++){
			var row=document.createElement("tr");
			dojo.html.disableSelection(row);
			if (data[i][this.valueField]){
				row.setAttribute("value",data[i][this.valueField]);
			}
			if(this.isSelected(data[i])){
				row.className=this.rowSelectedClass;
				row.setAttribute("selected","true");
			} else {
				if(this.enableAlternateRows&&i%2==1){
					row.className=this.rowAlternateClass;
				}
			}
			for(var j=0;j<this.columns.length;j++){
				var cell=document.createElement("td");
				cell.setAttribute("align", this.columns[j].align);
				cell.setAttribute("valign", this.columns[j].valign);
				dojo.html.disableSelection(cell);
				if(this.sortIndex==j){
					cell.className=this.columnSelected;
				}
				if(this.columns[j].sortType=="__markup__"){
					cell.innerHTML=data[i][this.columns[j].getField()];
					for(var k=0; k<cell.childNodes.length; k++){
						var node=cell.childNodes[k];
						if(node&&node.nodeType==dojo.html.ELEMENT_NODE){
							dojo.html.disableSelection(node);
						}
					}
				}else{
					if(this.columns[j].getType()==Date){
						var format=this.defaultDateFormat;
						if(this.columns[j].format) format=this.columns[j].format;
						cell.appendChild(document.createTextNode(dojo.date.format(data[i][this.columns[j].getField()], format)));
					}else{
						cell.appendChild(document.createTextNode(data[i][this.columns[j].getField()]));
					}
				}
				row.appendChild(cell);
			}
			body.appendChild(row);
			dojo.event.connect(row, "onclick", this, "onUISelect");
		}
		
		//	if minRows exist.
		var minRows=parseInt(this.minRows);
		if (!isNaN(minRows) && minRows>0 && data.length<minRows){
			var mod=0;
			if(data.length%2==0) mod=1;
			var nRows=minRows-data.length;
			for(var i=0; i<nRows; i++){
				var row=document.createElement("tr");
				row.setAttribute("ignoreIfParsed","true");
				if(this.enableAlternateRows&&i%2==mod){
					row.className=this.rowAlternateClass;
				}
				for(var j=0;j<this.columns.length;j++){
					var cell=document.createElement("td");
					cell.appendChild(document.createTextNode("\u00A0"));
					row.appendChild(cell);
				}
				body.appendChild(row);
			}
		}
	},

	//	the following the user can override.
	onSelect:function(/* DomEvent */ e){ 
		//	summary
		//	empty function for the user to attach code to, fired by onUISelect
	},
	onUISelect:function(/* DomEvent */ e){
		//	summary
		//	fired when a user selects a row
		var row=dojo.html.getParentByType(e.target,"tr");
		var body=dojo.html.getParentByType(row,"tbody");
		if(this.enableMultipleSelect){
			if(e.metaKey||e.ctrlKey){
				if(this.isSelected(this.getObjectFromRow(row))){
					this.removeFromSelected(this.getObjectFromRow(row));
					row.removeAttribute("selected");
				}else{
					//	push onto the selection stack.
					this.setSelectionByRow(row);
					row.setAttribute("selected","true");
				}
			}else if(e.shiftKey){
				//	the tricky one.  We need to figure out the *last* selected row above, 
				//	and select all the rows in between.
				var startRow;
				var rows=body.getElementsByTagName("tr");
				//	if there's a selection above, we go with that first. 
				for(var i=0;i<rows.length;i++){
					if(rows[i].parentNode==body){
						if(rows[i]==row) break;
						if(dojo.html.getAttribute(rows[i],"selected")=="true"){
							startRow=rows[i];
						}
					}
				}
				//	if there isn't a selection above, we continue with a selection below.
				if(!startRow){
					startRow=row;
					for(;i<rows.length;i++){
						if(dojo.html.getAttribute(rows[i],"selected")=="true"){
							row=rows[i];
							break;
						}
					}
				}
				this.resetSelections(body);
				if(startRow==row){
					//	this is the only selection
					row.setAttribute("selected","true");
					this.setSelectionByRow(row);
				}else{
					var doSelect=false;
					for(var i=0; i<rows.length; i++){
						if(rows[i].parentNode==body){
							rows[i].removeAttribute("selected");
							if(rows[i]==startRow){
								doSelect=true;
							}
							if(doSelect){
								this.setSelectionByRow(rows[i]);
								rows[i].setAttribute("selected","true");
							}
							if(rows[i]==row){
								doSelect=false;
							}
						}
					}
				}
			}else{
				//	reset the selection
				this.resetSelections(body);
				row.setAttribute("selected","true");
				this.setSelectionByRow(row);
			}
		}else{
			//	reset the data selection and go.
			this.resetSelections(body);
			row.setAttribute("selected","true");
			this.setSelectionByRow(row);
		}
		this.showSelections();
		this.onSelect(e);
		e.stopPropagation();
		e.preventDefault();
	},
	onHeaderClick:function(/* DomEvent */ e){
		//	summary
		//	Main handler function for each header column click.
		var oldIndex=this.sortIndex;
		var oldDirection=this.sortDirection;
		var source=e.target;
		var row=dojo.html.getParentByType(source,"tr");
		var cellTag="td";
		if(row.getElementsByTagName(cellTag).length==0) cellTag="th";

		var headers=row.getElementsByTagName(cellTag);
		var header=dojo.html.getParentByType(source,cellTag);
		
		for(var i=0; i<headers.length; i++){
			if(headers[i]==header){
				if(i!=oldIndex){
					//	new col.
					this.sortIndex=i;
					this.sortDirection=0;
					headers[i].className=this.headerSortDownClass
				}else{
					this.sortDirection=(oldDirection==0)?1:0;
					if(this.sortDirection==0){
						headers[i].className=this.headerSortDownClass;
					}else{
						headers[i].className=this.headerSortUpClass;
					}
				}
			}else{
				//	reset the header class.
				headers[i].className=this.headerClass;
			}
		}
		this.render();
	},

	postCreate:function(){ 
		// 	summary
		//	overridden from HtmlWidget, initializes and renders the widget.
		var thead=this.domNode.getElementsByTagName("thead")[0];
		if(this.headClass.length>0){
			thead.className=this.headClass;
		}

		//	disable selections
		dojo.html.disableSelection(this.domNode);

		//	parse the columns.
		this.parseColumns(thead);

		//	attach header handlers.
		var header="td";
		if(thead.getElementsByTagName(header).length==0) header="th";
		var headers=thead.getElementsByTagName(header);
		for(var i=0; i<headers.length; i++){
			if(!this.columns[i].noSort){
				dojo.event.connect(headers[i], "onclick", this, "onHeaderClick");
			}
			if(this.sortIndex==i){
				if(this.sortDirection==0){
					headers[i].className=this.headerSortDownClass;
				}else{
					headers[i].className=this.headerSortUpClass;
				}
			}
		}

		//	parse the tbody element and re-render it.
		var tbody=this.domNode.getElementsByTagName("tbody")[0];
		if (this.tbodyClass.length>0) {
			tbody.className=this.tbodyClass;
		}

		this.parseDataFromTable(tbody);
		this.render(true);
	}
});

__CPAN_FILE__ src/widget/html/stabile.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

// Maintain state of widgets when user hits back/forward button

dojo.provide("dojo.widget.html.stabile");

dojo.widget.html.stabile = {
	// Characters to quote in single-quoted regexprs
	_sqQuotables: new RegExp("([\\\\'])", "g"),

	// Current depth.
	_depth: 0,

	// Set to true when calling v.toString, to sniff for infinite
	// recursion.
	_recur: false,

	// Levels of nesting of Array and object displays.
	// If when >= depth, no display or array or object internals.
	depthLimit: 2
};





//// PUBLIC METHODS

// Get the state stored for the widget with the given ID, or undefined
// if none.
// 
dojo.widget.html.stabile.getState = function(id){
	dojo.widget.html.stabile.setup();
	return dojo.widget.html.stabile.widgetState[id];
}


// Set the state stored for the widget with the given ID.  If isCommit
// is true, commits all widget state to more stable storage.
// 
dojo.widget.html.stabile.setState = function(id, state, isCommit){
	dojo.widget.html.stabile.setup();
	dojo.widget.html.stabile.widgetState[id] = state;
	if(isCommit){
		dojo.widget.html.stabile.commit(dojo.widget.html.stabile.widgetState);
	}
}


// Sets up widgetState: a hash keyed by widgetId, maps to an object
// or array writable with "describe".  If there is data in the widget
// storage area, use it, otherwise initialize an empty object.
// 
dojo.widget.html.stabile.setup = function(){
	if(!dojo.widget.html.stabile.widgetState){
		var text = dojo.widget.html.stabile.getStorage().value;
		dojo.widget.html.stabile.widgetState = text ? dj_eval("("+text+")") : {};
	}
}


// Commits all widget state to more stable storage, so if the user
// navigates away and returns, it can be restored.
// 
dojo.widget.html.stabile.commit = function(state){
	dojo.widget.html.stabile.getStorage().value = dojo.widget.html.stabile.description(state);
}


// Return a JSON "description string" for the given value.
// Supports only core JavaScript types with literals, plus Date,
// and cyclic structures are unsupported.
// showAll defaults to false -- if true, this becomes a simple symbolic
// object dumper, but you cannot "eval" the output.
//
dojo.widget.html.stabile.description = function(v, showAll){
	// Save and later restore dojo.widget.html.stabile._depth;
	var depth = dojo.widget.html.stabile._depth;

	try {

		if(v===void(0)){
			return "undefined";
		}
		if(v===null){
			return "null";
		}
		if(typeof(v)=="boolean" || typeof(v)=="number"
		    || v instanceof Boolean || v instanceof Number){
			return v.toString();
		}

		if(typeof(v)=="string" || v instanceof String){
			// Quote strings and their contents as required.
			// Replacing by $& fails in IE 5.0
			var v1 = v.replace(dojo.widget.html.stabile._sqQuotables, "\\$1"); 
			v1 = v1.replace(/\n/g, "\\n");
			v1 = v1.replace(/\r/g, "\\r");
			// Any other important special cases?
			return "'"+v1+"'";
		}

		if(v instanceof Date){
			// Create a data constructor.
			return "new Date("+d.getFullYear+","+d.getMonth()+","+d.getDate()+")";
		}

		var d;
		if(v instanceof Array || v.push){
			// "push" test needed for KHTML/Safari, don't know why -cp

			if(depth>=dojo.widget.html.stabile.depthLimit)
			  return "[ ... ]";

			d = "[";
			var first = true;
			dojo.widget.html.stabile._depth++;
			for(var i=0; i<v.length; i++){
				// Skip functions and undefined values
				// if(v[i]==undef || typeof(v[i])=="function")
				//   continue;
				if(first){
					first = false;
				}else{
					d += ",";
				}
				d+=arguments.callee(v[i], showAll);
			}
			return d+"]";
		}

		if(v.constructor==Object
		    || v.toString==describeThis){
			if(depth>=dojo.widget.html.stabile.depthLimit)
			  return "{ ... }";

			// Instanceof Hash is good, or if we just use Objects,
			// we can say v.constructor==Object.
			// IE (5?) lacks hasOwnProperty, but perhaps objects do not always
			// have prototypes??
			if(typeof(v.hasOwnProperty)!="function" && v.prototype){
				throw new Error("description: "+v+" not supported by script engine");
			}
			var first = true;
			d = "{";
			dojo.widget.html.stabile._depth++;
			for(var key in v){
				// Skip values that are functions or undefined.
				if(v[key]==void(0) || typeof(v[key])=="function")
					continue;
				if(first){
					first = false;
				}else{
					d += ", ";
				}
				kd = key;
				// If the key is not a legal identifier, use its description.
				// For strings this will quote the stirng.
				if(!kd.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)){
					kd = arguments.callee(key, showAll);
				}
				d += kd+": "+arguments.callee(v[key], showAll);
			}
			return d+"}";
		}

		if(showAll){
			if(dojo.widget.html.stabile._recur){
				return objectToString.apply(v, []);
			}else{
				dojo.widget.html.stabile._recur = true;
				return v.toString();
			}
		}else{
			// log("Description? "+v.toString()+", "+typeof(v));
			throw new Error("Unknown type: "+v);
			return "'unknown'";
		}

	} finally {
		// Always restore the global current depth.
		dojo.widget.html.stabile._depth = depth;
	}

}



//// PRIVATE TO MODULE

// Gets an object (form field) with a read/write "value" property.
// 
dojo.widget.html.stabile.getStorage = function(){
	if (dojo.widget.html.stabile.dataField) {
		return dojo.widget.html.stabile.dataField;
	}
	var form = document.forms._dojo_form;
	return dojo.widget.html.stabile.dataField = form ? form.stabile : {value: ""};
}


__CPAN_FILE__ src/widget/html/TaskBar.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.TaskBar");
dojo.provide("dojo.widget.html.TaskBarItem");

dojo.require("dojo.widget.*");
dojo.require("dojo.widget.FloatingPane");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.event");

// Icon associated w/a floating pane
dojo.widget.html.TaskBarItem = function(){
	dojo.widget.TaskBarItem.call(this);
	dojo.widget.HtmlWidget.call(this);
}
dojo.inherits(dojo.widget.html.TaskBarItem, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.TaskBarItem, {
	// constructor arguments
	iconSrc: '',
	caption: 'Untitled',
	window: null,
	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlTaskBarItemTemplate.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlTaskBar.css"),

	fillInTemplate: function() {
		if ( this.iconSrc != '' ) {
			var img = document.createElement("img");
			img.src = this.iconSrc;
			this.domNode.appendChild(img);
		}
		this.domNode.appendChild(document.createTextNode(this.caption));
		dojo.html.disableSelection(this.domNode);
	},

	postCreate: function() {
		this.window=dojo.widget.getWidgetById(this.windowId);
		this.window.explodeSrc = this.domNode;
		dojo.event.connect(this.window, "destroy", this, "destroy")
	},

	onClick: function() {
		this.window.show();
	}
});

// Collection of widgets in a bar, like Windows task bar
dojo.widget.html.TaskBar = function(){

	dojo.widget.html.FloatingPane.call(this);
	dojo.widget.TaskBar.call(this);
	this.titleBarDisplay = "none";
	this._addChildStack = [];
}

dojo.inherits(dojo.widget.html.TaskBar, dojo.widget.html.FloatingPane);

dojo.lang.extend(dojo.widget.html.TaskBar, {
	addChild: function(child) {
		if(!this.containerNode){ 
			this._addChildStack.push(child);
		}else if(this._addChildStack.length > 0){
			var oarr = this._addChildStack;
			this._addChildStack = [];
			dojo.lang.forEach(oarr, function(c){ this.addChild(c); }, this);
		}
		var tbi = dojo.widget.createWidget("TaskBarItem",
			{	windowId: child.widgetId, 
				caption: child.title, 
				iconSrc: child.iconSrc
			});
		dojo.widget.html.TaskBar.superclass.addChild.call(this,tbi);
	}
});

__CPAN_FILE__ src/widget/html/TimePicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.TimePicker");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.TimePicker");
dojo.require("dojo.event.*");
dojo.require("dojo.date");
dojo.require("dojo.html");

dojo.widget.html.TimePicker = function(){
	dojo.widget.TimePicker.call(this);
	dojo.widget.HtmlWidget.call(this);


	var _this = this;
	// selected time, JS Date object
	this.time = "";
	// set following flag to true if a default time should be set
	this.useDefaultTime = false;
	// set the following to true to set default minutes to current time, false to // use zero
	this.useDefaultMinutes = false;
	// rfc 3339 date
	this.storedTime = "";
	// time currently selected in the UI, stored in hours, minutes, seconds in the format that will be actually displayed
	this.currentTime = {};
	this.classNames = {
		selectedTime: "selectedItem"
	}
	this.any = "any"
	// dom node indecies for selected hour, minute, amPm, and "any time option"
	this.selectedTime = {
		hour: "",
		minute: "",
		amPm: "",
		anyTime: false
	}

	// minutes are ordered as follows: ["12", "6", "1", "7", "2", "8", "3", "9", "4", "10", "5", "11"]
	this.hourIndexMap = ["", 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11, 0];
	// minutes are ordered as follows: ["00", "30", "05", "35", "10", "40", "15", "45", "20", "50", "25", "55"]
	this.minuteIndexMap = [0, 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11];

	this.templatePath =  dojo.uri.dojoUri("src/widget/templates/HtmlTimePicker.html");
	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlTimePicker.css");

	this.fillInTemplate = function(){
		this.initData();
		this.initUI();
	}

	this.initData = function() {
		// FIXME: doesn't currently validate the time before trying to set it
		// Determine the date/time from stored info, or by default don't 
		//  have a set time
		// FIXME: should normalize against whitespace on storedTime... for now 
		// just a lame hack
		if(this.storedTime.indexOf("T")!=-1 && this.storedTime.split("T")[1] && this.storedTime!=" " && this.storedTime.split("T")[1]!="any") {
			this.time = dojo.widget.TimePicker.util.fromRfcDateTime(this.storedTime, this.useDefaultMinutes, this.selectedTime.anyTime);
		} else if (this.useDefaultTime) {
			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", this.useDefaultMinutes, this.selectedTime.anyTime);
		} else {
			this.selectedTime.anyTime = true;
			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", 0, 1);
		}
	}

	this.initUI = function() {
		// set UI to match the currently selected time
		if(!this.selectedTime.anyTime && this.time) {
			var amPmHour = dojo.widget.TimePicker.util.toAmPmHour(this.time.getHours());
			var hour = amPmHour[0];
			var isAm = amPmHour[1];
			var minute = this.time.getMinutes();
			var minuteIndex = parseInt(minute/5);
			this.onSetSelectedHour(this.hourIndexMap[hour]);
			this.onSetSelectedMinute(this.minuteIndexMap[minuteIndex]);
			this.onSetSelectedAmPm(isAm);
		} else {
			this.onSetSelectedAnyTime();
		}
	}

	this.setDateTime = function(rfcDate) {
		this.storedTime = rfcDate;
	}
	
	this.onClearSelectedHour = function(evt) {
		this.clearSelectedHour();
	}

	this.onClearSelectedMinute = function(evt) {
		this.clearSelectedMinute();
	}

	this.onClearSelectedAmPm = function(evt) {
		this.clearSelectedAmPm();
	}

	this.onClearSelectedAnyTime = function(evt) {
		this.clearSelectedAnyTime();
		if(this.selectedTime.anyTime) {
			this.selectedTime.anyTime = false;
			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", this.useDefaultMinutes);
			this.initUI();
		}
	}

	this.clearSelectedHour = function() {
		var hourNodes = this.hourContainerNode.getElementsByTagName("td");
		for (var i=0; i<hourNodes.length; i++) {
			dojo.html.setClass(hourNodes.item(i), "");
		}
	}

	this.clearSelectedMinute = function() {
		var minuteNodes = this.minuteContainerNode.getElementsByTagName("td");
		for (var i=0; i<minuteNodes.length; i++) {
			dojo.html.setClass(minuteNodes.item(i), "");
		}
	}

	this.clearSelectedAmPm = function() {
		var amPmNodes = this.amPmContainerNode.getElementsByTagName("td");
		for (var i=0; i<amPmNodes.length; i++) {
			dojo.html.setClass(amPmNodes.item(i), "");
		}
	}

	this.clearSelectedAnyTime = function() {
		dojo.html.setClass(this.anyTimeContainerNode, "anyTimeContainer");
	}

	this.onSetSelectedHour = function(evt) {
		this.onClearSelectedAnyTime();
		this.onClearSelectedHour();
		this.setSelectedHour(evt);
		this.onSetTime();
	}

	this.setSelectedHour = function(evt) {
		if(evt && evt.target) {
			dojo.html.setClass(evt.target, this.classNames.selectedTime);
			this.selectedTime["hour"] = evt.target.innerHTML;
		} else if (!isNaN(evt)) {
			var hourNodes = this.hourContainerNode.getElementsByTagName("td");
			if(hourNodes.item(evt)) {
				dojo.html.setClass(hourNodes.item(evt), this.classNames.selectedTime);
				this.selectedTime["hour"] = hourNodes.item(evt).innerHTML;
			}
		}
		this.selectedTime.anyTime = false;
	}

	this.onSetSelectedMinute = function(evt) {
		this.onClearSelectedAnyTime();
		this.onClearSelectedMinute();
		this.setSelectedMinute(evt);
		this.selectedTime.anyTime = false;
		this.onSetTime();
	}

	this.setSelectedMinute = function(evt) {
		if(evt && evt.target) {
			dojo.html.setClass(evt.target, this.classNames.selectedTime);
			this.selectedTime["minute"] = evt.target.innerHTML;
		} else if (!isNaN(evt)) {
			var minuteNodes = this.minuteContainerNode.getElementsByTagName("td");
			if(minuteNodes.item(evt)) {
				dojo.html.setClass(minuteNodes.item(evt), this.classNames.selectedTime);
				this.selectedTime["minute"] = minuteNodes.item(evt).innerHTML;
			}
		}
	}

	this.onSetSelectedAmPm = function(evt) {
		this.onClearSelectedAnyTime();
		this.onClearSelectedAmPm();
		this.setSelectedAmPm(evt);
		this.selectedTime.anyTime = false;
		this.onSetTime();
	}

	this.setSelectedAmPm = function(evt) {
		if(evt && evt.target) {
			dojo.html.setClass(evt.target, this.classNames.selectedTime);
			this.selectedTime["amPm"] = evt.target.innerHTML;
		} else {
			evt = evt ? 0 : 1;
			var amPmNodes = this.amPmContainerNode.getElementsByTagName("td");
			if(amPmNodes.item(evt)) {
				dojo.html.setClass(amPmNodes.item(evt), this.classNames.selectedTime);
				this.selectedTime["amPm"] = amPmNodes.item(evt).innerHTML;
			}
		}
	}

	this.onSetSelectedAnyTime = function(evt) {
		this.onClearSelectedHour();
		this.onClearSelectedMinute();
		this.onClearSelectedAmPm();
		this.setSelectedAnyTime();
		this.onSetTime();
	}

	this.setSelectedAnyTime = function(evt) {
		this.selectedTime.anyTime = true;
		dojo.html.setClass(this.anyTimeContainerNode, this.classNames.selectedTime + " " + "anyTimeContainer");
	}

	this.onClick = function(evt) {
		dojo.event.browser.stopEvent(evt)
	}

	this.onSetTime = function() {
		if(this.selectedTime.anyTime) {
			this.time = new Date();
			var tempDateTime = dojo.widget.TimePicker.util.toRfcDateTime(this.time);
			this.setDateTime(tempDateTime.split("T")[0]);
		} else {
			var hour = 12;
			var minute = 0;
			var isAm = false;
			if(this.selectedTime["hour"]) {
				hour = parseInt(this.selectedTime["hour"], 10);
			}
			if(this.selectedTime["minute"]) {
				minute = parseInt(this.selectedTime["minute"], 10);
			}
			if(this.selectedTime["amPm"]) {
				isAm = (this.selectedTime["amPm"].toLowerCase() == "am");
			}
			this.time = new Date();
			this.time.setHours(dojo.widget.TimePicker.util.fromAmPmHour(hour, isAm));
			this.time.setMinutes(minute);
			this.setDateTime(dojo.widget.TimePicker.util.toRfcDateTime(this.time));
		}
	}

}
dojo.inherits(dojo.widget.html.TimePicker, dojo.widget.HtmlWidget);

__CPAN_FILE__ src/widget/html/TitlePane.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.TitlePane");
dojo.require("dojo.widget.*");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.lfx.*");

dojo.widget.html.TitlePane = function(){
	dojo.widget.HtmlWidget.call(this);
	this.widgetType = "TitlePane";

	this.labelNode="";
	this.labelNodeClass="";
	this.containerNodeClass="";
	this.label="";

	this.open=true;
	this.templatePath = dojo.uri.dojoUri("src/widget/templates/TitlePane.html");
}

dojo.inherits(dojo.widget.html.TitlePane, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.TitlePane, {
	isContainer: true,
	postCreate: function() {
		if (this.label) {
			this.labelNode.appendChild(document.createTextNode(this.label));
		}

		if (this.labelNodeClass) {
			dojo.html.addClass(this.labelNode, this.labelNodeClass);
		}	

		if (this.containerNodeClass) {
			dojo.html.addClass(this.containerNode, this.containerNodeClass);
		}	

		if (!this.open) {
			dojo.lfx.wipeOut(this.containerNode,0).play();
		}
	},

	onLabelClick: function() {
		if (this.open) {
			dojo.lfx.wipeOut(this.containerNode,250).play();
			this.open=false;
		}else {
			dojo.lfx.wipeIn(this.containerNode,250).play();
			this.open=true;
		}
	},

	setContent: function(content) {
		this.containerNode.innerHTML=content;
	},

	setLabel: function(label) {
		this.labelNode.innerHTML=label;
	}
});

dojo.widget.tags.addParseTreeHandler("dojo:TitlePane");

__CPAN_FILE__ src/widget/html/Tooltip.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.Tooltip");
dojo.require("dojo.widget.html.ContentPane");
dojo.require("dojo.widget.Tooltip");
dojo.require("dojo.uri");
dojo.require("dojo.widget.*");
dojo.require("dojo.event");
dojo.require("dojo.style");
dojo.require("dojo.html");

dojo.widget.html.Tooltip = function(){
	// mix in the tooltip properties
	dojo.widget.Tooltip.call(this);
	dojo.widget.html.ContentPane.call(this);
}
dojo.inherits(dojo.widget.html.Tooltip, dojo.widget.html.ContentPane);
dojo.lang.extend(dojo.widget.html.Tooltip, {

	// Constructor arguments (should these be in tooltip.js rather than html/tooltip.js???)
	caption: "",
	showDelay: 500,
	hideDelay: 100,
	connectId: "",

	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlTooltipTemplate.html"),
	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlTooltipTemplate.css"),

	connectNode: null,

	// Tooltip has the following possible states:
	//   erased - nothing on screen
	//   displaying - currently being faded in (partially displayed)
	//   displayed - fully displayed
	//   erasing - currently being faded out (partially erased)
	state: "erased",

	fillInTemplate: function(args, frag){
		if(this.caption != ""){
			this.domNode.appendChild(document.createTextNode(this.caption));
		}
		this.connectNode = dojo.byId(this.connectId);		
		dojo.widget.html.Tooltip.superclass.fillInTemplate.call(this, args, frag);
	},
	
	postCreate: function(args, frag){
		// The domnode was appended to my parent widget's domnode, but the positioning
		// only works if the domnode is a child of document.body
		document.body.appendChild(this.domNode);

		dojo.event.connect(this.connectNode, "onmouseover", this, "onMouseOver");
		dojo.widget.html.Tooltip.superclass.postCreate.call(this, args, frag);
	},
	
	onMouseOver: function(e) {
		this.mouse = {x: e.pageX, y: e.pageY};

		if(!this.showTimer){
			this.showTimer = setTimeout(dojo.lang.hitch(this, "show"), this.showDelay);
			dojo.event.connect(document.documentElement, "onmousemove", this, "onMouseMove");
		}
	},

	onMouseMove: function(e) {
		this.mouse = {x: e.pageX, y: e.pageY};

		if(dojo.html.overElement(this.connectNode, e) || dojo.html.overElement(this.domNode, e)) {
			// If the tooltip has been scheduled to be erased, cancel that timer
			// since we are hovering over element/tooltip again
			if(this.hideTimer) {
				clearTimeout(this.hideTimer);
				delete this.hideTimer;
			}
		} else {
			// mouse has been moved off the element/tooltip
			// note: can't use onMouseOut to detect this because the "explode" effect causes
			// spurious onMouseOut/onMouseOver events (due to interference from outline)
			if(this.showTimer){
				clearTimeout(this.showTimer);
				delete this.showTimer;
			}
			if((this.state=="displaying"||this.state=="displayed") && !this.hideTimer){
				this.hideTimer = setTimeout(dojo.lang.hitch(this, "hide"), this.hideDelay);
			}
		}
	},

	show: function() {
		if(this.state=="erasing"){
			// we are in the process of erasing; when that is finished, display it.
			this.displayScheduled=true;
			return;
		}
		if ( this.state=="displaying" || this.state=="displayed" ) { return; }

		// prevent IE bleed through (iframe creation is deferred until first show()
		// call because apparently it takes a long time)
		if(!this.bgIframe){
			this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);
		}

		this.position();

		// if rendering using explosion effect, need to set explosion source
		this.explodeSrc = [this.mouse.x, this.mouse.y];

		this.state="displaying";

		dojo.widget.html.Tooltip.superclass.show.call(this);
	},

	onShow: function() {
		dojo.widget.html.Tooltip.superclass.onShow.call(this);
		
		this.state="displayed";
		
		// in the corner case where the user has moved his mouse away
		// while the tip was fading in
		if(this.eraseScheduled){
			this.hide();
			this.eraseScheduled=false;
		}
	},

	hide: function() {
		if(this.state=="displaying"){
			// in the process of fading in.  wait until that is finished and then fade out
			this.eraseScheduled=true;
			return;
		}
		if ( this.state=="displayed" ) {
			this.state="erasing";
			if ( this.showTimer ) {
				clearTimeout(this.showTimer);
				delete this.showTimer;
			}
			if ( this.hideTimer ) {
				clearTimeout(this.hideTimer);
				delete this.hideTimer;
			}
			dojo.event.disconnect(document.documentElement, "onmousemove", this, "onMouseMove");
			dojo.widget.html.Tooltip.superclass.hide.call(this);
		}
	},

	onHide: function(){
		this.state="erased";

		// in the corner case where the user has moved his mouse back
		// while the tip was fading out
		if(this.displayScheduled){
			this.display();
			this.displayScheduled=false;
		}
	},

	position: function(){
		dojo.html.placeOnScreenPoint(this.domNode, this.mouse.x, this.mouse.y, [10,15], true);
		this.bgIframe.onResized();
	},

	onLoad: function(){
		// the tooltip has changed size due to downloaded contents, so reposition it
		dojo.lang.setTimeout(this, this.position, 50);
		dojo.widget.html.Tooltip.superclass.onLoad.apply(this, arguments);
	},

	onParentResized: function() {
		// onParentResized() is called when the user has resized the browser window,
		// but that doesn't affect this widget (or this widget's children)
		// so it can be safely ignored
	}
});

__CPAN_FILE__ src/widget/html/YahooMap.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.html.YahooMap");
dojo.require("dojo.event.*");
dojo.require("dojo.html");
dojo.require("dojo.math");
dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.YahooMap");

(function(){
	var yappid = djConfig["yAppId"]||djConfig["yahooAppId"]||"dojotoolkit";
	if(!dojo.hostenv.post_load_){
		if(yappid == "dojotoolkit"){
			dojo.debug("please provide a unique Yahoo App ID in djConfig.yahooAppId when using the map widget");
		}
		var tag = "<scr"+"ipt src='http://api.maps.yahoo.com/ajaxymap?v=3.0&appid="+yappid+"'></scri"+"pt>";
		if(!dj_global["YMap"]){
			document.write(tag);
		}
	}else{
		dojo.debug("cannot initialize map system after the page has been loaded! Please either manually include the script block provided by Yahoo in your page or require() the YahooMap widget before onload has fired");
	}
})();

dojo.widget.html.YahooMap=function(){
	dojo.widget.HtmlWidget.call(this);
	dojo.widget.YahooMap.call(this);

	this.map=null;
	this.datasrc="";
	this.data=[];
	this.width=0;
	this.height=0;
	this.controls=["zoomlong","maptype","pan"];
};
dojo.inherits(dojo.widget.html.YahooMap, dojo.widget.HtmlWidget);

dojo.lang.extend(dojo.widget.html.YahooMap, {
	widgetType: "YahooMap",
	templatePath:null,
	templateCssPath:null,

	findCenter:function(aPts){
		var start=new YGeoPoint(37,-90);
		if(aPts.length==0) return start;
		var minLat,maxLat, minLon, maxLon, cLat, cLon;
		minLat=maxLat=aPts[0].Lat;
		minLon=maxLon=aPts[0].Lon;
		for(var i=0; i<aPts.length; i++){
			minLat=Math.min(minLat,aPts[i].Lat);
			maxLat=Math.max(maxLat,aPts[i].Lat);
			minLon=Math.min(minLon,aPts[i].Lon);
			maxLon=Math.max(maxLon,aPts[i].Lon);
		}
		cLat=dojo.math.round((minLat+maxLat)/2,6);
		cLon=dojo.math.round((minLon+maxLon)/2,6);
		return new YGeoPoint(cLat,cLon);
	},
	setControls:function(){
		var c=this.controls;
		var t=dojo.widget.YahooMap.Controls;
		for(var i=0; i<c.length; i++){
			switch(c[i]){
				case t.MapType:{
					this.map.addTypeControl();
					break;
				}
				case t.Pan:{
					this.map.addPanControl();
					break;
				}
				case t.ZoomLong:{
					this.map.addZoomLong();
					break;
				}
				case t.ZoomShort:{
					this.map.addZoomShort();
					break;
				}
			}
		}
	},
	
	parse:function(table){
		this.data=[];

		//	get the column indices
		var h=table.getElementsByTagName("thead")[0];
		if(!h){
			return;
		}

		var a=[];
		var cols=h.getElementsByTagName("td");
		if(cols.length==0){
			cols=h.getElementsByTagName("th");
		}
		for(var i=0; i<cols.length; i++){
			var c=cols[i].innerHTML.toLowerCase();
			if(c=="long") c="lng";
			a.push(c);
		}
		
		//	parse the data
		var b=table.getElementsByTagName("tbody")[0];
		if(!b){
			return;
		}
		for(var i=0; i<b.childNodes.length; i++){
			if(!(b.childNodes[i].nodeName&&b.childNodes[i].nodeName.toLowerCase()=="tr")){
				continue;
			}
			var cells=b.childNodes[i].getElementsByTagName("td");
			var o={};
			for(var j=0; j<a.length; j++){
				var col=a[j];
				if(col=="lat"||col=="lng"){
					o[col]=parseFloat(cells[j].innerHTML);					
				}else{
					o[col]=cells[j].innerHTML;
				}
			}
			this.data.push(o);
		}
	},
	render:function(){
		var pts=[];
		var d=this.data;
		for(var i=0; i<d.length; i++){
			var pt=new YGeoPoint(d[i].lat, d[i].lng);
			pts.push(pt);
			var icon=d[i].icon||null;
			if(icon){
				icon=new YImage(icon);
			}
			var m=new YMarker(pt,icon);
			if(d[i].description){
				m.addAutoExpand("<div>"+d[i].description+"</div>");
			}
			this.map.addOverlay(m);
		}
		var c=this.findCenter(pts);
		var z=this.map.getZoomLevel(pts);
		this.map.drawZoomAndCenter(c,z);
	},
	
	initialize:function(args, frag){
		if(!YMap || !YGeoPoint){
			dojo.raise("dojo.widget.YahooMap: The Yahoo Map script must be included in order to use this widget.");
		}
		if(this.datasrc){
			this.parse(dojo.byId(this.datasrc));
		}
		else if(this.domNode.getElementsByTagName("table")[0]){
			this.parse(this.domNode.getElementsByTagName("table")[0]);
		}
	},
	postCreate:function(){
		//	clean the domNode before creating the map.
		while(this.domNode.childNodes.length>0){
			this.domNode.removeChild(this.domNode.childNodes[0]);
		}

		if(this.width>0&&this.height>0){
			this.map=new YMap(this.domNode, YAHOO_MAP_REG, new YSize(this.width, this.height));
		}else{
			this.map=new YMap(this.domNode);
		}
		this.setControls();
		this.render();
	}
});

__CPAN_DIR__ src/widget/svg
__CPAN_FILE__ src/widget/svg/Chart.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.svg.Chart");

dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.Chart");
dojo.require("dojo.math");
dojo.require("dojo.html");
dojo.require("dojo.svg");
dojo.require("dojo.graphics.color");

dojo.widget.svg.Chart=function(){
	dojo.widget.Chart.call(this);
	dojo.widget.HtmlWidget.call(this);
};
dojo.inherits(dojo.widget.svg.Chart, dojo.widget.HtmlWidget);
dojo.lang.extend(dojo.widget.svg.Chart, {
	//	widget props
	templatePath:null,
	templateCssPath:null,

	//	state
	_isInitialized:false,
	hasData:false,

	//	chart props
	vectorNode:null,
	plotArea:null,
	dataGroup:null,
	axisGroup:null,

	properties:{
		height:400,	//	defaults, will resize to the domNode.
		width:600,
		plotType:null,
		padding:{
			top:10,
			bottom:2,
			left:60,
			right:30
		},
		axes:{
			x:{
				plotAt:0,
				label:"",
				unitLabel:"",
				unitType:Number,
				nUnitsToShow:10,
				range:{
					min:0,
					max:200
				}
			},
			y:{
				plotAt:0,
				label:"",
				unitLabel:"",
				unitType:Number,
				nUnitsToShow:10,
				range:{
					min:0,
					max:200
				}
			}
		}
	},
	
	fillInTemplate:function(args,frag){
		this.initialize();
		this.render();
	},
	parseData:function(){
	},
	initialize:function(){
		this.parseData();
	
		//	begin by grabbing the table, and reading it in.
		var table=this.domNode.getElementsByTagName("table")[0];
		if (!table) return;
		
		var bRangeX=false;
		var bRangeY=false;
		
		//	properties off the table
		if (table.getAttribute("width")) this.properties.width=table.getAttribute("width");
		if (table.getAttribute("height")) this.properties.height=table.getAttribute("height");
		if (table.getAttribute("plotType")) this.properties.plotType=table.getAttribute("plotType");
		if (table.getAttribute("padding")){
			if (table.getAttribute("padding").indexOf(",") > -1)
				var p=table.getAttribute("padding").split(","); 
			else var p=table.getAttribute("padding").split(" ");
			if (p.length==1){
				var pad=parseFloat(p[0]);
				this.properties.padding.top=pad;
				this.properties.padding.right=pad;
				this.properties.padding.bottom=pad;
				this.properties.padding.left=pad;
			} else if(p.length==2){
				var padV=parseFloat(p[0]);
				var padH=parseFloat(p[1]);
				this.properties.padding.top=padV;
				this.properties.padding.right=padH;
				this.properties.padding.bottom=padV;
				this.properties.padding.left=padH;
			} else if(p.length==4){
				this.properties.padding.top=parseFloat(p[0]);
				this.properties.padding.right=parseFloat(p[1]);
				this.properties.padding.bottom=parseFloat(p[2]);
				this.properties.padding.left=parseFloat(p[3]);
			}
		}
		if (table.getAttribute("rangeX")){
			var p=table.getAttribute("rangeX");
			if (p.indexOf(",")>-1) p=p.split(",");
			else p=p.split(" ");
			this.properties.axes.x.range.min=parseFloat(p[0]);
			this.properties.axes.x.range.max=parseFloat(p[1]);
			bRangeX=true;
		}
		if (table.getAttribute("rangeY")){
			var p=table.getAttribute("rangeY");
			if (p.indexOf(",")>-1) p=p.split(",");
			else p=p.split(" ");
			this.properties.axes.y.range.min=parseFloat(p[0]);
			this.properties.axes.y.range.max=parseFloat(p[1]);
			bRangeY=true;
		}

		var thead=table.getElementsByTagName("thead")[0];
		var tbody=table.getElementsByTagName("tbody")[0];
		if(!(thead&&tbody)) dojo.raise("dojo.widget.Chart: supplied table must define a head and a body.");

		//	set up the series.
		var columns=thead.getElementsByTagName("tr")[0].getElementsByTagName("th");	//	should be <tr><..>
		
		//	assume column 0 == X
		for (var i=1; i<columns.length; i++){
			var key="column"+i;
			var label=columns[i].innerHTML;
			var plotType=columns[i].getAttribute("plotType")||"line";
			var color=columns[i].getAttribute("color");
			var ds=new dojo.widget.Chart.DataSeries(key,label,plotType,color);
			this.series.push(ds);
		}

		//	ok, get the values.
		var rows=tbody.getElementsByTagName("tr");
		var xMin=Number.MAX_VALUE,xMax=Number.MIN_VALUE;
		var yMin=Number.MAX_VALUE,yMax=Number.MIN_VALUE;
		var ignore = [
			"accesskey","align","bgcolor","class",
			"colspan","height","id","nowrap",
			"rowspan","style","tabindex","title",
			"valign","width"
		];

		for(var i=0; i<rows.length; i++){
			var row=rows[i];
			var cells=row.getElementsByTagName("td");
			var x=Number.MIN_VALUE;
			for (var j=0; j<cells.length; j++){
				if (j==0){
					x=parseFloat(cells[j].innerHTML);
					xMin=Math.min(xMin, x);
					xMax=Math.max(xMax, x);
				} else {
					var ds=this.series[j-1];
					var y=parseFloat(cells[j].innerHTML);
					yMin=Math.min(yMin,y);
					yMax=Math.max(yMax,y);
					var o={x:x, value:y};
					var attrs=cells[j].attributes;
					for(var k=0; k<attrs.length; k++){
						var attr=attrs.item(k);
						var bIgnore=false;
						for (var l=0; l<ignore.length; l++){
							if (attr.nodeName.toLowerCase()==ignore[l]){
								bIgnore=true;
								break;
							}
						}
						if(!bIgnore) o[attr.nodeName]=attr.nodeValue;
					}
					ds.add(o);
				}
			}
		}

		//	fix the axes
		if(!bRangeX){
			this.properties.axes.x.range={min:xMin, max:xMax};
		}
		if(!bRangeY){
			this.properties.axes.y.range={min:yMin, max:yMax};
		}

		//	where to plot the axes
		if (table.getAttribute("axisAt")){
			var p=table.getAttribute("axisAt");
			if (p.indexOf(",")>-1) p=p.split(",");
			else p=p.split(" ");
			
			//	x axis
			if (!isNaN(parseFloat(p[0]))){
				this.properties.axes.x.plotAt=parseFloat(p[0]);
			} else if (p[0].toLowerCase()=="ymin"){
				this.properties.axes.x.plotAt=this.properties.axes.y.range.min;
			} else if (p[0].toLowerCase()=="ymax"){
				this.properties.axes.x.plotAt=this.properties.axes.y.range.max;
			}

			// y axis
			if (!isNaN(parseFloat(p[1]))){
				this.properties.axes.y.plotAt=parseFloat(p[1]);
			} else if (p[1].toLowerCase()=="xmin"){
				this.properties.axes.y.plotAt=this.properties.axes.x.range.min;
			} else if (p[1].toLowerCase()=="xmax"){
				this.properties.axes.y.plotAt=this.properties.axes.x.range.max;
			}
		} else {
			this.properties.axes.x.plotAt=this.properties.axes.y.range.min;
			this.properties.axes.y.plotAt=this.properties.axes.x.range.min;
		}

		//	table values should be populated, now pop it off.
		this.domNode.removeChild(table);

		//	get the width and the height.
//		this.properties.width=dojo.html.getInnerWidth(this.domNode);
//		this.properties.height=dojo.html.getInnerHeight(this.domNode);

		// ok, lets create the chart itself.
		dojo.svg.g.suspend();		
		if(this.vectorNode) this.destroy();
		this.vectorNode=document.createElementNS(dojo.svg.xmlns.svg, "svg");
		this.vectorNode.setAttribute("width", this.properties.width);
		this.vectorNode.setAttribute("height", this.properties.height);

		//	set up the clip path for the plot area.
		var defs = document.createElementNS(dojo.svg.xmlns.svg, "defs");
		var clip = document.createElementNS(dojo.svg.xmlns.svg, "clipPath");
		clip.setAttribute("id","plotClip"+this.widgetId);
		var rect = document.createElementNS(dojo.svg.xmlns.svg, "rect");		
		rect.setAttribute("x", this.properties.padding.left);
		rect.setAttribute("y", this.properties.padding.top);
		rect.setAttribute("width", this.properties.width-this.properties.padding.left-this.properties.padding.right);
		rect.setAttribute("height", this.properties.height-this.properties.padding.bottom-this.properties.padding.bottom);
		clip.appendChild(rect);
		defs.appendChild(clip);
		this.vectorNode.appendChild(defs);

		//	the plot background.
		this.plotArea = document.createElementNS(dojo.svg.xmlns.svg, "g");
		this.vectorNode.appendChild(this.plotArea);
		var rect = document.createElementNS(dojo.svg.xmlns.svg, "rect");		
		rect.setAttribute("x", this.properties.padding.left);
		rect.setAttribute("y", this.properties.padding.top);
		rect.setAttribute("width", this.properties.width-this.properties.padding.left-this.properties.padding.right);
		rect.setAttribute("height", this.properties.height-this.properties.padding.bottom-this.properties.padding.bottom);
		rect.setAttribute("fill", "#fff");
		this.plotArea.appendChild(rect);

		//	data group
		this.dataGroup = document.createElementNS(dojo.svg.xmlns.svg, "g");
		this.dataGroup.setAttribute("style","clip-path:url(#plotClip"+this.widgetId+");");
		this.plotArea.appendChild(this.dataGroup);

		//	axis group
		this.axisGroup = document.createElementNS(dojo.svg.xmlns.svg, "g");
		this.plotArea.appendChild(this.axisGroup);

		//	x axis
		var stroke=1;
		var line = document.createElementNS(dojo.svg.xmlns.svg, "line");
		var y=dojo.widget.svg.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
		line.setAttribute("y1", y);
		line.setAttribute("y2", y);
		line.setAttribute("x1",this.properties.padding.left-stroke);
		line.setAttribute("x2",this.properties.width-this.properties.padding.right);
		line.setAttribute("style","stroke:#000;stroke-width:"+stroke+";");
		this.axisGroup.appendChild(line);
		
		//	x axis units.
		//	(min and max)
		var textSize=10;
		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
		text.setAttribute("x", this.properties.padding.left);
		text.setAttribute("y", this.properties.height-this.properties.padding.bottom+textSize+2);
		text.setAttribute("style", "text-anchor:middle;font-size:"+textSize+"px;fill:#000;");
		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.min),2)));
		this.axisGroup.appendChild(text);
		
		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
		text.setAttribute("x", this.properties.width-this.properties.padding.right-(textSize/2));
		text.setAttribute("y", this.properties.height-this.properties.padding.bottom+textSize+2);
		text.setAttribute("style", "text-anchor:middle;font-size:"+textSize+"px;fill:#000;");
		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.max),2)));
		this.axisGroup.appendChild(text);	
		
		//	y axis
		var line=document.createElementNS(dojo.svg.xmlns.svg, "line");
		var x=dojo.widget.svg.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
		line.setAttribute("x1", x);
		line.setAttribute("x2", x);
		line.setAttribute("y1", this.properties.padding.top);
		line.setAttribute("y2", this.properties.height-this.properties.padding.bottom);
		line.setAttribute("style", "stroke:#000;stroke-width:"+stroke+";");
		this.axisGroup.appendChild(line);

		//	y axis units
		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
		text.setAttribute("x", this.properties.padding.left-4);
		text.setAttribute("y", this.properties.height-this.properties.padding.bottom);
		text.setAttribute("style", "text-anchor:end;font-size:"+textSize+"px;fill:#000;");
		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.min),2)));
		this.axisGroup.appendChild(text);
		
		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
		text.setAttribute("x", this.properties.padding.left-4);
		text.setAttribute("y", this.properties.padding.top+(textSize/2));
		text.setAttribute("style", "text-anchor:end;font-size:"+textSize+"px;fill:#000;");
		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.max),2)));
		this.axisGroup.appendChild(text);	

		this.domNode.appendChild(this.vectorNode);
		dojo.svg.g.resume();

		//	this is last.
		this.assignColors();
		this._isInitialized=true;
	},
	destroy:function(){
		while(this.domNode.childNodes.length>0){
			this.domNode.removeChild(this.domNode.childNodes.item(0));
		}
		this.vectorNode=this.plotArea=this.dataGroup=this.axisGroup=null;
	},
	render:function(){
		dojo.svg.g.suspend();
		
		if (this.dataGroup){
			while(this.dataGroup.childNodes.length>0){
				this.dataGroup.removeChild(this.dataGroup.childNodes.item(0));
			}
		} else {
			this.initialize();
		}

		//	the remove/append is an attempt to streamline the rendering, it's totally optional
//		var p=this.dataGroup.parentNode;
//		p.removeChild(this.dataGroup);
		for(var i=0; i<this.series.length; i++){
			dojo.widget.svg.Chart.Plotter.plot(this.series[i], this);
		}
//		p.appendChild(this.dataGroup);
		
		dojo.svg.g.resume();
	}
});

dojo.widget.svg.Chart.Plotter=new function(){
	var _this=this;
	var plotters = {};
	var types=dojo.widget.Chart.PlotTypes;
	
	this.getX=function(value, chart){
		var v=parseFloat(value);
		var min=chart.properties.axes.x.range.min;
		var max=chart.properties.axes.x.range.max;
		var ofst=0-min;
		min+=ofst; max+=ofst; v+=ofst;

		var xmin=chart.properties.padding.left;
		var xmax=chart.properties.width-chart.properties.padding.right;
		var x=(v*((xmax-xmin)/max))+xmin;
		return x;
	};
	this.getY=function(value, chart){
		var v=parseFloat(value);
		var max=chart.properties.axes.y.range.max;
		var min=chart.properties.axes.y.range.min;
		var ofst=0;
		if(min<0)ofst+=Math.abs(min);
		min+=ofst; max+=ofst; v+=ofst;
		
		var ymin=chart.properties.height-chart.properties.padding.bottom;
		var ymax=chart.properties.padding.top;
		var y=(((ymin-ymax)/(max-min))*(max-v))+ymax;
		return y;
	};

	this.addPlotter=function(name, func){
		plotters[name]=func;
	};
	this.plot=function(series, chart){
		if (series.values.length==0) return;
		if (series.plotType && plotters[series.plotType]){
			return plotters[series.plotType](series, chart);
		}
		else if (chart.plotType && plotters[chart.plotType]){
			return plotters[chart.plotType](series, chart);
		}
	};

	//	plotting
	plotters[types.Bar]=function(series, chart){
		var space=1;
		var lastW = 0;
		for (var i=0; i<series.values.length; i++){
			var x=_this.getX(series.values[i].x, chart);
			var w;
			if (i==series.values.length-1){
				w=lastW;
			} else{
				w=_this.getX(series.values[i+1].x, chart)-x-space;
				lastW=w;
			}
			x-=(w/2);

			var yA=_this.getY(chart.properties.axes.x.plotAt, chart);
			var y=_this.getY(series.values[i].value, chart);
			var h=Math.abs(yA-y);
			if (parseFloat(series.values[i].value)<chart.properties.axes.x.plotAt){
				var oy=yA;
				yA=y;
				y=oy;
			}

			var bar=document.createElementNS(dojo.svg.xmlns.svg, "rect");
			bar.setAttribute("fill", series.color);
			bar.setAttribute("title", series.label + ": " + series.values[i].value);
			bar.setAttribute("stroke-width", "0");
			bar.setAttribute("x", x);
			bar.setAttribute("y", y);
			bar.setAttribute("width", w);
			bar.setAttribute("height", h);
			bar.setAttribute("fill-opacity", "0.9");
			chart.dataGroup.appendChild(bar);
		}
	};
	plotters[types.Line]=function(series, chart){
		var tension=3;
		var line = document.createElementNS(dojo.svg.xmlns.svg, "path");
		line.setAttribute("fill", "none");
		line.setAttribute("stroke", series.color);
		line.setAttribute("stroke-width", "2");
		line.setAttribute("stroke-opacity", "0.85");
		line.setAttribute("title", series.label);
		chart.dataGroup.appendChild(line);

		var path = [];
		for (var i=0; i<series.values.length; i++){
			var x = _this.getX(series.values[i].x, chart)
			var y = _this.getY(series.values[i].value, chart);

			var dx = chart.properties.padding.left+1;
			var dy = chart.properties.height-chart.properties.padding.bottom;
			if (i>0){
				dx=x-_this.getX(series.values[i-1].x, chart);
				dy=_this.getY(series.values[i-1].value, chart);
			}
			
			if (i==0) path.push("M");
			else {
				path.push("C");
				var cx=x-(tension-1)*(dx/tension);
				path.push(cx+","+dy);
				cx=x-(dx/tension);
				path.push(cx+","+y);
			}
			path.push(x+","+y);
		}
		line.setAttribute("d", path.join(" "));
	};
	plotters[types.Scatter]=function(series, chart){
		var r=7;
		for (var i=0; i<series.values.length; i++){
			var x=_this.getX(series.values[i].x, chart);
			var y=_this.getY(series.values[i].value, chart);
			var point = document.createElementNS(dojo.svg.xmlns.svg, "path");
			point.setAttribute("fill", series.color);
			point.setAttribute("stroke-width", "0");
			point.setAttribute("title", series.label + ": " + series.values[i].value);
			point.setAttribute("d",
				"M " + x + "," + (y-r) + " " +
				"Q " + x + "," + y + " " + (x+r) + "," + y + " " +
				"Q " + x + "," + y + " " + x + "," + (y+r) + " " +
				"Q " + x + "," + y + " " + (x-r) + "," + y + " " +
				"Q " + x + "," + y + " " + x + "," + (y-r) + " " +
				"Z"
			);
			chart.dataGroup.appendChild(point);
		}
	};
	plotters[types.Bubble]=function(series, chart){
		//	added param for series[n].value: size
		var minR=1;
		
		//	do this off the x axis?
		var min=chart.properties.axes.x.range.min;
		var max=chart.properties.axes.x.range.max;
		var ofst=0-min;
		min+=ofst; max+=ofst; v+=ofst;
		var xmin=chart.properties.padding.left;
		var xmax=chart.properties.width-chart.properties.padding.right;
		var factor=(max-min)/(xmax-xmin)*25;
		
		for (var i=0; i<series.values.length; i++){
			var size = series.values[i].size;
			if (isNaN(parseFloat(size))) size=minR;
			var point=document.createElementNS(dojo.svg.xmlns.svg, "circle");
			point.setAttribute("stroke-width", 0);
			point.setAttribute("fill", series.color);
			point.setAttribute("fill-opacity", "0.8");
			point.setAttribute("r", (parseFloat(size)*factor)/2);
			point.setAttribute("cx", _this.getX(series.values[i].x, chart));
			point.setAttribute("cy", _this.getY(series.values[i].value, chart));
			point.setAttribute("title", series.label + ": " + series.values[i].value + " (" + size + ")");
			chart.dataGroup.appendChild(point);
		}
	};
}();

__CPAN_FILE__ src/widget/svg/HslColorPicker.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.svg.HslColorPicker");

dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.HslColorPicker");
dojo.require("dojo.math");
dojo.require("dojo.svg");
dojo.require("dojo.graphics.color");
dojo.require("dojo.graphics.color.hsl");

dojo.widget.svg.HslColorPicker=function(){
	dojo.widget.HslColorPicker.call(this);
	dojo.widget.HtmlWidget.call(this);
	dojo.debug("warning: the HslColorPicker is not a finished widget, and is not yet ready for general use");
	this.hue = "0";
	this.saturation = "0";
	this.light = "0";
	this.storedColor = "#0054aa";
	var _this = this;
	this.filterObject = {
	}
};
dojo.inherits(dojo.widget.svg.HslColorPicker, dojo.widget.HtmlWidget);
dojo.lang.extend(dojo.widget.svg.HslColorPicker, {
	//	widget props
	templatePath: dojo.uri.dojoUri("src/widget/templates/HslColorPicker.svg"),
	fillInTemplate: function() {
		this.height = "131px";
		this.svgDoc = this.hueNode.ownerDocument;
		this.leftGradientColorNode = this.hueNode.ownerDocument.getElementById("leftGradientColor");
		this.rightGradientColorNode = this.hueNode.ownerDocument.getElementById("rightGradientColor");
		this.hueNode.setAttributeNS(dojo.dom.xmlns.xlink, "href", dojo.uri.dojoUri("src/widget/templates/images/hue.png"));
		var hsl = dojo.graphics.color.hex2hsl(this.storedColor);
		this.hue = hsl[0];
		this.saturation = hsl[1];
		this.light = hsl[2];
		this.setSaturationStopColors();
		//this.setHueSlider();
		//this.setSaturationLightSlider();
	},
	setSaturationStopColors: function() {
		//this.leftGradientStopColor = "rgb(" + dojo.graphics.color.hsl2rgb(this.hue, 20, 50).join(", ") + ")";
		//this.rightGradientStopColor = "rgb(" + dojo.graphics.color.hsl2rgb(this.hue, 100, 50).join(", ") + ")";
		//this.leftGradientStopColor = dojo.graphics.color.hsl2hex(this.hue, 20, 50);
		//this.rightGradientStopColor = dojo.graphics.color.hsl2hex(this.hue, 100, 50);
		this.leftGradientStopColor = dojo.graphics.color.rgb2hex(this.hsl2rgb(this.hue, 0, 50));
		this.rightGradientStopColor = dojo.graphics.color.rgb2hex(this.hsl2rgb(this.hue, 100, 50));
		this.leftGradientColorNode.setAttributeNS(null,'stop-color',this.leftGradientStopColor);
		this.rightGradientColorNode.setAttributeNS(null,'stop-color',this.rightGradientStopColor);
	},
	setHue: function(hue) {
		this.hue = hue;
	},
	setHueSlider: function() {
		// FIXME: need to add some padding around the picker so you can see the slider at the top and bottom of the picker)
		this.hueSliderNode.setAttribute("y", parseInt((this.hue/360) * parseInt(this.height) - 2) + "px" );
	},
	setSaturationLight: function(saturation, light) {
		this.saturation = saturation;
		this.light = light;
	},
	setSaturationLightSlider: function() {
		// TODO
	},
	onHueClick: function(evt) {
		// get the position that was clicked on the element
		// FIXME: handle document scrolling, offset
		var yPosition = parseInt(evt.clientY) - parseInt(evt.target.getAttribute("y"));
		this.setHue( 360 - parseInt(yPosition*(360/parseInt(this.height))) );
		this.setSaturationStopColors();
		this.setStoredColor(dojo.graphics.color.hsl2hex(this.hue, this.saturation, this.light));
	},
	onHueDrag: function(evt) {
		// TODO
	},
	onSaturationLightClick: function(evt) {
		// get the position that was clicked on the element
		// FIXME: handle document scrolling, offset
		var xPosition = parseInt(evt.clientX) - parseInt(evt.target.getAttribute("y"));
		var yPosition = parseInt(evt.clientY) - parseInt(evt.target.getAttribute("y"));
		saturation = parseInt(parseInt(xPosition)*(101/106));
		light = parseInt(parseInt(yPosition)*(101/106));
		this.setSaturationLight(saturation, light);
		this.setStoredColor(dojo.graphics.color.hsl2hex(this.hue, this.saturation, this.light));
	},
	onSaturationLightDrag: function(evt) {
		// TODO
	},
	getStoredColor: function() {
		return this.storedColor;
	},
	setStoredColor: function(rgbHexColor) {
		this.storedColor = rgbHexColor;
		dojo.event.topic.publish("/" + this.widgetId + "/setStoredColor", this.filterObject);
	},
	hsl2rgb: function(hue, saturation, light)
	{
		// hsl2rgb in dojo.graphics.color did not behave hte way I expected, so 
		// I'm using some old code I wrote until I figure out what the issue is
		// first, check to see if saturation = 0
		function rgb(q1,q2,hue) {
			if (hue>360) hue=hue-360;
			if (hue<0) hue=hue+360;
			if (hue<60) return (q1+(q2-q1)*hue/60);
			else if (hue<180) return(q2);
			else if (hue<240) return(q1+(q2-q1)*(240-hue)/60);
			else return(q1);
		}
		this.rgb = rgb
	
		if (saturation==0) {
			return [Math.round(light*255/100), Math.round(light*255/100), Math.round(light*255/100)];
		} else {
			light = light/100;
			saturation = saturation/100;
			// check to see if light > 0.5
			if ((light)<0.5) {
				var temp2 = (light)*(1.0+saturation)
			} else {
				var temp2 = (light+saturation-(light*saturation))
			}
			temp1 = 2.0*light - temp2;
			var rgbcolor = [];
			rgbcolor[0] = Math.round(rgb(temp1,temp2,parseInt(hue)+120)*255);
			rgbcolor[1] = Math.round(rgb(temp1,temp2,hue)*255);
			rgbcolor[2] = Math.round(rgb(temp1,temp2,parseInt(hue)-120)*255);
			return rgbcolor;
		}
	}
});

__CPAN_DIR__ src/widget/templates
__CPAN_FILE__ src/widget/templates/check_off.gif
GIF89a    ~~~y            !     ,       @pH,
Ih.$E`A&gq4PC0fiDIhy:
Xpz99);q!:5 9332/42	+:%		66"-:.7':*0,#(FCA ;
__CPAN_FILE__ src/widget/templates/check_on.gif
GIF89a    euy]y}okrzxlh|vy                                                                                                            !     ,       ZYYP3MZYWG%8HVI[F
SS7E[[&4YTT@>+;9C<$=#	* 	['.0Y5[A([,:"?![NKJ 2/B 1YR m	@)D
"(4B J$,1hc
DIA  ;
__CPAN_FILE__ src/widget/templates/decrementMonth.gif
GIF89a	    000WWWaaayyy222:::FFF                                 !     ,    	   #  h6eRD2Bxn(H! ;
__CPAN_FILE__ src/widget/templates/decrementWeek.gif
GIF89a    000fffyyyFFFCCCmmmjjj                                    !     ,         (
Ci<LN0	D ;A ;
__CPAN_FILE__ src/widget/templates/DemoEngine.html
<div dojoAttachPoint="domNode">
	<div dojoAttachPoint="navigationNode">
		<table border="0" cellspacing="0" cellpadding="0">
			<tr>
				<td width="1%" valign="top" class="navigationCell"><h1>Categories</h1><div dojoAttachPoint="menuNavigationNode"></div></td>
				<td width="99%" valign="top">
					<div dojoAttachPoint="demoNavigationNode">
					</div>
				</td>
			</tr>
		</table>
	</div>

	<div dojoAttachPoint="demoContainerNode">

		<div dojoAttachPoint="demoPaneNode">
		</div>

		<div dojoAttachPoint="demoHeaderNode">
			<span dojoAttachPoint="collapsedMenuNode" dojoAttachEvent="onclick: expandDemoNavigation"></span>
			<div dojoAttachPoint="aboutNode">About this Demo</div>
		</div>
	</div>
</div>

__CPAN_FILE__ src/widget/templates/grabCorner.gif
GIF89a      !   ,       *L(}\daXU{QH ;
__CPAN_FILE__ src/widget/templates/HslColorPicker.svg
<svg xmlns="http://www.w3.org/2000/svg"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	version="1.1" baseProfile="full" width="170" height="131" xmlns:html="http://www.w3.org/1999/xhtml">
	<defs>
	<linearGradient id="colorGradient" dojoAttachPoint="colorGradientNode" x1="0" x2="131" y1="0" y2="0" gradientUnits="userSpaceOnUse">
		<stop id="leftGradientColor" dojoAttachPoint="leftGradientColorNode" offset="0%" stop-color="#828282"/>
		<stop id="rightGradientColor" dojoAttachPoint="rightGradientColorNode" offset="100%" stop-color="#053fff"/>
	</linearGradient>
	<linearGradient id="verticalGradient" x1="0" x2="0" y1="0" y2="131" gradientUnits="userSpaceOnUse">
		<stop offset="0%" style="stop-color:#000000;"/>
		<stop offset="50%" style="stop-color:#000000;stop-opacity:0;"/>
		<stop offset="50%" style="stop-color:#ffffff;stop-opacity:0;"/>
		<stop offset="100%" style="stop-color:#ffffff;"/>
	</linearGradient>
	<linearGradient id="sliderGradient">
		<stop offset="0%" style="stop-color:#000000;"/>
		<stop offset="15%" style="stop-color:#ffffff;"/>
		<stop offset="30%" style="stop-color:#000000;"/>
		<stop offset="45%" style="stop-color:#ffffff;"/>
		<stop offset="60%" style="stop-color:#000000;"/>
		<stop offset="75%" style="stop-color:#ffffff;"/>
		<stop offset="90%" style="stop-color:#000000;"/>
	</linearGradient>
</defs>
	<rect x="0" y="0" width="131px" height="131px" fill="url(#colorGradient)"/>
	<rect x="0" y="0" width="131px" height="131px" style="fill:url(#verticalGradient);"/>
	<rect id="saturationLightSlider" dojoAttachPoint="saturationLightSliderNode" x="100" y="100" width="5px" height="5px" style="stroke:url(#sliderGradient);stroke-width:1px;fill-opacity:0;"/>
	<image xlink:href="images/hue.png" dojoAttachPoint="hueNode" x="140px" y="0px" width="21px" height="131px" dojoAttachEvent="onclick: onHueClick;"/>
	<rect dojoAttachPoint="hueSliderNode" x="139px" y="40px" width="24px" height="4px" style="stroke-opacity:1;fill-opacity:0;stroke:black;"/>
</svg>

__CPAN_FILE__ src/widget/templates/HtmlButtonTemplate.css
/* ---- button --- */
.dojoButton {
	padding: 0 0 0 0;
	font-size: 8pt;
	white-space: nowrap;
	cursor: pointer;
	font-family: Myriad, Tahoma, Verdana, sans-serif;
}

.dojoButton .dojoButtonContents {
	padding: 2px 2px 2px 2px;
	text-align: center;		/* if icon and label are split across two lines, center icon */
	color: white;
}

.dojoButtonLeftPart .dojoButtonContents {
	padding-right: 8px;
}

.dojoButtonDisabled {
	cursor: url("images/no.gif"), default;
}


.dojoButtonContents img {
	vertical-align: middle;	/* if icon and label are on same line, center them */
}

/* -------- colors ------------ */

.dojoButtonHover .dojoButtonContents {
}

.dojoButtonDepressed .dojoButtonContents {
	color: #293a4b;
}

.dojoButtonDisabled .dojoButtonContents {
	color: #eeeeee;
}


/* ---------- drop down button specific ---------- */

/* border between label and arrow (for drop down buttons */
.dojoButton .border {
	width: 1px;
	background: gray;
}

/* button arrow */
.dojoButton .downArrow {
	padding-left: 10px;
	text-align: center;
}

.dojoButton.disabled .downArrow {
	cursor : default;
}
__CPAN_FILE__ src/widget/templates/HtmlButtonTemplate.html
<div class="dojoButton" style="position:relative;" dojoAttachEvent="onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick:buttonClick;">
  <div class="dojoButtonContents" align=center dojoAttachPoint="containerNode" style="position:absolute;z-index:2;"></div>
  <img dojoAttachPoint="leftImage" style="position:absolute;left:0px;">
  <img dojoAttachPoint="centerImage" style="position:absolute;z-index:1;">
  <img dojoAttachPoint="rightImage" style="position:absolute;top:0px;right:0px;">
</div>

__CPAN_FILE__ src/widget/templates/HtmlCiviCrmDatePicker.html
<table cellpadding="0" cellspacing="0" border="0" width="400">
	<tr>
		<td id="dateHolderTd" width="200">
		</td>
		<td id="timeHolderTd" width="200">
		</td>
	</tr>
	<tr style="display: none;" id="formItemsTr">
		<td id="formItemsTd">&nbsp;</td>
		<td>&nbsp;</td>
	</tr>
</table>

__CPAN_FILE__ src/widget/templates/HtmlComboBox.css
input.dojoComboBoxInput {
	/* font-size: 0.8em; */
	border: 0px;
	
}

.dojoComboBoxOptions {
	font-family: Verdana, Helvetica, Garamond, sans-serif;
	/* font-size: 0.7em; */
	background-color: white;
	border: 1px solid #afafaf;
	position: absolute;
	z-index: 1000; 
	overflow: auto;
	-moz-opacity: 0;
	cursor: default;
}

table.dojoComboBox {
	border: 1px solid #afafaf;
}

.dojoComboBoxItem {
	padding-left: 2px;
	padding-top: 2px;
	margin: 0px;
}

.dojoComboBoxItemEven {
	background-color: #f4f4f4;
}

.dojoComboBoxItemOdd {
	background-color: white;
}

.dojoComboBoxItemHighlight {
	background-color: #63709A;
	color: white;
}

__CPAN_FILE__ src/widget/templates/HtmlComboBox.html
<div style="position: relative; z-index: 100;">
	<input type="hidden" name="" value="" 
		dojoAttachPoint="comboBoxValue">
	<input type="hidden" name="" value="" 
		dojoAttachPoint="comboBoxSelectionValue">
	<table class="dojoComboBox"
		cellpadding="0"
		cellmargin="0"
		border="0"
		dojoAttachPoint="cbTableNode">
		<tr valign="top">
			<td width=100%>
				<input type="text" class="dojoComboBoxInput"
					dojoAttachEvent="keyDown: onKeyDown; keyUp: onKeyUp; keyPress: onKeyPress;"
					dojoAttachPoint="textInputNode"
					style="width: 100%;">
			</td>
			<td>
				<img border="0" 
					hspace="0"
					vspace="0"
					dojoAttachPoint="downArrowNode"
					dojoAttachEvent="onMouseUp: handleArrowClick;"
					src="${dojoRoot}src/widget/templates/images/combo_box_arrow.png">
			</td>
		</tr>
	</table>
	<div dojoAttachPoint="optionsListWrapper" style="position:relative;" tabindex="-1">
		<div class="dojoComboBoxOptions" dojoAttachPoint="optionsListNode"
			dojoAttachEvent="onClick: selectOption;  onMouseOver: _onMouseOver; onMouseOut: _onMouseOut;"
			style="display:none;" tabindex="-1">
		</div>
	</div>
</div>

__CPAN_FILE__ src/widget/templates/HtmlComboButtonTemplate.html
<div class="dojoButton" style="position:relative;top:0px;left:0px; text-align:none;">

	<div dojoAttachPoint="leftPart" class="dojoButtonLeftPart" style="position:absolute;left:0px;top:0px;"
		dojoAttachEvent="onMouseOver:leftOver; onMouseOut:leftOut; onMouseUp:leftUp; onClick:leftClick;">
		<div class="dojoButtonContents" dojoAttachPoint="containerNode" style="position:absolute;top:0px;right:0px;z-index:2;"></div>
		<img dojoAttachPoint="leftImage" style="position:absolute;left:0px;top:0px;">
		<img dojoAttachPoint="centerImage" style="position:absolute;right:0px;top:0px;z-index:1;">
	</div>

	<div dojoAttachPoint="rightPart" class="dojoButtonRightPart" style="position:absolute;top:0px;right:0px;"
		dojoAttachEvent="onMouseOver:rightOver; onMouseOut:rightOut; onMouseUp:rightUp; onClick:rightClick;">
		<img dojoAttachPoint="arrowBackgroundImage" style="position:absolute;top:0px;left:0px;z-index:1;">
		<img src="${dojoRoot}src/widget/templates/images/whiteDownArrow.gif"
		  		style="z-index:2;position:absolute;left:3px;top:50%;">
		<img dojoAttachPoint="rightImage" style="position:absolute;top:0px;right:0px;">
	</div>

</div>

__CPAN_FILE__ src/widget/templates/HtmlContextMenuTemplate.html
<ul class="dojoContextMenu" 
	dojoAttachPoint="containerNode">
</ul>

__CPAN_FILE__ src/widget/templates/HtmlDatePicker.css
.calendarContainer {
/*	border:1px solid #566f8f;*/
}

.calendarBodyContainer {
	width:160px;
	background: #7591bc url("images/dpBg.gif") top left repeat-x;
}

.calendarBodyContainer thead tr td {
	color:#293a4b;
	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
	text-align:center;
	padding:0.25em;
	background: url("images/dpHorizLine.gif") bottom left repeat-x;
}

.calendarBodyContainer tbody tr td {
	color:#fff;
	font:bold 0.7em Helvetica, Arial, Verdana, sans-serif;
	text-align:center;
	padding:0.4em;
	background: url("images/dpVertLine.gif") top right repeat-y;
	cursor:pointer;
	cursor:hand;
}


.monthWrapper {
	padding-bottom:2px;
	background: url("images/dpHorizLine.gif") bottom left repeat-x;
}

.monthContainer {
	width:100%;
}

.monthLabelContainer {
	text-align:center;
	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
	background: url("images/dpMonthBg.png") repeat-x top left !important;
	color:#293a4b;
	padding:0.25em;
}

.monthCurve {
	width:12px;
}

.monthCurveTL {
	background: url("images/dpCurveTL.png") no-repeat top left !important;
}

.monthCurveTR {
		background: url("images/dpCurveTR.png") no-repeat top left !important;
}


.yearWrapper {
	background: url("images/dpHorizLineFoot.gif") top left repeat-x;
	padding-top:2px;
}

.yearContainer {
	width:100%;
}

.yearContainer td {
	background:url("images/dpYearBg.png") top left repeat-x;
}

.yearContainer .yearLabel {
	margin:0;
	padding:0.45em 0 0.45em 0;
	color:#fff;
	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
	text-align:center;
}

.curveBL {
	background: url("images/dpCurveBL.png") bottom left no-repeat !important;
	width:9px !important;
	padding:0;
	margin:0;
}

.curveBR {
	background: url("images/dpCurveBR.png") bottom left no-repeat !important;
	width:9px !important;
	padding:0;
	margin:0;
}


.previousMonth {
	background-color:#6782a8 !important;
}

.currentMonth {
}

.nextMonth {
	background-color:#6782a8 !important;
}

.currentDate {
	text-decoration:underline;
	font-style:italic;
}

.selectedItem {
	background-color:#fff !important;
	color:#6782a8 !important;
}

.yearLabel .selectedYear {
	padding:0.2em;
	background-color:#9ec3fb !important;
}

.nextYear, .previousYear {
	cursor:pointer;cursor:hand;
	margin:0 0.55em;
}

.incrementControl {
	cursor:pointer;cursor:hand;
	width:1em;
}

.increase {
	float:right;
}

.decrease {
	float:left;
}

.lastColumn {
	background-image:none !important;
}



__CPAN_FILE__ src/widget/templates/HtmlDatePicker.html
<div class="datePickerContainer" dojoAttachPoint="datePickerContainerNode">
	<table cellspacing="0" cellpadding="0" class="calendarContainer">
		<thead>
			<tr>
				<td class="monthWrapper" valign="top">
					<table class="monthContainer" cellspacing="0" cellpadding="0" border="0">
						<tr>
							<td class="monthCurve monthCurveTL" valign="top"></td>
							<td class="monthLabelContainer" valign="top">
								<span dojoAttachPoint="increaseWeekNode" 
									dojoAttachEvent="onClick: onIncrementWeek;" 
									class="incrementControl increase">
									<img src="${dojoRoot}src/widget/templates/images/incrementMonth.png" 
									alt="&darr;" style="width:7px;height:5px;" />
								</span>
								<span 
									dojoAttachPoint="increaseMonthNode" 
									dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl increase">
									<img src="${dojoRoot}src/widget/templates/images/incrementMonth.png" 
										alt="&darr;"  dojoAttachPoint="incrementMonthImageNode">
								</span>
								<span 
									dojoAttachPoint="decreaseWeekNode" 
									dojoAttachEvent="onClick: onIncrementWeek;" 
									class="incrementControl decrease">
									<img src="${dojoRoot}src/widget/templates/images/decrementMonth.png" alt="&uarr;" style="width:7px;height:5px;" />
								</span>
								<span 
									dojoAttachPoint="decreaseMonthNode" 
									dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl decrease">
									<img src="${dojoRoot}src/widget/templates/images/decrementMonth.png" 
										alt="&uarr;" dojoAttachPoint="decrementMonthImageNode">
								</span>
								<span dojoAttachPoint="monthLabelNode" class="month">July</span>
							</td>
							<td class="monthCurve monthCurveTR" valign="top"></td>
						</tr>
					</table>
				</td>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td colspan="3">
					<table class="calendarBodyContainer" cellspacing="0" cellpadding="0" border="0">
						<thead>
							<tr>
								<td>S</td>
								<td>M</td>
								<td>T</td>
								<td>W</td>
								<td>T</td>
								<td>F</td>
								<td>S</td>
							</tr>
						</thead>
						<tbody dojoAttachPoint="calendarDatesContainerNode" 
							dojoAttachEvent="onClick: onSetDate;">
							<tr dojoAttachPoint="calendarRow0">
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
							</tr>
							<tr dojoAttachPoint="calendarRow1">
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
							</tr>
							<tr dojoAttachPoint="calendarRow2">
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
							</tr>
							<tr dojoAttachPoint="calendarRow3">
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
							</tr>
							<tr dojoAttachPoint="calendarRow4">
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
							</tr>
							<tr dojoAttachPoint="calendarRow5">
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
								<td></td>
							</tr>
						</tbody>
					</table>
				</td>
			</tr>
		</tbody>
		<tfoot>
			<tr>
				<td colspan="3" class="yearWrapper">
					<table cellspacing="0" cellpadding="0" border="0" class="yearContainer">
						<tr>
							<td class="curveBL" valign="top"></td>
							<td valign="top">
								<h3 class="yearLabel">
									<span dojoAttachPoint="previousYearLabelNode"
										dojoAttachEvent="onClick: onIncrementYear;" class="previousYear"></span>
									<span class="selectedYear" dojoAttachPoint="currentYearLabelNode"></span>
									<span dojoAttachPoint="nextYearLabelNode" 
										dojoAttachEvent="onClick: onIncrementYear;" class="nextYear"></span>
								</h3>
							</td>
							<td class="curveBR" valign="top"></td>
						</tr>
					</table>
				</td>
			</tr>
		</tfoot>
	</table>
	
</div>

__CPAN_FILE__ src/widget/templates/HtmlDialog.html
<div id="${this.widgetId}" class="dojoDialog" dojoAttachPoint="wrapper">

	<span dojoAttachPoint="tabStart" 
		dojoOnFocus="trapTabs" 
		dojoOnBlur="clearTrap" tabindex="0"></span>

	<div dojoAttachPoint="containerNode" style=" position: relative; z-index: 2;"></div>

	<span dojoAttachPoint="tabEnd" 
		dojoOnFocus="trapTabs" 
		dojoOnBlur="clearTrap" tabindex="0"></span>

</div>

__CPAN_FILE__ src/widget/templates/HtmlDocPane.css

__CPAN_FILE__ src/widget/templates/HtmlDocPane.html
<div>
	<div dojoAttachPoint="containerNode"></div>
	<div dojoAttachPoint="select">
		<h1>Detail: <span dojoAttachPoint="fn">dojo.select</span></h1>
		<div dojoAttachPoint="description">Description</div>
		<div class="params" dojoAttachPoint="parameters">
			<h2>Parameters</h2>
			<div dojoAttachPoint="pRow"><span dojoAttachPoint="pOpt"><em>optional</em> </span><span><span dojoAttachPoint="pType">type</span> </span><a href="#" dojoAttachPoint="pLink">variable</a><span> - <span dojoAttachPoint="pDesc"></span></span></div>
		</div>
		<div class="vars" dojoAttachPoint="variables">
			<h2>Variables</h2>
			<div dojoAttachPoint="vRow"><a href="#" dojoAttachPoint="vLink">variable</a><span> - <span dojoAttachPoint="vDesc"></span></span></div>
		</div>
		<div id="src">
			<h2>Source Code</h2>
			<pre dojoAttachPoint="source">returnType foo(paramName){
  ...
}</pre>
		</div>
	</div>
	<div dojoAttachPoint="result">
		<h1>Search Results: <span dojoAttachPoint="count">0</span> matches</h1>
		<div dojoAttachPoint="row"><a href="#" dojoAttachPoint="fnLink">dojo.fnLink</a><span> - <span dojoAttachPoint="summary">summary</span></span></div>
	</div>
</div>
__CPAN_FILE__ src/widget/templates/HtmlDropDownButtonTemplate.html
<button dojoAttachPoint="button" class="dojoButton dojoButtonNoHover" dojoAttachEvent="onMouseOver: ; onMouseOut: ; onClick: ;">
  <table dojoAttachPoint="table" style="margin:0 0 0 0;"><tr>
    <td class="label" dojoAttachPoint="labelCell"></td>
    <td class="border" dojoAttachPoint="borderCell"></td>
    <td class="downArrow" dojoAttachPoint="arrowCell">
      <img dojoAttachPoint="arrow">
    </td>
  </tr></table>
</button>
__CPAN_FILE__ src/widget/templates/HtmlEditorToolbar.css
.StyleDropdownContainer {
	position: absolute;
	z-index: 1000;
	overflow: auto;
	cursor: default;
	width: 250px;
	height: 250px;
	background-color: white;
	border: 1px solid black;
}

.ColorDropdownContainer {
	position: absolute;
	z-index: 1000;
	overflow: auto;
	cursor: default;
	width: 250px;
	height: 150px;
	background-color: white;
	border: 1px solid black;
}

.EditorToolbarDomNode {
	background-image: url(buttons/bg-fade.png);
	background-repeat: repeat-x;
	background-position: 0px -50px;
}

.EditorToolbarSmallBg {
	background-image: url(images/toolbar-bg.gif);
	background-repeat: repeat-x;
	background-position: 0px 0px;
}

/*
body {
	background:url(images/blank.gif) fixed;
}*/

.IEFixedToolbar {
	position:absolute;
	/* top:0; */
	top: expression(eval((document.documentElement||document.body).scrollTop));
}

div.bigIcon {
	width: 40px;
	height: 40px; 
	/* background-color: white; */
	/* border: 1px solid #a6a7a3; */
	font-family: Verdana, Trebuchet, Tahoma, Arial;
}

.iconContainer {
	font-family: Verdana, Trebuchet, Tahoma, Arial;
	font-size: 13px;
	float: left;
	height: 18px;
	display: block;
	/* background-color: white; */
	/* border: 1px solid white; */
	/* border: 1px solid #a6a7a3; */
	padding-right: 3px;
	cursor: pointer;
	border: 1px solid transparent;
	_border: none;
}

span.icon {
	display: block;
	text-align: center;
	min-width: 18px;
	width: 18px;
	height: 18px;
	/* background-color: #a6a7a3; */
	background-repeat: no-repeat;
	background-image: url(buttons/aggregate.gif);
}


span.icon[class~=icon] {
}

.headingContainer {
	width: 150px;
	height: 30px;
	margin: 0px;
	/* padding-left: 5px; */
	overflow: hidden;
	line-height: 25px;
	border-bottom: 1px solid black;
	border-top: 1px solid white;
}

.EditorToolbarDomNode select {
	font-size: 14px;
}

.sep { width: 5px; min-width: 5px; max-width: 5px; background-position: 0px 0px}
.backcolor { background-position: -18px 0px}
.bold { background-position: -36px 0px}
.cancel { background-position: -54px 0px}
.copy { background-position: -72px 0px}
.createlink { background-position: -90px 0px}
.cut { background-position: -108px 0px}
.delete { background-position: -126px 0px}
.forecolor { background-position: -144px 0px}
.hilitecolor { background-position: -162px 0px}
.indent { background-position: -180px 0px}
.inserthorizontalrule { background-position: -198px 0px}
.insertimage { background-position: -216px 0px}
.insertorderedlist { background-position: -234px 0px}
.inserttable { background-position: -252px 0px}
.insertunorderedlist { background-position: -270px 0px}
.italic { background-position: -288px 0px}
.justifycenter { background-position: -306px 0px}
.justifyfull { background-position: -324px 0px}
.justifyleft { background-position: -342px 0px}
.justifyright { background-position: -360px 0px}
.left_to_right { background-position: -378px 0px}
.list_bullet_indent { background-position: -396px 0px}
.list_bullet_outdent { background-position: -414px 0px}
.list_num_indent { background-position: -432px 0px}
.list_num_outdent { background-position: -450px 0px}
.outdent { background-position: -468px 0px}
.paste { background-position: -486px 0px}
.redo { background-position: -504px 0px}
.removeformat { background-position: -522px 0px}
.right_to_left { background-position: -540px 0px}
.save { background-position: -558px 0px}
.space { background-position: -576px 0px}
.strikethrough { background-position: -594px 0px}
.subscript { background-position: -612px 0px}
.superscript { background-position: -630px 0px}
.underline { background-position: -648px 0px}
.undo { background-position: -666px 0px}
.wikiword { background-position: -684px 0px}


__CPAN_FILE__ src/widget/templates/HtmlEditorToolbar.html
<div dojoAttachPoint="domNode" class="EditorToolbarDomNode" unselectable="on">
	<table cellpadding="3" cellspacing="0" border="0">
		<!--
			our toolbar should look something like:

			+=======+=======+=======+=============================================+
			| w   w | style | copy  | bo | it | un | le | ce | ri |
			| w w w | style |=======|==============|==============|
			|  w w  | style | paste |  undo | redo | change style |
			+=======+=======+=======+=============================================+
		-->
		<tbody>
			<tr valign="top">
				<td rowspan="2">
					<div class="bigIcon" dojoAttachPoint="wikiWordButton"
						dojoOnClick="wikiWordClick; buttonClick;">
						<span style="font-size: 30px; margin-left: 5px;">
							W
						</span>
					</div>
				</td>
				<td rowspan="2">
					<div class="bigIcon" dojoAttachPoint="styleDropdownButton"
						dojoOnClick="styleDropdownClick; buttonClick;">
						<span unselectable="on"
							style="font-size: 30px; margin-left: 5px;">
							S
						</span>
					</div>
					<div class="StyleDropdownContainer" style="display: none;"
						dojoAttachPoint="styleDropdownContainer">
						<table cellpadding="0" cellspacing="0" border="0"
							height="100%" width="100%">
							<tr valign="top">
								<td rowspan="2">
									<div style="height: 245px; overflow: auto;">
										<div class="headingContainer"
											unselectable="on"
											dojoOnClick="normalTextClick">normal</div>
										<h1 class="headingContainer"
											unselectable="on"
											dojoOnClick="h1TextClick">Heading 1</h1>
										<h2 class="headingContainer"
											unselectable="on"
											dojoOnClick="h2TextClick">Heading 2</h2>
										<h3 class="headingContainer"
											unselectable="on"
											dojoOnClick="h3TextClick">Heading 3</h3>
										<h4 class="headingContainer"
											unselectable="on"
											dojoOnClick="h4TextClick">Heading 4</h4>
										<div class="headingContainer"
											unselectable="on"
											dojoOnClick="blahTextClick">blah</div>
										<div class="headingContainer"
											unselectable="on"
											dojoOnClick="blahTextClick">blah</div>
										<div class="headingContainer"
											unselectable="on"
											dojoOnClick="blahTextClick">blah</div>
										<div class="headingContainer">blah</div>
										<div class="headingContainer">blah</div>
										<div class="headingContainer">blah</div>
										<div class="headingContainer">blah</div>
									</div>
								</td>
								<!--
								<td>
									<span class="iconContainer" dojoOnClick="buttonClick;">
										<span class="icon justifyleft" 
											style="float: left;">&nbsp;</span>
									</span>
									<span class="iconContainer" dojoOnClick="buttonClick;">
										<span class="icon justifycenter" 
											style="float: left;">&nbsp;</span>
									</span>
									<span class="iconContainer" dojoOnClick="buttonClick;">
										<span class="icon justifyright" 
											style="float: left;">&nbsp;</span>
									</span>
									<span class="iconContainer" dojoOnClick="buttonClick;">
										<span class="icon justifyfull" 
											style="float: left;">&nbsp;</span>
									</span>
								</td>
								-->
							</tr>
							<tr valign="top">
								<td>
									thud
								</td>
							</tr>
						</table>
					</div>
				</td>
				<td>
					<!-- copy -->
					<span class="iconContainer" dojoAttachPoint="copyButton"
						unselectable="on"
						dojoOnClick="copyClick; buttonClick;">
						<span class="icon copy" 
							unselectable="on"
							style="float: left;">&nbsp;</span> copy
					</span>
					<!-- "droppable" options -->
					<span class="iconContainer" dojoAttachPoint="boldButton"
						unselectable="on"
						dojoOnClick="boldClick; buttonClick;">
						<span class="icon bold" unselectable="on">&nbsp;</span>
					</span>
					<span class="iconContainer" dojoAttachPoint="italicButton"
						dojoOnClick="italicClick; buttonClick;">
						<span class="icon italic" unselectable="on">&nbsp;</span>
					</span>
					<span class="iconContainer" dojoAttachPoint="underlineButton"
						dojoOnClick="underlineClick; buttonClick;">
						<span class="icon underline" unselectable="on">&nbsp;</span>
					</span>
					<span class="iconContainer" dojoAttachPoint="leftButton"
						dojoOnClick="leftClick; buttonClick;">
						<span class="icon justifyleft" unselectable="on">&nbsp;</span>
					</span>
					<span class="iconContainer" dojoAttachPoint="fullButton"
						dojoOnClick="fullClick; buttonClick;">
						<span class="icon justifyfull" unselectable="on">&nbsp;</span>
					</span>
					<span class="iconContainer" dojoAttachPoint="rightButton"
						dojoOnClick="rightClick; buttonClick;">
						<span class="icon justifyright" unselectable="on">&nbsp;</span>
					</span>
				</td>
			</tr>
			<tr>
				<td>
					<!-- paste -->
					<span class="iconContainer" dojoAttachPoint="pasteButton"
						dojoOnClick="pasteClick; buttonClick;" unselectable="on">
						<span class="icon paste" style="float: left;" unselectable="on">&nbsp;</span> paste
					</span>
					<!-- "droppable" options -->
					<span class="iconContainer" dojoAttachPoint="undoButton"
						dojoOnClick="undoClick; buttonClick;" unselectable="on">
						<span class="icon undo" style="float: left;" unselectable="on">&nbsp;</span> undo
					</span>
					<span class="iconContainer" dojoAttachPoint="redoButton"
						dojoOnClick="redoClick; buttonClick;" unselectable="on">
						<span class="icon redo" style="float: left;" unselectable="on">&nbsp;</span> redo
					</span>
				</td>	
			</tr>
		</tbody>
	</table>

__CPAN_FILE__ src/widget/templates/HtmlEditorToolbarOneline.html
<div class="EditorToolbarDomNode EditorToolbarSmallBg" 
	unselectable="on" dojoOnMouseDown="preventSelect">
	<table cellpadding="1" cellspacing="0" border="0">
		<!--
			toobar options, in order:

				* wikiword
				* paste
				* copy
				* undo
				* redo
				* link
				* insert image
				* insert <hr>
				* font-select
				* bold
				* italic
				* underline
				* strikethrough
				* numlist
				* dotlist
				* indent
				* outdent
				* text color
				* bg color

		-->
		<tbody>
			<tr valign="top" align="left" dojoAttachPoint="oneLineTr">
				<td>
					<!-- htmltoggle -->
					<span class="iconContainer" dojoAttachPoint="htmltoggleButton"
						dojoOnClick="htmltoggleClick; buttonClick;" style="display: none;">
						<span title="Toggle Rich Text and HTML Markup Editing Modes" class="icon" 
						style="background-image: none; width: 30px;" 
						unselectable="on">&lt;h&gt;</span>
					</span>
				</td>
				<td>
					<!-- wikiword -->
					<span class="iconContainer" dojoAttachPoint="wikiwordButton"
						dojoOnClick="wikiwordClick; buttonClick;" style="display: none;">
						<span title="Toggle Wiki Word" class="icon wikiword" 
						unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- paste -->
					<span class="iconContainer" dojoAttachPoint="copyButton"
						unselectable="on" dojoOnClick="copyClick; buttonClick;">
						<span title="Copy (Ctrl-C)" class="icon copy" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- copy -->
					<span class="iconContainer" dojoAttachPoint="pasteButton"
						dojoOnClick="pasteClick; buttonClick;" unselectable="on">
						<span title="Paste (Ctrl-V)" class="icon paste" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- undo -->
					<span class="iconContainer" dojoAttachPoint="undoButton"
						dojoOnClick="undoClick; buttonClick;" unselectable="on">
						<!-- FIXME: should we have the text "undo" here? -->
						<span title="Undo (Ctrl-Z)" class="icon undo" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- redo -->
					<span class="iconContainer" dojoAttachPoint="redoButton"
						dojoOnClick="redoClick; buttonClick;" unselectable="on">
						<span title="Redo (Ctrl-R)" class="icon redo" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td isSpacer="true">
					<!-- spacer -->
					<span class="iconContainer">
						<span class="icon sep" unselectable="on" 
							style="width: 5px; min-width: 5px;"></span>
					</span>
				</td>
				<td>
					<!-- link -->
					<span class="iconContainer" dojoAttachPoint="linkButton"
						unselectable="on" dojoOnClick="linkClick; buttonClick;">
						<span title="Create Link" class="icon createlink" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- insertimage -->
					<span class="iconContainer" 
						style="display: none;"
						dojoAttachPoint="insertimageButton"
						unselectable="on" dojoOnClick="insertimageClick; buttonClick;">
						<span title="Insert Image" class="icon insertimage" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- inserthorizontalrule -->
					<span class="iconContainer" dojoAttachPoint="inserthorizontalruleButton"
						unselectable="on" dojoOnClick="inserthorizontalruleClick; buttonClick;">
						<span title="Insert Horizontal Rule" class="icon inserthorizontalrule " unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- bold -->
					<span class="iconContainer" dojoAttachPoint="boldButton"
						unselectable="on" dojoOnClick="boldClick; buttonClick;">
						<span title="Toggle Bold (Ctrl-B)" class="icon bold" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- italic -->
					<span class="iconContainer" dojoAttachPoint="italicButton"
						dojoOnClick="italicClick; buttonClick;">
						<span title="Toggle Italic (Ctrl-I)" class="icon italic" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- underline -->
					<span class="iconContainer" dojoAttachPoint="underlineButton"
						dojoOnClick="underlineClick; buttonClick;">
						<span title="Toggle Underline (Ctrl-U)" class="icon underline" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- strikethrough -->
					<span class="iconContainer" dojoAttachPoint="strikethroughButton"
						dojoOnClick="strikethroughClick; buttonClick;">
						<span title="Toggle Strike-Through" 
							class="icon strikethrough" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td isSpacer="true">
					<!-- spacer -->
					<span class="iconContainer">
						<span class="icon sep" unselectable="on" 
							style="width: 5px; min-width: 5px;"></span>
					</span>
				</td>
				<td>
					<!-- insertunorderedlist -->
					<span class="iconContainer" dojoAttachPoint="insertunorderedlistButton"
						unselectable="on" 
						dojoOnClick="insertunorderedlistClick; buttonClick;">
						<span title="Insert Bullet List" 
							class="icon insertunorderedlist" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- insertorderedlist -->
					<span class="iconContainer" dojoAttachPoint="insertorderedlistButton"
						unselectable="on" dojoOnClick="insertorderedlistClick; buttonClick;">
						<span title="Insert Numbered List" 
							class="icon insertorderedlist" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td isSpacer="true">
					<!-- spacer -->
					<span class="iconContainer">
						<span class="icon sep" unselectable="on" 
							style="width: 5px; min-width: 5px;"></span>
					</span>
				</td>
				<td>
					<!-- indent -->
					<span class="iconContainer" dojoAttachPoint="indentButton"
						unselectable="on" dojoOnClick="indentClick; buttonClick;">
						<span title="Indent Selection" class="icon indent" 
							unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- outdent -->
					<span class="iconContainer" dojoAttachPoint="outdentButton"
						unselectable="on" dojoOnClick="outdentClick; buttonClick;">
						<span title="Outdent Selection" class="icon outdent" 
							unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td isSpacer="true">
					<!-- spacer -->
					<span class="iconContainer">
						<span class="icon sep" unselectable="on" 
							style="width: 5px; min-width: 5px;"></span>
					</span>
				</td>
				<td>
					<!-- forecolor -->
					<span class="iconContainer" dojoAttachPoint="forecolorButton"
						unselectable="on" dojoOnClick="forecolorClick; buttonClick;">
						<span title="Change Text Color" class="icon forecolor" 
							unselectable="on">&nbsp;</span>
					</span>
					<div class="ColorDropdownContainer" 
						style="display: none; margin-top: 22px;"
						dojoAttachPoint="forecolorDropDown">
					</div>
				</td>
				<td>
					<!-- hilitecolor -->
					<span class="iconContainer" dojoAttachPoint="hilitecolorButton"
						unselectable="on" dojoOnClick="hilitecolorClick; buttonClick;">
						<span title="Change Background Color" class="icon hilitecolor" 
							unselectable="on">&nbsp;</span>
					</span>
					<div class="ColorDropdownContainer" 
						style="display: none; margin-top: 22px;"
						dojoAttachPoint="hilitecolorDropDown">
					</div>
				</td>
				<td isSpacer="true">
					<!-- spacer -->
					<span class="iconContainer">
						<span class="icon sep" unselectable="on" 
							style="width: 5px; min-width: 5px;"></span>
					</span>
				</td>
				<td>
					<!-- justify left -->
					<span class="iconContainer" dojoAttachPoint="justifyleftButton"
						dojoOnClick="justifyleftClick; buttonClick;">
						<span title="Justify Left" class="icon justifyleft" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- justify center -->
					<span class="iconContainer" dojoAttachPoint="justifycenterButton"
						dojoOnClick="justifycenterClick; buttonClick;">
						<span title="Center" class="icon justifycenter" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- justify right -->
					<span class="iconContainer" dojoAttachPoint="justifyrightButton"
						dojoOnClick="justifyrightClick; buttonClick;">
						<span title="Justify Right" class="icon justifyright" unselectable="on">&nbsp;</span>
					</span>
				</td>
				<td>
					<!-- justify full -->
					<span class="iconContainer" dojoAttachPoint="justifyfullButton"
						dojoOnClick="justifyfullClick; buttonClick;">
						<span title="Justify Both" class="icon justifyfull" unselectable="on">&nbsp;</span>
					</span>
				</td>	
				<td>
					<!-- font select -->
					<select dojoOnChange="formatSelectClick; buttonClick;"
						dojoAttachPoint="formatSelectBox" unselectable="on">
						<!-- FIXME: using "p" here inserts a paragraph in most cases! -->
						<option value="">-- format --</option>
						<option value="p">Normal</option>
						<option value="pre">Fixed Font</option>
						<option value="h1">Main Heading</option>
						<option value="h2">Section Heading</option>
						<option value="h3">Sub-Heading</option>
						<!-- <option value="blockquote">Block Quote</option> -->
					</select>
				</td>
				<td width="*">&nbsp;</td>
			</tr>
		</tbody>
	</table>
</div>

__CPAN_FILE__ src/widget/templates/HtmlFisheyeList.css
.dojoHtmlFisheyeListItemLabel {
	font-family: Arial, Helvetica, sans-serif;
	background-color: #eee;
	border: 2px solid #666;
	padding: 2px;
	text-align: center;
	position: absolute;
	display: none;
}

.dojoHtmlFisheyeListItemLabel.selected {
	display: block;
}

.dojoHtmlFisheyeListItemImage {
	border: 0px;
	position: absolute;
}

.dojoHtmlFisheyeListItem {
	position: absolute;
	z-index: 2;
}

.dojoHtmlFisheyeListBar {
	position: relative;
}

__CPAN_FILE__ src/widget/templates/HtmlFloatingPane.css

/********** Outer Window ***************/

.dojoFloatingPane {
	/* essential css */
	position: absolute;
	overflow: visible;		/* so drop shadow is displayed */
	z-index: 10;

	/* styling css */
	border: 1px solid;
	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
	background-color: ThreeDFace;
}


/********** Title Bar ****************/

.dojoFloatingPaneTitleBar {
	vertical-align: top;
	margin: 2px 2px 2px 2px;
	z-index: 10;
	background-color: #7596c6;
	cursor: default;
	overflow: hidden;
	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
	vertical-align: middle;
}

.dojoFloatingPaneTitleText {
	float: left;
	padding: 2px 4px 2px 2px;
	white-space: nowrap;
	color: CaptionText;
	font: small-caption;
}

.dojoTitleBarIcon {
	float: left;
	height: 22px;
	width: 22px;
	vertical-align: middle;
	margin-right: 5px;
	margin-left: 5px;
}

.dojoFloatingPaneActions{
	float: right;
	position: absolute;
	right: 2px;
	top: 2px;
	vertical-align: middle;
}


.dojoFloatingPaneActionItem {
	vertical-align: middle;
	margin-right: 1px;
	height: 22px;
	width: 22px;
}


.dojoFloatingPaneTitleBarIcon {
	/* essential css */
	float: left;

	/* styling css */
	margin-left: 2px;
	margin-right: 4px;
	height: 22px;
}

/* minimize/maximize icons are specified by CSS only */
.dojoFloatingPaneMinimizeIcon,
.dojoFloatingPaneMaximizeIcon,
.dojoFloatingPaneRestoreIcon,
.dojoFloatingPaneCloseIcon {
	vertical-align: middle;
	height: 22px;
	width: 22px;
	float: right;
}
.dojoFloatingPaneMinimizeIcon {
	background-image: url(images/floatingPaneMinimize.gif);
}
.dojoFloatingPaneMaximizeIcon {
	background-image: url(images/floatingPaneMaximize.gif);
}
.dojoFloatingPaneRestoreIcon {
	background-image: url(images/floatingPaneRestore.gif);
}
.dojoFloatingPaneCloseIcon {
	background-image: url(images/floatingPaneClose.gif);
}

/* bar at bottom of window that holds resize handle */
.dojoFloatingPaneResizebar {
	z-index: 10;
	height: 13px;
	background-color: ThreeDFace;
}

/************* Client Area ***************/

.dojoFloatingPaneClient {
	position: relative;
	z-index: 10;
	border: 1px solid;
	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
	margin: 2px;
	background-color: ThreeDFace;
	padding: 8px;
	font-family: Verdana, Helvetica, Garamond, sans-serif;
	font-size: 12px;
	overflow: auto;
}


__CPAN_FILE__ src/widget/templates/HtmlFloatingPane.html
<div id="${this.widgetId}" class="dojoFloatingPane">
	<div dojoAttachPoint="titleBar" class="dojoFloatingPaneTitleBar"  dojoAttachEvent="onMouseDown" style="display:none">
	  	<img dojoAttachPoint="titleBarIcon"  class="dojoFloatingPaneTitleBarIcon">
		<div dojoAttachPoint="closeAction" dojoAttachEvent="onClick:closeWindow"
   	  		class="dojoFloatingPaneCloseIcon"></div>
		<div dojoAttachPoint="restoreAction" dojoAttachEvent="onClick:restoreWindow"
   	  		class="dojoFloatingPaneRestoreIcon"></div>
		<div dojoAttachPoint="maximizeAction" dojoAttachEvent="onClick:maximizeWindow"
   	  		class="dojoFloatingPaneMaximizeIcon"></div>
		<div dojoAttachPoint="minimizeAction" dojoAttachEvent="onClick:minimizeWindow"
   	  		class="dojoFloatingPaneMinimizeIcon"></div>
	  	<div dojoAttachPoint="titleBarText" class="dojoFloatingPaneTitleText">${this.title}</div>
	</div>

	<div id="${this.widgetId}_container" dojoAttachPoint="containerNode" class="dojoFloatingPaneClient"></div>

	<div dojoAttachPoint="resizeBar" class="dojoFloatingPaneResizebar"></div>
</div>
__CPAN_FILE__ src/widget/templates/HtmlInlineEditBox.css
.editLabel {
	font-size : small;
	padding : 0 5px;
	display : none;
}

.editableRegion {
	background-color : #ffc !important;
	cursor : pointer;
	_cursor : hand;
}

.editableRegion .editLabel {
	display : inline;
}

.editableTextareaRegion .editLabel {
	display : block;
}

.inlineEditBox {
	/*background-color : #ffc;*/
	display : inline;
}

__CPAN_FILE__ src/widget/templates/HtmlInlineEditBox.html
<form class="inlineEditBox" style="display: none" dojoAttachPoint="form" dojoAttachEvent="onSubmit:saveEdit; onReset:cancelEdit; onKeyUp: checkForValueChange;">
	<input type="text" dojoAttachPoint="text" style="display: none;" />
	<textarea dojoAttachPoint="textarea" style="display: none;"></textarea>
	<input type="submit" value="Save" dojoAttachPoint="submitButton" />
	<input type="reset" value="Cancel" dojoAttachPoint="cancelButton" />
</form>

__CPAN_FILE__ src/widget/templates/HtmlMenu2.css

.dojoPopupMenu2 {
	position: absolute;
	border: 1px solid;
	border-color: ThreeDLightShadow ThreeDDarkShadow ThreeDDarkShadow ThreeDLightShadow;
}

.dojoPopupMenu2Client {
	border: 1px solid;
	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
	background-color: ThreeDFace;
	padding: 1px;
}

.dojoMenuItem2 {
	position: relative;
	white-space: nowrap;
	font: menu;
	color: WindowText;
	margin: 0;
}

.dojoMenuItem2 span {
	margin: 0;
}

.dojoMenuItem2Hover {
	background-color: Highlight;
	color: HighlightText;
}

.dojoMenuItem2Icon {
	position: absolute;
	background-position: center center;
	background-repeat: no-repeat;
	z-index: 1;
}

.dojoMenuItem2Label {
	position: absolute;
	vertical-align: middle;
	z-index: 1;
}

.dojoMenuItem2Label span {
	position: relative;
	vertical-align: middle;
	z-index: 2;
}

.dojoMenuItem2Label span span {
	position: absolute;
	color: ThreeDHighlight;
	display: none;
	left: 1px;
	top: 1px;
	z-index: -2;
}

.dojoMenuItem2Accel {
	position: absolute;
	vertical-align: middle;
	z-index: 1;
}

.dojoMenuItem2Accel span {
	position: relative;
	vertical-align: middle;
	z-index: 2;
}

.dojoMenuItem2Accel span span {
	position: absolute;
	color: ThreeDHighlight;
	display: none;
	left: 1px;
	top: 1px;
	z-index: -2;
}

.dojoMenuItem2Disabled .dojoMenuItem2Label span,
.dojoMenuItem2Disabled .dojoMenuItem2Accel span {
	color: ThreeDShadow;
}

.dojoMenuItem2Disabled .dojoMenuItem2Label span span,
.dojoMenuItem2Disabled .dojoMenuItem2Accel span span {
	color: ThreeDHighlight;
	display: block;
}

.dojoMenuItem2Hover .dojoMenuItem2Label span span,
.dojoMenuItem2Hover .dojoMenuItem2Accel span span {
	display: none;
}

.dojoMenuItem2Submenu {
	position: absolute;
	background-position: center center;
	background-repeat: no-repeat;
}

.dojoMenuItem2Target {
	position: absolute;
	z-index: 10;
	font-size: 1px;
	background-image: url('images/transparent.gif');
}

.dojoMenuSeparator2 {
	font-size: 1px;
	margin: 0;
}

.dojoMenuSeparator2Top {
	height: 50%;
	border-bottom: 1px solid ThreeDShadow;
	margin: 0px 2px;
	font-size: 1px;
}

.dojoMenuSeparator2Bottom {
	height: 50%;
	border-top: 1px solid ThreeDHighlight;
	margin: 0px 2px;
	font-size: 1px;
}



.dojoMenuBar2 {
	/*position: relative;*/
	background-color: ThreeDFace;
	border-bottom: 1px solid ThreeDHighlight;
}

.dojoMenuBar2Client {
	padding: 1px;
	border-top: 1px solid ThreeDHighlight;
	border-bottom: 1px solid ThreeDShadow;
}

.dojoMenuBarItem2 {
	position: absolute;
	white-space: nowrap;
	font: menu;
	color: WindowText;
	margin: 0;
}

.dojoMenuBarItem2 span {
	margin: 0;
}

.dojoMenuBarItem2Target {
	position: absolute;
	z-index: 10;
	font-size: 1px;
	background-image: url('images/transparent.gif');
}

.dojoMenuBarItem2Label {
	position: absolute;
	vertical-align: middle;
	z-index: 1;
	padding: 3px 8px;
}

.dojoMenuBarItem2Label span {
	position: relative;
	z-index: 2;
}

.dojoMenuBarItem2Label span span {
	position: absolute;
	color: ThreeDHighlight;
	display: none;
	left: 1px;
	top: 1px;
	z-index: -2;
}

.dojoMenuBarItem2Hover {
	background-color: Highlight;
	color: HighlightText;
}

.dojoMenuBarItem2Disabled .dojoMenuBarItem2Label span,
.dojoMenuBarItem2Disabled .dojoMenuBarItem2Accel span {
	color: ThreeDShadow;
}

.dojoMenuBarItem2Disabled .dojoMenuBarItem2Label span span,
.dojoMenuBarItem2Disabled .dojoMenuBarItem2Accel span span {
	color: ThreeDHighlight;
	display: block;
}

.dojoMenuBarItem2Hover .dojoMenuBarItem2Label span span,
.dojoMenuBarItem2Hover .dojoMenuBarItem2Accel span span {
	display: none;
}

__CPAN_FILE__ src/widget/templates/HtmlMenuItemTemplate.html
<div dojoAttachPoint="labelNode" dojoAttachEvent="onClick">
</div>

__CPAN_FILE__ src/widget/templates/HtmlMonthlyCalendar.css
.datePickerContainer {
	margin:0.5em 2em 0.5em 0;
	/*width:10em;*/
	float:left;
}

.previousMonth {
	background-color:#bbbbbb;
}

.currentMonth {
	background-color:#8f8f8f;
}

.nextMonth {
	background-color:#eeeeee;
}

.currentDate {
	text-decoration:underline;
	font-style:italic;
}

.selectedItem {
	background-color:#3a3a3a;
	color:#ffffff;
}

.calendarContainer {
	border-collapse:collapse;
	border-spacing:0;
	border-bottom:1px solid #e6e6e6;
	overflow: hidden;
	text-align: right;
}

.calendarContainer thead{
	border-bottom:1px solid #e6e6e6;
}

.calendarContainer tbody * td {
        height: 100px;
        border: 1px solid gray;
}

.calendarContainer td {
        width: 100px;
        padding: 2px;
	vertical-align: top;
}

.monthLabel {
	font-size:0.9em;
	font-weight:400;
	margin:0;
	text-align:center;
}

.monthLabel .month {
	padding:0 0.4em 0 0.4em;
}

.yearLabel {
	font-size:0.9em;
	font-weight:400;
	margin:0.25em 0 0 0;
	text-align:right;
	color:#a3a3a3;
}

.yearLabel .selectedYear {
	color:#000;
	padding:0 0.2em;
}

.nextYear, .previousYear {
	cursor:pointer;cursor:hand;
}

.incrementControl {
	cursor:pointer;cursor:hand;
	width:1em;
}

.dojoMonthlyCalendarEvent {
	font-size:0.7em;
	overflow: hidden;
	font-color: grey;
	white-space: nowrap;
	text-align: left;
}

__CPAN_FILE__ src/widget/templates/HtmlMonthlyCalendar.html
<div class="datePickerContainer" dojoAttachPoint="datePickerContainerNode">
	<h3 class="monthLabel">
	<!--
	<span 
		dojoAttachPoint="decreaseWeekNode" 
		dojoAttachEvent="onClick: onIncrementWeek;" 
		class="incrementControl">
		<img src="${dojoRoot}src/widget/templates/decrementWeek.gif" alt="&uarr;" />
	</span>
	-->
	<span 
		dojoAttachPoint="decreaseMonthNode" 
		dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl">
		<img src="${dojoRoot}src/widget/templates/decrementMonth.gif" 
			alt="&uarr;" dojoAttachPoint="decrementMonthImageNode">
	</span>
	<span dojoAttachPoint="monthLabelNode" class="month">July</span>
	<span 
		dojoAttachPoint="increaseMonthNode" 
		dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl">
		<img src="${dojoRoot}src/widget/templates/incrementMonth.gif" 
			alt="&darr;"  dojoAttachPoint="incrementMonthImageNode">
	</span>
	<!--
		<span dojoAttachPoint="increaseWeekNode" 
			dojoAttachEvent="onClick: onIncrementWeek;" 
			class="incrementControl">
			<img src="${dojoRoot}src/widget/templates/incrementWeek.gif" 
			alt="&darr;" />
		</span>
	-->
	</h3>
	<table class="calendarContainer">
		<thead>
			<tr>
				<td>Sunday</td>
				<td>Monday</td>
				<td>Tuesday</td>
				<td>Wednesday</td>
				<td>Thursday</td>
				<td>Friday</td>
				<td>Saturday</td>
			</tr>
		</thead>
		<tbody dojoAttachPoint="calendarDatesContainerNode" 
			dojoAttachEvent="onClick: onSetDate;">
			<tr dojoAttachPoint="calendarRow0">
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			</tr>
			<tr dojoAttachPoint="calendarRow1">
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			</tr>
			<tr dojoAttachPoint="calendarRow2">
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			</tr>
			<tr dojoAttachPoint="calendarRow3">
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			</tr>
			<tr dojoAttachPoint="calendarRow4">
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			</tr>
			<tr dojoAttachPoint="calendarRow5">
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			</tr>
		</tbody>
	</table>
	<h3 class="yearLabel">
		<span dojoAttachPoint="previousYearLabelNode"
			dojoAttachEvent="onClick: onIncrementYear;" class="previousYear"></span>
		<span class="selectedYear" dojoAttachPoint="currentYearLabelNode"></span>
		<span dojoAttachPoint="nextYearLabelNode" 
			dojoAttachEvent="onClick: onIncrementYear;" class="nextYear"></span>
	</h3>
</div>

__CPAN_FILE__ src/widget/templates/HtmlResizableTextarea.css
div.statusBar {
	background-color: ThreeDFace;
	height: 28px;
	padding: 1px;
	overflow: hidden;
	font-size: 12px;
}

div.statusPanel {
	background-color: ThreeDFace;
	border: 1px solid;
	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
	margin: 1px;
	padding: 2px 6px;
}

__CPAN_FILE__ src/widget/templates/HtmlResizableTextarea.html
<div>
	<div style="border: 2px solid black; width: 90%; height: 200px;"
		dojoAttachPoint="rootLayoutNode">
		<div dojoAttachPoint="textAreaContainerNode" 
			style="border: 0px; margin: 0px; overflow: hidden;">
		</div>
		<div dojoAttachPoint="statusBarContainerNode" class="statusBar">
			<div dojoAttachPoint="statusLabelNode" 
				class="statusPanel"
				style="padding-right: 0px; z-index: 1;">drag to resize</div>
			<div dojoAttachPoint="resizeHandleNode"></div>
		</div>
	</div>
</div>

__CPAN_FILE__ src/widget/templates/HtmlResizeHandle.css
.dojoHtmlResizeHandle {
	float: right;
	position: absolute;
	right: 2px;
	bottom: 2px;
	width: 13px;
	height: 13px;
	z-index: 20;
	cursor: nw-resize;
	background-image: url(grabCorner.gif);
	line-height: 0px;
}
__CPAN_FILE__ src/widget/templates/HtmlSimpleDropdownButtons.css
ul.dojoSimpleDropdownButtons {
	margin : 0;
	padding : 5px 0;
}

ul.dojoSimpleDropdownButtons li {
	display : inline;
	margin-right : 5px;
	padding : 2px 0;
}

ul.dojoSimpleDropdownButtons li a {
	padding : 2px 9px;
	border : 2px outset #ccc;
	border-right-width : 1px;
	background : #f4f4f4;
	color : #333;
	text-decoration : none;
}

ul.dojoSimpleDropdownButtons li ul {
	display : none;
}

ul.dojoSimpleDropdownButtons li a.disabled {
	color : #999;
	cursor : default;
}

ul.dojoSimpleDropdownButtons li .downArrow {
	display : inline;
	padding : 2px 4px;
	border : 2px outset #ccc;
	border-left : 0;
	background : #f4f4f4 url(images/dropdownButtonsArrow.gif) no-repeat 4px 9px;
	text-decoration : none;
	color : black;
	cursor : pointer;
	_cursor : hand;
}

ul.dojoSimpleDropdownButtons li .downArrow.disabled {
	background-image : url(images/dropdownButtonsArrow-disabled.gif);
	cursor : default;
}

ul.dojoSimpleDropdownButtons li a:hover,
ul.dojoSimpleDropdownButtons li span.downArrow:hover {
	color : black;
	background-color : #ddd;
}

ul.dojoSimpleDropdownButtons li .downArrow.pressed, ul.dojoSimpleDropdownButtons li .downArrow:focus {
	border-style : inset;
	background-position : 5px 10px;
	padding : 2px 4px;
}

ul.dojoSimpleDropdownButtons li a.disabled:hover,
ul.dojoSimpleDropdownButtons li span.downArrow.disabled:hover {
	color : #999;
	background-color : #f4f4f4;
}

ul.dojoSimpleDropdownButtons li a:focus {
	padding : 3px 8px 1px 10px;
	color : #333;
	border-style : inset;
}

/* Menu
 ******************** */
ul.dojoSimpleDropdownButtonsMenu {
	position : absolute;
	margin : 0;
	_margin : -2px;
	padding : 0;
	display : none;
	border : 1px solid #aaa;
	background : #f4f4f4;
	list-style : none;
	z-index : 99;
}

ul.dojoSimpleDropdownButtonsMenu li {
	_display : inline;
}

ul.dojoSimpleDropdownButtonsMenu a {
	display : block;
	padding : 2px 5px;
	color : #333;
	text-decoration : none;
}

ul.dojoSimpleDropdownButtonsMenu a:hover {
	background : #ddd;
	color : black;
}


__CPAN_FILE__ src/widget/templates/HtmlSlideShow.css
.slideShowImg {
	position: absolute;
	left: 0px;
	top: 0px; 
	border: 2px solid #4d4d4d;
	padding: 0px;
	margin: 0px;
}


__CPAN_FILE__ src/widget/templates/HtmlSlideShow.html
<table cellpadding="0" cellspacing="0" border="0">
	<tr>
		<td dojoAttachPoint="controlsContainer">
			<input type="button" value="pause" 
				dojoAttachPoint="startStopButton"
				dojoAttachEvent="onClick: togglePaused;">
		</td>
	</tr>
	<tr>
		<td>
			<div style="position: relative; width: 800px; height: 600px;"
				dojoAttachPoint="imagesContainer"
				dojoAttachEvent="onClick: togglePaused;">
				<img dojoAttachPoint="img1" class="slideShowImg" 
					style="z-index: 1;"  />
				<img dojoAttachPoint="img2" class="slideShowImg" 
					style="z-index: 0;" />
			</div>	
		</td>
	</tr>
</table>

__CPAN_FILE__ src/widget/templates/HtmlSplitContainer.css
.dojoSplitContainer{
	position: relative;
	overflow: hidden;
}

.dojoSplitPane{
	position: absolute;
}

.dojoSplitContainerSizerH,
.dojoSplitContainerSizerV {
	font-size: 1px;
	cursor: move;
	cursor: w-resize;
	background-color: ThreeDFace;
	border: 1px solid;
	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
	margin: 0;
}

.dojoSplitContainerSizerV {
	cursor: n-resize;
}

.dojoSplitContainerVirtualSizerH,
.dojoSplitContainerVirtualSizerV {
	font-size: 1px;
	cursor: move;
	cursor: w-resize;
	background-color: ThreeDShadow;
	-moz-opacity: 0.5;
	opacity: 0.5;
	filter: Alpha(Opacity=50);
	margin: 0;
}

.dojoSplitContainerVirtualSizerV {
	cursor: n-resize;
}

__CPAN_FILE__ src/widget/templates/HtmlTabContainer.css
.dojoTabContainer {
	position : relative;
}

.dojoTabPaneWrapper {
	position : relative;
	border : 1px solid;
}

.dojoTabLabels-top {
	position : absolute;
	top : 0px;
	left : 0px;
	overflow : visible;
	margin-bottom : -1px;
	width : 100%;
}

.dojoTabPaneTab {
	position : relative;
	float : left;
	padding-left : 9px;
	border-bottom : 1px solid;
	background : url(images/tab_left.gif) no-repeat left top;
	cursor: pointer;
}

.dojoTabPaneTab span {
	display : block;
	padding : 4px 15px 4px 6px;
	background : url(images/tab_top_right.gif) no-repeat right top;
	color : #333;
	font-size : 90%;
}

.dojoTabPanePaneClose {
	position : absolute;
	bottom : 0px;
	right : 6px;
	height : 12px;
	width : 12px;
	background : url(images/tab_close.gif) no-repeat right top;
}

.dojoTabPanePaneCloseHover {
	background-image : url(images/tab_close_h.gif);
}

.dojoTabPaneTabClose {
	display : inline;
	height : 12px;
	width : 12px;
	padding : 0 12px 0 0;
	margin : 0 -10px 0 10px;
	background : url(images/tab_close.gif) no-repeat right top;
	cursor : default;
}

.dojoTabPaneTabCloseHover {
	background-image : url(images/tab_close_h.gif);
}

.dojoTabPaneTab.current {
	padding-bottom : 1px;
	border-bottom : 0;
	background-position : 0 -150px;
}

.dojoTabPaneTab.current span {
	padding-bottom : 5px;
	margin-bottom : -1px;
	background-position : 100% -150px;
}

/* bottom tabs */

.dojoTabLabels-bottom {
	position : absolute;
	bottom : 0px;
	left : 0px;
	overflow : visible;
	margin-top : -1px;
	width : 100%;
}

.dojoTabLabels-bottom .dojoTabPaneTab {
	border-top :  1px solid;
	border-bottom : 0;
	background : url(images/tab_bot_left.gif) no-repeat left bottom;
}

.dojoTabLabels-bottom .dojoTabPaneTab span {
	background : url(images/tab_bot_right.gif) no-repeat right bottom;
}

.dojoTabLabels-bottom .dojoTabPaneTab.current {
	padding-top : 1px;
	border-top : 0;
	background : url(images/tab_bot_left_curr.gif) no-repeat left bottom;
}

.dojoTabLabels-bottom .dojoTabPaneTab.current span {
	padding-top : 5px;
	margin-top : -1px;
	background : url(images/tab_bot_right_curr.gif) no-repeat right bottom;
}

/* right-h tabs */

.dojoTabLabels-right-h {
	position : absolute;
	top : 0px;
	right : 0px;
	overflow : visible;
	margin-left : -1px;
}

.dojoTabLabels-right-h .dojoTabPaneTab {
	padding-left : 0;
	border-left :  1px solid;
	border-bottom : 0;
	background : url(images/tab_bot_right.gif) no-repeat right bottom;
	float : none;
}

.dojoTabLabels-right-h .dojoTabPaneTab span {
	padding : 4px 15px 4px 15px;
}

.dojoTabLabels-right-h .dojoTabPaneTab.current {
	border-left :  0;
	border-bottom :  1px solid;
}

/* left-h tabs */

.dojoTabLabels-left-h {
	position : absolute;
	top : 0px;
	left : 0px;
	overflow : visible;
	margin-right : -1px;
}

.dojoTabLabels-left-h .dojoTabPaneTab {
	border-right :  1px solid;
	border-bottom : 0;
	float : none;
	background : url(images/tab_top_left.gif) no-repeat left top;
}

.dojoTabLabels-left-h .dojoTabPaneTab.current {
	border-right : 0;
	border-bottom :  1px solid;
	padding-bottom : 0;
	background : url(images/tab_top_left.gif) no-repeat 0 -150px;
}

.dojoTabLabels-left-h .dojoTabPaneTab span {
	background : 0;
}

__CPAN_FILE__ src/widget/templates/HtmlTabContainer.html
<div id="${this.widgetId}" class="dojoTabContainer">
	<div class="dojoTabPaneWrapper" dojoAttachPoint="containerNode" >
	</div>
	<div dojoAttachPoint="dojoTabLabels">
	</div>
</div>
__CPAN_FILE__ src/widget/templates/HtmlTaskBar.css
.dojoTaskBarItem {
	background-color: ThreeDFace;
	border: outset 2px;
	display: inline;
	margin-right: 5px;
	cursor: pointer;
	height: 35px;
	width: 100px;
	font-size: 10pt;
	white-space: nowrap;
	text-align: center;
}

.dojoTaskBarItem img {
	vertical-align: middle;
	margin-right: 5px;
	margin-left: 5px;	
	height: 32px;
	width: 32px;
}

.dojoTaskBarItem a {
	 color: black;
	text-decoration: none;
}



__CPAN_FILE__ src/widget/templates/HtmlTaskBarItemTemplate.html
<div class="dojoTaskBarItem" dojoAttachEvent="onClick">
</div>
__CPAN_FILE__ src/widget/templates/HtmlTimePicker.css
.timePickerContainer {
	margin:1.75em 0 0.5em 0;
	width:10em;
	float:left;
}

.timeContainer {
	border-collapse:collapse;
	border-spacing:0;
}

.timeContainer thead td{
	border-bottom:1px solid #e6e6e6;
	padding:0 0.4em 0.2em 0.4em;
}

.timeContainer td {
	font-size:0.9em;
	padding:0 0.25em 0 0.25em;
	text-align:left;
	cursor:pointer;cursor:hand;
}

.timeContainer td.minutesHeading {
	border-left:1px solid #e6e6e6;
	border-right:1px solid #e6e6e6;	
}

.timeContainer .minutes {
	border-left:1px solid #e6e6e6;
	border-right:1px solid #e6e6e6;
}

.selectedItem {
	background-color:#3a3a3a;
	color:#ffffff;
}

__CPAN_FILE__ src/widget/templates/HtmlTimePicker.html
<div class="timePickerContainer" dojoAttachPoint="timePickerContainerNode">
	<table class="timeContainer" cellspacing="0" >
		<thead>
			<tr>
				<td>Hour</td>
				<td class="minutesHeading">Minute</td>
				<td>&nbsp;</td>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td valign="top">
					<table>
						<tbody dojoAttachPoint="hourContainerNode"  
							dojoAttachEvent="onClick: onSetSelectedHour;">
							<tr>
								<td>12</td>
								<td>6</td>
							</tr>
							<tr>
								<td>1</td>
								<td>7</td>
							</tr>
							<tr>
								<td>2</td>
								<td>8</td>
							</tr>
							<tr>
								<td>3</td>
								<td>9</td>
							</tr>
							<tr>
								<td>4</td>
								<td>10</td>
							</tr>
							<tr>
								<td>5</td>
								<td>11</td>
							</tr>
						</tbody>
					</table>
				</td>
				<td valign="top" class="minutes">
					<table>
						<tbody dojoAttachPoint="minuteContainerNode" 
							dojoAttachEvent="onClick: onSetSelectedMinute;">
							<tr>
								<td>00</td>
								<td>30</td>
							</tr>
							<tr>
								<td>05</td>
								<td>35</td>
							</tr>
							<tr>
								<td>10</td>
								<td>40</td>
							</tr>
							<tr>
								<td>15</td>
								<td>45</td>
							</tr>
							<tr>
								<td>20</td>
								<td>50</td>
							</tr>
							<tr>
								<td>25</td>
								<td>55</td>
							</tr>
						</tbody>
					</table>
				</td>
				<td valign="top">
					<table>
						<tbody dojoAttachPoint="amPmContainerNode" 
							dojoAttachEvent="onClick: onSetSelectedAmPm;">
							<tr>
								<td>AM</td>
							</tr>
							<tr>
								<td>PM</td>
							</tr>
						</tbody>
					</table>
				</td>
			</tr>
			<tr>
				<td></td>
				<td>
					<div dojoAttachPoint="anyTimeContainerNode" 
						dojoAttachEvent="onClick: onSetSelectedAnyTime;" 
						class="anyTimeContainer">any</div>
				</td>
				<td></td>
			</tr>
		</tbody>
	</table>
</div>

__CPAN_FILE__ src/widget/templates/HtmlToolbar.css
.toolbarContainer {
	border-bottom : 0;
	background-color : #def;
	color : ButtonText;
	font : Menu;
	background-image: url(images/toolbar-bg.gif);
}

.toolbar {
	padding : 2px 4px;
	min-height : 26px;
	_height : 26px;
}

.toolbarItem {
	float : left;
	padding : 1px 2px;
	margin : 0 2px 1px 0;
	cursor : pointer;
}

.toolbarItem.selected, .toolbarItem.down {
	margin : 1px 1px 0 1px;
	padding : 0px 1px;
	border : 1px solid #bbf;
	background-color : #fafaff;
}

.toolbarButton img {
	vertical-align : bottom;
}

.toolbarButton span {
	line-height : 16px;
	vertical-align : middle;
}

.toolbarButton.hover {
	padding : 0px 1px;
	border : 1px solid #99c;
}

.toolbarItem.disabled {
	opacity : 0.3;
	filter : alpha(opacity=30);
	cursor : default;
}

.toolbarSeparator {
	cursor : default;
}

.toolbarFlexibleSpace {
}

__CPAN_FILE__ src/widget/templates/HtmlTooltipTemplate.css
.dojoTooltip {
	border: solid black 1px;
	background: beige;
	color: black;
	position: absolute;
	font-size: small;
	padding: 2px 2px 2px 2px;
	z-index: 10;
}

__CPAN_FILE__ src/widget/templates/HtmlTooltipTemplate.html
<div class='dojoTooltip' style="display:none" dojoAttachPoint="containerNode">
</div>
__CPAN_FILE__ src/widget/templates/incrementMonth.gif
GIF89a	    000yyyFFFUUUWWW222aaa:::                              !     ,    	   %`!@@NK(tR4=T#4D`"  ;
__CPAN_FILE__ src/widget/templates/incrementWeek.gif
GIF89a    000cccyyyCCCFFFjjjmmm                                       !     ,         PQ@!N  ;
__CPAN_FILE__ src/widget/templates/Menu.css
.dojoMenu {
	border:1px solid #000000;
	list-style-type:none;
	margin:0;
	padding:0;
	padding-bottom: 1px;
	background-color:#f4f4f4;
	font-size: 8pt;
}

.dojoMenuSeparator {
	list-style-type:none;
	margin:0;
	padding:1px 0;
	border-bottom:1px solid #000000;
	line-height:1px;
	height:1px;
}

li:hover.dojoMenuSeparator {
	background-color:#e5e5e5;
	cursor:default;
}




.dojoContextMenu {
	position: absolute;
	display: none;
	border: 2px solid;
	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
	list-style-type: none;
	margin: 0;
	padding: 1px;
	background-color: ThreeDFace;
	font-size: 8pt;
}

.dojoMenuItem {
	white-space: nowrap;
	padding: 2px;
	font: menu;
	color: WindowText;
}

.dojoMenuItem a {
	text-decoration: none;
	color: WindowText;
	font: inherit;
}

.dojoMenuItemHover {
	padding: 2px;
	background-color: blue;
	cursor: pointer;
	_cursor: hand;
	background-color: Highlight;
	color: HighlightText;
}
__CPAN_FILE__ src/widget/templates/PopUpButton.css
.PopUpButton {
	padding : 2px 6px 2px 9px;
	border : 1px outset #ccc;
	background : #f4f4f4;
	color : #333;
	text-decoration : none;
}

.PopUpButton .downArrow {
	margin-left: 0.5em;
	margin-bottom: 2px;
}

.downArrow.disabled {
	background-image : url(images/dropdownButtonsArrow-disabled.gif);
	cursor : default;
}

ul.dropdownButtons li a:hover,
ul.dropdownButtons li span.downArrow:hover {
	color : black;
	background-color : #ddd;
}

ul.dropdownButtons li .downArrow.pressed, ul.dropdownButtons li .downArrow:focus {
	border-style : inset;
	background-position : 5px 10px;
	padding : 2px 4px;
}

ul.dropdownButtons li a.disabled:hover,
ul.dropdownButtons li span.downArrow.disabled:hover {
	color : #999;
	background-color : #f4f4f4;
}

__CPAN_FILE__ src/widget/templates/richtextframe.html
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title></title>
    <script type="text/javascript">
    function init(){
       document.designMode = 'On';
       parentPageDomain = document.location.href.split('#')[1];
       if (parentPageDomain) {
          document.domain = parentPageDomain;
       }
    }
    window.onload = init;
    </script>
  </head>
  <body>
  <br />
  </body>
</html>

__CPAN_FILE__ src/widget/templates/TitlePane.html
<div dojoAttachPoint="domNode">
<div dojoAttachPoint="labelNode" dojoAttachEvent="onclick: onLabelClick"></div>
<div dojoAttachPoint="containerNode"></div>
</div>

__CPAN_FILE__ src/widget/templates/Tree.css
.dojoTree {
	font: caption;
	font-size: 11px;
	font-weight: normal;
	overflow: auto;
}

.dojoTreeNodeLabel {
	padding: 1px 2px;
	color: WindowText;
	cursor: default;
}

.dojoTreeNodeLabel:hover {
	text-decoration: underline;
}

.dojoTreeNodeLabelSelected {
	background-color: Highlight;
	color: HighlightText;
}

.dojoTree div {
	white-space: nowrap;
}

.dojoTree img {
	vertical-align: middle;
}

__CPAN_FILE__ src/widget/templates/Wizard.css
.WizardContainer {
	background: #EEEEEE;
	border: #798EC5 1px solid;
	padding: 2px;
}

.WizardTitle {
	color: #003366;
	padding: 8px 5px 15px 2px;
	font-weight: bold;
	font-size: x-small;
	font-style: normal;
	font-family: Verdana, Arial, Helvetica;
	text-align: left;
}

.WizardText {
	color: #000033;
	font-weight: normal;
	font-size: xx-small;
	font-family: Verdana, Arial, Helvetica;
	padding: 2 50; text-align: justify;
}

.WizardLightText {
	color: #666666;
	font-weight: normal;
	font-size: xx-small;
	font-family: verdana, arial, helvetica;
	padding: 2px 50px;
	text-align: justify;
}

.WizardButtonHolder {
	text-align: right;
	padding: 10px 5px;
}

.WizardButton {
	color: #ffffff;
	background: #798EC5;
	font-size: xx-small;
	font-family: verdana, arial, helvetica, sans-serif;
	border-right: #000000 1px solid;
	border-bottom: #000000 1px solid;
	border-left: #666666 1px solid;
	border-top: #666666 1px solid;
	padding-right: 4px;
	padding-left: 4px;
	text-decoration: none; height: 18px;
}

.WizardButton:hover {
	cursor: pointer;
}

.WizardButtonDisabled {
	color: #eeeeee;
	background-color: #999999;
	font-size: xx-small;
	FONT-FAMILY: verdana, arial, helvetica, sans-serif;
	border-right: #000000 1px solid;
	border-bottom: #000000 1px solid;
	border-left: #798EC5 1px solid;
	border-top: #798EC5 1px solid;
	padding-right: 4px;
	padding-left: 4px;
	text-decoration: none;
	height: 18px;
}



__CPAN_FILE__ src/widget/templates/Wizard.html
<div class="WizardContainer" dojoAttachPoint="wizardNode">
    <div class="WizardText" dojoAttachPoint="wizardPanelContainerNode">
    </div>
    <div class="WizardButtonHolder" dojoAttachPoint="wizardControlContainerNode">
        <input class="WizardButton" type="button" dojoAttachPoint="previousButton"/>
        <input class="WizardButton" type="button" dojoAttachPoint="nextButton"/>
        <input class="WizardButton" type="button" dojoAttachPoint="cancelButton"/>
        <input class="WizardButton" type="button" dojoAttachPoint="doneButton" style="display:none"/>
    </div>
</div>


__CPAN_DIR__ src/widget/templates/buttons
__CPAN_FILE__ src/widget/templates/buttons/-.gif
GIF89a   !   ,       L`d|{ ;
__CPAN_FILE__ src/widget/templates/buttons/aggregate.gif
GIF89a  Vxll**@@@GhOQ| lyXHHOt][cji	mUTFE2j9YQo1,+Mwcedrevi111uzofeK|||||?>ii[~a|Z[Zr$Ws5qEL':t n|tt98~G21Mrk54tLm>^kML\ZVrWdcmnm768SLI`wvo%A@O{A]"Qq. ?W`  Aa=lQ|`lvszX[*)/.PP`<`_}771mG~'{dW\ba'&!   ,       	<"*\#JH2j@ yI(S\07ytA4dMh*%JJXNU_u4@<pbf4Xhsv:KpjYeqP2ev##QkO>_:]z-*;vh#
=	'p	
xF9{-?M5G(n=hPATPYTp0SEJ^bd0d~QDdG/ zhK	A+&4'~aCBre?D
!L%]A/_"ZlI [m[Y
MU`7Q1WB?]B$I
FAYI.	D	#^$|GdJjjt  G(txr'(tQH# l}kB"R4	2,q 2G*
}nz#o?RC:&jB&pa|I$>$W5AP&MB4 GJA>:T5
T>tL78d1eMmB4I%f	%O<:>'G;ppy$EA$'BL9A3|s<*|iqFEgpB.^PR^
"T v C5|P&Q@	4utp$-
L IB@>L 8! l0St3l	$eC}Yia M,&BjM!w&  zP&KN`
aBwY0!,Aq\.88W!$!,"*4EP$C" $hY(GX%cw#2`@*:0 	`2H^pgAnA@ AqHV+$,( V,p./hNLn
B6c'%1)aa: 8z*@coq%,J0,4q VSM(B8gQCa%YHq-l	$eQN JTWbAd*3+H', R$,!U/8S$f)D8VmHVzU3(aI!|b@
hAbp=`	H-"G di0B &;RlL@3<'((Fd@OxDe'H DH0ZD.7t,!@=EPiThZxMP 1%u3&^TC""'UdS4hs*:6 Ph Z0-{^ Zm 1 U(NOnU.~1Le]0@ AA[ U/{{ioA ^,D#YzI(4X[IA /8Y B 
Qxpy80a5H.l.Q&.BAHq ZznAiMKek^RJ16q!U~qVwkU;?*kW.E>0 `F 7H,c9IMz;!/vH+8bxb@~28vk&8`gKxKX@R(f^jkBpnh B<#	qC(w&H	0=k [xAZ@`fqa@Wb x^M8.Ba=
 G=:{!Wv~wi!H1mG7 d#87B aL!xS$/22Nd#(N%gCx#	13~P(  `$  l![	eVHT
B h
L` H@c
^0c[
!NI&C~7G.vav`v:0wa
0' sOs0}
i#_ZH\_i~"ekl
{	pPvhfG|! Q}w`w[o-vU/X(wvX4pPUVh8M& (0H"XJJD[a[P[Q
`SifHD p @s P`70~zBQN|k R38vJRa
PYShEoXU;qa
UU t60{0axaU'pK`>1rgzWM6L})C479	gPp
 0b  Q
Yh D  g77pH X1Ep c`Cy+'!Cy RICa M9U8s7> ! yPSqxbyQv.qyy0.z	a1!&Uk P0*	 7/Cp5g@KD# Pa0p	P@iqNda:VyKPz]S IYQ
[`Sz@Z;pG@pX cP E0!N&Lp 	jyl9)IJL}ko]q$ljAeiLm:rb@%-Hji	0dJ v?y.0"0PJ	P"Q P:Pmy p7hvyzvX |H
z6)!
*.'zYPe4*@*5F2q	*q'/	m%	~U5	aS65k!C	 bjK Z "k2c& ;
__CPAN_FILE__ src/widget/templates/buttons/backcolor.gif
GIF89a  b  {}WD~]E =q  OT vl.  { u]f"?j\ Q|p+Z@@@                                                                                       !  b ,       ba>B7D,@aaX?LNM;EZ9VK&]'_R3(S.+! P<`FC^*a`-W"6YAI	b\Q`1) `O#%5$zU %
F	/H\A  ;
__CPAN_FILE__ src/widget/templates/buttons/bg-fade.png
PNG

   IHDR   
   d   06   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   CIDATxb<sn022M>t=5|>RGu
zci:	H G&(x}    IENDB`
__CPAN_FILE__ src/widget/templates/buttons/bold.gif
GIF89a  < rvQqRqMl|xBbtkQyVr?_Qq\x@`dlIj|Ei?_\ztMmUtHg~bsi9Y         !  < ,       w@pH,RH9NXF49> xh[h	]dQO81^ *
p:7("sB
%E,6.:0&	GPOKCA ;
__CPAN_FILE__ src/widget/templates/buttons/cancel.gif
GIF89a  7 BB@@zz>>cc//;;66TT""bbxx,,PP]]##                        !  7 ,       pH,kd`l<Z%d:[tkI!5-+WN 0F*}{^ %
( C5000N"75,&5'!//	$/3344JIMEA ;
__CPAN_FILE__ src/widget/templates/buttons/copy.gif
GIF89a   @@@8   !   ,       TIxS#:1C:pCp.*t-Y1`c4`)Yh6F`fj ^LPeER~ ;
__CPAN_FILE__ src/widget/templates/buttons/createlink.gif
GIF89a   ccc666555[[[JJJ]]]GGGAAAqmo444kmkllneeezzzdtblcfvfik---bbbnqoHHHtmoxz|vwwzdRSSNNNW\EEEZZZkok777`bdjf~oyyvqtiimfw{mMMMnqn\\\DDD}}}PYPx                                                                                                                                                                                                                                 !   ,        i	HY"XafEL3^(Z `VA	NQCp#^08@*vD(fzXeH(tP8(b+=~$@T!x@r%JjG&@g2(=p2R!Qh$5`+(L THJ"PTT ,?LhPJ8)%J3RhP3,"Q @(`J$)!4pNyrxJDl(!c/0  ;
__CPAN_FILE__ src/widget/templates/buttons/cut.gif
GIF89a  2 ~    Xcbmnl    BB?>s    opo""  z22y228]\Ued}}                                              !  2 ,       f@pH,x$!*TVU!d5Pd"U1211I+22,2H./G2BG1# *CuGA ;
__CPAN_FILE__ src/widget/templates/buttons/delete.gif
GIF89a      !   ,       (@)R=G~p N ;
__CPAN_FILE__ src/widget/templates/buttons/forecolor.gif
GIF89a  ]  {{j\" u  Ep+. f[T~]}W q ]  =?Z  OD000                                                                                                      !  ] ,       ]\J%5=40\\HM<>[;@[
E	[S1&+G([-[IW#X6[C LKF![NOB[VYU)DT' [QP2A":/[7R8TXe-\`@bFZD@ ;
__CPAN_FILE__ src/widget/templates/buttons/hilitecolor.gif
GIF89a  b  {}WD~]E =q  OT vl.  { u]f"?j\ Q|p+Z@@@                                                                                       !  b ,       ba>B7D,@aaX?LNM;EZ9VK&]'_R3(S.+! P<`FC^*a`-W"6YAI	b\Q`1) `O#%5$zU %
F	/H\A  ;
__CPAN_FILE__ src/widget/templates/buttons/indent.gif
GIF89a  
 =KX&ld1z`!]UT'&               !  
 ,       0PI8GR"#g$YSRpJ Z$|@9lR" ;
__CPAN_FILE__ src/widget/templates/buttons/inserthorizontalrule.gif
GIF89a   IHNMYX:9ji]\65?>TSml21feDCba   !   ,       "I8KSH 0`(#4x ;
__CPAN_FILE__ src/widget/templates/buttons/insertimage.gif
GIF89a  \ xwp^!5rz[|2klX~F~TgV4pzyrZ]dq9_YC}~nC]tSqnYW!`$_ G~'}yCHqL#bVPKdr-RI}MeN `t91m2t^b'TLIwvo                                                                                                         !  \ ,       \[[\  4
K ZYY\=/N.6E3C[;B89!,MW[<-"L+(5[U?H%I$Q[)V7>A &2P[1'*S@:<9wO#`p
[:LP,3jX Cd5 ;
__CPAN_FILE__ src/widget/templates/buttons/insertorderedlist.gif
GIF89a   KvQ'&!   ,       &jzj}Oq+dbJr ;
__CPAN_FILE__ src/widget/templates/buttons/inserttable.gif
GIF89a   ?>TLI                           !   ,       f%dih^ $VT)ei)0$QBZ
d1pcJbic@lc |RCC+"! ;
__CPAN_FILE__ src/widget/templates/buttons/insertunorderedlist.gif
GIF89a   GR`'&         !   ,       'H0Jl5e]di&mU*j66_	 ;
__CPAN_FILE__ src/widget/templates/buttons/italic.gif
GIF89a  3 <\s9YU~@bCa{eXu|^xMsc|A_Gh?_Vq>^Mp~RoZC`WrJhGeMnIh_{KkFe                                    !  3 ,       RpH,x F 	V1
(*djl*D^y9
j.	p$X0^^RA ;
__CPAN_FILE__ src/widget/templates/buttons/justifycenter.gif
GIF89a   :943/.@?NMGF[Za`TSgf,+   !   ,       1I8}JBLLH0Y\@niel:5 ;
__CPAN_FILE__ src/widget/templates/buttons/justifyfull.gif
GIF89a  ) 2165:9DCIH-,?>_^10jibaml]\RQUTML87cb43.-<;ZYfe98BAYXKJ>=FEPOGFA@TSWV0/54NM/.,+                                                                  !  ) ,       QpH,r\$,
FD" `hBy`0S9TCHD1L\F'rCuuwHVXZ%qsaHA ;
__CPAN_FILE__ src/widget/templates/buttons/justifyleft.gif
GIF89a   65ONDC?>IHJIUTVU9843//-,ed*)54[Y>=10:9onPPa_;:jiCB,+'&   !   ,       ?'dihEeEHl`:T
P a88lv'>4* ;
__CPAN_FILE__ src/widget/templates/buttons/justifyright.gif
GIF89a   .-21>=54:9CBHGNMSRXWfeih]\a`,+                                       !   ,       ;$dihg, Q `Et R%Q[nBHlJZ(K.B ;
__CPAN_FILE__ src/widget/templates/buttons/left_to_right.gif
GIF89a  
 GFDC@?=<IH54.-1087Q                  !  
 ,       7PI8&T@ 8"2[I_!
 /6)(AOtJD  ;
__CPAN_FILE__ src/widget/templates/buttons/list_bullet_indent.gif
GIF89a   GR`'&         !   ,       'H0Jl5BYWifvXwC	 ;
__CPAN_FILE__ src/widget/templates/buttons/list_bullet_outdent.gif
GIF89a   GR`'&         !   ,       (H0J&,S]Xi>qzJztl[6Y ;
__CPAN_FILE__ src/widget/templates/buttons/list_num_indent.gif
GIF89a   KvQ'&!   ,       &jN:a7U^Z~rR  ;
__CPAN_FILE__ src/widget/templates/buttons/list_num_outdent.gif
GIF89a   KvQ'&!   ,       &Gp1y`*:T  ;
__CPAN_FILE__ src/widget/templates/buttons/outdent.gif
GIF89a  
 =KX&ld1z`!]UT'&               !  
 ,       0PI8}R`N
a
0XRqD  ;
__CPAN_FILE__ src/widget/templates/buttons/paste.gif
GIF89a   }tpdhylb%TLI8                        !   ,       q &di(JIT*V*peV!lnB$
Qel:'ajZ(Z.`-#5n)3~_/Use	}@se5'ss.! ;
__CPAN_FILE__ src/widget/templates/buttons/redo.gif
GIF89a  B PQO[P"Ui&W$VQPyPzE|2hz:t;iO!TlRs:gD0`TiT| SzO'[OL                                                                                                                                                                                       !  B ,       |B	0#14'>"
!@, -8=+9A B. 3 *%;6:)? <	72A($/&5 ;
__CPAN_FILE__ src/widget/templates/buttons/removeformat.gif
GIF89a   mm!   ,       6|AX\ E}"]"m
+b
!B);>  ;
__CPAN_FILE__ src/widget/templates/buttons/right_to_left.gif
GIF89a  
 GFDC@?=<IH54.-1087Q                  !  
 ,       ;PI8$ #@R(AtBU

dX9(#,6 ;
__CPAN_FILE__ src/widget/templates/buttons/save.gif
GIF89a   dv9Yr         !   ,       UI8WuLiBupa<u=c(BNhx(}NiVW<l ;
__CPAN_FILE__ src/widget/templates/buttons/space.gif
GIF89a          !    ,       D ;
__CPAN_FILE__ src/widget/templates/buttons/strikethrough.gif
GIF89a  ! ?_Hg@`BbQy~IjQqtqQqbEivi989Y                                                                                          !  ! ,       fpH,r9Nv pa*0QphI!|NC~9	lC B]
E  DPO KA ;
__CPAN_FILE__ src/widget/templates/buttons/subscript.gif
GIF89a   QKv21!   ,       Ncau iN	{ ;
__CPAN_FILE__ src/widget/templates/buttons/superscript.gif
GIF89a   QKv21!   ,       ^Q`LY^x_ ;
__CPAN_FILE__ src/widget/templates/buttons/underline.gif
GIF89a  / `EiiZVwHm?_=^qw|HgWKo?afhSq]{=]qwOpQx_{HiqGhAbiTr\vx9Y                                                !  / ,       {pH,H!(.F(u]EqQFbR4LtI6E=t)2E.tA<E$|/.E-.D%		&C #G  H!I R) IF,UR(CA ;
__CPAN_FILE__ src/widget/templates/buttons/undo.gif
GIF89a  B PQO[P"Ui&W$VQPyPzE|2hz:t;iO!TlRs:gD0`TiT| SzO'[OL                                                                                                                                                                                       !  B ,       zB	'41#0@!
">A9+=8- ,A3 .B :6;%* < ?)7A2/$(B5& ;
__CPAN_FILE__ src/widget/templates/buttons/wikiword.gif
GIF89a  2 <\Zc|MnMsU~?_~^xeJh_{GeC`VqXuIh|MpWrA_Ca@bFe>^Ro{KkGhs9Y                                       !  2 ,       @pH,RAb)8U(+XId!}4!AzD$!C!$F""G00G).&	.)G%	0
0	%G+'
0
'+G   H-  2-IFO12A ;
__CPAN_DIR__ src/widget/templates/images
__CPAN_FILE__ src/widget/templates/images/bdYearBg.1.gif

__CPAN_FILE__ src/widget/templates/images/bdYearBg.gif
GIF89a    tutssrst!     ,       pPC+x	 ;
__CPAN_FILE__ src/widget/templates/images/blank.gif
GIF89a    !
  ,       L ;
__CPAN_FILE__ src/widget/templates/images/combo_box_arrow.png
PNG

   IHDR         h6   tEXtSoftware Adobe ImageReadyqe<   IDAT8cv$ %5;?hNB5,; ZuIc?	G!4?^*Ys5ul5
BdWy8a[>YZq-Bo oj K-?8j_Y|7sO@5t{GkYd ,Q^n B\zu7"z	%^9NZj 	 :    IENDB`
__CPAN_FILE__ src/widget/templates/images/dateIcon.gif
GIF89a    "Aq&J9aJdp@[:e9c+Iw2N{0S1T!ApOs2W.Y                                 !     ,       pH,
	,1smlv`)Z6`
f:YkP	h*4**~{_acegik]v(4(4(({y4$ {( #nf t|~*%u.!Q"/'&Q1M	2HA ;
__CPAN_FILE__ src/widget/templates/images/decrementMonth.gif
GIF89a    BXq}q]w?Tm,=O5H]):K                  !     ,       $`%2$Z( -uYCr%O" ;
__CPAN_FILE__ src/widget/templates/images/decrementMonth.png
PNG

   IHDR         5Y^   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   IDATxbf@6y1	}PAK2D%7Nvt1nf}fU@d,@({kHIdV;
$  "td=E    IENDB`
__CPAN_FILE__ src/widget/templates/images/dpBg.gif
GIF89a k   wyy{zu~|vv{~y|{wxxv}u{|~}vwxz}                                                                                                                                                      !     ,     k  gB &9A>%4*,=372?!E($)0		5+-I:

<"@LD/CFM1;8K'J#H  G.6 ;
__CPAN_FILE__ src/widget/templates/images/dpCurveBL.png
PNG

   IHDR   	      :%   tEXtSoftware Adobe ImageReadyqe<   IDATX	`EWbaea5MXFjLn,Y0|q> @ @ @BEQtOWF)WQa,:fS*|-qPzaAbN.    IENDB`
__CPAN_FILE__ src/widget/templates/images/dpCurveBR.png
PNG

   IHDR   	      :%   tEXtSoftware Adobe ImageReadyqe<   IDATX	@ DcR*C	0MLd7A?{cze@ @ @ 
%NzT:kw&64J&"i:ka37    IENDB`
__CPAN_FILE__ src/widget/templates/images/dpCurveTL.png
PNG

   IHDR          E   tEXtSoftware Adobe ImageReadyqe<   IDATh@?J*@b $FBL%bAT
dPU \op&>0{dp,GXTG 		wFZCC;@tg@ @ ?@ @ /
$S    IENDB`
__CPAN_FILE__ src/widget/templates/images/dpCurveTR.png
PNG

   IHDR          E   tEXtSoftware Adobe ImageReadyqe<   IDATha@@/^co(@|=F@;k
T! fRW	 [	 nI24X^#~8/?9N1:p8`0`0`0`0`    IENDB`
__CPAN_FILE__ src/widget/templates/images/dpHorizLine.gif
GIF89a    !     ,       
 ;
__CPAN_FILE__ src/widget/templates/images/dpHorizLineFoot.gif
GIF89a    q!     ,       D
 ;
__CPAN_FILE__ src/widget/templates/images/dpMonthBg.gif
GIF89a          !     ,       f*1 ` A$qA ;
__CPAN_FILE__ src/widget/templates/images/dpMonthBg.png
PNG

   IHDR         @   tEXtSoftware Adobe ImageReadyqe<   KIDATH+  Bvpn+dG:\8*H`sdOT.%qaAQ0lA    IENDB`
__CPAN_FILE__ src/widget/templates/images/dpVertLine.gif
GIF89a    y!     ,       D\ ;
__CPAN_FILE__ src/widget/templates/images/dpYearBg.png
PNG

   IHDR         e   tEXtSoftware Adobe ImageReadyqe<   0IDATHKc,GYQ(k5yk.Y;a~ kmX i_6Oh    IENDB`
__CPAN_FILE__ src/widget/templates/images/dropdownButtonsArrow-disabled.gif
GIF89a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          !   ,        8` ;
__CPAN_FILE__ src/widget/templates/images/dropdownButtonsArrow.gif
GIF89a   /?Z!   ,       [ ;
__CPAN_FILE__ src/widget/templates/images/floatingPaneClose.gif
GIF89a    r:Nd<Pfp>Qg;Nd}Zsm;Odny>Rhql@Sjo?Rh<Pg;Oev`w<Odoqqr<Oel):Klrk                                                                                 !     ,       da	dDUccUD"UG]GU"#U2[2U#RdU;\;UQd&UXX U&/dCMA''AMC9K>+5Y..Y5+>K9PdFW*EYSN8(+Fpef\B""Ba+| $Y<iORD!F+\)L+- h $
.hJxJnMz lxo_~@'@@2)hBe8hx$b0BFSAc ;
__CPAN_FILE__ src/widget/templates/images/floatingPaneMaximize.gif
GIF89a    prqy}mnolvrqqollrk):K                                                                                                                                                            !     ,       IFI<HH<<4B4<.< @ <.7I<A<9I<J<I0+J+0&''&8I=5JKJ5=
I=SOBZ  A@K4$	=^8P/zLdD
t$#T$A#C fJh JH!PJ* 4W \BD]FdeTDR;_,La, ;
__CPAN_FILE__ src/widget/templates/images/floatingPaneMinimize.gif
GIF89a    prnmqvyol}qqlro):Krlk                                                                                                                                                               !     ,       JH
JII4D40$=$09JC7JB"J/A/,!@!,6J13?31	J**-AA%#Jx JkxBI)(K)t(9\,s`0`AHZ0!vHJj.>(9!C` V.%FK
%G@ ;
__CPAN_FILE__ src/widget/templates/images/floatingPaneRestore.gif
GIF89a    p6FVrm}qnovylqqorlrlk):K                                                                                                                                       !     ,       PN
P$EOOE$EIEE&H&E>PEQE;PE#Q#EP220QRQ07P5F1Q1F5P3F@K6\Ck86q/A:#!z@yad`	(44@9  
FD % BP"+h
*@abh]X.(Lo(MLp@ ;
__CPAN_FILE__ src/widget/templates/images/hue.png
PNG

   IHDR         J   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<  IDATxn0a\?]*P Rn{JD;9L?[vS'T_pt[|}E|N	wxW:\?~qwx}O|/^;8N}>w?O`Lr?Wc=>?r"O%^qW2BE8~j>[\<M\z5'Xz5" ='QS_`O;8 _
zT?L-_A|}_uj=~loo}~+8>?_<4p_/4Pu??A@?!d'`*==~ 3S    IENDB`
__CPAN_FILE__ src/widget/templates/images/incrementMonth.gif
GIF89a    pr}^x>Rj,=O5H]):K                     !     ,       % dHXIPNu]E8#Y*! ;
__CPAN_FILE__ src/widget/templates/images/incrementMonth.png
PNG

   IHDR   	      g`   gAMA  OX2   tEXtSoftware Adobe ImageReadyqe<   IDATxb6kfd$T j;&E i6452#@& }hMy S@I)Z>}J
+S~0>#0631lYls&d_ t>  .7"|    IENDB`
__CPAN_FILE__ src/widget/templates/images/no.gif
GIF89a  	 X\.4<AJO &                  !  	 ,       `0&)WxDGH!l er@P5~KqCNsZ+lAhY
6BLkQ*X0 ;
__CPAN_FILE__ src/widget/templates/images/no.svg
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 12.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 51448)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" [
	<!ENTITY ns_svg "http://www.w3.org/2000/svg">
	<!ENTITY ns_xlink "http://www.w3.org/1999/xlink">
]>
<svg  version="1.1" id="Layer_1" xmlns="&ns_svg;" xmlns:xlink="&ns_xlink;" width="15.433" height="15.433"
	 viewBox="0 0 15.433 15.433" overflow="visible" enable-background="new 0 0 15.433 15.433" xml:space="preserve">
<circle fill="none" stroke="#D02026" stroke-width="2" cx="7.716" cy="7.716" r="6.716"/>
<line fill="none" stroke="#D02026" stroke-width="2" x1="3.02" y1="12.352" x2="12.639" y2="2.732"/>
</svg>

__CPAN_FILE__ src/widget/templates/images/soriaActive-c.gif
GIF89a6 w   pqqpnproro                                                                                                         !     ,    6 w  [,Y1\IXZ 
H*\8#JHb3j CI2(S\0c8sg@
JH*]4(PJJU6j`KhUpKx<+^#K>,3kCMiVR^aMsN'K>]kN__@ 7h&4F(RfvH($h(,0(Eh8<@)DiF$L6PBYTViXft`)dhlp)h`x|*j:6FVjfB*Zj*
+`&6F+Tkfvk-k.+[o l'p7G,agwq ,$l'c,04l8;K@-D]H'L7O TWmXg\w`-c`hl6p-tmw|n'SG.W^gw n.`{/oC7GWog/_ o?  8+L6'H
Z7z aW@(L
W0gH8@HD"HL&:H*ZX.z`82hLF6pH:B>dIBL"iF:$'IIJ*$" ;
__CPAN_FILE__ src/widget/templates/images/soriaActive-l.gif
GIF89a6 w   rqnprpqoov}wutsyt~|xs{zzxp!     ,    6 w   	H*#J(3FC(S\r?~0cI6_'M>
H*]t3PFXjTs <KhG[aKagKCp9(^6lq3SsgCV/,ScU?Z9tNKN{cOZw}1 X`~&h`<!VhZOv!($h%,"0?zhmt<@?yimL6PF?TiI\v`z)dYflm3t&x?mcj&z?k4mdCVjfz)>*?jm?ejm+F>8$6R5dvJ[mk#{<W+k{=5,loT#G,W<?ldo8l M(,2 "38!<X DmHO"L74IG-bWQ\w`-6bgalp-7Xbw-|?nopC7G?Tnow?|no?noP?o7;,W_w{,_~2P%_20 ?lALZ8>t@
Z1@x=@(L
QH/;@8q@?;L@"HL\8O>@*ZXGx_64@2hLZoH:#xc IHACLd"XF:$'9_L#&7Nz(G9JK~L?V,gIZ?Z^0VD;|f:4CXD3bnz8W&v;zG~ ?B:u?:AVt@F7z ?2AYHJW-)fJS
VNw=JT
#(HR:MJU
PVz]G!JV^5hMZ\:We x^ `;XMb.d%k Xf7Ymh,MjWZ#ml(nw[cnpiMr\l.0`Zv]t@Mz|K?BL6?t7'L
[?xw[GL%.VbCX0gLwcbxc@L"d_PL*[e_H`L2f/pL:ce1MhAy{`F;!;XEzN{AAVVZH v^bf;v?FAjW\pMrv7z}c N;#X7s%GN()??H0g.s|8w
	  ;
__CPAN_FILE__ src/widget/templates/images/soriaActive-r.gif
GIF89a6 w   vzxu}zpr~xupprpnorqqov}s{yt|~swxs|pop!     ,    6 w   cH&#J(3FC,!(S\re~0cI6gM>
iH*]tiPJJ"iZ`KX
Yrj[1Kn56x_q
+^I#G%k|=S^jbma]0N87+_s#(Nzkw(O{fO("86F(!&h9dv2`,$X: "j/4h8x#?DiH&y$4T!TViXZi4t dih/lfi)[
`wJ0|' i5$6#VZ)fZi*jJ* *j+ +k,l<@4F+.`M"f-vj+n<skZ{{k/>^l'|8 
G,c|w ,2gl#|0|4l83-{?Dr2H'6`4PG-QW02Xg6t`-a[}hlp-7Vbwk|nx7;n(W^}dw7 0^pn@;"'7|t"Pgw=/`5/o/  H'H
N`Oz GB~(D	0aHo'w@!=A"'&:Pt=Q*ZI)b`	~@2hLjc\86x#
h> jDF6$%X&7IM2e(+R,*WJ,gIZr.wK0IbH2	(84IMin6	3x8INq^Lg:Qv<k:g:~ @4Eh::D!ZPVX@6z G]' "V0KIPNw@:@PR:PuPAV5NVz]],A5OHZm%hA5[^}6fA6kHb:6dAV6f7z)FKZMjW]lg;p nwVp;dMr.t{/Xv] @Mz][=K}ESuLNE8v&L
[ GLF+Vb@0gL)Nwct@L"Ya&;Pe$CX2:.{`,hF3:6p\4W>}n@BmHF;'&X7iME&NWjUu;pZp .vk^[ 	Mbf;m%XnsIMr>7?v-o~~8NO8;'N7{BFN#$  ;
__CPAN_FILE__ src/widget/templates/images/soriaButton-c.gif
GIF89a6 w   oroppqtqr}|ws~vnqzxpw{u                                                                                                                  !     ,    6 w  YX)L0( 
8*\#J<3j CZ4B(S\0cI8s|@
JH*]S?JJX`K\U]pM@xL+V#KL3kg5BMQXcsNq+_KNrkO>_^+ (h6F	VhfZ ($Xb(,/V!4h8<@)Cz`H&L6dPF)TViW\v`dihkp)tYx|R!j&6F*^afv*j*j*k&6 VkfvP+k{+k; ,l$7CLWlg$t ,$\(,R,4l8<@-ImH'L3PG-TWm"d\w`dmh@p-tx|;.n#7G.#Tngs.nD^n//'7<D/Woc?w/o?/o HL:'HA
B7z GH(D!V0ex8wC@>@"HL:PL`H*ZX.z<H2hLcS63x>Q  ;
__CPAN_FILE__ src/widget/templates/images/soriaButton-l.gif
GIF89a6 w   xrpqoov}prqnt|{wzu~qswxxxssztyx{w}~z|vvp!     ,    6 w   	H*#J(3FC7(S\re?0cI6_'M>
iH*]ti?PF=XjT,hBKvi!kI.~H5:(^Lp]2kMI_S^Zu?c>m=;4SBzuRk/{O=* OX`:6`l!f`?t$h,xI;(4X]?8@@)3H"9 '5P:O
TVY%*LFO`7ihY`?tiqw4;&6c?D*fHB: jzj?cjU+`"K3{6:V[m"v-Zkm"|j{n? "S 'oWlSs|,a',0,3`7
<=D]1Z$L7MTS]=g\wp?6-hlv?1-xC58n'~s?=4SWnDs^;U.Nu?(2.b36s/w?>o7SH<gwx??/T+oz?H@HG@*#'H
5iT GH~(D"10vGHD"C@L8O(6H*ZX`?.vQYgD%n6pa?@:qk~,$#0BL"~ HJZ|b?Nv@(GIRP*WJx",gIZH.whx"0IL@Lf2H:4!5X,>Xnz\e?@r :vtg?@zs>~ g?@ B:uh?@VF7z h?@JWLg:f#8NwpP:TLHMRPjT1+XXVUC`kXhMZVdE\Jxk?Z `KE `:d!BAf7zd "MjWZPfKmKMq
tKNv{l|xKhHz r|Kc~^ L}7;!R7{py)!
(NWbfL8L"HNa`SPL*[eS`L2yDypL: ~MBhE'MJ[7Ns#GMR>u?V8gMYw^VMl ;
__CPAN_FILE__ src/widget/templates/images/soriaButton-r.gif
GIF89a6 w   rz}xvtupoprqo}vnrqp{uwtz|~wsqxssxtzyx~psq|xwpp~orqvyz!     ,    6 w   kH&#J(3FC (S\r0cI6	gM>
	H*]t)=PJJvhe+h1Y-pL.xgv_
wgcIL-gMh\^:I&BvmWus[7b)N=9s6g;B_|`9_&h`m42Fh`Th@vs40$v(,f"%0#2h8x^H?Di$L2)PFYdaW&\vdYf2%lIb	 !s6x	'|6*?&>M6F/`2v)^ 6*ikk1|+
$&86F`Sv-T-~k+o;/"/0'0CClWpwd ,$)(2+0|K:gl<@<3D]4+'L74X!SXg\w4!chp,7mxm34bnEs7,TG.W>1W@.cc@zr.|aW ._'7n-SD/!pngo}$~/P  Hv@L`C0:x
Z'7z|F#FHB(L
W`Bex+,4H"Z VP,"AA*V3.8F,zh"U6H:u\=>L IB.q"H$'9FD$Nz(AidD%/V8Z`.w^rp#ILb"L2LT 49?X6Mm>sg8'rL:odg<'pz>Oo  h@MBP`hD!ZhDz*@HGJ(5)7(*LgJ8(S$@PJuHR
.8PTJUN#V
;x`XJV#UFp[Gx^\[Mbd'KZ$_zhG2|HjW JAanweiMr\ ntg Zv] oxs1Mz^o.
A~l 7>LNA-8'La	+7{6(NWb0q8wcmHL"H6-&7{L*[VF&e.`'hN6yX,]<x>hMA"
NF;'MJSI7il4GMRPWj ;
__CPAN_FILE__ src/widget/templates/images/soriaDisabled-c.gif
GIF89a3 w                              !     ,    3 w  $dihlp,tmQ|pH,rl
tJZvzxL.zn|N~ 
 
H(\#JH3" CI(Sd0cI8sI@
JH&XPJJXj}`Kh]-	pKxL+K#KL3kCMS^cMs7N+_KNk];O_O ;
__CPAN_FILE__ src/widget/templates/images/soriaDisabled-l.gif
GIF89a3 w                                                               !     ,    3 w  @pH,rl:tJZvz`S1L.Z^7E~u&*ED**E++DC$DE$E>?dPQu!0'd"BDD,y
*I	S-KuqaH*u'gPmPT" @"h-"vlYpexA.p	}+^ LG3f"!KLt!^SM5	k]Do@N~WND:?yEW/}_?Ex 0&	x`F(!bX rhB($8!~h,b&x4h8H@X*AY
PF)T>$LVUe\P)T
p)tluYB|
j(yq&n
Bh)d)	Zj(@B	jZD*+E8`@*[ 
lE{l.[R	f;m\mV-n.[o k
/JpE0"|0D,Zc3KDsqE$`<r''q3D\6:{pL7PG-5 JOmWW\/]`-dm|l]p-tm#|ww$7 ;
__CPAN_FILE__ src/widget/templates/images/soriaDisabled-r.gif
GIF89a3 w                                                                     !     ,    3 w  @pH,rl:tJZvzxL.zng|N0j|	y`{	))"~"}|(%O_x*QaJ,%V01z$(\[0?I'i\ig@HePKUXRj5`1V4" X-pmK@xe[{LU^K.8 CcSY;Mgrws#_\8qKNw~;v_ PO~; {h`wzB#D(Vh:!vxz(0(NX"&0(.j`"4#6?#DxE&H*	LZl01
0	\v`)^jIhePp)'l:`x'urj:2 VV)v*g ,`&ij+h*d&,c
0+@`J&v`Ak._kn+v	kul'7G,`gw q$l(,0,4s8<< ;
__CPAN_FILE__ src/widget/templates/images/soriaPressed-c.gif
GIF89a6 w   pqrqpoopnr                                                                                                                                                                                    !     ,    6 w  A'?5B;
> 
H`A*\AHH3f C9r(S\e0cI7-@eAH*]TPJJjXj_sKhp;xo_LS(^#GA3kCMtS^cM;soNXKN)h@_O (&6F(`fv ($h',0# 4h8<@XDiH&4PF)TRIXf\v`)XN`hl
p)tiw6|*j8$6BzVjf0t**`k+k&;F+Vkfb+[.+k  l'7|Wlgw!$l(,0,4l8<@-DmH'L7PG-TWmX\w`-dmglptmx{s.^	'7w Wng9	w.`:.n+# ;
__CPAN_FILE__ src/widget/templates/images/soriaPressed-l.gif
GIF89a6 w   orrqqpnop}v|tsxuzwxys{zt~p                                                                                                !     ,    6 w   	H*#J(3FC(S\rem0cI6_'M>
)H*]ti7"PF5XjTf~Khv[fZKxem\fafX#?&|k22kMeR^Mb9rNg7+_N^%kO6]=_O>du1"$6vsRD2&dvv$0#,-Xb@8<c7`)@dH&L6d7lD)@0SXf\ve7p)@(shlf7)@x|g7i*@&6h7D*@fvi7*@j7*2`lk
+,F+Jf-+M.+{[ p,`'+BWlg1X"$l(2,/420<@-4$aG3JL7PG-5E#Sg_3qdmh6o3tmx73n'8,3Wng9@K:.;/M$'< G/K"g=w!3>!31M?0 8@&B L:'8T`ztGH(4a7!gH5F&vCzb6H"EFD&zBH*ZU$E.>`A2hF6p: E >B HFvd$9JZ&7nx%%9IRH*Uj,gIZ.uR 0IbVH2Kc:IMj6/nzIrL9vXEIz=~@Jn4E)X:D'n4(JzHG:Q(MJWLg:S8i79PQ9GIvPjTjVJUzXZaHZjx\:Q^j6R`	Ubd';Y>f5kTmh;Y-K10jjlWAn_-p:].o@V7n7vK^7*^Dm|nd/}BoxQ`'x'<a[p7{ GLw(NW.fL8s	@L"H&;P~r70@*[Xn8`L26p3a:x=+4B ;
__CPAN_FILE__ src/widget/templates/images/soriaPressed-r.gif
GIF89a6 w   rz}xvtupprrponqoq}vwxxsytuz|~s{zt~ps|xqpopqrvwyz!     ,    6 w   =H&#J(13FC(S\re~0cI6	gM>
)H*]t)PJJh`KxYr%PpA2xeK_v
&P+^^1#G3kMM7HkMmKoNy_UKNw/)OyY}+O}) (h !2(F(Vh!	n
 ($8b>|+
0(48c)0\@)A#H&8L4PF)Qj'Xf8Bt`)ajpK'hf7>p)qp'xg78*i"*6F*)vbv)ar*~j2`,3?k&.2CVkf{t k6g+l .dl7;gw1"#(<1,2 T,4l5< @-D= xKlPC4TXg\w "c0hl<"s`x|7.`'+NM.D.7n?ns.n:.n;//?'cGo1uTo w{?}_~2YOL
?  H@*Lx:
P'H
Z` vP<GH%0P=gH5<d"H"E1`&6HDBXW.z`AEg6p?wTG>d /@BL"Hid$	JZD&78(GIR*Wt,gIZ.w]&.AbL2_P8IjZ5qInzP8Ir4g10vH<IuL~ @j	E>6D%:XF7QvAHEZ'V(LRM7ELwRd@NyJT: HMjRZtT:UV6	X:Vx`ZV]JW3$W^;!KX2!X%&KYf 1B vMf=YjWzMlg;[]`-v[reG$K\E"\n }t;g@7] ]ZnK^~4^]Po{v~[ Z<H4%XG0.w.GL(>19Z0g,cr8wL"HN2&;PL)X.{^FL2hN|$pL:93>3:BB! ;
__CPAN_FILE__ src/widget/templates/images/submenu_off.gif
GIF89a 	  q|!/=htfrp|8HX(8HTao*;L*6Zgt#1@,8DSb%4D#.AP_!/<",&6F$.'3)5(4                     !   ,     	   08Xa,5E4&	 ;
__CPAN_FILE__ src/widget/templates/images/submenu_on.gif
GIF89a 	     !   ,     	  Q	, t B9 ;
__CPAN_FILE__ src/widget/templates/images/tab_bot_left.gif
GIF89a	   dhfxb   !   ,    	    'dg&/Zpw{L=p(#fd&KS5,vkv>WfVdx:HZ{zoqs~}i0  
	"! ;
__CPAN_FILE__ src/widget/templates/images/tab_bot_left_curr.gif
GIF89a	  # fxhdb                                                                                    !  # ,    	   hH
#RD68eV)zvghZFo9wx^|u\{dtkI!!!!!  
#	##^ ABNp!D  ;
__CPAN_FILE__ src/widget/templates/images/tab_bot_right.gif
GIF89a  bhd|      !   ,        dihlp,tmx6pH,rl:tJZQ vzxLkzn3|Nx<u{JsSlWFwk_T eH0ELp)=H] |I2RF\KH*_sM+5o'>"*F@(BB)uVob:s+^+%%vmn3[q.v67!(xp!N\o1x,9.cy3N-mv7{xi!O.yTACg%}:MaV6O9^~}1+w$>?[   G F.5!NGapmbK#V'+*/63BV7N;Z?SiH&L6PF)TViXf\vHdihlp)tix|I*j&6F*Vjf<p*j*jktP+k&6F+VkK: X+k+k.A  l'#  ;
__CPAN_FILE__ src/widget/templates/images/tab_bot_right_curr.gif
GIF89a " bhi|d                                                                                       !  " ,      pH,rl:tJZv[pxL.h7n|\~gyNwWp[J{ocX {H[L?=H#]Q }I(+\	$~`r05os.?)(FANBjt*UVu'7)v,fYMr-n+#wo~p0LC'yran3s?-:P=Z`}-;pwS-<7=W^9uX]{;mOi=L'2>}IC$G !(H
 G>8EH!^HGa(}HbL'"+./:3FV7R&<@)DiH&L6PF)T:	@ Xf\v`)dihlp& ix|*j&6(  Vjfv*j@*j+k
 6F+Vkfv+- +k ,\'7G,Wlgw gl(,0,4l8<8DmH'L7PG-TWmXg\S $ dmhlp-tmxs[.n'7G.Wng9D"4 n.n;W@ < o'7G/Wogw@ A  ;
__CPAN_FILE__ src/widget/templates/images/tab_close.gif
GIF89a    ^^ccXXTTEEbbaa\\__VV}}XX[[SSddkkhhkkPPNNOO{{{{NNQQ\\HHJJppiiKKeehhggGGXXHHrrddjjFF__ggMM                     !     ,       U@pHvN t[Rh&!n4P{X`L$N)0 "i2 -1i+6#*iIEBA ;
__CPAN_FILE__ src/widget/templates/images/tab_close_h.gif
GIF89a    ~~~~mmwwvvvvyyee||dd~~zzkkuunniipp~~ttggnniijjrrjjhhii||xx}}ppuummss      !     ,       VpHg+P[T{KB@.//vYN]v*JL7)j8#.%j14'+jIEBA ;
__CPAN_FILE__ src/widget/templates/images/tab_left.gif
GIF89a	 ,; dhfxzb            !  ; ,    	 , pP&b*Z;NX#&'x
)hhbNGt<:}z~{8CDFHJ(/HD #vl Cd@Hq32XaC2X@RL.qIs& 8sQ8*H)NBcjTNJkUZru,fR%ZWfUm\s}W,w7#^Gv\!gr1h9LWtkW-6o&]wnQW: ;
__CPAN_FILE__ src/widget/templates/images/tab_left_r.gif
GIF89a	   dhfxb   !   ,    	    'dg&/Zpw{L=p(#fd&KS5,vkv>WfVdx:HZ{zoqs~}i0  
	"! ;
__CPAN_FILE__ src/widget/templates/images/tab_left_r_curr.gif
GIF89a	  # fxhdb                                                                                    !  # ,    	   hH
#RD68eV)zvghZFo9wx^|u\{dtkI!!!!!  
#	##^ ABNp!D  ;
__CPAN_FILE__ src/widget/templates/images/tab_right.gif
GIF89a,7 bdh|k                        !  7 ,    , @pH,rl:tJZvp.V)zn|N~0-%c2(7)74!HxP@*\#JH3jEI(S\0cI8sI@
JH*]PJJXN`KY\]p&M+xUKww+fZx#m,Rg?MzpSv{zMmo;7GNx+?|yCNw>y~'' mhj i	.`g>(eNhc^!bna`~(^!hd'Y*0Jb4~5c8buc<n~J	IE@)$N>IdRIe=^eZnYc^f.Ifybjf	ryavNg~y`Hh~.z_iMJz^z^i}
w
m*vJd
s[qR
oKm.KSB;dFm]-jn\cX.Y^nBFobn,bFppkpAlEqr]1\o`"X'r+2/3\7s;3?cDmH'L7PG-TW`q\w`-dmhlp-t*@.n'7G.Wn9+Pt.n.n1\pC/o'7G/Ww/o/  HL:h 7z GH(L
W0L!D8w@H"HL&: H*ZX.z`H2hLXF pH:x> IB$ F:$'IJZ&7Nz(GIR~ H*WV,gIZ.w^0y	 L2f:4IjZ6nz@IrL:v<Iz>O{ @JMB:D'JZDz HGJt=JW0)BS*8NOJ@PmHMRZ:PL*ZX(Uz5[XJVhMZ[zph[Js^
_KJuMb:8m,d'KYJ,H/zVhC--jWZu-lgY-nwXw-pW=r:}tZvzxswMW=l|]~A40SL`lEU
&0#	S~3ar0+&N/SlX.~wc,c1;>V.l!yF>o2}2g+)V^-|-sy^rk<0f>sl4n~sm8yvsn<~so]@z>tp]aF7+#ISztZ3ruoEO>5XU}bV7nYCo]'na-6e<s-R56cmNp<nr{Fwnv;r  ;
__CPAN_FILE__ src/widget/templates/images/tab_right_r.gif
GIF89a  bhd|      !   ,        dihlp,tmx6pH,rl:tJZQ vzxLkzn3|Nx<u{JsSlWFwk_T eH0ELp)=H] |I2RF\KH*_sM+5o'>"*F@(BB)uVob:s+^+%%vmn3[q.v67!(xp!N\o1x,9.cy3N-mv7{xi!O.yTACg%}:MaV6O9^~}1+w$>?[   G F.5!NGapmbK#V'+*/63BV7N;Z?SiH&L6PF)TViXf\vHdihlp)tix|I*j&6F*Vjf<p*j*jktP+k&6F+VkK: X+k+k.A  l'#  ;
__CPAN_FILE__ src/widget/templates/images/tab_right_r_curr.gif
GIF89a " bhi|d                                                                                       !  " ,      pH,rl:tJZv[pxL.h7n|\~gyNwWp[J{ocX {H[L?=H#]Q }I(+\	$~`r05os.?)(FANBjt*UVu'7)v,fYMr-n+#wo~p0LC'yran3s?-:P=Z`}-;pwS-<7=W^9uX]{;mOi=L'2>}IC$G !(H
 G>8EH!^HGa(}HbL'"+./:3FV7R&<@)DiH&L6PF)T:	@ Xf\v`)dihlp& ix|*j&6(  Vjfv*j@*j+k
 6F+Vkfv+- +k ,\'7G,Wlgw gl(,0,4l8<8DmH'L7PG-TWmXg\S $ dmhlp-tmxs[.n'7G.Wng9D"4 n.n;W@ < o'7G/Wogw@ A  ;
__CPAN_FILE__ src/widget/templates/images/tab_top_left.gif
GIF89a,; bdhfxz            !  ; ,    , pl,rl:tJZvz:`dWen|N~w;&0;" 16)% c1c*\#JH3j3P@(S\0cI8sM :
JH*]PJJXj
t`Kd]pMvx.|/+^0#Kx3W9M`S^5cgu-Hi;-+_~89:Nzk}/;O^O?? _V)9IHYiyzHg&b_/4fX#_:(dcCHk$N>YdR
Ie>^Znyc^f1Ifbjf#	rav^g~`Hh(._iMJ)|^^i}
{)j|nj
}J)k~.k
)lZ>+[Fm]jnkZ6nnh[(Kodk bLichp-01OWqrm1\\\@-DmH'}DPG-TWmK4@`-dmhlp-tmx}7 .n'7G.Wn;!D.n.n`
/o'7G/Wow/o/
  HL:$7z GH(L
W0L! @8w@H"HL& H*ZX.z`H2hL pH:x> IB@F:$'IJZ&7Nz(GIJO` L*WV,gIZ.w^.@bL2f:4IjZ6nz @8IrL:v<Iz>YO  @JMB:D'JZ?3z HGJt&MJW0=(JcJ8Ig@jMy*HMB:P)SJZ*VbU^XThM+Ke+\JTv^a+`K
MlQ:}d'Re3f-H7+=jA}lnp:^6MXn.U+6Q/N+J*y|;ug_ ^j|^xNpJ`3~0,	/3\sX{C,b=1..c6qts1+!F-%3N~l,eR2M-^fmE1sfm35Onm!9+vm=~m	An)"p}4*IF+3MMszqmQsjMy_-wokv->Ol6{v.miS6Lmr=nr+FwnvC ;
__CPAN_FILE__ src/widget/templates/images/tab_top_right.gif
GIF89a,7 bdh|k                        !  7 ,    , @pH,rl:tJZvp.V)zn|N~0-%c2(7)74!HxP@*\#JH3jEI(S\0cI8sI@
JH*]PJJXN`KY\]p&M+xUKww+fZx#m,Rg?MzpSv{zMmo;7GNx+?|yCNw>y~'' mhj i	.`g>(eNhc^!bna`~(^!hd'Y*0Jb4~5c8buc<n~J	IE@)$N>IdRIe=^eZnYc^f.Ifybjf	ryavNg~y`Hh~.z_iMJz^z^i}
w
m*vJd
s[qR
oKm.KSB;dFm]-jn\cX.Y^nBFobn,bFppkpAlEqr]1\o`"X'r+2/3\7s;3?cDmH'L7PG-TW`q\w`-dmhlp-t*@.n'7G.Wn9+Pt.n.n1\pC/o'7G/Ww/o/  HL:h 7z GH(L
W0L!D8w@H"HL&: H*ZX.z`H2hLXF pH:x> IB$ F:$'IJZ&7Nz(GIR~ H*WV,gIZ.w^0y	 L2f:4IjZ6nz@IrL:v<Iz>O{ @JMB:D'JZDz HGJt=JW0)BS*8NOJ@PmHMRZ:PL*ZX(Uz5[XJVhMZ[zph[Js^
_KJuMb:8m,d'KYJ,H/zVhC--jWZu-lgY-nwXw-pW=r:}tZvzxswMW=l|]~A40SL`lEU
&0#	S~3ar0+&N/SlX.~wc,c1;>V.l!yF>o2}2g+)V^-|-sy^rk<0f>sl4n~sm8yvsn<~so]@z>tp]aF7+#ISztZ3ruoEO>5XU}bV7nYCo]'na-6e<s-R56cmNp<nr{Fwnv;r  ;
__CPAN_FILE__ src/widget/templates/images/toolbar-bg.gif
GIF89a             !     ,       1$fV0&;4bCSs@P@l3r8A}X6 ;
__CPAN_FILE__ src/widget/templates/images/transparent.gif
GIF89a( (     g0*  2    !   $0  2  H  !`L  2  H  !`$h82         dtuxqu!       u, !`     @      $                       @(z
         ,     tH(            @      H           @ L@   !\Qm      !XQH   !XQHm     D    0   !   0    l      !`@   Gi Q8mGn8Gi(  q  `x     pm	    !`	!`    b  b                PGi(Dpm     Gn8Gi(  hGi(Gi(P \ pDGi(ccEG  Gn8I       ltII    !   ,    ( (  C H*\#JH3j CI(S\0cI8	 ;
__CPAN_FILE__ src/widget/templates/images/treenode_blank.gif
GIF89a  '    ___                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           !  ' ,        OH*\#JH1 ;
__CPAN_FILE__ src/widget/templates/images/treenode_child.gif
GIF89a         !   ,        `k:i!tH[iVS  ;
__CPAN_FILE__ src/widget/templates/images/treenode_expand_minus.gif
GIF89a  I 999DDD}y                                                                                                                                                                     !  I ,       IHHH7%,.0?('F+&9!) =$H4*:C
H<
"E;A86G2 	HD/5	B-#3@1> ;
__CPAN_FILE__ src/widget/templates/images/treenode_expand_plus.gif
GIF89a  H 999~DDDCCD~}}CDDy                                                                                                                                                                        !  H ,       {HFFFG-@3C
?#.	8=D),	5/%>  E21A+* ;<(76!09$B4&":' ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_c.gif
GIF89a   rrr   !   ,       oL ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_l.gif
GIF89a   rrr   !   ,       SojkHz ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_p.gif
GIF89a   rrr   !   ,       oSy8K ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_t.gif
GIF89a   rrr   !   ,       !SojkH6[vZF-:q ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_v.gif
GIF89a   rrr   !   ,       SojkeuNiR ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_x.gif
GIF89a   rrr   !   ,       t3` ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_y.gif
GIF89a   rrr   !   ,       t3Xv[}j ;
__CPAN_FILE__ src/widget/templates/images/treenode_grid_z.gif
GIF89a   999   !   ,       tzik}M ;
__CPAN_FILE__ src/widget/templates/images/treenode_node.gif
GIF89a   y                                                !   ,       @ $dih0tM:!3  CF,l2cJd6+-A+ ;
__CPAN_FILE__ src/widget/templates/images/verticalbar.gif
GIF89a "   YYY+++hhh999IIIppp}}}mmmtttxxx            !     ,     "   P#`Vq)2m4eD @ ;
__CPAN_FILE__ src/widget/templates/images/whiteDownArrow.gif
GIF89a   !   ,       [ ;
__CPAN_DIR__ src/widget/templates/images/Tree
__CPAN_FILE__ src/widget/templates/images/Tree/blank.gif
GIF89a       !     ,       > ;
__CPAN_FILE__ src/widget/templates/images/Tree/closed.gif
GIF89a   nrg{wur~pjyvd}lzhsj{aeyvomd}vxltmorq                                                                                                                                                                                                            !   ,        y	Hye1%M4n CW<	#L>r dI`~TjU=x]$**\5FQRT-xd8+:- O@!*]D`@p
@P@(l0D%Y$D AT&d)"#HXkQe]
8KMJ2\AK`x1C!JLj ]P)( ;
__CPAN_FILE__ src/widget/templates/images/Tree/document.gif
GIF89a   _F^u   !   ,       m'divhepum1MvHwq 'u0H`XP&SHQ4Xl0l;Lx@sk2g}gg+[&"! ;
__CPAN_FILE__ src/widget/templates/images/Tree/minus.gif
GIF89a    999zzzDDDrrry                                                                                                                                                               !     ,       ~JI$&73"9H',2(:I)8A 6/0*+  45#!;1GE=I%	-
JI.>	F
@CDB<?J ;
__CPAN_FILE__ src/widget/templates/images/Tree/plus.gif
GIF89a    999DDDCCDCDDrrrzzzy                                                                                                                                                                  !     ,       xIH"/I	5,!D9-F
4@0H
  C2'G<>1E%#B+=.8):? 76A;(&$3*I ;
__CPAN_FILE__ src/widget/templates/images/Tree/transparent.gif
GIF89a( (     g0*  2    !   $0  2  H  !`L  2  H  !`$h82         dtuxqu!       u, !`     @      $                       @(z
         ,     tH(            @      H           @ L@   !\Qm      !XQH   !XQHm     D    0   !   0    l      !`@   Gi Q8mGn8Gi(  q  `x     pm	    !`	!`    b  b                PGi(Dpm     Gn8Gi(  hGi(Gi(P \ pDGi(ccEG  Gn8I       ltII    !   ,    ( (  C H*\#JH3j CI(S\0cI8	 ;
__CPAN_FILE__ src/widget/templates/images/Tree/Tree.css

.dojoTree {
	font: caption;
	font-size: 11px;
	font-weight: normal;
	overflow: auto;
}


.dojoTreeNodeLabelTitle {
	padding-left: 2px;
	color: WindowText;
}

.dojoTreeNodeLabel {
	cursor:hand;
	cursor:pointer;
}

.dojoTreeNodeLabelTitle:hover {
	text-decoration: underline;
}

.dojoTreeNodeLabelSelected {
	background-color: Highlight;
	color: HighlightText;
}

.dojoTree div {
	white-space: nowrap;
}

.dojoTree img, .dojoTreeNodeLabel img {
	vertical-align: middle;
}


__CPAN_FILE__ src/widget/templates/images/Tree/treenode_blank.gif
GIF89a  '    ___                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           !  ' ,        OH*\#JH1 ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_child.gif
GIF89a         !   ,        `k:i!tH[iVS  ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_expand_minus.gif
GIF89a  I 999DDD}y                                                                                                                                                                     !  I ,       IHHH7%,.0?('F+&9!) =$H4*:C
H<
"E;A86G2 	HD/5	B-#3@1> ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_expand_plus.gif
GIF89a  H 999~DDDCCD~}}CDDy                                                                                                                                                                        !  H ,       {HFFFG-@3C
?#.	8=D),	5/%>  E21A+* ;<(76!09$B4&":' ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_c.gif
GIF89a   rrr   !   ,       oL ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_l.gif
GIF89a   rrr   !   ,       SojkHz ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_p.gif
GIF89a   rrr   !   ,       oSy8K ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_t.gif
GIF89a   rrr   !   ,       !SojkH6[vZF-:q ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_v.gif
GIF89a   rrr   !   ,       SojkeuNiR ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_x.gif
GIF89a   rrr   !   ,       t3` ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_y.gif
GIF89a   rrr   !   ,       t3Xv[}j ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_grid_z.gif
GIF89a   999   !   ,       tzik}M ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_loading.gif
GIF89a    rxz|yn|}xzmkop{qi                                       !     ,        h/ 4	Ii<GB|q_iT24Q^ (fQqPAEI8YM6Xx%B~I,:JdB ``}x0B& $&iY,wF^ p	/d(G=4bd70L[T<4I4: (Y ^lcw:(Ax2`+IaxltA#gZV7uVidJ\;3&4G@\HSrDD"LAD:v	JB% 3LR-7 F7*@B11"".xA"p" @J+mr<K ;
__CPAN_FILE__ src/widget/templates/images/Tree/treenode_loading.jpg
 JFIF   d d   Ducky     A   &Adobe d    
    "      		
	



	
                                                        !1"Aa#               0         ! 1AaQq    he xLf$`*y  M@>e5C}.:Cm  9    ? ? ?IcZd N*_`MI<}2(D ?!TzL=g(:>u g)~?p ?!07Ho0 ?!RUG    J#6 ?ZjY(hlGc	0@20~o?q ?!F2PJT3 ?1V3%<G;
__CPAN_DIR__ src/widget/vml
__CPAN_FILE__ src/widget/vml/Chart.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.widget.vml.Chart");

dojo.require("dojo.widget.HtmlWidget");
dojo.require("dojo.widget.Chart");
dojo.require("dojo.math");
dojo.require("dojo.html");
//dojo.require("dojo.vml");
dojo.require("dojo.graphics.color");

dojo.widget.vml.Chart=function(){
	dojo.widget.Chart.call(this);
	dojo.widget.HtmlWidget.call(this);
};
dojo.inherits(dojo.widget.vml.Chart, dojo.widget.HtmlWidget);
dojo.lang.extend(dojo.widget.vml.Chart, {
	//	widget props
	templatePath:null,
	templateCssPath:null,

	//	state
	_isInitialized:false,
	hasData:false,

	//	chart props
	vectorNode:null,
	plotArea:null,
	dataGroup:null,
	axisGroup:null,

	properties:{
		height:400,	//	defaults, will resize to the domNode.
		width:600,
		plotType:null,
		padding:{
			top:10,
			bottom:2,
			left:60,
			right:30
		},
		axes:{
			x:{
				plotAt:0,
				label:"",
				unitLabel:"",
				unitType:Number,
				nUnitsToShow:10,
				range:{
					min:0,
					max:200
				}
			},
			y:{
				plotAt:0,
				label:"",
				unitLabel:"",
				unitType:Number,
				nUnitsToShow:10,
				range:{
					min:0,
					max:200
				}
			}
		}
	},
	
	fillInTemplate:function(args,frag){
		this.initialize();
		this.render();
	},
	parseData:function(){
	},
	initialize:function(){
		//	parse the data first.
		this.parseData();
	
		// render the body of the chart, not the chart data.
		if(this.vectorNode){ this.destroy(); }
		this.vectorNode=document.createElement("div");
		this.vectorNode.style.width=this.properties.width+"px";
		this.vectorNode.style.height=this.properties.height+"px";
		this.vectorNode.style.position="relative";
		this.domNode.appendChild(this.vectorNode);

		var plotWidth=this.properties.width-this.properties.padding.left-this.properties.padding.right;
		var plotHeight=this.properties.height-this.properties.padding.top-this.properties.padding.bottom;

		this.plotArea=document.createElement("div");
		this.plotArea.style.position="absolute";
		this.plotArea.style.backgroundColor="#fff";
		this.plotArea.style.top=(this.properties.padding.top)-2+"px";
		this.plotArea.style.left=(this.properties.padding.left-1)+"px";
		this.plotArea.style.width=plotWidth+"px";
		this.plotArea.style.height=plotHeight+"px";
		this.vectorNode.appendChild(this.plotArea);
		
		this.dataGroup=document.createElement("div");
		this.dataGroup.style.position="relative";
		this.plotArea.appendChild(this.dataGroup);

		//	clipping rects, what a fucking pain.
		var bg=this.domNode.style.backgroundColor;
		var r=document.createElement("v:rect");
		r.setAttribute("fillcolor", bg);
		r.setAttribute("stroked", "false");
		r.style.position="absolute";
		r.style.top=(-1*this.properties.padding.top)-1+"px";
		r.style.left=(-1*this.properties.padding.left)+"px";
		r.style.width=(this.properties.width-3)+"px";
		r.style.height=(this.properties.padding.top)-2+"px";
		this.vectorNode.appendChild(r);

		r=document.createElement("v:rect");
		r.setAttribute("fillcolor", bg);
		r.setAttribute("stroked", "false");
		r.style.position="absolute";
		r.style.top=plotHeight-2+"px";
		r.style.left=(-1*this.properties.padding.left)+"px";
		r.style.width=(this.properties.width-3)+"px";
		r.style.height=(this.properties.padding.bottom)-2+"px"; // fixme: check this.
		this.vectorNode.appendChild(r);

		r=document.createElement("v:rect");
		r.setAttribute("fillcolor", bg);
		r.setAttribute("stroked", "false");
		r.style.position="absolute";
		r.style.top="-2px";
		r.style.left=(-1*this.properties.padding.left)+"px";
		r.style.width=(this.properties.padding.left-1)+"px";
		r.style.height=plotHeight+"px";
		this.vectorNode.appendChild(r);
		
		r=document.createElement("v:rect");
		r.setAttribute("fillcolor", bg);
		r.setAttribute("stroked", "false");
		r.style.position="absolute";
		r.style.top="-2px";
		r.style.right=(-1*this.properties.padding.right)+1+"px";
		r.style.width=(this.properties.padding.right-1)+"px";
		r.style.height=plotHeight+"px";
		this.vectorNode.appendChild(r);
		//	end clipping rects.  god that sucks, i wish VML had clipping outside of that crap vmlframe...

		this.axisGroup=document.createElement("div");
		this.axisGroup.style.position="relative";
		this.plotArea.appendChild(this.axisGroup);

		var stroke=1;

		//	x axis
		var line=document.createElement("v:line");
		var y=dojo.widget.vml.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
		line.setAttribute("from", this.properties.padding.left-stroke + "," + y);
		line.setAttribute("to", plotWidth + "," + y);
		line.style.position="absolute";
		line.style.antialias="false";
		line.setAttribute("strokecolor", "#666");
		line.setAttribute("strokeweight", stroke*2+"px");
		this.axisGroup.appendChild(line);

		//	y axis
		var line=document.createElement("v:line");
		var y=dojo.widget.vml.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
		line.setAttribute("from", x+","+this.properties.padding.top);
		line.setAttribute("to", x+","+this.properties.height-this.properties.padding.bottom);
		line.style.position="absolute";
		line.style.antialias="false";
		line.setAttribute("strokecolor", "#666");
		line.setAttribute("strokeweight", stroke*2+"px");
		this.axisGroup.appendChild(line);
		
		//	labels
		var size=10;

		//	x axis labels.
		var t=document.createElement("div");
		t.style.position="absolute";
		t.style.top=(this.properties.height-this.properties.padding.bottom+size+2)+"px";
		t.style.left=this.properties.padding.left+"px";
		t.style.fontFamily="sans-serif";
		t.style.fontSize=size+"px";
		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.x.range.min),2);
		this.axisGroup.appendChild(t);

		t=document.createElement("div");
		t.style.position="absolute";
		t.style.top=(this.properties.height-this.properties.padding.bottom+size+2)+"px";
		t.style.left=(this.properties.width-this.properties.padding.right-(size/2))+"px";
		t.style.fontFamily="sans-serif";
		t.style.fontSize=size+"px";
		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.x.range.max),2);
		this.axisGroup.appendChild(t);

		//	y axis labels.
		t=document.createElement("div");
		t.style.position="absolute";
		t.style.top=-1*(size/2)+"px";
		t.style.right=(plotWidth+4)+"px";
		t.style.fontFamily="sans-serif";
		t.style.fontSize=size+"px";
		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.y.range.max),2);
		this.axisGroup.appendChild(t);
		
		t=document.createElement("div");
		t.style.position="absolute";
		t.style.top=(this.properties.height-this.properties.padding.bottom)+"px";
		t.style.right=(plotWidth+4)+"px";
		t.style.fontFamily="sans-serif";
		t.style.fontSize=size+"px";
		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.y.range.min),2);
		this.axisGroup.appendChild(t);
		
		//	this is last.
		this.assignColors();
		this._isInitialized=true;
	},
	destroy:function(){
		while(this.domNode.childNodes.length>0){
			this.domNode.removeChild(this.domNode.childNodes[0]);
		}
		this.vectorNode=this.plotArea=this.dataGroup=this.axisGroup=null;
	},
	render:function(){
		if (this.dataGroup){
			while(this.dataGroup.childNodes.length>0){
				this.dataGroup.removeChild(this.dataGroup.childNodes[0]);
			}
		} else {
			this.initialize();
		}
		for(var i=0; i<this.series.length; i++){
			dojo.widget.vml.Chart.Plotter.plot(this.series[i], this);
		}
	}
});

dojo.widget.vml.Chart.Plotter=new function(){
	var _this=this;
	var plotters = {};
	var types=dojo.widget.Chart.PlotTypes;
	
	this.getX=function(value, chart){
		var v=parseFloat(value);
		var min=chart.properties.axes.x.range.min;
		var max=chart.properties.axes.x.range.max;
		var ofst=0-min;
		min+=ofst; max+=ofst; v+=ofst;

		var xmin=chart.properties.padding.left;
		var xmax=chart.properties.width-chart.properties.padding.right;
		var x=(v*((xmax-xmin)/max))+xmin;
		return x;
	};
	this.getY=function(value, chart){
		var v=parseFloat(value);
		var max=chart.properties.axes.y.range.max;
		var min=chart.properties.axes.y.range.min;
		var ofst=0;
		if(min<0)ofst+=Math.abs(min);
		min+=ofst; max+=ofst; v+=ofst;
		
		var ymin=chart.properties.height-chart.properties.padding.bottom;
		var ymax=chart.properties.padding.top;
		var y=(((ymin-ymax)/(max-min))*(max-v))+ymax;
		return y;
	};

	this.addPlotter=function(name, func){
		plotters[name]=func;
	};
	this.plot=function(series, chart){
		if (series.values.length==0) return;
		if (series.plotType && plotters[series.plotType]){
			return plotters[series.plotType](series, chart);
		}
		else if (chart.plotType && plotters[chart.plotType]){
			return plotters[chart.plotType](series, chart);
		}
	};

	//	plotting
	plotters[types.Bar]=function(series, chart){
		var space=1;
		var lastW = 0;
		for (var i=0; i<series.values.length; i++){
			var x=_this.getX(series.values[i].x, chart);
			var w;
			if (i==series.values.length-1){
				w=lastW;
			} else{
				w=_this.getX(series.values[i+1].x, chart)-x-space;
				lastW=w;
			}
			x-=(w/2);

			var yA=_this.getY(chart.properties.axes.x.plotAt, chart);
			var y=_this.getY(series.values[i].value, chart);
			var h=Math.abs(yA-y);
			if (parseFloat(series.values[i].value)<chart.properties.axes.x.plotAt){
				var oy=yA;
				yA=y;
				y=oy;
			}

			var bar=document.createElement("v:rect");
			bar.style.position="absolute";
			bar.style.top=x+"px";
			bar.style.left=y+"px";
			bar.style.width=w+"px";
			bar.style.height=h+"px";
			bar.setAttribute("fillColor", series.color);
			bar.setAttribute("title", series.label + ": " + series.values[i].value);
			bar.setAttribute("coordsize", chart.properties.width + "," + chart.properties.height);
			var fill=document.createElement("v:fill");
			fill.setAttribute("opacity", "0.9");
			bar.appendChild(fill);
			chart.dataGroup.appendChild(bar);
		}
	};	
	plotters[types.Line]=function(series, chart){
		var tension=3;

		var line=document.createElement("v:shape");
		line.setAttribute("strokeweight", "2px");
		line.setAttribute("strokecolor", series.color);
		line.setAttribute("fillcolor", "none");
		line.setAttribute("filled", "false");
		line.setAttribute("title", series.label);
		line.setAttribute("coordsize", chart.properties.width + "," + chart.properties.height);
		line.style.position="absolute";
		line.style.top="0px";
		line.style.left="0px";
		line.style.width= chart.properties.width+"px";
		line.style.height=chart.properties.height+"px";
		var stroke=document.createElement("v:stroke");
		stroke.setAttribute("opacity", "0.85");
		line.appendChild(stroke);

		var path = [];
		for (var i=0; i<series.values.length; i++){
			var x = _this.getX(series.values[i].x, chart)
			var y = _this.getY(series.values[i].value, chart);

			if (i==0){
				path.push("m");
				path.push(x+","+y);
			}else{
				var lastx=_this.getX(series.values[i-1].x, chart);
				var lasty=_this.getY(series.values[i-1].value, chart);
				var dx=x-lastx;
				
				path.push("v");
				var cx=x-(tension-1)*(dx/tension);
				path.push(cx+",0");
				cx=x-(dx/tension);
				path.push(cx+","+y-lasty);
				path.push(dx, y-lasty);
			}
		}
		line.setAttribute("path", path.join(" ")+" e");
		chart.dataGroup.appendChild(line);
	};
	plotters[types.Scatter]=function(series, chart){
		var r=8;
		for (var i=0; i<series.values.length; i++){
			var x=_this.getX(series.values[i].x, chart);
			var y=_this.getY(series.values[i].value, chart);
			var mod=r/2;

			var point=document.createElement("v:rect");
			point.setAttribute("fillcolor", series.color);
			point.setAttribute("strokecolor", series.color);
			point.setAttribute("title", series.label + ": " + series.values[i].value);
			point.style.position="absolute";
			point.style.rotation="45";
			point.style.top=(y-mod)+"px";
			point.style.left=(x-mod)+"px";
			point.style.width=r+"px";
			point.style.height=r+"px";
			var fill=document.createElement("v:fill");
			fill.setAttribute("opacity", "0.5");
			point.appendChild(fill);
			chart.dataGroup.appendChild(point);
		}
	};	
	plotters[types.Bubble]=function(series, chart){
		//	added param for series[n].value: size
		var minR=1;
		
		//	do this off the x axis?
		var min=chart.properties.axes.x.range.min;
		var max=chart.properties.axes.x.range.max;
		var ofst=0-min;
		min+=ofst; max+=ofst; v+=ofst;
		var xmin=chart.properties.padding.left;
		var xmax=chart.properties.width-chart.properties.padding.right;
		var factor=(max-min)/(xmax-xmin)*25;
		
		for (var i=0; i<series.values.length; i++){
			var size = series.values[i].size;
			if (isNaN(parseFloat(size))) size=minR;
			var mod=(parseFloat(size)*factor)/2;

			var point=document.createElement("v:oval");
			point.setAttribute("strokecolor", series.color);
			point.setAttribute("fillcolor", series.color);
			point.setAttribute("title", series.label + ": " + series.values[i].value + " (" + size + ")");
			point.style.position="absolute";
			point.style.top=(_this.getY(series.values[i].value, chart)-mod) + "px";
			point.style.left=(_this.getX(series.values[i].x, chart)-mod) + "px";
			point.style.width=mod+"px";
			point.style.height=mod+"px";
			chart.dataGroup.appendChild(point);
		}
	};
}();

__CPAN_DIR__ src/xml
__CPAN_FILE__ src/xml/domUtil.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.xml.domUtil");
dojo.require("dojo.graphics.color");
dojo.require("dojo.dom");
dojo.require("dojo.style");

dojo.deprecated("dojo.xml.domUtil is deprecated, use dojo.dom instead");

// for loading script:
dojo.xml.domUtil = new function(){
	this.nodeTypes = {
		ELEMENT_NODE                  : 1,
		ATTRIBUTE_NODE                : 2,
		TEXT_NODE                     : 3,
		CDATA_SECTION_NODE            : 4,
		ENTITY_REFERENCE_NODE         : 5,
		ENTITY_NODE                   : 6,
		PROCESSING_INSTRUCTION_NODE   : 7,
		COMMENT_NODE                  : 8,
		DOCUMENT_NODE                 : 9,
		DOCUMENT_TYPE_NODE            : 10,
		DOCUMENT_FRAGMENT_NODE        : 11,
		NOTATION_NODE                 : 12
	}
	
	this.dojoml = "http://www.dojotoolkit.org/2004/dojoml";
	this.idIncrement = 0;
	
	this.getTagName = function(){return dojo.dom.getTagName.apply(dojo.dom, arguments);}
	this.getUniqueId = function(){return dojo.dom.getUniqueId.apply(dojo.dom, arguments);}
	this.getFirstChildTag = function() {return dojo.dom.getFirstChildElement.apply(dojo.dom, arguments);}
	this.getLastChildTag = function() {return dojo.dom.getLastChildElement.apply(dojo.dom, arguments);}
	this.getNextSiblingTag = function() {return dojo.dom.getNextSiblingElement.apply(dojo.dom, arguments);}
	this.getPreviousSiblingTag = function() {return dojo.dom.getPreviousSiblingElement.apply(dojo.dom, arguments);}

	this.forEachChildTag = function(node, unaryFunc) {
		var child = this.getFirstChildTag(node);
		while(child) {
			if(unaryFunc(child) == "break") { break; }
			child = this.getNextSiblingTag(child);
		}
	}

	this.moveChildren = function() {return dojo.dom.moveChildren.apply(dojo.dom, arguments);}
	this.copyChildren = function() {return dojo.dom.copyChildren.apply(dojo.dom, arguments);}
	this.clearChildren = function() {return dojo.dom.removeChildren.apply(dojo.dom, arguments);}
	this.replaceChildren = function() {return dojo.dom.replaceChildren.apply(dojo.dom, arguments);}

	this.getStyle = function() {return dojo.style.getStyle.apply(dojo.style, arguments);}
	this.toCamelCase = function() {return dojo.style.toCamelCase.apply(dojo.style, arguments);}
	this.toSelectorCase = function() {return dojo.style.toSelectorCase.apply(dojo.style, arguments);}

	this.getAncestors = function(){return dojo.dom.getAncestors.apply(dojo.dom, arguments);}
	this.isChildOf = function() {return dojo.dom.isDescendantOf.apply(dojo.dom, arguments);}
	this.createDocumentFromText = function() {return dojo.dom.createDocumentFromText.apply(dojo.dom, arguments);}

	if(dojo.render.html.capable || dojo.render.svg.capable) {
		this.createNodesFromText = function(txt, wrap){return dojo.dom.createNodesFromText.apply(dojo.dom, arguments);}
	}

	this.extractRGB = function(color) { return dojo.graphics.color.extractRGB(color); }
	this.hex2rgb = function(hex) { return dojo.graphics.color.hex2rgb(hex); }
	this.rgb2hex = function(r, g, b) { return dojo.graphics.color.rgb2hex(r, g, b); }

	this.insertBefore = function() {return dojo.dom.insertBefore.apply(dojo.dom, arguments);}
	this.before = this.insertBefore;
	this.insertAfter = function() {return dojo.dom.insertAfter.apply(dojo.dom, arguments);}
	this.after = this.insertAfter
	this.insert = function(){return dojo.dom.insertAtPosition.apply(dojo.dom, arguments);}
	this.insertAtIndex = function(){return dojo.dom.insertAtIndex.apply(dojo.dom, arguments);}
	this.textContent = function () {return dojo.dom.textContent.apply(dojo.dom, arguments);}
	this.renderedTextContent = function () {return dojo.dom.renderedTextContent.apply(dojo.dom, arguments);}
	this.remove = function (node) {return dojo.dom.removeNode.apply(dojo.dom, arguments);}
}


__CPAN_FILE__ src/xml/htmlUtil.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.xml.htmlUtil");
dojo.require("dojo.html");
dojo.require("dojo.style");
dojo.require("dojo.dom");

dojo.deprecated("dojo.xml.htmlUtil is deprecated, use dojo.html instead");

dojo.xml.htmlUtil = new function(){
	this.styleSheet = dojo.style.styleSheet;
	
	this._clobberSelection = function(){return dojo.html.clearSelection.apply(dojo.html, arguments);}
	this.disableSelect = function(){return dojo.html.disableSelection.apply(dojo.html, arguments);}
	this.enableSelect = function(){return dojo.html.enableSelection.apply(dojo.html, arguments);}
	
	this.getInnerWidth = function(){return dojo.style.getInnerWidth.apply(dojo.style, arguments);}
	
	this.getOuterWidth = function(node){
		dojo.unimplemented("dojo.xml.htmlUtil.getOuterWidth");
	}

	this.getInnerHeight = function(){return dojo.style.getInnerHeight.apply(dojo.style, arguments);}

	this.getOuterHeight = function(node){
		dojo.unimplemented("dojo.xml.htmlUtil.getOuterHeight");
	}

	this.getTotalOffset = function(){return dojo.style.getTotalOffset.apply(dojo.style, arguments);}
	this.totalOffsetLeft = function(){return dojo.style.totalOffsetLeft.apply(dojo.style, arguments);}

	this.getAbsoluteX = this.totalOffsetLeft;

	this.totalOffsetTop = function(){return dojo.style.totalOffsetTop.apply(dojo.style, arguments);}
	
	this.getAbsoluteY = this.totalOffsetTop;

	this.getEventTarget = function(){return dojo.html.getEventTarget.apply(dojo.html, arguments);}
	this.getScrollTop = function() {return dojo.html.getScrollTop.apply(dojo.html, arguments);}
	this.getScrollLeft = function() {return dojo.html.getScrollLeft.apply(dojo.html, arguments);}

	this.evtTgt = this.getEventTarget;

	this.getParentOfType = function(){return dojo.html.getParentOfType.apply(dojo.html, arguments);}
	this.getAttribute = function(){return dojo.html.getAttribute.apply(dojo.html, arguments);}
	this.getAttr = function (node, attr) { // for backwards compat (may disappear!!!)
		dojo.deprecated("dojo.xml.htmlUtil.getAttr is deprecated, use dojo.xml.htmlUtil.getAttribute instead");
		return dojo.xml.htmlUtil.getAttribute(node, attr);
	}
	this.hasAttribute = function(){return dojo.html.hasAttribute.apply(dojo.html, arguments);}

	this.hasAttr = function (node, attr) { // for backwards compat (may disappear!!!)
		dojo.deprecated("dojo.xml.htmlUtil.hasAttr is deprecated, use dojo.xml.htmlUtil.hasAttribute instead");
		return dojo.xml.htmlUtil.hasAttribute(node, attr);
	}
	
	this.getClass = function(){return dojo.html.getClass.apply(dojo.html, arguments)}
	this.hasClass = function(){return dojo.html.hasClass.apply(dojo.html, arguments)}
	this.prependClass = function(){return dojo.html.prependClass.apply(dojo.html, arguments)}
	this.addClass = function(){return dojo.html.addClass.apply(dojo.html, arguments)}
	this.setClass = function(){return dojo.html.setClass.apply(dojo.html, arguments)}
	this.removeClass = function(){return dojo.html.removeClass.apply(dojo.html, arguments)}

	// Enum type for getElementsByClass classMatchType arg:
	this.classMatchType = {
		ContainsAll : 0, // all of the classes are part of the node's class (default)
		ContainsAny : 1, // any of the classes are part of the node's class
		IsOnly : 2 // only all of the classes are part of the node's class
	}

	this.getElementsByClass = function() {return dojo.html.getElementsByClass.apply(dojo.html, arguments)}
	this.getElementsByClassName = this.getElementsByClass;
	
	this.setOpacity = function() {return dojo.style.setOpacity.apply(dojo.style, arguments)}
	this.getOpacity = function() {return dojo.style.getOpacity.apply(dojo.style, arguments)}
	this.clearOpacity = function() {return dojo.style.clearOpacity.apply(dojo.style, arguments)}
	
	this.gravity = function(){return dojo.html.gravity.apply(dojo.html, arguments)}
	
	this.gravity.NORTH = 1;
	this.gravity.SOUTH = 1 << 1;
	this.gravity.EAST = 1 << 2;
	this.gravity.WEST = 1 << 3;
	
	this.overElement = function(){return dojo.html.overElement.apply(dojo.html, arguments)}

	this.insertCssRule = function(){return dojo.style.insertCssRule.apply(dojo.style, arguments)}
	
	this.insertCSSRule = function(selector, declaration, index){
		dojo.deprecated("dojo.xml.htmlUtil.insertCSSRule is deprecated, use dojo.xml.htmlUtil.insertCssRule instead");
		return dojo.xml.htmlUtil.insertCssRule(selector, declaration, index);
	}
	
	this.removeCssRule = function(){return dojo.style.removeCssRule.apply(dojo.style, arguments)}

	this.removeCSSRule = function(index){
		dojo.deprecated("dojo.xml.htmlUtil.removeCSSRule is deprecated, use dojo.xml.htmlUtil.removeCssRule instead");
		return dojo.xml.htmlUtil.removeCssRule(index);
	}

	this.insertCssFile = function(){return dojo.style.insertCssFile.apply(dojo.style, arguments)}

	this.insertCSSFile = function(URI, doc, checkDuplicates){
		dojo.deprecated("dojo.xml.htmlUtil.insertCSSFile is deprecated, use dojo.xml.htmlUtil.insertCssFile instead");
		return dojo.xml.htmlUtil.insertCssFile(URI, doc, checkDuplicates);
	}

	this.getBackgroundColor = function() {return dojo.style.getBackgroundColor.apply(dojo.style, arguments)}

	this.getUniqueId = function() { return dojo.dom.getUniqueId(); }

	this.getStyle = function() {return dojo.style.getStyle.apply(dojo.style, arguments)}
}

__CPAN_FILE__ src/xml/Parse.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.xml.Parse");

dojo.require("dojo.dom");

//TODO: determine dependencies
// currently has dependency on dojo.xml.DomUtil nodeTypes constants...

/* generic method for taking a node and parsing it into an object

TODO: WARNING: This comment is wrong!

For example, the following xml fragment

<foo bar="bar">
	<baz xyzzy="xyzzy"/>
</foo>

can be described as:

dojo.???.foo = {}
dojo.???.foo.bar = {}
dojo.???.foo.bar.value = "bar";
dojo.???.foo.baz = {}
dojo.???.foo.baz.xyzzy = {}
dojo.???.foo.baz.xyzzy.value = "xyzzy"

*/
// using documentFragment nomenclature to generalize in case we don't want to require passing a collection of nodes with a single parent
dojo.xml.Parse = function(){

	function getDojoTagName (node) {
		var tagName = node.tagName;
		if (tagName.substr(0,5).toLowerCase() != "dojo:") {
			
			if (tagName.substr(0,4).toLowerCase() == "dojo") {
				// FIXME: this assuumes tag names are always lower case
				return "dojo:" + tagName.substring(4).toLowerCase();
			}
		
			// allow lower-casing
			var djt = node.getAttribute("dojoType") || node.getAttribute("dojotype");
			if (djt) { return "dojo:" + djt.toLowerCase(); }
			
			if (node.getAttributeNS && node.getAttributeNS(dojo.dom.dojoml,"type")) {
				return "dojo:" + node.getAttributeNS(dojo.dom.dojoml,"type").toLowerCase();
			}
			try {
				// FIXME: IE really really doesn't like this, so we squelch
				// errors for it
				djt = node.getAttribute("dojo:type");
			} catch (e) { /* FIXME: log? */ }

			if (djt) { return "dojo:"+djt.toLowerCase(); }
		
			if (!dj_global["djConfig"] || !djConfig["ignoreClassNames"]) {
				// FIXME: should we make this optionally enabled via djConfig?
				var classes = node.className||node.getAttribute("class");
				// FIXME: following line, without check for existence of classes.indexOf
				// breaks firefox 1.5's svg widgets
				if (classes && classes.indexOf && classes.indexOf("dojo-") != -1) {
					var aclasses = classes.split(" ");
					for(var x=0; x<aclasses.length; x++){
						if (aclasses[x].length > 5 && aclasses[x].indexOf("dojo-") >= 0) {
							return "dojo:"+aclasses[x].substr(5).toLowerCase();
						}
					}
				}
			}
		
		}
		return tagName.toLowerCase();
	}

	this.parseElement = function(node, hasParentNodeSet, optimizeForDojoML, thisIdx){

        // if parseWidgets="false" don't search inside this node for widgets
        if (node.getAttribute("parseWidgets") == "false") {
            return {};
        }

		// TODO: make this namespace aware
		var parsedNodeSet = {};

		var tagName = getDojoTagName(node);
		parsedNodeSet[tagName] = [];
		if((!optimizeForDojoML)||(tagName.substr(0,4).toLowerCase()=="dojo")){
			var attributeSet = parseAttributes(node);
			for(var attr in attributeSet){
				if((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != "array")){
					parsedNodeSet[tagName][attr] = [];
				}
				parsedNodeSet[tagName][attr].push(attributeSet[attr]);
			}
	
			// FIXME: we might want to make this optional or provide cloning instead of
			// referencing, but for now, we include a node reference to allow
			// instantiated components to figure out their "roots"
			parsedNodeSet[tagName].nodeRef = node;
			parsedNodeSet.tagName = tagName;
			parsedNodeSet.index = thisIdx||0;
		}
	
		var count = 0;
		var tcn, i = 0, nodes = node.childNodes;
		while(tcn = nodes[i++]){
			switch(tcn.nodeType){
				case  dojo.dom.ELEMENT_NODE: // element nodes, call this function recursively
					count++;
					var ctn = getDojoTagName(tcn);
					if(!parsedNodeSet[ctn]){
						parsedNodeSet[ctn] = [];
					}
					parsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));
					if(	(tcn.childNodes.length == 1)&&
						(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){
						parsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;
					}
					break;
				case  dojo.dom.TEXT_NODE: // if a single text node is the child, treat it as an attribute
					if(node.childNodes.length == 1) {
						parsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });
					}
					break;
				default: break;
				/*
				case  dojo.dom.ATTRIBUTE_NODE: // attribute node... not meaningful here
					break;
				case  dojo.dom.CDATA_SECTION_NODE: // cdata section... not sure if this would ever be meaningful... might be...
					break;
				case  dojo.dom.ENTITY_REFERENCE_NODE: // entity reference node... not meaningful here
					break;
				case  dojo.dom.ENTITY_NODE: // entity node... not sure if this would ever be meaningful
					break;
				case  dojo.dom.PROCESSING_INSTRUCTION_NODE: // processing instruction node... not meaningful here
					break;
				case  dojo.dom.COMMENT_NODE: // comment node... not not sure if this would ever be meaningful 
					break;
				case  dojo.dom.DOCUMENT_NODE: // document node... not sure if this would ever be meaningful
					break;
				case  dojo.dom.DOCUMENT_TYPE_NODE: // document type node... not meaningful here
					break;
				case  dojo.dom.DOCUMENT_FRAGMENT_NODE: // document fragment node... not meaningful here
					break;
				case  dojo.dom.NOTATION_NODE:// notation node... not meaningful here
					break;
				*/
			}
		}
		//return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;
		return parsedNodeSet;
	}

	/* parses a set of attributes on a node into an object tree */
	function parseAttributes(node) {
		// TODO: make this namespace aware
		var parsedAttributeSet = {};
		var atts = node.attributes;
		// TODO: should we allow for duplicate attributes at this point...
		// would any of the relevant dom implementations even allow this?
		var attnode, i=0;
		while(attnode=atts[i++]) {
			if((dojo.render.html.capable)&&(dojo.render.html.ie)){
				if(!attnode){ continue; }
				if(	(typeof attnode == "object")&&
					(typeof attnode.nodeValue == 'undefined')||
					(attnode.nodeValue == null)||
					(attnode.nodeValue == '')){ 
					continue; 
				}
			}
			var nn = (attnode.nodeName.indexOf("dojo:") == -1) ? attnode.nodeName : attnode.nodeName.split("dojo:")[1];
			parsedAttributeSet[nn] = { 
				value: attnode.nodeValue 
			};
		}
		return parsedAttributeSet;
	}
}

__CPAN_FILE__ src/xml/svgUtil.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.provide("dojo.xml.svgUtil");
// FIXME: add imports for deps!

dojo.xml.svgUtil = new function(){

	this.getInnerWidth = function(node){
		// FIXME: need to find out from dylan how to 
	}

	this.getOuterWidth = function(node){
		
	}

	this.getInnerHeight = function(node){
		
	}

	this.getOuterHeight = function(node){
		
	}

}

__CPAN_FILE__ src/xml/__package__.js
/*
	Copyright (c) 2004-2006, The Dojo Foundation
	All Rights Reserved.

	Licensed under the Academic Free License version 2.1 or above OR the
	modified BSD license. For more information on Dojo licensing, see:

		http://dojotoolkit.org/community/licensing.shtml
*/

dojo.require("dojo.xml.Parse");
dojo.kwCompoundRequire({
	common:		["dojo.xml.domUtil"],
    browser: 	["dojo.xml.htmlUtil"],
    dashboard: 	["dojo.xml.htmlUtil"],
    svg: 		["dojo.xml.svgUtil"]
});
dojo.provide("dojo.xml.*");

